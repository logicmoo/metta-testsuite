<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi36 { color: #00aaaa; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-12-26 18:29:04+00:00 [COMMAND="timeout --preserve-status --foreground --signal=SIGTERM --kill-after=5s 40 swipl  /home/runner/work/metta-testsuite/metta-testsuite/prolog/metta_lang/metta_interp.pl -- --python=enable -- --timeout=40 --output=./reports/tests_output/baseline-compat/ --html --test tests/baseline_compat/hyperon-experimental_scripts/b4_nondeterm.metta --halt=true  --stdin=tty --stdout=tty --stderr=tty" TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;         #(set_debug transpiler false)

P;HTML|
;          #(set_debug overtime 4.0)

P;HTML|
;          #(set_debug overflow 1000)

P;HTML|
;          #(set_debug eval false)

P;HTML|
;          #(set_debug load silent)

P;HTML|
;          #(set_debug trace-on-load false)

P;HTML|
;          #(set_debug exec false)

P;HTML|
;          #(set_debug error non-type)

P;HTML|
;          #(set_debug fail false)

P;HTML|
;          #(set_debug test true)

P;HTML|
;         #(set_debug test false)

P;HTML|
;         #(set_debug fail false)
P;HTML|
;          #(set_debug transpiler false)
P;HTML|
;          #(set_debug overtime 4.0)
P;HTML|
;          #(set_debug overflow 1000)
P;HTML|
;          #(set_debug eval false)
P;HTML|
;          #(set_debug load silent)
P;HTML|
;          #(set_debug trace-on-load false)
P;HTML|
;          #(set_debug exec false)
P;HTML|
;          #(set_debug error non-type)
P;HTML|
;          #(set_debug fail false)
P;HTML|
;          #(set_debug test true)
P;HTML|
;          #(set_debug test false)
P;HTML|
;          #(set_debug fail false)

; #( : user #(load_metta_file &self tests/baseline_compat/hyperon-experimental_scripts/b4_nondeterm.metta) )
P;HTML|
;                #(track_load_into_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-experimental_scripts/b4_nondeterm.metta)
P;HTML|
;                       #(load_answer_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-experimental_scripts/b4_nondeterm.metta.answers /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-experimental_scripts/b4_nondeterm.metta)
P;HTML|
;                        #( = 1 "[()]" )
P;HTML|
;                        #( = 2 "[()]" )
P;HTML|
;                         #( = 3 "[()]" )
P;HTML|
;                         #( = 4 "[()]" )
P;HTML|
;                          #( = 5 "[()]" )
P;HTML|
;                          #( = 6 "[()]" )
P;HTML|
;                          #( = 7 "[()]" )
P;HTML|
;                           #( = 8 "[()]" )
P;HTML|
;                           #( = 9 "[()]" )
P;HTML|
;                            #( = 10 "[()]" )
P;HTML|
;                            #( = 11 "[()]" )
P;HTML|
;                            #( = 12 "0.06user 0.00system 0:00.07elapsed 100%CPU (0avgtext+0avgdata 27728maxresident)k" )
P;HTML|
;                             #( = 12 "0inputs+0outputs (0major+3372minor)pagefaults 0swaps" )
P;HTML|
;                        #(load_answer_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-experimental_scripts/b4_nondeterm.metta.answers /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-experimental_scripts/b4_nondeterm.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Nondeterminism in matching and interpretation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (= (color)  green)
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(color, 1, 0, [], 'AnyRet', [], x(doeval, eager), [color], green).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_0__color</span>(<span class="pl-args"
><span class="pl-var"
>A</span></span>)</span>, 
  [ [ assign ,   A   ,'green']]].&#13;&#10;
mc_0__color(A) :-
    A=green.
<span class="ansi36"
>
mc_0__color(A) :-
    A=green.

</span>
<span class="ansi38-255165000"
> (= (color)  yellow)
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(color, 1, 1, [], 'AnyRet', [], x(doeval, eager), [color], yellow).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_0__color</span>(<span class="pl-args"
><span class="pl-var"
>A</span></span>)</span>, 
  [ [  assign ,   A    ,'yellow']]].&#13;&#10;
mc_0__color(A) :-
    A=yellow.
<span class="ansi36"
>
mc_0__color(A) :-
    A=yellow.

</span>
<span class="ansi38-255165000"
> (= (color)  red)
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(color, 1, 2, [], 'AnyRet', [], x(doeval, eager), [color], red).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_0__color</span>(<span class="pl-args"
><span class="pl-var"
>A</span></span>)</span>, 
  [ [ assign,  A   ,'red' ]]].&#13;&#10;
mc_0__color(A) :-
    A=red.
<span class="ansi36"
>
mc_0__color(A) :-
    A=red.

</span>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; In `a1_symbols` we saw that `match` can return multiple or no results
;;; The same is true for equality queries
;;; `superpose` turns a tuple into a non-deterministic result (for comparison here)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(assertEqual (match &self (= (color)  $x) $x) (superpose (red yellow green)))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.01"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.01</h3>
; 
; EVAL TEST
; took 0.000508 secs. (507.61 microseconds) 

!(assertEqual (match &self (= (color)  $x) $x) (superpose (red yellow green)))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      (green yellow red) 
      (red yellow green)))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;;!(assertEqual (match &self (= (color) $x) $x) (color))
;;;!(assertEqual (collapse (color)) (red yellow green))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; `collapse` converts a nondeterministic result into a tuple
;;; We don't use it above, because the order of non-deterministic results
;;; is not guaranteed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(assertEqual (collapse (match &self (= (shape)  $x) $x)) ())

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.02"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.02</h3>
; 
; EVAL TEST
; took 0.000242 secs. (242.15 microseconds) 

!(assertEqual (collapse (match &self (= (shape)  $x) $x)) ())

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      (()) 
      (())))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Multiple results from equality queries
;;; are also returned by the interpreter
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(assertEqual (color) (superpose (red yellow green)))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.03"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.03</h3>
; 
; EVAL TEST
; took 0.000516 secs. (516.45 microseconds) 

!(assertEqual (color) (superpose (red yellow green)))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      (green yellow red) 
      (red yellow green)))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; `superpose` reverts `collapse`
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; `let` is used to introduce temporary variable bindings within an expression
<span class="ansi38-013099040"
>!(assertEqual (color) (let $x (collapse (color)) (superpose $x)))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.04"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.04</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.10 milliseconds) 

!(assertEqual (color) (let $x (collapse (color)) (superpose $x)))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      (green yellow red) 
      (green yellow red)))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; In contrast to `match`, if the equality query returns an empty result
;;; the interpreter doesn't reduce a symbolic expression
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(assertEqual (collapse (shape)) ((shape)))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.05"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.05</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.91 milliseconds) 

!(assertEqual (collapse (shape)) ((shape)))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( ( (shape))) 
      ( ( (shape)))))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqualToResult (shape) ((shape)))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.06"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.06</h3>
; 
; EVAL TEST
; took 0.000324 secs. (323.79 microseconds) 

!(assertEqualToResult (shape) ((shape)))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (shape)) 
      ( (shape))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; If the expression is composed over nondeterministic
;;; expressions, all combinations will be produced
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (= (bin)  A)
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(bin, 1, 0, [], 'AnyRet', [], x(doeval, eager), [bin], 'A').

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_0__bin</span>(<span class="pl-args"
><span class="pl-var"
>A</span></span>)</span>, 
  [ [ assign,  A   , 'A'  ]]].&#13;&#10;
mc_0__bin(A) :-
    A='A'.
<span class="ansi36"
>
mc_0__bin(A) :-
    A='A'.

</span>
<span class="ansi38-255165000"
> (= (bin)  B)
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(bin, 1, 1, [], 'AnyRet', [], x(doeval, eager), [bin], 'B').

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_0__bin</span>(<span class="pl-args"
><span class="pl-var"
>A</span></span>)</span>, 
  [ [ assign,  A   , 'B'  ]]].&#13;&#10;
mc_0__bin(A) :-
    A='B'.
<span class="ansi36"
>
mc_0__bin(A) :-
    A='B'.

</span>
<span class="ansi38-255165000"
> (= (pair $x $y)  
  ($x $y))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(pair, 3, 0, ['Any', 'Any'], 'AnyRet', [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [pair, _x, _y], [_x, _y]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_2__pair</span>(<span class="pl-args"
><span class="pl-var"
>_x</span>, <span class="pl-var"
>_y</span>, <span class="pl-var"
>A</span></span>)</span>, 
  [ [ <span class="pl-atom"
>assign</span>, <span class="pl-var"
>A</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>list</span>(<span class="pl-args"
><span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-var"
>_x</span>|<span class="pl-ellipsis"
>...</span></span>]</span></span>)</span>]]].&#13;&#10;
mc_2__pair(_x, _y, A) :-
    A=[_x, _y].
<span class="ansi36"
>
mc_2__pair(_x, _y, A) :-
    A=[_x, _y].

</span>
<span class="ansi38-013099040"
>!(assertEqualToResult (pair (bin) (bin)) ((A A) (A B) (B A) (B B)))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.07"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.07</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.15 milliseconds) 

!(assertEqualToResult (pair (bin) (bin)) ((A A) (A B) (B A) (B B)))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (A A) 
        (A B) 
        (B A) 
        (B B)) 
      ( (A A) 
        (A B) 
        (B A) 
        (B B))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; For the ordinary symbolic expression, if its subexpressions
;;; are nondeterministic, and no reduction rule is available
;;; for some combinations of their values, the whole expression
;;; for these values will appear in the set of final results,
;;; but without reduction. However, `match` can be called
;;; directly to filter out non-reducible results
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (= (foo)  red)
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(foo, 1, 0, [], 'AnyRet', [], x(doeval, eager), [foo], red).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_0__foo</span>(<span class="pl-args"
><span class="pl-var"
>A</span></span>)</span>, 
  [ [ assign,  A   ,'red' ]]].&#13;&#10;
mc_0__foo(A) :-
    A=red.
<span class="ansi36"
>
mc_0__foo(A) :-
    A=red.

</span>
<span class="ansi38-255165000"
> (= (foo)  boo)
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(foo, 1, 1, [], 'AnyRet', [], x(doeval, eager), [foo], boo).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_0__foo</span>(<span class="pl-args"
><span class="pl-var"
>A</span></span>)</span>, 
  [ [ assign,  A   , boo  ]]].&#13;&#10;
mc_0__foo(A) :-
    A=boo.
<span class="ansi36"
>
mc_0__foo(A) :-
    A=boo.

</span>
<span class="ansi38-255165000"
> (= (eq $x $x)  T)
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(eq, 3, 0, ['Any', 'Any'], 'AnyRet', [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [eq, _x, _x], 'T').

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_2__eq</span>(<span class="pl-args"
><span class="pl-var"
>_x</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>A</span></span>)</span>, 
  [ [ assign,  A   , 'T'  ]]].&#13;&#10;
mc_2__eq(_x, _x, A) :-
    A='T'.
<span class="ansi36"
>
mc_2__eq(_x, _x, A) :-
    A='T'.

</span>
<span class="ansi38-255165000"
> (= (find-equal $x $y)  
  (match &self 
    (= (eq $x $y)  T) $x))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store('find-equal', 3, 0, ['Any', 'Any'], 'AnyRet', [x(doeval, eager), x(doeval, eager)], x(doeval, eager), ['find-equal', _x, _y], [match, '&self', [=, [eq, _x, _y], 'T'], _x]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'mc_2__find-equal'</span>(<span class="pl-args"
><span class="pl-var"
>_x</span>, <span class="pl-var"
>_y</span>, <span class="pl-var"
>A</span></span>)</span>, 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      [ <span class="pl-atom"
>=</span>, 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>eq</span>, <span class="pl-var"
>_x</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
        <span class="pl-atom"
>'T'</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>match</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>2</span></span>)</span>, 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>]]]].&#13;&#10;
Asserting: transpiler_depends_on('find-equal',3,match,4)
'mc_2__find-equal'(_x, _y, A) :-
    B='&self',
    C=[=, [eq, _x, _y], 'T'],
    mc_3__match(B, C, is_p1(true, _x), A).
<span class="ansi36"
>
'mc_2__find-equal'(_x, _y, A) :-
    B='&self',
    C=[=, [eq, _x, _y], 'T'],
    mc_3__match(B, C, is_p1(true, _x), A).

</span>
<span class="ansi38-013099040"
>!(assertEqual (find-equal (color) (foo)) red)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.08"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.08</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.38 milliseconds) 

!(assertEqual (find-equal (color) (foo)) red)

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      (red) 
      (red)))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; One can pass nondeterministic expressions to an ordinary
;;; function and get multiple results.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (= (rev $x $y)  
  ($y $x))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(rev, 3, 0, ['Any', 'Any'], 'AnyRet', [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [rev, _x, _y], [_y, _x]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_2__rev</span>(<span class="pl-args"
><span class="pl-var"
>_x</span>, <span class="pl-var"
>_y</span>, <span class="pl-var"
>A</span></span>)</span>, 
  [ [ <span class="pl-atom"
>assign</span>, <span class="pl-var"
>A</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>list</span>(<span class="pl-args"
><span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-var"
>_y</span>|<span class="pl-ellipsis"
>...</span></span>]</span></span>)</span>]]].&#13;&#10;
mc_2__rev(_x, _y, A) :-
    A=[_y, _x].
<span class="ansi36"
>
mc_2__rev(_x, _y, A) :-
    A=[_y, _x].

</span>
<span class="ansi38-013099040"
>!(assertEqualToResult (rev A (superpose (B C D))) ((B A) (C A) (D A)))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.09"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.09</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.46 milliseconds) 

!(assertEqualToResult (rev A (superpose (B C D))) ((B A) (C A) (D A)))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (B A) 
        (C A) 
        (D A)) 
      ( (B A) 
        (C A) 
        (D A))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Extended example
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Some rules
<span class="ansi38-255165000"
> (= (ift T $then)  $then)
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(ift, 3, 0, ['Any', 'Any'], 'AnyRet', [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [ift, 'T', _then], _then).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_2__ift</span>(<span class="pl-args"
><span class="pl-atom"
>'T'</span>, <span class="pl-var"
>_then</span>, <span class="pl-var"
>_then</span></span>)</span>, 
  []].&#13;&#10;
mc_2__ift('T', _then, _then).
<span class="ansi36"
>
mc_2__ift('T', _then, _then).

</span>
<span class="ansi38-255165000"
> (= (And T T)  T)
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store('And', 3, 0, ['Any', 'Any'], 'AnyRet', [x(doeval, eager), x(doeval, eager)], x(doeval, eager), ['And', 'T', 'T'], 'T').

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_2__And</span>(<span class="pl-args"
><span class="pl-atom"
>'T'</span>, <span class="pl-atom"
>'T'</span>, <span class="pl-var"
>A</span></span>)</span>, 
  [ [ assign,  A   , 'T'  ]]].&#13;&#10;
mc_2__And('T', 'T', A) :-
    A='T'.
<span class="ansi36"
>
mc_2__And('T', 'T', A) :-
    A='T'.

</span>
<span class="ansi38-255165000"
> (= (make $x)  
  (ift 
    (makes $y $x) 
    (start $y)))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(make, 2, 0, ['Any'], 'AnyRet', [x(doeval, eager)], x(doeval, eager), [make, _x], [ift, [makes, _y, _x], [start, _y]]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_1__make</span>(<span class="pl-args"
><span class="pl-var"
>_x</span>, <span class="pl-var"
>A</span></span>)</span>, 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>makes</span></span>)</span>, <span class="pl-var"
>_y</span>, <span class="pl-var"
>_x</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>start</span></span>)</span>, 
        <span class="pl-var"
>_y</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>ift</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>2</span></span>)</span>]]]].&#13;&#10;
Asserting: transpiler_depends_on(make,2,makes,3)
<span class="ansi36"
>transpiler_stub_created(makes/3).

</span>; % ######### warning: creating stub for:makes
<span class="ansi36"
>
mc_2__makes(B, C, D) :-
    D=[makes, B, C].

</span>Asserting: transpiler_depends_on(make,2,start,2)
<span class="ansi36"
>transpiler_stub_created(start/2).

</span>; % ######### warning: creating stub for:start
<span class="ansi36"
>
mc_1__start(B, C) :-
    C=[start, B].

</span>Asserting: transpiler_depends_on(make,2,ift,3)
mc_1__make(_x, A) :-
    mc_2__makes(_y, _x, B),
    mc_1__start(_y, C),
    mc_2__ift(B, C, A).
<span class="ansi36"
>
mc_1__make(_x, A) :-
    mc_2__makes(_y, _x, B),
    mc_1__start(_y, C),
    mc_2__ift(B, C, A).

</span>
<span class="ansi38-255165000"
> (= (make $x)  
  (ift 
    (And 
      (prevents 
        (making $y) 
        (making $x)) 
      (makes $z $y)) 
    (stop $z)))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(make, 2, 1, ['Any'], 'AnyRet', [x(doeval, eager)], x(doeval, eager), [make, _x], [ift, ['And', [prevents, [making, _y], [making, _x]], [makes, _z, _y]], [stop, _z]]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_1__make</span>(<span class="pl-args"
><span class="pl-var"
>_x</span>, <span class="pl-var"
>A</span></span>)</span>, 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>making</span></span>)</span>, 
        <span class="pl-var"
>_y</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>making</span></span>)</span>, 
        <span class="pl-var"
>_x</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>D</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>prevents</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>2</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>E</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>makes</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_z'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_y'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>F</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'And'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>3</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>4</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>G</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>stop</span></span>)</span>, 
        <span class="pl-var"
>_z</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>ift</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>5</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>6</span></span>)</span>]]]].&#13;&#10;
Asserting: transpiler_depends_on(make,2,making,2)
<span class="ansi36"
>transpiler_stub_created(making/2).

</span>; % ######### warning: creating stub for:making
<span class="ansi36"
>
mc_1__making(B, C) :-
    C=[making, B].

</span>Asserting: transpiler_depends_on(make,2,prevents,3)
<span class="ansi36"
>transpiler_stub_created(prevents/3).

</span>; % ######### warning: creating stub for:prevents
<span class="ansi36"
>
mc_2__prevents(B, C, D) :-
    D=[prevents, B, C].

</span>Asserting: transpiler_depends_on(make,2,'And',3)
Asserting: transpiler_depends_on(make,2,stop,2)
<span class="ansi36"
>transpiler_stub_created(stop/2).

</span>; % ######### warning: creating stub for:stop
<span class="ansi36"
>
mc_1__stop(B, C) :-
    C=[stop, B].

</span>mc_1__make(_x, A) :-
    mc_1__making(_y, B),
    mc_1__making(_x, C),
    mc_2__prevents(B, C, D),
    mc_2__makes(_z, _y, E),
    mc_2__And(D, E, F),
    mc_1__stop(_z, G),
    mc_2__ift(F, G, A).
<span class="ansi36"
>
mc_1__make(_x, A) :-
    mc_1__making(_y, B),
    mc_1__making(_x, C),
    mc_2__prevents(B, C, D),
    mc_2__makes(_z, _y, E),
    mc_2__And(D, E, F),
    mc_1__stop(_z, G),
    mc_2__ift(F, G, A).

</span>
;;; Add facts to knowledge base
<span class="ansi38-255165000"
> (= (prevents (making (air dry)) (making (air wet)))  T)
</span><span class="ansi38-255165005"
>Retracting stub: mc_2__prevents(B,C,D)
</span><span class="ansi36"
>transpiler_clause_store(prevents, 3, 0, ['Any', 'Any'], 'AnyRet', [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [prevents, [making, [air, dry]], [making, [air, wet]]], 'T').

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-atom"
>mc_2__prevents</span>( 
     [ <span class="pl-atom"
>making</span>, 
       <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>air</span>, <span class="pl-atom"
>dry</span></span>]</span>], 
     [ <span class="pl-atom"
>making</span>, 
       <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>air</span>, <span class="pl-atom"
>wet</span></span>]</span>], 
     <span class="pl-var"
>A</span>), 
  [ [ assign,  A   , 'T'  ]]].&#13;&#10;
mc_2__prevents([making, [air, dry]], [making, [air, wet]], A) :-
    A='T'.
<span class="ansi36"
>
mc_2__prevents([making, [air, dry]], [making, [air, wet]], A) :-
    A='T'.

</span>
<span class="ansi38-255165000"
> (= (prevents (making (air wet)) (making (air dry)))  T)
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(prevents, 3, 1, ['Any', 'Any'], 'AnyRet', [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [prevents, [making, [air, wet]], [making, [air, dry]]], 'T').

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-atom"
>mc_2__prevents</span>( 
     [ <span class="pl-atom"
>making</span>, 
       <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>air</span>, <span class="pl-atom"
>wet</span></span>]</span>], 
     [ <span class="pl-atom"
>making</span>, 
       <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>air</span>, <span class="pl-atom"
>dry</span></span>]</span>], 
     <span class="pl-var"
>A</span>), 
  [ [ assign,  A   , 'T'  ]]].&#13;&#10;
mc_2__prevents([making, [air, wet]], [making, [air, dry]], A) :-
    A='T'.
<span class="ansi36"
>
mc_2__prevents([making, [air, wet]], [making, [air, dry]], A) :-
    A='T'.

</span>
<span class="ansi38-255165000"
> (= (makes humidifier (air wet))  T)
</span><span class="ansi38-255165005"
>Retracting stub: mc_2__makes(B,C,D)
</span><span class="ansi36"
>transpiler_clause_store(makes, 3, 0, ['Any', 'Any'], 'AnyRet', [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [makes, humidifier, [air, wet]], 'T').

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_2__makes</span>(<span class="pl-args"
><span class="pl-atom"
>humidifier</span>, <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>air</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, <span class="pl-var"
>A</span></span>)</span>, 
  [ [ assign,  A   , 'T'  ]]].&#13;&#10;
mc_2__makes(humidifier, [air, wet], A) :-
    A='T'.
<span class="ansi36"
>
mc_2__makes(humidifier, [air, wet], A) :-
    A='T'.

</span>
<span class="ansi38-255165000"
> (= (makes kettle (air wet))  T)
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(makes, 3, 1, ['Any', 'Any'], 'AnyRet', [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [makes, kettle, [air, wet]], 'T').

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_2__makes</span>(<span class="pl-args"
><span class="pl-atom"
>kettle</span>, <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>air</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, <span class="pl-var"
>A</span></span>)</span>, 
  [ [ assign,  A   , 'T'  ]]].&#13;&#10;
mc_2__makes(kettle, [air, wet], A) :-
    A='T'.
<span class="ansi36"
>
mc_2__makes(kettle, [air, wet], A) :-
    A='T'.

</span>
<span class="ansi38-255165000"
> (= (makes ventilation (air dry))  T)
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(makes, 3, 2, ['Any', 'Any'], 'AnyRet', [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [makes, ventilation, [air, dry]], 'T').

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_2__makes</span>(<span class="pl-args"
><span class="pl-atom"
>ventilation</span>, <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>air</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, <span class="pl-var"
>A</span></span>)</span>, 
  [ [ assign,  A   , 'T'  ]]].&#13;&#10;
mc_2__makes(ventilation, [air, dry], A) :-
    A='T'.
<span class="ansi36"
>
mc_2__makes(ventilation, [air, dry], A) :-
    A='T'.

</span>
<span class="ansi38-255165000"
> (= (is (air dry))  
  (make (air wet)))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(is, 2, 0, ['Any'], 'AnyRet', [x(doeval, eager)], x(doeval, eager), [is, [air, dry]], [make, [air, wet]]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_1__is</span>(<span class="pl-args"
><span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>air</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, <span class="pl-var"
>A</span></span>)</span>, 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>air</span></span>)</span>, 
        <span class="pl-var"
>B</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>make</span></span>)</span>, 
        <span class="pl-var"
>C</span>]]]].&#13;&#10;
Asserting: transpiler_depends_on(is,2,air,2)
<span class="ansi36"
>transpiler_stub_created(air/2).

</span>; % ######### warning: creating stub for:air
<span class="ansi36"
>
mc_1__air(B, C) :-
    C=[air, B].

</span>Asserting: transpiler_depends_on(is,2,make,2)
mc_1__is([air, dry], A) :-
    B=wet,
    mc_1__air(B, C),
    mc_1__make(C, A).
<span class="ansi36"
>
mc_1__is([air, dry], A) :-
    B=wet,
    mc_1__air(B, C),
    mc_1__make(C, A).

</span>
<span class="ansi38-255165000"
> (= (is (air wet))  
  (make (air dry)))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(is, 2, 1, ['Any'], 'AnyRet', [x(doeval, eager)], x(doeval, eager), [is, [air, wet]], [make, [air, dry]]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_1__is</span>(<span class="pl-args"
><span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>air</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, <span class="pl-var"
>A</span></span>)</span>, 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>air</span></span>)</span>, 
        <span class="pl-var"
>B</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>make</span></span>)</span>, 
        <span class="pl-var"
>C</span>]]]].&#13;&#10;
mc_1__is([air, wet], A) :-
    B=dry,
    mc_1__air(B, C),
    mc_1__make(C, A).
<span class="ansi36"
>
mc_1__is([air, wet], A) :-
    B=dry,
    mc_1__air(B, C),
    mc_1__make(C, A).

</span>
;;; the results are not sequential in sense that their order is arbitrary
<span class="ansi38-013099040"
>!(assertEqual (is (air dry)) (superpose ((stop ventilation) (start kettle) (start humidifier))))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.10"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.10</h3>
; 
; EVAL TEST
; took 0.006 secs. (6.26 milliseconds) 

!(assertEqual (is (air dry)) (superpose ((stop ventilation) (start kettle) (start humidifier))))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (start humidifier) 
        (start kettle) 
        (stop ventilation)) 
      ( (stop ventilation) 
        (start kettle) 
        (start humidifier))))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqual (is (air wet)) (superpose ((stop kettle) (stop humidifier) (start ventilation))))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.11"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.B4-NONDETERM.11</h3>
; 
; EVAL TEST
; took 0.006 secs. (6.33 milliseconds) 

!(assertEqual (is (air wet)) (superpose ((stop kettle) (stop humidifier) (start ventilation))))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (start ventilation) 
        (stop humidifier) 
        (stop kettle)) 
      ( (stop kettle) 
        (stop humidifier) 
        (start ventilation))))
</span>
Deterministic: <span class="ansi33"
>()
</span>P;HTML|
;                #( = /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-experimental_scripts/b4_nondeterm.metta 0 )
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 11
</span><span class="ansi32"
>Failures: 0
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
P;HTML|
;          #(set_debug transpiler false)
P;HTML|
;          #(set_debug overtime 4.0)
P;HTML|
;          #(set_debug overflow 1000)
P;HTML|
;          #(set_debug eval false)
P;HTML|
;          #(set_debug load silent)
P;HTML|
;          #(set_debug trace-on-load false)
P;HTML|
;          #(set_debug exec false)
P;HTML|
;          #(set_debug error non-type)
P;HTML|
;          #(set_debug fail false)
P;HTML|
;          #(set_debug test true)
P;HTML|
;          #(set_debug test false)
P;HTML|
;          #(set_debug fail false)
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
P;HTML|
;           #(maybe_halt 7)
<span class="ansi31"
>#(in #(not_compat_io #(maybe_halt 7)) #(unwind #(halt 7)))
</span>
Script done on 2024-12-26 18:29:13+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat/' --timeout=40 --html --repl=false  --test "tests/baseline_compat/hyperon-experimental_scripts/b4_nondeterm.metta" --halt=true\033[0m
