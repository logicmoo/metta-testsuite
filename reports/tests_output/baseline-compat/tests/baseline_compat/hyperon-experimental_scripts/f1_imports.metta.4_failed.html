<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi36 { color: #00aaaa; }
.ansi90 { color: #7f7f7f; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-11-29 10:53:03+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;           (set_option_value  compat false)

P;HTML|
;           (set_option_value  compatio false)

P;HTML|
;           (set_option_value  src_indents false)

P;HTML|
;         (set_option_value  devel false)

P;HTML|
;         (set_option_value  stack-max 500)

P;HTML|
;         (set_option_value  limit inf)

P;HTML|
;         (set_option_value  initial-result-count 10)

P;HTML|
;         (set_option_value  answer-format show)

P;HTML|
;         (set_option_value  repeats true)

P;HTML|
;         (set_option_value  time true)

P;HTML|
;         (set_option_value  synth-unit-tests false)

P;HTML|
;         (set_option_value  optimize true)

P;HTML|
;         (set_option_value  transpiler silent)

P;HTML|
;          (set_debug  transpiler false)

P;HTML|
;         (set_option_value  compile false)

P;HTML|
;         (set_option_value  tabling auto)

P;HTML|
;         (set_option_value  log false)

P;HTML|
;         (set_option_value  output ./)

P;HTML|
;         (set_option_value  exeout ./Sav.gitlab.MeTTaLog)

P;HTML|
;         (set_option_value  halt false)

P;HTML|
;         (set_option_value  trace-length 500)

P;HTML|
;         (set_option_value  trace-on-overtime 4.0)

P;HTML|
;          (set_debug  overtime 4.0)

P;HTML|
;         (set_option_value  trace-on-overflow 1000)

P;HTML|
;          (set_debug  overflow 1000)

P;HTML|
;         (set_option_value  trace-on-eval false)

P;HTML|
;          (set_debug  eval false)

P;HTML|
;         (set_option_value  trace-on-load silent)

P;HTML|
;          (set_debug  load silent)

P;HTML|
;          (set_debug  trace-on-load false)

P;HTML|
;         (set_option_value  trace-on-exec false)

P;HTML|
;          (set_debug  exec false)

P;HTML|
;         (set_option_value  trace-on-error non-type)

P;HTML|
;          (set_debug  error non-type)

P;HTML|
;         (set_option_value  trace-on-fail false)

P;HTML|
;          (set_debug  fail false)

P;HTML|
;         (set_option_value  trace-on-test true)

P;HTML|
;          (set_debug  test true)

P;HTML|
;         (set_option_value  repl-on-error true)

P;HTML|
;         (set_option_value  repl-on-fail false)

P;HTML|
;         (set_option_value  exit-on-fail false)

P;HTML|
;         (set_option_value  repl auto)

P;HTML|
;         (set_option_value  prolog false)

P;HTML|
;         (set_option_value  exec noskip)

P;HTML|
;         (set_option_value  maximum-result-count inf)

P;HTML|
;         (set_option_value  html false)

P;HTML|
;         (set_option_value  python true)

P;HTML|
;         (set_option_value  trace-on-test false)

P;HTML|
;         (set_debug  test false)

P;HTML|
;         (set_option_value  trace-on-fail false)

P;HTML|
;         (set_debug  fail false)

P;HTML|
;         (set_option_value  load show)

P;HTML|
;         (set_option_value  test false)
<span class="ansi32"
>
% 46,854 inferences, 0.181 CPU in 0.181 seconds (100% CPU, 259529 Lips)
</span>P;HTML|
;          (is_cmd_option  prescan halt --halt=true true)
P;HTML|
;          (set_option_value  halt true)
P;HTML|
;          (is_cmd_option  prescan stdin --stdin=tty tty)
P;HTML|
;           (set_option_value  stdin tty)
P;HTML|
;          (is_cmd_option  prescan stdout --stdout=tty tty)
P;HTML|
;           (set_option_value  stdout tty)
P;HTML|
;          (is_cmd_option  prescan stderr --stderr=tty tty)
P;HTML|
;           (set_option_value  stderr tty)
P;HTML|
;          (set_option_value  compat false)
P;HTML|
;          (set_option_value  compatio false)
P;HTML|
;          (set_option_value  src_indents false)
P;HTML|
;          (set_option_value  devel false)
P;HTML|
;          (set_option_value  stack-max 500)
P;HTML|
;          (set_option_value  limit inf)
P;HTML|
;          (set_option_value  initial-result-count 10)
P;HTML|
;          (set_option_value  answer-format show)
P;HTML|
;          (set_option_value  repeats true)
P;HTML|
;          (set_option_value  time true)
P;HTML|
;          (set_option_value  synth-unit-tests false)
P;HTML|
;          (set_option_value  optimize true)
P;HTML|
;          (set_option_value  transpiler silent)
P;HTML|
;          (set_debug  transpiler false)
P;HTML|
;          (set_option_value  compile false)
P;HTML|
;          (set_option_value  tabling auto)
P;HTML|
;          (set_option_value  log false)
P;HTML|
;          (set_option_value  output ./)
P;HTML|
;          (set_option_value  exeout ./Sav.gitlab.MeTTaLog)
P;HTML|
;          (set_option_value  halt false)
P;HTML|
;          (set_option_value  trace-length 500)
P;HTML|
;          (set_option_value  trace-on-overtime 4.0)
P;HTML|
;          (set_debug  overtime 4.0)
P;HTML|
;          (set_option_value  trace-on-overflow 1000)
P;HTML|
;          (set_debug  overflow 1000)
P;HTML|
;          (set_option_value  trace-on-eval false)
P;HTML|
;          (set_debug  eval false)
P;HTML|
;          (set_option_value  trace-on-load silent)
P;HTML|
;          (set_debug  load silent)
P;HTML|
;          (set_debug  trace-on-load false)
P;HTML|
;          (set_option_value  trace-on-exec false)
P;HTML|
;          (set_debug  exec false)
P;HTML|
;          (set_option_value  trace-on-error non-type)
P;HTML|
;          (set_debug  error non-type)
P;HTML|
;          (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;          (set_option_value  trace-on-test true)
P;HTML|
;          (set_debug  test true)
P;HTML|
;          (set_option_value  repl-on-error true)
P;HTML|
;          (set_option_value  repl-on-fail false)
P;HTML|
;          (set_option_value  exit-on-fail false)
P;HTML|
;          (set_option_value  repl auto)
P;HTML|
;          (set_option_value  prolog false)
P;HTML|
;          (set_option_value  exec noskip)
P;HTML|
;          (set_option_value  maximum-result-count inf)
P;HTML|
;          (set_option_value  html false)
P;HTML|
;          (set_option_value  python true)
P;HTML|
;         (set_option_value  trace-on-test false)
P;HTML|
;          (set_debug  test false)
P;HTML|
;         (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;         (set_option_value  load show)
P;HTML|
;         (set_option_value  test true)
P;HTML|
;        (is_cmd_option  execute python --python=enable enable)
P;HTML|
;         (set_option_value  python enable)
P;HTML|
;        (is_cmd_option  execute timeout --timeout=40 40)
P;HTML|
;         (set_option_value  timeout 40)
P;HTML|
;         (is_cmd_option  execute output --output=./reports/tests_output/baseline-compat/ ./reports/tests_output/baseline-compat/)
P;HTML|
;         (set_option_value  output ./reports/tests_output/baseline-compat/)
P;HTML|
;         (is_cmd_option  execute html --html true)
P;HTML|
;          (set_option_value  html true)
P;HTML|
;         (is_cmd_option  execute test --test true)
P;HTML|
;          (set_option_value  test true)

; (load_metta_file  &self tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta)
P;HTML|
;                       (track_load_into_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta)
P;HTML|
;                                        (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta)
P;HTML|
;                                         (= 1  "[hyperon::space::DynSpace]")
P;HTML|
;                                         (= 2  "[(Error (assertEqual ((let $x (get-atoms GroundingSpace-top) (get-type $x))) ((get-type GroundingSpace-top))) ")
P;HTML|
;                                         (= 2  "Expected: [(hyperon::space::DynSpace)]")
P;HTML|
;                                         (= 2  "Got: [(hyperon::space::DynSpace), (hyperon::space::DynSpace)]")
P;HTML|
;                                         (= 3  "Excessive result: (hyperon::space::DynSpace))]")
P;HTML|
;                                         (= 3  "0.05user 0.00system 0:00.05elapsed 96%CPU (0avgtext+0avgdata 30952maxresident)k")
P;HTML|
;                                         (= 3  "0inputs+0outputs (0major+3659minor)pagefaults 0swaps")
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta is 4.06K bytes (120 lines)
</span>P;HTML|
;                                        (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta)

;;; NOTE: This test won't work outside the test environment because it relies on
;;;  specific atoms in a specific order in the space, and loading the default environment's
;;;  init.metta will break the assumptions in this test
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Even at the very beginning of the main script `(get-atoms &self)`
;;; returns one atom, which wraps the space of stdlib.
;;; The type of this atom is the same as of `&self`
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;!(get-atoms &self)
;;;;!(get-type (get-atoms &self))
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>!(get-type &self)
</span>;; To unit test case:
<span class="ansi38-013099040"
>!(assertEqualToResult (get-type &self) (hyperon::space::DynSpace))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.01"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.01</h3>
; 
; EVAL TEST
; took 0.000229 secs. (228.84 microseconds) 

!(assertEqualToResult (get-type &self) (hyperon::space::DynSpace))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (hyperon::space::DynSpace) (hyperon::space::DynSpace)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual ((let $x (get-atoms &self) (get-type $x))) ((get-type &self)))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.02"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.02</h3>

(failed  once (if_or_else  (eval  = $_502032 495 &self (let a b never-happens) $_503706) (call  eval (let a b never-happens) $_503706)))


(on_mettalog_error  (failed  once (if_or_else  (eval  = $_502032 495 &self (let a b never-happens) $_503706) (call  eval (let a b never-happens) $_503706))))

^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] call(user:once, user:if_or_else(eval(=, _502032, 495, '&self', [let, a, b, 'never-happens'], _503706), call(eval, [let, a, b, 'never-happens'], _503706)))
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] once(user:if_or_else(eval(=, _502032, 495, '&self', [let, a, b, 'never-happens'], _503706), call(eval, [let, a, b, 'never-happens'], _503706)))
   <span class="ansi1 ansi32"
>Call: </span>(299) [user] if_or_else(eval(=, _502032, 495, '&self', [let, a, b, 'never-happens'], _503706), call(eval, [let, a, b, 'never-happens'], _503706))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] eval(=, _502032, 495, '&self', [let, a, b, 'never-happens'], _503706)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] catch_metta_return(eval_args(=, _502032, 495, '&self', [let, a, b, 'never-happens'], _503706), _503706)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_args(=, _502032, 495, '&self', [let, a, b, 'never-happens'], _503706)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_512116, _512118), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_512116, _512118))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_512116, _512118))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_514204, _514206), once(user:nonvar(_503706)), '$restore_trace'(_514204, _514206))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_514204, _514206))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_516292, _516294), once(user:nonvar(_503706)), '$restore_trace'(_516292, _516294))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_516292, _516294))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] setup_call_cleanup('$notrace'(_523448, _523450), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_523448, _523450))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] sig_atomic(system:'$notrace'(_523448, _523450))
^  <span class="ansi1 ansi31"
>Fail: </span>(304) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] eval_00(=, _502032, 495, '&self', [let, a, b, 'never-happens'], _503706)
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] setup_call_cleanup('$notrace'(_528592, _528594), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_528592, _528594))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] sig_atomic(system:'$notrace'(_528592, _528594))
^  <span class="ansi1 ansi31"
>Fail: </span>(305) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] eval_01(=, _502032, 495, '&self', [let, a, b, 'never-happens'], _503706)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] 495<1
   <span class="ansi1 ansi31"
>Fail: </span>(308) [system] 495<1
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] setup_call_cleanup('$notrace'(_536828, _536830), once(user:(_536804 is 495-1, copy_term([let, a, b, 'never-happens'], _536818))), '$restore_trace'(_536828, _536830))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] sig_atomic(system:'$notrace'(_536828, _536830))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(494 is 495-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] trace_eval(eval_20(=, _502032), e, 494, '&self', [let, a, b, 'never-happens'], _539938)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] must_det_ll((notrace((flag(eval_num, _540992, _540992+1), _541010 is _540992 mod 500, _541028 is 99-494 mod 100, _541052=_541054, option_else('trace-length', _541066, 500), option_else('trace-depth', _541074, 30))), quietly(if_t((nop(stop_rtrace), _541010>_541066), (set_debug(eval, false), _541130 is _541066+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_541130])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_541182)))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] once(user:(notrace((flag(eval_num, _540992, _540992+1), _541010 is _540992 mod 500, _541028 is 99-494 mod 100, _541052=_541054, option_else('trace-length', _541066, 500), option_else('trace-depth', _541074, 30))), quietly(if_t((nop(stop_rtrace), _541010>_541066), (set_debug(eval, false), _541130 is _541066+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_541130])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_541182)))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] setup_call_cleanup('$notrace'(_543228, _543230), once(user:(flag(eval_num, _540992, _540992+1), _541010 is _540992 mod 500, _541028 is 99-494 mod 100, _541052=_541054, option_else('trace-length', _541066, 500), option_else('trace-depth', _541074, 30))), '$restore_trace'(_543228, _543230))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] sig_atomic(system:'$notrace'(_543228, _543230))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2880, 2880+1), 380 is 2880 mod 500, 5 is 99-494 mod 100, _541052=_541052, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 380>500), (set_debug(eval, false), _541130 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_541130])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 380>500), (set_debug(eval, false), _541130 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_541130])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] nop(notrace(no_repeats_var(_541182)))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] nop(notrace(no_repeats_var(_541182)))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] once(user:(notrace((flag(eval_num, 2880, 2880+1), 380 is 2880 mod 500, 5 is 99-494 mod 100, _541052=_541052, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 380>500), (set_debug(eval, false), _541130 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_541130])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_541182)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] must_det_ll(user:(notrace((flag(eval_num, 2880, 2880+1), 380 is 2880 mod 500, 5 is 99-494 mod 100, _541052=_541052, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 380>500), (set_debug(eval, false), _541130 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_541130])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_541182)))))
   <span class="ansi1 ansi32"
>Call: </span>(307) [occurs] occurs:sub_term(_552880, e)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(307) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(308) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(307) [occurs] occurs:sub_term(_552880, e)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _559986=e
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] if_trace((eval;e), (_541052=1, indentq(5, 380, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_563126, _563128), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _541052=1, indentq(5, 380, -->, [e, [let, a, b, 'never-happens']]))), _563084, fbug((_563084-->if_trace((eval;e), (_541052=1, indentq(5, 380, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_563126, _563128))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_563126, _563128))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _541052=1, indentq(5, 380, -->, [e, [let, a, b, 'never-happens']]))), _563084, fbug((_563084-->if_trace((eval;e), (_541052=1, indentq(5, 380, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] if_trace((eval;e), (_541052=1, indentq(5, 380, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _567322=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _569360=(\+ \+ (flag(eval_num, _569380, _569380+1), (retval(fail)\=@=retval(fail), nonvar(_539938)->indentq(5, _569380, <--, [e, _539938]);indentq(5, _569380, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] (\+ \+ (flag(eval_num, _569380, _569380+1), (retval(fail)\=@=retval(fail), nonvar(_539938)->indentq(5, _569380, <--, [e, _539938]);indentq(5, _569380, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _569380, _569380+1), (retval(fail)\=@=retval(fail), nonvar(_539938)->indentq(5, _569380, <--, [e, _539938]);indentq(5, _569380, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] call_cleanup(((call(eval_20(=, _502032), 494, '&self', [let, a, b, 'never-happens'], _539938)*->nb_setarg(1, retval(fail), _539938);fail, trace, call(eval_20(=, _502032), 494, '&self', [let, a, b, 'never-happens'], _539938)), ignore(notrace((\+_539938\=_541182, nb_setarg(1, retval(fail), _539938))))), ignore((_541052==1->ignore(\+ \+ (flag(eval_num, _569380, _569380+1), (retval(fail)\=@=retval(fail), nonvar(_539938)->indentq(5, _569380, <--, [e, _539938]);indentq(5, _569380, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _569380, _569380+1), (retval(fail)\=@=retval(fail), nonvar(_539938)->indentq(5, _569380, <--, [e, _539938]);indentq(5, _569380, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_20(=, _502032, 494, '&self', [let, a, b, 'never-happens'], _539938)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] setup_call_cleanup('$notrace'(_576768, _576770), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_576768, _576770))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(system:'$notrace'(_576768, _576770))
^  <span class="ansi1 ansi31"
>Fail: </span>(311) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(311) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] once(expand_eval([let, a, b, 'never-happens'], _599112))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] expand_eval([let, a, b, 'never-happens'], _599112)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _605212)
   <span class="ansi1 ansi32"
>Call: </span>(313) [apply] apply:maplist_([a, b, 'never-happens'], _605212, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] expand_eval(a, _607268)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] a=_607268
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(314) [apply] apply:maplist_([b, 'never-happens'], _607270, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] expand_eval(b, _613370)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] b=_613370
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(315) [apply] apply:maplist_(['never-happens'], _613372, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] expand_eval('never-happens', _619472)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] 'never-happens'=_619472
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(316) [apply] apply:maplist_([], _619474, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(314) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] possible_type('&self', a, _636764)
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] possible_type('&self', a, _636764)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] eval_args(=, _636764, 494, '&self', b, _638806)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_640864, _640866), once(user:self_eval(b)), '$restore_trace'(_640864, _640866))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_640864, _640866))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] _638806=b
   <span class="ansi1 ansi32"
>Exit: </span>(311) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] eval_args(=, _636764, 494, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] eval_20(=, _502032, 494, '&self', [let, a, b, 'never-happens'], _539938)
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(309) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] ignore((_541052==1->ignore(\+ \+ (flag(eval_num, _569380, _569380+1), (retval(fail)\=@=retval(fail), nonvar(_539938)->indentq(5, _569380, <--, [e, _539938]);indentq(5, _569380, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _569380, _569380+1), (retval(fail)\=@=retval(fail), nonvar(_539938)->indentq(5, _569380, <--, [e, _539938]);indentq(5, _569380, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] _541052==1
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] _541052==1
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_654194, _654196), once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _569380, _569380+1), (retval(fail)\=@=retval(fail), nonvar(_539938)->indentq(5, _569380, <--, [e, _539938]);indentq(5, _569380, <--, [e, retval(fail)])))))))), '$restore_trace'(_654194, _654196))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_654194, _654196))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _569380, _569380+1), (retval(fail)\=@=retval(fail), nonvar(_539938)->indentq(5, _569380, <--, [e, _539938]);indentq(5, _569380, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] ignore(user:(_541052==1->ignore(\+ \+ (flag(eval_num, _569380, _569380+1), (retval(fail)\=@=retval(fail), nonvar(_539938)->indentq(5, _569380, <--, [e, _539938]);indentq(5, _569380, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _569380, _569380+1), (retval(fail)\=@=retval(fail), nonvar(_539938)->indentq(5, _569380, <--, [e, _539938]);indentq(5, _569380, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(307) [system] call_cleanup(user:((call(eval_20(=, _502032), 494, '&self', [let, a, b, 'never-happens'], _539938)*->nb_setarg(1, retval(fail), _539938);fail, trace, call(eval_20(=, _502032), 494, '&self', [let, a, b, 'never-happens'], _539938)), ignore(notrace((\+_539938\=_541182, nb_setarg(1, retval(fail), _539938))))), user:ignore((_541052==1->ignore(\+ \+ (flag(eval_num, _569380, _569380+1), (retval(fail)\=@=retval(fail), nonvar(_539938)->indentq(5, _569380, <--, [e, _539938]);indentq(5, _569380, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _569380, _569380+1), (retval(fail)\=@=retval(fail), nonvar(_539938)->indentq(5, _569380, <--, [e, _539938]);indentq(5, _569380, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(306) [user] trace_eval(eval_20(=, _502032), e, 494, '&self', [let, a, b, 'never-happens'], _539938)
^  <span class="ansi1 ansi31"
>Fail: </span>(303) [user] eval_args(=, _502032, 495, '&self', [let, a, b, 'never-happens'], _503706)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] call(eval, [let, a, b, 'never-happens'], _503706)
   <span class="ansi1 ansi32"
>Call: </span>(301) [user] eval([let, a, b, 'never-happens'], _503706)
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] current_self(_663602)
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] nb_current(self_space, _663602)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(302) [user] eval('&self', [let, a, b, 'never-happens'], _503706)
   <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _503706)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] catch_metta_return(eval_args(=, _671716, 500, '&self', [let, a, b, 'never-happens'], _503706), _503706)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_args(=, _671716, 500, '&self', [let, a, b, 'never-happens'], _503706)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_674826, _674828), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_674826, _674828))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_674826, _674828))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_676914, _676916), once(user:nonvar(_503706)), '$restore_trace'(_676914, _676916))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_676914, _676916))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_679002, _679004), once(user:nonvar(_503706)), '$restore_trace'(_679002, _679004))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_679002, _679004))
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_686158, _686160), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_686158, _686160))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_686158, _686160))
^  <span class="ansi1 ansi31"
>Fail: </span>(307) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] eval_00(=, _671716, 500, '&self', [let, a, b, 'never-happens'], _503706)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_691302, _691304), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_691302, _691304))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_691302, _691304))
^  <span class="ansi1 ansi31"
>Fail: </span>(308) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] eval_01(=, _671716, 500, '&self', [let, a, b, 'never-happens'], _503706)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_699538, _699540), once(user:(_699514 is 500-1, copy_term([let, a, b, 'never-happens'], _699528))), '$restore_trace'(_699538, _699540))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_699538, _699540))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] trace_eval(eval_20(=, _671716), e, 499, '&self', [let, a, b, 'never-happens'], _702648)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] must_det_ll((notrace((flag(eval_num, _703702, _703702+1), _703720 is _703702 mod 500, _703738 is 99-499 mod 100, _703762=_703764, option_else('trace-length', _703776, 500), option_else('trace-depth', _703784, 30))), quietly(if_t((nop(stop_rtrace), _703720>_703776), (set_debug(eval, false), _703840 is _703776+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_703840])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_703892)))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] once(user:(notrace((flag(eval_num, _703702, _703702+1), _703720 is _703702 mod 500, _703738 is 99-499 mod 100, _703762=_703764, option_else('trace-length', _703776, 500), option_else('trace-depth', _703784, 30))), quietly(if_t((nop(stop_rtrace), _703720>_703776), (set_debug(eval, false), _703840 is _703776+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_703840])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_703892)))))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] setup_call_cleanup('$notrace'(_705938, _705940), once(user:(flag(eval_num, _703702, _703702+1), _703720 is _703702 mod 500, _703738 is 99-499 mod 100, _703762=_703764, option_else('trace-length', _703776, 500), option_else('trace-depth', _703784, 30))), '$restore_trace'(_705938, _705940))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] sig_atomic(system:'$notrace'(_705938, _705940))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2881, 2881+1), 381 is 2881 mod 500, 0 is 99-499 mod 100, _703762=_703762, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 381>500), (set_debug(eval, false), _703840 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_703840])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 381>500), (set_debug(eval, false), _703840 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_703840])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] nop(notrace(no_repeats_var(_703892)))
   <span class="ansi1 ansi32"
>Exit: </span>(313) [user] nop(notrace(no_repeats_var(_703892)))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] once(user:(notrace((flag(eval_num, 2881, 2881+1), 381 is 2881 mod 500, 0 is 99-499 mod 100, _703762=_703762, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 381>500), (set_debug(eval, false), _703840 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_703840])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_703892)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] must_det_ll(user:(notrace((flag(eval_num, 2881, 2881+1), 381 is 2881 mod 500, 0 is 99-499 mod 100, _703762=_703762, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 381>500), (set_debug(eval, false), _703840 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_703840])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_703892)))))
   <span class="ansi1 ansi32"
>Call: </span>(310) [occurs] occurs:sub_term(_715590, e)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(310) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(310) [occurs] occurs:sub_term(_715590, e)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _722696=e
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] if_trace((eval;e), (_703762=1, indentq(0, 381, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_725836, _725838), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _703762=1, indentq(0, 381, -->, [e, [let, a, b, 'never-happens']]))), _725794, fbug((_725794-->if_trace((eval;e), (_703762=1, indentq(0, 381, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_725836, _725838))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_725836, _725838))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _703762=1, indentq(0, 381, -->, [e, [let, a, b, 'never-happens']]))), _725794, fbug((_725794-->if_trace((eval;e), (_703762=1, indentq(0, 381, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_trace((eval;e), (_703762=1, indentq(0, 381, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _730032=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _732070=(\+ \+ (flag(eval_num, _732090, _732090+1), (retval(fail)\=@=retval(fail), nonvar(_702648)->indentq(0, _732090, <--, [e, _702648]);indentq(0, _732090, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] (\+ \+ (flag(eval_num, _732090, _732090+1), (retval(fail)\=@=retval(fail), nonvar(_702648)->indentq(0, _732090, <--, [e, _702648]);indentq(0, _732090, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _732090, _732090+1), (retval(fail)\=@=retval(fail), nonvar(_702648)->indentq(0, _732090, <--, [e, _702648]);indentq(0, _732090, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] call_cleanup(((call(eval_20(=, _671716), 499, '&self', [let, a, b, 'never-happens'], _702648)*->nb_setarg(1, retval(fail), _702648);fail, trace, call(eval_20(=, _671716), 499, '&self', [let, a, b, 'never-happens'], _702648)), ignore(notrace((\+_702648\=_703892, nb_setarg(1, retval(fail), _702648))))), ignore((_703762==1->ignore(\+ \+ (flag(eval_num, _732090, _732090+1), (retval(fail)\=@=retval(fail), nonvar(_702648)->indentq(0, _732090, <--, [e, _702648]);indentq(0, _732090, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _732090, _732090+1), (retval(fail)\=@=retval(fail), nonvar(_702648)->indentq(0, _732090, <--, [e, _702648]);indentq(0, _732090, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval_20(=, _671716, 499, '&self', [let, a, b, 'never-happens'], _702648)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] setup_call_cleanup('$notrace'(_739478, _739480), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_739478, _739480))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] sig_atomic(system:'$notrace'(_739478, _739480))
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] once(expand_eval([let, a, b, 'never-happens'], _761822))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] expand_eval([let, a, b, 'never-happens'], _761822)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _767922)
   <span class="ansi1 ansi32"
>Call: </span>(316) [apply] apply:maplist_([a, b, 'never-happens'], _767922, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] expand_eval(a, _769978)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] a=_769978
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(317) [apply] apply:maplist_([b, 'never-happens'], _769980, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] expand_eval(b, _776080)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] b=_776080
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(318) [apply] apply:maplist_(['never-happens'], _776082, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] expand_eval('never-happens', _782182)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] 'never-happens'=_782182
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(319) [apply] apply:maplist_([], _782184, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(317) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] possible_type('&self', a, _799474)
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] possible_type('&self', a, _799474)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval_args(=, _799474, 499, '&self', b, _801516)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_803574, _803576), once(user:self_eval(b)), '$restore_trace'(_803574, _803576))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_803574, _803576))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] _801516=b
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] eval_args(=, _799474, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(312) [user] eval_20(=, _671716, 499, '&self', [let, a, b, 'never-happens'], _702648)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(312) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] ignore((_703762==1->ignore(\+ \+ (flag(eval_num, _732090, _732090+1), (retval(fail)\=@=retval(fail), nonvar(_702648)->indentq(0, _732090, <--, [e, _702648]);indentq(0, _732090, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _732090, _732090+1), (retval(fail)\=@=retval(fail), nonvar(_702648)->indentq(0, _732090, <--, [e, _702648]);indentq(0, _732090, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] _703762==1
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] _703762==1
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_816904, _816906), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _732090, _732090+1), (retval(fail)\=@=retval(fail), nonvar(_702648)->indentq(0, _732090, <--, [e, _702648]);indentq(0, _732090, <--, [e, retval(fail)])))))))), '$restore_trace'(_816904, _816906))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_816904, _816906))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _732090, _732090+1), (retval(fail)\=@=retval(fail), nonvar(_702648)->indentq(0, _732090, <--, [e, _702648]);indentq(0, _732090, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] ignore(user:(_703762==1->ignore(\+ \+ (flag(eval_num, _732090, _732090+1), (retval(fail)\=@=retval(fail), nonvar(_702648)->indentq(0, _732090, <--, [e, _702648]);indentq(0, _732090, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _732090, _732090+1), (retval(fail)\=@=retval(fail), nonvar(_702648)->indentq(0, _732090, <--, [e, _702648]);indentq(0, _732090, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(310) [system] call_cleanup(user:((call(eval_20(=, _671716), 499, '&self', [let, a, b, 'never-happens'], _702648)*->nb_setarg(1, retval(fail), _702648);fail, trace, call(eval_20(=, _671716), 499, '&self', [let, a, b, 'never-happens'], _702648)), ignore(notrace((\+_702648\=_703892, nb_setarg(1, retval(fail), _702648))))), user:ignore((_703762==1->ignore(\+ \+ (flag(eval_num, _732090, _732090+1), (retval(fail)\=@=retval(fail), nonvar(_702648)->indentq(0, _732090, <--, [e, _702648]);indentq(0, _732090, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _732090, _732090+1), (retval(fail)\=@=retval(fail), nonvar(_702648)->indentq(0, _732090, <--, [e, _702648]);indentq(0, _732090, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] trace_eval(eval_20(=, _671716), e, 499, '&self', [let, a, b, 'never-happens'], _702648)
^  <span class="ansi1 ansi31"
>Fail: </span>(306) [user] eval_args(=, _671716, 500, '&self', [let, a, b, 'never-happens'], _503706)
^  <span class="ansi1 ansi31"
>Fail: </span>(297) [system] call(user:once, user:if_or_else(eval(=, _502032, 495, '&self', [let, a, b, 'never-happens'], _503706), call(eval, [let, a, b, 'never-happens'], _503706)))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(299) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] setup_call_cleanup('$notrace'(_828366, _828368), once(rtrace:retract(t_l:tracer_reset(_828356))), '$restore_trace'(_828366, _828368))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] sig_atomic(system:'$notrace'(_828366, _828368))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [rtrace] tAt(false, 271, 271, false)
; 
; EVAL TEST
; took 0.938 secs. (937.99 milliseconds) 

!(assertEqual ((let $x (get-atoms &self) (get-type $x))) ((get-type &self)))

<span class="ansi31"
>(loonit_failureR  (equal_enough_for_test  ((hyperon::space::DynSpace) (hyperon::space::DynSpace) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (()) (DocInformal) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (())) ((hyperon::space::DynSpace))))
</span>
Deterministic: ((Error  (got  ((hyperon::space::DynSpace) (hyperon::space::DynSpace) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (()) (DocInformal) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()))) (expected  ((hyperon::space::DynSpace)))))
;;; stdlib is already loaded
<span class="ansi38-013099040"
>!(assertEqual (if (> 1 2) 1 2) 2)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.03"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.03</h3>
; 
; EVAL TEST
; took 0.000245 secs. (244.51 microseconds) 

!(assertEqual (if (> 1 2) 1 2) 2)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (2) (2)))
</span>
Deterministic: ()
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Importing the module into new space
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &m f1_moduleA.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta)
P;HTML|
;                                         (= 1  "[(Error (import! GroundingSpace-top f1_moduleC.metta) Illegal module name: f1_moduleC.metta)]")
P;HTML|
;                                         (= 2  "0.05user 0.00system 0:00.05elapsed 100%CPU (0avgtext+0avgdata 31132maxresident)k")
P;HTML|
;                                         (= 2  "0inputs+0outputs (0major+3659minor)pagefaults 0swaps")
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta is 625 bytes (17 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta is 291 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Numer))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()
;;; FIXME? stdlib space is not available at importing time -
;;; only tokens / grounded operations work, while symbolic functions
;;; (like `if`) don't work.
;;; FIXME? Exceptions are not caught by `importOp`
<span class="ansi38-013099040"
>!(assertEqual (+ 1 2) 3)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.04"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.04</h3>
; 
; EVAL TEST
; took 0.000175 secs. (175.08 microseconds) 

!(assertEqual (+ 1 2) 3)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (3) (3)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (if True "S" "F") "S")

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.05"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.05</h3>
; 
; EVAL TEST
; took 0.000141 secs. (141.40 microseconds) 

!(assertEqual (if True "S" "F") "S")

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  ("S") ("S")))
</span>
Deterministic: ()<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (+ $x 10) (g $x)))
</span><span class="ansi38-255165000"
> (: f (-> Number Number))
</span><span class="ansi38-255165000"
> (= (f $x) (if (< $x 0) (- 0 $x) (g (+ 1 $x))))
</span>
Last Result(2): ()
;;; It's first atom is a space
;;;!(assertEqual
;;;  (let* (($x (collapse (get-atoms &m)))
;;;         ($y (car-atom $x)))
;;;        (get-type $y))
;;;  (get-type &self))
;;; FIXME? Now, it is moduleC space.
;;;        Should it be `stdlib` atom for a separately imported space
;;; !(let $x (collapse (get-atoms &m)) (car-atom $x))
;;; MeTTLog:  xlisting('&m').
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Without additional means like `(&m.f 2)` notation or `(interpret &m (f 2))`,
;;; we cannot execute functions from the separate space - we can only use `match`.
;;; Although `&m` imports another space with definition of `g`, it is not reduced
;;; because it is not defined in the context of `&self`. This is the expected
;;; behavior, but it shows that this way of importing spaces is not too useful
;;; for importing modules with functions.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(assertEqual (match &m (= (f 2) $x) $x) (g 3))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.06"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.06</h3>
; 
; EVAL TEST
; took 0.003 secs. (3.50 milliseconds) 

!(assertEqual (match &m (= (f 2) $x) $x) (g 3))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  ((g 3)) ((g 3))))
</span>
Deterministic: ()
;;; Importing the same space into `&self` should break nothing
;;; TODO? If stdlib space would be in `&m`, which should check that it is not
;;; there anymore since in should be removed after importing it to `&self`
<span class="ansi38-013099040"
>!(import! &self f1_moduleA.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta is 625 bytes (17 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta is 291 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Numer))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()
;;; FIXME? stdlib space is not available at importing time -
;;; only tokens / grounded operations work, while symbolic functions
;;; (like `if`) don't work.
;;; FIXME? Exceptions are not caught by `importOp`
<span class="ansi38-013099040"
>!(assertEqual (+ 1 2) 3)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.07"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.07</h3>
; 
; EVAL TEST
; took 0.000170 secs. (170.32 microseconds) 

!(assertEqual (+ 1 2) 3)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (3) (3)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (if True "S" "F") "S")

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.08"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.08</h3>
; 
; EVAL TEST
; took 0.000131 secs. (130.80 microseconds) 

!(assertEqual (if True "S" "F") "S")

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  ("S") ("S")))
</span>
Deterministic: ()<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (+ $x 10) (g $x)))
</span><span class="ansi38-255165000"
> (: f (-> Number Number))
</span><span class="ansi38-255165000"
> (= (f $x) (if (< $x 0) (- 0 $x) (g (+ 1 $x))))
</span>
Last Result(2): ()
;;; Now indirectly imported `g` works and `f` fully works
<span class="ansi38-013099040"
>!(assertEqual (g 2) 102)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.09"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.09</h3>
; 
; EVAL TEST
; took 0.000956 secs. (955.65 microseconds) 

!(assertEqual (g 2) 102)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102) (102)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (f 2) 103)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.10"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.10</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.31 milliseconds) 

!(assertEqual (f 2) 103)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (103) (103)))
</span>
Deterministic: ()
;;; MeTTLog:  xlisting('&self').
;;; `&self` contains 3 atoms-spaces now:
;;; - stdlib
;;; - moduleC imported by moduleA and removed from A after its import to &self
;;; - moduleA itself, which is the same as &m
<span class="ansi38-013099040"
>!(assertEqual &m (let* (($a (collapse (get-atoms &self))) ($x (cdr-atom $a)) ($y (cdr-atom $x))) (car-atom $y)))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.11"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.11</h3>

(failed  once (if_or_else  (eval  = $_296782 495 &self (let a b never-happens) $_298456) (call  eval (let a b never-happens) $_298456)))


(on_mettalog_error  (failed  once (if_or_else  (eval  = $_296782 495 &self (let a b never-happens) $_298456) (call  eval (let a b never-happens) $_298456))))

^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] call(user:once, user:if_or_else(eval(=, _296782, 495, '&self', [let, a, b, 'never-happens'], _298456), call(eval, [let, a, b, 'never-happens'], _298456)))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] once(user:if_or_else(eval(=, _296782, 495, '&self', [let, a, b, 'never-happens'], _298456), call(eval, [let, a, b, 'never-happens'], _298456)))
   <span class="ansi1 ansi32"
>Call: </span>(312) [user] if_or_else(eval(=, _296782, 495, '&self', [let, a, b, 'never-happens'], _298456), call(eval, [let, a, b, 'never-happens'], _298456))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval(=, _296782, 495, '&self', [let, a, b, 'never-happens'], _298456)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] catch_metta_return(eval_args(=, _296782, 495, '&self', [let, a, b, 'never-happens'], _298456), _298456)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_args(=, _296782, 495, '&self', [let, a, b, 'never-happens'], _298456)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_306866, _306868), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_306866, _306868))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_306866, _306868))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_308954, _308956), once(user:nonvar(_298456)), '$restore_trace'(_308954, _308956))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_308954, _308956))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_311042, _311044), once(user:nonvar(_298456)), '$restore_trace'(_311042, _311044))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_311042, _311044))
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_318198, _318200), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_318198, _318200))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_318198, _318200))
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] eval_00(=, _296782, 495, '&self', [let, a, b, 'never-happens'], _298456)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_323342, _323344), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_323342, _323344))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_323342, _323344))
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] eval_01(=, _296782, 495, '&self', [let, a, b, 'never-happens'], _298456)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] 495<1
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] 495<1
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_331578, _331580), once(user:(_331554 is 495-1, copy_term([let, a, b, 'never-happens'], _331568))), '$restore_trace'(_331578, _331580))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_331578, _331580))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(494 is 495-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] trace_eval(eval_20(=, _296782), e, 494, '&self', [let, a, b, 'never-happens'], _334688)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] must_det_ll((notrace((flag(eval_num, _335742, _335742+1), _335760 is _335742 mod 500, _335778 is 99-494 mod 100, _335802=_335804, option_else('trace-length', _335816, 500), option_else('trace-depth', _335824, 30))), quietly(if_t((nop(stop_rtrace), _335760>_335816), (set_debug(eval, false), _335880 is _335816+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335880])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335932)))))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] once(user:(notrace((flag(eval_num, _335742, _335742+1), _335760 is _335742 mod 500, _335778 is 99-494 mod 100, _335802=_335804, option_else('trace-length', _335816, 500), option_else('trace-depth', _335824, 30))), quietly(if_t((nop(stop_rtrace), _335760>_335816), (set_debug(eval, false), _335880 is _335816+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335880])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335932)))))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_337978, _337980), once(user:(flag(eval_num, _335742, _335742+1), _335760 is _335742 mod 500, _335778 is 99-494 mod 100, _335802=_335804, option_else('trace-length', _335816, 500), option_else('trace-depth', _335824, 30))), '$restore_trace'(_337978, _337980))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_337978, _337980))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2078, 2078+1), 78 is 2078 mod 500, 5 is 99-494 mod 100, _335802=_335802, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _335880 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335880])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _335880 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335880])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(323) [user] nop(notrace(no_repeats_var(_335932)))
   <span class="ansi1 ansi32"
>Exit: </span>(323) [user] nop(notrace(no_repeats_var(_335932)))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] once(user:(notrace((flag(eval_num, 2078, 2078+1), 78 is 2078 mod 500, 5 is 99-494 mod 100, _335802=_335802, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _335880 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335880])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335932)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] must_det_ll(user:(notrace((flag(eval_num, 2078, 2078+1), 78 is 2078 mod 500, 5 is 99-494 mod 100, _335802=_335802, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _335880 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335880])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335932)))))
   <span class="ansi1 ansi32"
>Call: </span>(320) [occurs] occurs:sub_term(_347630, e)
   <span class="ansi1 ansi32"
>Exit: </span>(320) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(320) [occurs] occurs:sub_term(_347630, e)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _354736=e
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] if_trace((eval;e), (_335802=1, indentq(5, 78, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_357876, _357878), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _335802=1, indentq(5, 78, -->, [e, [let, a, b, 'never-happens']]))), _357834, fbug((_357834-->if_trace((eval;e), (_335802=1, indentq(5, 78, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_357876, _357878))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_357876, _357878))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _335802=1, indentq(5, 78, -->, [e, [let, a, b, 'never-happens']]))), _357834, fbug((_357834-->if_trace((eval;e), (_335802=1, indentq(5, 78, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_trace((eval;e), (_335802=1, indentq(5, 78, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _362072=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _364110=(\+ \+ (flag(eval_num, _364130, _364130+1), (retval(fail)\=@=retval(fail), nonvar(_334688)->indentq(5, _364130, <--, [e, _334688]);indentq(5, _364130, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] (\+ \+ (flag(eval_num, _364130, _364130+1), (retval(fail)\=@=retval(fail), nonvar(_334688)->indentq(5, _364130, <--, [e, _334688]);indentq(5, _364130, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _364130, _364130+1), (retval(fail)\=@=retval(fail), nonvar(_334688)->indentq(5, _364130, <--, [e, _334688]);indentq(5, _364130, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] call_cleanup(((call(eval_20(=, _296782), 494, '&self', [let, a, b, 'never-happens'], _334688)*->nb_setarg(1, retval(fail), _334688);fail, trace, call(eval_20(=, _296782), 494, '&self', [let, a, b, 'never-happens'], _334688)), ignore(notrace((\+_334688\=_335932, nb_setarg(1, retval(fail), _334688))))), ignore((_335802==1->ignore(\+ \+ (flag(eval_num, _364130, _364130+1), (retval(fail)\=@=retval(fail), nonvar(_334688)->indentq(5, _364130, <--, [e, _334688]);indentq(5, _364130, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _364130, _364130+1), (retval(fail)\=@=retval(fail), nonvar(_334688)->indentq(5, _364130, <--, [e, _334688]);indentq(5, _364130, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] eval_20(=, _296782, 494, '&self', [let, a, b, 'never-happens'], _334688)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] setup_call_cleanup('$notrace'(_371518, _371520), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_371518, _371520))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] sig_atomic(system:'$notrace'(_371518, _371520))
^  <span class="ansi1 ansi31"
>Fail: </span>(324) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] once(expand_eval([let, a, b, 'never-happens'], _393862))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] expand_eval([let, a, b, 'never-happens'], _393862)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _399962)
   <span class="ansi1 ansi32"
>Call: </span>(326) [apply] apply:maplist_([a, b, 'never-happens'], _399962, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] expand_eval(a, _402018)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] a=_402018
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(327) [apply] apply:maplist_([b, 'never-happens'], _402020, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] expand_eval(b, _408120)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] b=_408120
   <span class="ansi1 ansi32"
>Exit: </span>(329) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(328) [apply] apply:maplist_(['never-happens'], _408122, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] expand_eval('never-happens', _414222)
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] 'never-happens'=_414222
   <span class="ansi1 ansi32"
>Exit: </span>(330) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(329) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(329) [apply] apply:maplist_([], _414224, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(329) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] possible_type('&self', a, _431514)
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] possible_type('&self', a, _431514)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] eval_args(=, _431514, 494, '&self', b, _433556)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_435614, _435616), once(user:self_eval(b)), '$restore_trace'(_435614, _435616))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_435614, _435616))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] _433556=b
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] eval_args(=, _431514, 494, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(322) [user] eval_20(=, _296782, 494, '&self', [let, a, b, 'never-happens'], _334688)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(322) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] ignore((_335802==1->ignore(\+ \+ (flag(eval_num, _364130, _364130+1), (retval(fail)\=@=retval(fail), nonvar(_334688)->indentq(5, _364130, <--, [e, _334688]);indentq(5, _364130, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _364130, _364130+1), (retval(fail)\=@=retval(fail), nonvar(_334688)->indentq(5, _364130, <--, [e, _334688]);indentq(5, _364130, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] _335802==1
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] _335802==1
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_448944, _448946), once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _364130, _364130+1), (retval(fail)\=@=retval(fail), nonvar(_334688)->indentq(5, _364130, <--, [e, _334688]);indentq(5, _364130, <--, [e, retval(fail)])))))))), '$restore_trace'(_448944, _448946))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_448944, _448946))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _364130, _364130+1), (retval(fail)\=@=retval(fail), nonvar(_334688)->indentq(5, _364130, <--, [e, _334688]);indentq(5, _364130, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] ignore(user:(_335802==1->ignore(\+ \+ (flag(eval_num, _364130, _364130+1), (retval(fail)\=@=retval(fail), nonvar(_334688)->indentq(5, _364130, <--, [e, _334688]);indentq(5, _364130, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _364130, _364130+1), (retval(fail)\=@=retval(fail), nonvar(_334688)->indentq(5, _364130, <--, [e, _334688]);indentq(5, _364130, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [system] call_cleanup(user:((call(eval_20(=, _296782), 494, '&self', [let, a, b, 'never-happens'], _334688)*->nb_setarg(1, retval(fail), _334688);fail, trace, call(eval_20(=, _296782), 494, '&self', [let, a, b, 'never-happens'], _334688)), ignore(notrace((\+_334688\=_335932, nb_setarg(1, retval(fail), _334688))))), user:ignore((_335802==1->ignore(\+ \+ (flag(eval_num, _364130, _364130+1), (retval(fail)\=@=retval(fail), nonvar(_334688)->indentq(5, _364130, <--, [e, _334688]);indentq(5, _364130, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _364130, _364130+1), (retval(fail)\=@=retval(fail), nonvar(_334688)->indentq(5, _364130, <--, [e, _334688]);indentq(5, _364130, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] trace_eval(eval_20(=, _296782), e, 494, '&self', [let, a, b, 'never-happens'], _334688)
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] eval_args(=, _296782, 495, '&self', [let, a, b, 'never-happens'], _298456)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] call(eval, [let, a, b, 'never-happens'], _298456)
   <span class="ansi1 ansi32"
>Call: </span>(314) [user] eval([let, a, b, 'never-happens'], _298456)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] current_self(_458352)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] nb_current(self_space, _458352)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval('&self', [let, a, b, 'never-happens'], _298456)
   <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _298456)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] catch_metta_return(eval_args(=, _466466, 500, '&self', [let, a, b, 'never-happens'], _298456), _298456)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_args(=, _466466, 500, '&self', [let, a, b, 'never-happens'], _298456)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_469576, _469578), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_469576, _469578))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_469576, _469578))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_471664, _471666), once(user:nonvar(_298456)), '$restore_trace'(_471664, _471666))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_471664, _471666))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_473752, _473754), once(user:nonvar(_298456)), '$restore_trace'(_473752, _473754))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_473752, _473754))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_480908, _480910), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_480908, _480910))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_480908, _480910))
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] eval_00(=, _466466, 500, '&self', [let, a, b, 'never-happens'], _298456)
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] setup_call_cleanup('$notrace'(_486052, _486054), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_486052, _486054))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] sig_atomic(system:'$notrace'(_486052, _486054))
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] eval_01(=, _466466, 500, '&self', [let, a, b, 'never-happens'], _298456)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] setup_call_cleanup('$notrace'(_494288, _494290), once(user:(_494264 is 500-1, copy_term([let, a, b, 'never-happens'], _494278))), '$restore_trace'(_494288, _494290))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] sig_atomic(system:'$notrace'(_494288, _494290))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] trace_eval(eval_20(=, _466466), e, 499, '&self', [let, a, b, 'never-happens'], _497398)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] must_det_ll((notrace((flag(eval_num, _498452, _498452+1), _498470 is _498452 mod 500, _498488 is 99-499 mod 100, _498512=_498514, option_else('trace-length', _498526, 500), option_else('trace-depth', _498534, 30))), quietly(if_t((nop(stop_rtrace), _498470>_498526), (set_debug(eval, false), _498590 is _498526+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_498590])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_498642)))))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] once(user:(notrace((flag(eval_num, _498452, _498452+1), _498470 is _498452 mod 500, _498488 is 99-499 mod 100, _498512=_498514, option_else('trace-length', _498526, 500), option_else('trace-depth', _498534, 30))), quietly(if_t((nop(stop_rtrace), _498470>_498526), (set_debug(eval, false), _498590 is _498526+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_498590])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_498642)))))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] setup_call_cleanup('$notrace'(_500688, _500690), once(user:(flag(eval_num, _498452, _498452+1), _498470 is _498452 mod 500, _498488 is 99-499 mod 100, _498512=_498514, option_else('trace-length', _498526, 500), option_else('trace-depth', _498534, 30))), '$restore_trace'(_500688, _500690))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] sig_atomic(system:'$notrace'(_500688, _500690))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2079, 2079+1), 79 is 2079 mod 500, 0 is 99-499 mod 100, _498512=_498512, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _498590 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_498590])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _498590 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_498590])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(326) [user] nop(notrace(no_repeats_var(_498642)))
   <span class="ansi1 ansi32"
>Exit: </span>(326) [user] nop(notrace(no_repeats_var(_498642)))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] once(user:(notrace((flag(eval_num, 2079, 2079+1), 79 is 2079 mod 500, 0 is 99-499 mod 100, _498512=_498512, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _498590 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_498590])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_498642)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] must_det_ll(user:(notrace((flag(eval_num, 2079, 2079+1), 79 is 2079 mod 500, 0 is 99-499 mod 100, _498512=_498512, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _498590 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_498590])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_498642)))))
   <span class="ansi1 ansi32"
>Call: </span>(323) [occurs] occurs:sub_term(_510340, e)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(323) [occurs] occurs:sub_term(_510340, e)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _517446=e
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] if_trace((eval;e), (_498512=1, indentq(0, 79, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_520586, _520588), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _498512=1, indentq(0, 79, -->, [e, [let, a, b, 'never-happens']]))), _520544, fbug((_520544-->if_trace((eval;e), (_498512=1, indentq(0, 79, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_520586, _520588))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_520586, _520588))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _498512=1, indentq(0, 79, -->, [e, [let, a, b, 'never-happens']]))), _520544, fbug((_520544-->if_trace((eval;e), (_498512=1, indentq(0, 79, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] if_trace((eval;e), (_498512=1, indentq(0, 79, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _524782=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _526820=(\+ \+ (flag(eval_num, _526840, _526840+1), (retval(fail)\=@=retval(fail), nonvar(_497398)->indentq(0, _526840, <--, [e, _497398]);indentq(0, _526840, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] (\+ \+ (flag(eval_num, _526840, _526840+1), (retval(fail)\=@=retval(fail), nonvar(_497398)->indentq(0, _526840, <--, [e, _497398]);indentq(0, _526840, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _526840, _526840+1), (retval(fail)\=@=retval(fail), nonvar(_497398)->indentq(0, _526840, <--, [e, _497398]);indentq(0, _526840, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] call_cleanup(((call(eval_20(=, _466466), 499, '&self', [let, a, b, 'never-happens'], _497398)*->nb_setarg(1, retval(fail), _497398);fail, trace, call(eval_20(=, _466466), 499, '&self', [let, a, b, 'never-happens'], _497398)), ignore(notrace((\+_497398\=_498642, nb_setarg(1, retval(fail), _497398))))), ignore((_498512==1->ignore(\+ \+ (flag(eval_num, _526840, _526840+1), (retval(fail)\=@=retval(fail), nonvar(_497398)->indentq(0, _526840, <--, [e, _497398]);indentq(0, _526840, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526840, _526840+1), (retval(fail)\=@=retval(fail), nonvar(_497398)->indentq(0, _526840, <--, [e, _497398]);indentq(0, _526840, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] eval_20(=, _466466, 499, '&self', [let, a, b, 'never-happens'], _497398)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(329) [system] setup_call_cleanup('$notrace'(_534228, _534230), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_534228, _534230))
^  <span class="ansi1 ansi32"
>Call: </span>(330) [system] sig_atomic(system:'$notrace'(_534228, _534230))
^  <span class="ansi1 ansi31"
>Fail: </span>(327) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] once(expand_eval([let, a, b, 'never-happens'], _556572))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] expand_eval([let, a, b, 'never-happens'], _556572)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _562672)
   <span class="ansi1 ansi32"
>Call: </span>(329) [apply] apply:maplist_([a, b, 'never-happens'], _562672, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] expand_eval(a, _564728)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] a=_564728
   <span class="ansi1 ansi32"
>Exit: </span>(331) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(330) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(330) [apply] apply:maplist_([b, 'never-happens'], _564730, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] expand_eval(b, _570830)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] b=_570830
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(331) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(331) [apply] apply:maplist_(['never-happens'], _570832, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(332) [user] expand_eval('never-happens', _576932)
   <span class="ansi1 ansi32"
>Call: </span>(333) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(333) [system] 'never-happens'=_576932
   <span class="ansi1 ansi32"
>Exit: </span>(333) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(332) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(332) [apply] apply:maplist_([], _576934, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(332) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(331) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(330) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(329) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] possible_type('&self', a, _594224)
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] possible_type('&self', a, _594224)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] eval_args(=, _594224, 499, '&self', b, _596266)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] setup_call_cleanup('$notrace'(_598324, _598326), once(user:self_eval(b)), '$restore_trace'(_598324, _598326))
^  <span class="ansi1 ansi32"
>Call: </span>(329) [system] sig_atomic(system:'$notrace'(_598324, _598326))
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] _596266=b
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] eval_args(=, _594224, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(325) [user] eval_20(=, _466466, 499, '&self', [let, a, b, 'never-happens'], _497398)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(325) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] ignore((_498512==1->ignore(\+ \+ (flag(eval_num, _526840, _526840+1), (retval(fail)\=@=retval(fail), nonvar(_497398)->indentq(0, _526840, <--, [e, _497398]);indentq(0, _526840, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526840, _526840+1), (retval(fail)\=@=retval(fail), nonvar(_497398)->indentq(0, _526840, <--, [e, _497398]);indentq(0, _526840, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] _498512==1
   <span class="ansi1 ansi31"
>Fail: </span>(327) [system] _498512==1
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] setup_call_cleanup('$notrace'(_611654, _611656), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526840, _526840+1), (retval(fail)\=@=retval(fail), nonvar(_497398)->indentq(0, _526840, <--, [e, _497398]);indentq(0, _526840, <--, [e, retval(fail)])))))))), '$restore_trace'(_611654, _611656))
^  <span class="ansi1 ansi32"
>Call: </span>(329) [system] sig_atomic(system:'$notrace'(_611654, _611656))
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526840, _526840+1), (retval(fail)\=@=retval(fail), nonvar(_497398)->indentq(0, _526840, <--, [e, _497398]);indentq(0, _526840, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] ignore(user:(_498512==1->ignore(\+ \+ (flag(eval_num, _526840, _526840+1), (retval(fail)\=@=retval(fail), nonvar(_497398)->indentq(0, _526840, <--, [e, _497398]);indentq(0, _526840, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526840, _526840+1), (retval(fail)\=@=retval(fail), nonvar(_497398)->indentq(0, _526840, <--, [e, _497398]);indentq(0, _526840, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(323) [system] call_cleanup(user:((call(eval_20(=, _466466), 499, '&self', [let, a, b, 'never-happens'], _497398)*->nb_setarg(1, retval(fail), _497398);fail, trace, call(eval_20(=, _466466), 499, '&self', [let, a, b, 'never-happens'], _497398)), ignore(notrace((\+_497398\=_498642, nb_setarg(1, retval(fail), _497398))))), user:ignore((_498512==1->ignore(\+ \+ (flag(eval_num, _526840, _526840+1), (retval(fail)\=@=retval(fail), nonvar(_497398)->indentq(0, _526840, <--, [e, _497398]);indentq(0, _526840, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526840, _526840+1), (retval(fail)\=@=retval(fail), nonvar(_497398)->indentq(0, _526840, <--, [e, _497398]);indentq(0, _526840, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(322) [user] trace_eval(eval_20(=, _466466), e, 499, '&self', [let, a, b, 'never-happens'], _497398)
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] eval_args(=, _466466, 500, '&self', [let, a, b, 'never-happens'], _298456)
^  <span class="ansi1 ansi31"
>Fail: </span>(310) [system] call(user:once, user:if_or_else(eval(=, _296782, 495, '&self', [let, a, b, 'never-happens'], _298456), call(eval, [let, a, b, 'never-happens'], _298456)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(312) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] setup_call_cleanup('$notrace'(_623116, _623118), once(rtrace:retract(t_l:tracer_reset(_623106))), '$restore_trace'(_623116, _623118))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] sig_atomic(system:'$notrace'(_623116, _623118))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [rtrace] tAt(false, 271, 271, false)
; 
; EVAL TEST
; took 4.92 seconds.

!(assertEqual &m (let* (($a (collapse (get-atoms &self))) ($x (cdr-atom $a)) ($y (cdr-atom $x))) (car-atom $y)))

<span class="ansi31"
>(loonit_failureR  (equal_enough_for_test  (&m) ((: __g (-> Number)))))
</span>
Deterministic: ((Error  (got  (&m)) (expected  ((: __g (-> Number))))))
;;; NOTE: now the first atom, which was a space, is removed from `&m`,
;;; because we load modules only once, and we collect atoms-spaces to
;;; prevent duplication
<span class="ansi38-013099040"
>!(assertEqual (== (let* (($x (collapse (get-atoms &m))) ($y (car-atom $x))) (get-type $y)) (get-type &self)) False)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.12"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.12</h3>

(failed  once (if_or_else  (eval  = $_297012 494 &self (let a b never-happens) $_298686) (call  eval (let a b never-happens) $_298686)))


(on_mettalog_error  (failed  once (if_or_else  (eval  = $_297012 494 &self (let a b never-happens) $_298686) (call  eval (let a b never-happens) $_298686))))

^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] call(user:once, user:if_or_else(eval(=, _297012, 494, '&self', [let, a, b, 'never-happens'], _298686), call(eval, [let, a, b, 'never-happens'], _298686)))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] once(user:if_or_else(eval(=, _297012, 494, '&self', [let, a, b, 'never-happens'], _298686), call(eval, [let, a, b, 'never-happens'], _298686)))
   <span class="ansi1 ansi32"
>Call: </span>(324) [user] if_or_else(eval(=, _297012, 494, '&self', [let, a, b, 'never-happens'], _298686), call(eval, [let, a, b, 'never-happens'], _298686))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] eval(=, _297012, 494, '&self', [let, a, b, 'never-happens'], _298686)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] catch_metta_return(eval_args(=, _297012, 494, '&self', [let, a, b, 'never-happens'], _298686), _298686)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] eval_args(=, _297012, 494, '&self', [let, a, b, 'never-happens'], _298686)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(330) [system] setup_call_cleanup('$notrace'(_307096, _307098), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_307096, _307098))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [system] sig_atomic(system:'$notrace'(_307096, _307098))
^  <span class="ansi1 ansi32"
>Call: </span>(330) [system] setup_call_cleanup('$notrace'(_309184, _309186), once(user:nonvar(_298686)), '$restore_trace'(_309184, _309186))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [system] sig_atomic(system:'$notrace'(_309184, _309186))
^  <span class="ansi1 ansi32"
>Call: </span>(330) [system] setup_call_cleanup('$notrace'(_311272, _311274), once(user:nonvar(_298686)), '$restore_trace'(_311272, _311274))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [system] sig_atomic(system:'$notrace'(_311272, _311274))
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(329) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(331) [system] setup_call_cleanup('$notrace'(_318428, _318430), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_318428, _318430))
^  <span class="ansi1 ansi32"
>Call: </span>(332) [system] sig_atomic(system:'$notrace'(_318428, _318430))
^  <span class="ansi1 ansi31"
>Fail: </span>(329) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] eval_00(=, _297012, 494, '&self', [let, a, b, 'never-happens'], _298686)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(332) [system] setup_call_cleanup('$notrace'(_323572, _323574), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_323572, _323574))
^  <span class="ansi1 ansi32"
>Call: </span>(333) [system] sig_atomic(system:'$notrace'(_323572, _323574))
^  <span class="ansi1 ansi31"
>Fail: </span>(330) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] eval_01(=, _297012, 494, '&self', [let, a, b, 'never-happens'], _298686)
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] if_t((494<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(333) [system] 494<1
   <span class="ansi1 ansi31"
>Fail: </span>(333) [system] 494<1
^  <span class="ansi1 ansi32"
>Exit: </span>(331) [user] if_t((494<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(332) [system] setup_call_cleanup('$notrace'(_331808, _331810), once(user:(_331784 is 494-1, copy_term([let, a, b, 'never-happens'], _331798))), '$restore_trace'(_331808, _331810))
^  <span class="ansi1 ansi32"
>Call: </span>(333) [system] sig_atomic(system:'$notrace'(_331808, _331810))
^  <span class="ansi1 ansi32"
>Exit: </span>(332) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(493 is 494-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] trace_eval(eval_20(=, _297012), e, 493, '&self', [let, a, b, 'never-happens'], _334918)
^  <span class="ansi1 ansi32"
>Call: </span>(332) [user] must_det_ll((notrace((flag(eval_num, _335972, _335972+1), _335990 is _335972 mod 500, _336008 is 99-493 mod 100, _336032=_336034, option_else('trace-length', _336046, 500), option_else('trace-depth', _336054, 30))), quietly(if_t((nop(stop_rtrace), _335990>_336046), (set_debug(eval, false), _336110 is _336046+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_336110])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_336162)))))
^  <span class="ansi1 ansi32"
>Call: </span>(333) [user] once(user:(notrace((flag(eval_num, _335972, _335972+1), _335990 is _335972 mod 500, _336008 is 99-493 mod 100, _336032=_336034, option_else('trace-length', _336046, 500), option_else('trace-depth', _336054, 30))), quietly(if_t((nop(stop_rtrace), _335990>_336046), (set_debug(eval, false), _336110 is _336046+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_336110])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_336162)))))
^  <span class="ansi1 ansi32"
>Call: </span>(336) [system] setup_call_cleanup('$notrace'(_338208, _338210), once(user:(flag(eval_num, _335972, _335972+1), _335990 is _335972 mod 500, _336008 is 99-493 mod 100, _336032=_336034, option_else('trace-length', _336046, 500), option_else('trace-depth', _336054, 30))), '$restore_trace'(_338208, _338210))
^  <span class="ansi1 ansi32"
>Call: </span>(337) [system] sig_atomic(system:'$notrace'(_338208, _338210))
^  <span class="ansi1 ansi32"
>Exit: </span>(336) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2079, 2079+1), 79 is 2079 mod 500, 6 is 99-493 mod 100, _336032=_336032, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(336) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _336110 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_336110])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(336) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _336110 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_336110])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(335) [user] nop(notrace(no_repeats_var(_336162)))
   <span class="ansi1 ansi32"
>Exit: </span>(335) [user] nop(notrace(no_repeats_var(_336162)))
^  <span class="ansi1 ansi32"
>Exit: </span>(333) [system] once(user:(notrace((flag(eval_num, 2079, 2079+1), 79 is 2079 mod 500, 6 is 99-493 mod 100, _336032=_336032, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _336110 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_336110])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_336162)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(332) [user] must_det_ll(user:(notrace((flag(eval_num, 2079, 2079+1), 79 is 2079 mod 500, 6 is 99-493 mod 100, _336032=_336032, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _336110 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_336110])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_336162)))))
   <span class="ansi1 ansi32"
>Call: </span>(332) [occurs] occurs:sub_term(_347860, e)
   <span class="ansi1 ansi32"
>Exit: </span>(332) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(332) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(333) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(333) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(332) [occurs] occurs:sub_term(_347860, e)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] _354966=e
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(332) [user] if_trace((eval;e), (_336032=1, indentq(6, 79, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(334) [system] setup_call_cleanup('$notrace'(_358106, _358108), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _336032=1, indentq(6, 79, -->, [e, [let, a, b, 'never-happens']]))), _358064, fbug((_358064-->if_trace((eval;e), (_336032=1, indentq(6, 79, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_358106, _358108))
^  <span class="ansi1 ansi32"
>Call: </span>(335) [system] sig_atomic(system:'$notrace'(_358106, _358108))
^  <span class="ansi1 ansi32"
>Exit: </span>(334) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _336032=1, indentq(6, 79, -->, [e, [let, a, b, 'never-happens']]))), _358064, fbug((_358064-->if_trace((eval;e), (_336032=1, indentq(6, 79, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(332) [user] if_trace((eval;e), (_336032=1, indentq(6, 79, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] _362302=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] _364340=(\+ \+ (flag(eval_num, _364360, _364360+1), (retval(fail)\=@=retval(fail), nonvar(_334918)->indentq(6, _364360, <--, [e, _334918]);indentq(6, _364360, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] (\+ \+ (flag(eval_num, _364360, _364360+1), (retval(fail)\=@=retval(fail), nonvar(_334918)->indentq(6, _364360, <--, [e, _334918]);indentq(6, _364360, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _364360, _364360+1), (retval(fail)\=@=retval(fail), nonvar(_334918)->indentq(6, _364360, <--, [e, _334918]);indentq(6, _364360, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(332) [user] call_cleanup(((call(eval_20(=, _297012), 493, '&self', [let, a, b, 'never-happens'], _334918)*->nb_setarg(1, retval(fail), _334918);fail, trace, call(eval_20(=, _297012), 493, '&self', [let, a, b, 'never-happens'], _334918)), ignore(notrace((\+_334918\=_336162, nb_setarg(1, retval(fail), _334918))))), ignore((_336032==1->ignore(\+ \+ (flag(eval_num, _364360, _364360+1), (retval(fail)\=@=retval(fail), nonvar(_334918)->indentq(6, _364360, <--, [e, _334918]);indentq(6, _364360, <--, [e, retval(fail)]))));notrace(ignore(if_t(6<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _364360, _364360+1), (retval(fail)\=@=retval(fail), nonvar(_334918)->indentq(6, _364360, <--, [e, _334918]);indentq(6, _364360, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(334) [user] eval_20(=, _297012, 493, '&self', [let, a, b, 'never-happens'], _334918)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(336) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(338) [system] setup_call_cleanup('$notrace'(_371748, _371750), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_371748, _371750))
^  <span class="ansi1 ansi32"
>Call: </span>(339) [system] sig_atomic(system:'$notrace'(_371748, _371750))
^  <span class="ansi1 ansi31"
>Fail: </span>(336) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(336) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(336) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(337) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] once(expand_eval([let, a, b, 'never-happens'], _394092))
^  <span class="ansi1 ansi32"
>Call: </span>(336) [user] expand_eval([let, a, b, 'never-happens'], _394092)
   <span class="ansi1 ansi32"
>Call: </span>(337) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(337) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(337) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(337) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(337) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _400192)
   <span class="ansi1 ansi32"
>Call: </span>(338) [apply] apply:maplist_([a, b, 'never-happens'], _400192, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(339) [user] expand_eval(a, _402248)
   <span class="ansi1 ansi32"
>Call: </span>(340) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(340) [system] a=_402248
   <span class="ansi1 ansi32"
>Exit: </span>(340) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(339) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(339) [apply] apply:maplist_([b, 'never-happens'], _402250, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(340) [user] expand_eval(b, _408350)
   <span class="ansi1 ansi32"
>Call: </span>(341) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(341) [system] b=_408350
   <span class="ansi1 ansi32"
>Exit: </span>(341) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(340) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(340) [apply] apply:maplist_(['never-happens'], _408352, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(341) [user] expand_eval('never-happens', _414452)
   <span class="ansi1 ansi32"
>Call: </span>(342) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(342) [system] 'never-happens'=_414452
   <span class="ansi1 ansi32"
>Exit: </span>(342) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(341) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(341) [apply] apply:maplist_([], _414454, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(341) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(340) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(339) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(338) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(337) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(336) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(335) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] possible_type('&self', a, _431744)
^  <span class="ansi1 ansi32"
>Exit: </span>(335) [user] possible_type('&self', a, _431744)
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] eval_args(=, _431744, 493, '&self', b, _433786)
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(337) [system] setup_call_cleanup('$notrace'(_435844, _435846), once(user:self_eval(b)), '$restore_trace'(_435844, _435846))
^  <span class="ansi1 ansi32"
>Call: </span>(338) [system] sig_atomic(system:'$notrace'(_435844, _435846))
^  <span class="ansi1 ansi32"
>Exit: </span>(337) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] _433786=b
   <span class="ansi1 ansi32"
>Exit: </span>(336) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(335) [user] eval_args(=, _431744, 493, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(334) [user] eval_20(=, _297012, 493, '&self', [let, a, b, 'never-happens'], _334918)
   <span class="ansi1 ansi32"
>Call: </span>(334) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(334) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(334) [user] ignore((_336032==1->ignore(\+ \+ (flag(eval_num, _364360, _364360+1), (retval(fail)\=@=retval(fail), nonvar(_334918)->indentq(6, _364360, <--, [e, _334918]);indentq(6, _364360, <--, [e, retval(fail)]))));notrace(ignore(if_t(6<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _364360, _364360+1), (retval(fail)\=@=retval(fail), nonvar(_334918)->indentq(6, _364360, <--, [e, _334918]);indentq(6, _364360, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] _336032==1
   <span class="ansi1 ansi31"
>Fail: </span>(336) [system] _336032==1
^  <span class="ansi1 ansi32"
>Call: </span>(337) [system] setup_call_cleanup('$notrace'(_449174, _449176), once(user:ignore(if_t(6<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _364360, _364360+1), (retval(fail)\=@=retval(fail), nonvar(_334918)->indentq(6, _364360, <--, [e, _334918]);indentq(6, _364360, <--, [e, retval(fail)])))))))), '$restore_trace'(_449174, _449176))
^  <span class="ansi1 ansi32"
>Call: </span>(338) [system] sig_atomic(system:'$notrace'(_449174, _449176))
^  <span class="ansi1 ansi32"
>Exit: </span>(337) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(6<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _364360, _364360+1), (retval(fail)\=@=retval(fail), nonvar(_334918)->indentq(6, _364360, <--, [e, _334918]);indentq(6, _364360, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(334) [system] ignore(user:(_336032==1->ignore(\+ \+ (flag(eval_num, _364360, _364360+1), (retval(fail)\=@=retval(fail), nonvar(_334918)->indentq(6, _364360, <--, [e, _334918]);indentq(6, _364360, <--, [e, retval(fail)]))));notrace(ignore(if_t(6<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _364360, _364360+1), (retval(fail)\=@=retval(fail), nonvar(_334918)->indentq(6, _364360, <--, [e, _334918]);indentq(6, _364360, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(332) [system] call_cleanup(user:((call(eval_20(=, _297012), 493, '&self', [let, a, b, 'never-happens'], _334918)*->nb_setarg(1, retval(fail), _334918);fail, trace, call(eval_20(=, _297012), 493, '&self', [let, a, b, 'never-happens'], _334918)), ignore(notrace((\+_334918\=_336162, nb_setarg(1, retval(fail), _334918))))), user:ignore((_336032==1->ignore(\+ \+ (flag(eval_num, _364360, _364360+1), (retval(fail)\=@=retval(fail), nonvar(_334918)->indentq(6, _364360, <--, [e, _334918]);indentq(6, _364360, <--, [e, retval(fail)]))));notrace(ignore(if_t(6<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _364360, _364360+1), (retval(fail)\=@=retval(fail), nonvar(_334918)->indentq(6, _364360, <--, [e, _334918]);indentq(6, _364360, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(331) [user] trace_eval(eval_20(=, _297012), e, 493, '&self', [let, a, b, 'never-happens'], _334918)
^  <span class="ansi1 ansi31"
>Fail: </span>(328) [user] eval_args(=, _297012, 494, '&self', [let, a, b, 'never-happens'], _298686)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] call(eval, [let, a, b, 'never-happens'], _298686)
   <span class="ansi1 ansi32"
>Call: </span>(326) [user] eval([let, a, b, 'never-happens'], _298686)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] current_self(_458582)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] nb_current(self_space, _458582)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(327) [user] eval('&self', [let, a, b, 'never-happens'], _298686)
   <span class="ansi1 ansi32"
>Call: </span>(328) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _298686)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] catch_metta_return(eval_args(=, _466696, 500, '&self', [let, a, b, 'never-happens'], _298686), _298686)
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] eval_args(=, _466696, 500, '&self', [let, a, b, 'never-happens'], _298686)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(333) [system] setup_call_cleanup('$notrace'(_469806, _469808), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_469806, _469808))
^  <span class="ansi1 ansi32"
>Call: </span>(334) [system] sig_atomic(system:'$notrace'(_469806, _469808))
^  <span class="ansi1 ansi32"
>Call: </span>(333) [system] setup_call_cleanup('$notrace'(_471894, _471896), once(user:nonvar(_298686)), '$restore_trace'(_471894, _471896))
^  <span class="ansi1 ansi32"
>Call: </span>(334) [system] sig_atomic(system:'$notrace'(_471894, _471896))
^  <span class="ansi1 ansi32"
>Call: </span>(333) [system] setup_call_cleanup('$notrace'(_473982, _473984), once(user:nonvar(_298686)), '$restore_trace'(_473982, _473984))
^  <span class="ansi1 ansi32"
>Call: </span>(334) [system] sig_atomic(system:'$notrace'(_473982, _473984))
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(332) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(334) [system] setup_call_cleanup('$notrace'(_481138, _481140), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_481138, _481140))
^  <span class="ansi1 ansi32"
>Call: </span>(335) [system] sig_atomic(system:'$notrace'(_481138, _481140))
^  <span class="ansi1 ansi31"
>Fail: </span>(332) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(332) [user] eval_00(=, _466696, 500, '&self', [let, a, b, 'never-happens'], _298686)
^  <span class="ansi1 ansi32"
>Call: </span>(333) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(335) [system] setup_call_cleanup('$notrace'(_486282, _486284), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_486282, _486284))
^  <span class="ansi1 ansi32"
>Call: </span>(336) [system] sig_atomic(system:'$notrace'(_486282, _486284))
^  <span class="ansi1 ansi31"
>Fail: </span>(333) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(333) [user] eval_01(=, _466696, 500, '&self', [let, a, b, 'never-happens'], _298686)
^  <span class="ansi1 ansi32"
>Call: </span>(334) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(336) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(334) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(335) [system] setup_call_cleanup('$notrace'(_494518, _494520), once(user:(_494494 is 500-1, copy_term([let, a, b, 'never-happens'], _494508))), '$restore_trace'(_494518, _494520))
^  <span class="ansi1 ansi32"
>Call: </span>(336) [system] sig_atomic(system:'$notrace'(_494518, _494520))
^  <span class="ansi1 ansi32"
>Exit: </span>(335) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(334) [user] trace_eval(eval_20(=, _466696), e, 499, '&self', [let, a, b, 'never-happens'], _497628)
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] must_det_ll((notrace((flag(eval_num, _498682, _498682+1), _498700 is _498682 mod 500, _498718 is 99-499 mod 100, _498742=_498744, option_else('trace-length', _498756, 500), option_else('trace-depth', _498764, 30))), quietly(if_t((nop(stop_rtrace), _498700>_498756), (set_debug(eval, false), _498820 is _498756+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_498820])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_498872)))))
^  <span class="ansi1 ansi32"
>Call: </span>(336) [user] once(user:(notrace((flag(eval_num, _498682, _498682+1), _498700 is _498682 mod 500, _498718 is 99-499 mod 100, _498742=_498744, option_else('trace-length', _498756, 500), option_else('trace-depth', _498764, 30))), quietly(if_t((nop(stop_rtrace), _498700>_498756), (set_debug(eval, false), _498820 is _498756+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_498820])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_498872)))))
^  <span class="ansi1 ansi32"
>Call: </span>(339) [system] setup_call_cleanup('$notrace'(_500918, _500920), once(user:(flag(eval_num, _498682, _498682+1), _498700 is _498682 mod 500, _498718 is 99-499 mod 100, _498742=_498744, option_else('trace-length', _498756, 500), option_else('trace-depth', _498764, 30))), '$restore_trace'(_500918, _500920))
^  <span class="ansi1 ansi32"
>Call: </span>(340) [system] sig_atomic(system:'$notrace'(_500918, _500920))
^  <span class="ansi1 ansi32"
>Exit: </span>(339) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2080, 2080+1), 80 is 2080 mod 500, 0 is 99-499 mod 100, _498742=_498742, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(339) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 80>500), (set_debug(eval, false), _498820 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_498820])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(339) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 80>500), (set_debug(eval, false), _498820 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_498820])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(338) [user] nop(notrace(no_repeats_var(_498872)))
   <span class="ansi1 ansi32"
>Exit: </span>(338) [user] nop(notrace(no_repeats_var(_498872)))
^  <span class="ansi1 ansi32"
>Exit: </span>(336) [system] once(user:(notrace((flag(eval_num, 2080, 2080+1), 80 is 2080 mod 500, 0 is 99-499 mod 100, _498742=_498742, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 80>500), (set_debug(eval, false), _498820 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_498820])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_498872)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(335) [user] must_det_ll(user:(notrace((flag(eval_num, 2080, 2080+1), 80 is 2080 mod 500, 0 is 99-499 mod 100, _498742=_498742, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 80>500), (set_debug(eval, false), _498820 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_498820])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_498872)))))
   <span class="ansi1 ansi32"
>Call: </span>(335) [occurs] occurs:sub_term(_510570, e)
   <span class="ansi1 ansi32"
>Exit: </span>(335) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(335) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(336) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(335) [occurs] occurs:sub_term(_510570, e)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] _517676=e
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] if_trace((eval;e), (_498742=1, indentq(0, 80, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(337) [system] setup_call_cleanup('$notrace'(_520816, _520818), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _498742=1, indentq(0, 80, -->, [e, [let, a, b, 'never-happens']]))), _520774, fbug((_520774-->if_trace((eval;e), (_498742=1, indentq(0, 80, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_520816, _520818))
^  <span class="ansi1 ansi32"
>Call: </span>(338) [system] sig_atomic(system:'$notrace'(_520816, _520818))
^  <span class="ansi1 ansi32"
>Exit: </span>(337) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _498742=1, indentq(0, 80, -->, [e, [let, a, b, 'never-happens']]))), _520774, fbug((_520774-->if_trace((eval;e), (_498742=1, indentq(0, 80, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(335) [user] if_trace((eval;e), (_498742=1, indentq(0, 80, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] _525012=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] _527050=(\+ \+ (flag(eval_num, _527070, _527070+1), (retval(fail)\=@=retval(fail), nonvar(_497628)->indentq(0, _527070, <--, [e, _497628]);indentq(0, _527070, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] (\+ \+ (flag(eval_num, _527070, _527070+1), (retval(fail)\=@=retval(fail), nonvar(_497628)->indentq(0, _527070, <--, [e, _497628]);indentq(0, _527070, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _527070, _527070+1), (retval(fail)\=@=retval(fail), nonvar(_497628)->indentq(0, _527070, <--, [e, _497628]);indentq(0, _527070, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] call_cleanup(((call(eval_20(=, _466696), 499, '&self', [let, a, b, 'never-happens'], _497628)*->nb_setarg(1, retval(fail), _497628);fail, trace, call(eval_20(=, _466696), 499, '&self', [let, a, b, 'never-happens'], _497628)), ignore(notrace((\+_497628\=_498872, nb_setarg(1, retval(fail), _497628))))), ignore((_498742==1->ignore(\+ \+ (flag(eval_num, _527070, _527070+1), (retval(fail)\=@=retval(fail), nonvar(_497628)->indentq(0, _527070, <--, [e, _497628]);indentq(0, _527070, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _527070, _527070+1), (retval(fail)\=@=retval(fail), nonvar(_497628)->indentq(0, _527070, <--, [e, _497628]);indentq(0, _527070, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(337) [user] eval_20(=, _466696, 499, '&self', [let, a, b, 'never-happens'], _497628)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(338) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(339) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(341) [system] setup_call_cleanup('$notrace'(_534458, _534460), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_534458, _534460))
^  <span class="ansi1 ansi32"
>Call: </span>(342) [system] sig_atomic(system:'$notrace'(_534458, _534460))
^  <span class="ansi1 ansi31"
>Fail: </span>(339) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(339) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(339) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(339) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(340) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(338) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(338) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(338) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(338) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(338) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(338) [user] once(expand_eval([let, a, b, 'never-happens'], _556802))
^  <span class="ansi1 ansi32"
>Call: </span>(339) [user] expand_eval([let, a, b, 'never-happens'], _556802)
   <span class="ansi1 ansi32"
>Call: </span>(340) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(340) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(340) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(340) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(340) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _562902)
   <span class="ansi1 ansi32"
>Call: </span>(341) [apply] apply:maplist_([a, b, 'never-happens'], _562902, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(342) [user] expand_eval(a, _564958)
   <span class="ansi1 ansi32"
>Call: </span>(343) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(343) [system] a=_564958
   <span class="ansi1 ansi32"
>Exit: </span>(343) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(342) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(342) [apply] apply:maplist_([b, 'never-happens'], _564960, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(343) [user] expand_eval(b, _571060)
   <span class="ansi1 ansi32"
>Call: </span>(344) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(344) [system] b=_571060
   <span class="ansi1 ansi32"
>Exit: </span>(344) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(343) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(343) [apply] apply:maplist_(['never-happens'], _571062, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(344) [user] expand_eval('never-happens', _577162)
   <span class="ansi1 ansi32"
>Call: </span>(345) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(345) [system] 'never-happens'=_577162
   <span class="ansi1 ansi32"
>Exit: </span>(345) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(344) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(344) [apply] apply:maplist_([], _577164, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(344) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(343) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(342) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(341) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(340) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(339) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(338) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(338) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(339) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(338) [user] possible_type('&self', a, _594454)
^  <span class="ansi1 ansi32"
>Exit: </span>(338) [user] possible_type('&self', a, _594454)
^  <span class="ansi1 ansi32"
>Call: </span>(338) [user] eval_args(=, _594454, 499, '&self', b, _596496)
   <span class="ansi1 ansi32"
>Call: </span>(339) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(340) [system] setup_call_cleanup('$notrace'(_598554, _598556), once(user:self_eval(b)), '$restore_trace'(_598554, _598556))
^  <span class="ansi1 ansi32"
>Call: </span>(341) [system] sig_atomic(system:'$notrace'(_598554, _598556))
^  <span class="ansi1 ansi32"
>Exit: </span>(340) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(339) [system] _596496=b
   <span class="ansi1 ansi32"
>Exit: </span>(339) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(338) [user] eval_args(=, _594454, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(337) [user] eval_20(=, _466696, 499, '&self', [let, a, b, 'never-happens'], _497628)
   <span class="ansi1 ansi32"
>Call: </span>(337) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(337) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(337) [user] ignore((_498742==1->ignore(\+ \+ (flag(eval_num, _527070, _527070+1), (retval(fail)\=@=retval(fail), nonvar(_497628)->indentq(0, _527070, <--, [e, _497628]);indentq(0, _527070, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _527070, _527070+1), (retval(fail)\=@=retval(fail), nonvar(_497628)->indentq(0, _527070, <--, [e, _497628]);indentq(0, _527070, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(339) [system] _498742==1
   <span class="ansi1 ansi31"
>Fail: </span>(339) [system] _498742==1
^  <span class="ansi1 ansi32"
>Call: </span>(340) [system] setup_call_cleanup('$notrace'(_611884, _611886), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _527070, _527070+1), (retval(fail)\=@=retval(fail), nonvar(_497628)->indentq(0, _527070, <--, [e, _497628]);indentq(0, _527070, <--, [e, retval(fail)])))))))), '$restore_trace'(_611884, _611886))
^  <span class="ansi1 ansi32"
>Call: </span>(341) [system] sig_atomic(system:'$notrace'(_611884, _611886))
^  <span class="ansi1 ansi32"
>Exit: </span>(340) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _527070, _527070+1), (retval(fail)\=@=retval(fail), nonvar(_497628)->indentq(0, _527070, <--, [e, _497628]);indentq(0, _527070, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(337) [system] ignore(user:(_498742==1->ignore(\+ \+ (flag(eval_num, _527070, _527070+1), (retval(fail)\=@=retval(fail), nonvar(_497628)->indentq(0, _527070, <--, [e, _497628]);indentq(0, _527070, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _527070, _527070+1), (retval(fail)\=@=retval(fail), nonvar(_497628)->indentq(0, _527070, <--, [e, _497628]);indentq(0, _527070, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(335) [system] call_cleanup(user:((call(eval_20(=, _466696), 499, '&self', [let, a, b, 'never-happens'], _497628)*->nb_setarg(1, retval(fail), _497628);fail, trace, call(eval_20(=, _466696), 499, '&self', [let, a, b, 'never-happens'], _497628)), ignore(notrace((\+_497628\=_498872, nb_setarg(1, retval(fail), _497628))))), user:ignore((_498742==1->ignore(\+ \+ (flag(eval_num, _527070, _527070+1), (retval(fail)\=@=retval(fail), nonvar(_497628)->indentq(0, _527070, <--, [e, _497628]);indentq(0, _527070, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _527070, _527070+1), (retval(fail)\=@=retval(fail), nonvar(_497628)->indentq(0, _527070, <--, [e, _497628]);indentq(0, _527070, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(334) [user] trace_eval(eval_20(=, _466696), e, 499, '&self', [let, a, b, 'never-happens'], _497628)
^  <span class="ansi1 ansi31"
>Fail: </span>(331) [user] eval_args(=, _466696, 500, '&self', [let, a, b, 'never-happens'], _298686)
^  <span class="ansi1 ansi31"
>Fail: </span>(322) [system] call(user:once, user:if_or_else(eval(=, _297012, 494, '&self', [let, a, b, 'never-happens'], _298686), call(eval, [let, a, b, 'never-happens'], _298686)))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] setup_call_cleanup('$notrace'(_623346, _623348), once(rtrace:retract(t_l:tracer_reset(_623336))), '$restore_trace'(_623346, _623348))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] sig_atomic(system:'$notrace'(_623346, _623348))
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [rtrace] tAt(false, 271, 271, false)
<span class="ansi1 ansi90"
>Info: Processing progress: 100% </span><span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta progress.
</span>; 
; EVAL TEST
; took 4.57 seconds.

!(assertEqual (== (let* (($x (collapse (get-atoms &m))) ($y (car-atom $x))) (get-type $y)) (get-type &self)) False)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (False) (False)))
</span>
Deterministic: ()
;;; Let's check that `if` from stdlib is not duplicated and gives only one result
<span class="ansi38-013099040"
>!(assertEqual (if (> 1 2) 1 2) 2)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.13"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.13</h3>
; 
; EVAL TEST
; took 0.000269 secs. (268.66 microseconds) 

!(assertEqual (if (> 1 2) 1 2) 2)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (2) (2)))
</span>
Deterministic: ()
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Let's import one more module into `&self` with a diamond dependence
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleB.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta is 288 bytes (7 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta is 291 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Numer))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (g $x) (+ $x 10)))
</span>
Last Result(2): ()
;;; `g` from moduleC imported via two paths as well as `f`, which uses `g`,
;;; are not duplicated and produce deterministic results
<span class="ansi38-013099040"
>!(assertEqual (g 2) 102)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.14"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.14</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.04 milliseconds) 

!(assertEqual (g 2) 102)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102) (102)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (f 2) 103)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.15"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.15</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.39 milliseconds) 

!(assertEqual (f 2) 103)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (103) (103)))
</span>
Deterministic: ()
;;; Function declared in different imported modules will still produce
;;; non-deterministic results
<span class="ansi38-013099040"
>!(assertEqualToResult (dup 2) (12 102))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.16"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.16</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.00 milliseconds) 

!(assertEqualToResult (dup 2) (12 102))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102 12) (12 102)))
</span>
Deterministic: ()
;;; Let's import f1_moduleB.metta once more using a different path.
;;; Such import should be ignored and thus f, g and dup should remain
;;; unchanged.
<span class="ansi38-013099040"
>!(import! &self ../hyperon-experimental_scripts/f1_moduleB.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta is 288 bytes (7 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta is 291 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Numer))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (g $x) (+ $x 10)))
</span>
Last Result(2): ()
<span class="ansi38-013099040"
>!(assertEqual (g 2) 102)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.17"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.17</h3>
; 
; EVAL TEST
; took 0.000949 secs. (949.05 microseconds) 

!(assertEqual (g 2) 102)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102) (102)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (f 2) 103)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.18"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.18</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.37 milliseconds) 

!(assertEqual (f 2) 103)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (103) (103)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqualToResult (dup 2) (12 102))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.19"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.19</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.04 milliseconds) 

!(assertEqualToResult (dup 2) (12 102))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102 12) (12 102)))
</span>
Deterministic: ()<span class="ansi32"
>
% 44,300,660 inferences, 10.786 CPU in 10.806 seconds (100% CPU, 4107187 Lips)
</span>P;HTML|
;                       (= /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta  0)
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 17
</span><span class="ansi31"
>Failures: 2
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
P;HTML|
;         (is_cmd_option  execute halt --halt=true true)
P;HTML|
;          (set_option_value  halt true)
P;HTML|
;          (is_cmd_option  execute stdin --stdin=tty tty)
P;HTML|
;          (set_option_value  stdin tty)
P;HTML|
;          (is_cmd_option  execute stdout --stdout=tty tty)
P;HTML|
;           (set_option_value  stdout tty)
P;HTML|
;          (is_cmd_option  execute stderr --stderr=tty tty)
P;HTML|
;           (set_option_value  stderr tty)
P;HTML|
;         (set_option_value  compat false)
P;HTML|
;         (set_option_value  compatio false)
P;HTML|
;         (set_option_value  src_indents false)
P;HTML|
;         (set_option_value  devel false)
P;HTML|
;         (set_option_value  stack-max 500)
P;HTML|
;         (set_option_value  limit inf)
P;HTML|
;         (set_option_value  initial-result-count 10)
P;HTML|
;         (set_option_value  answer-format show)
P;HTML|
;         (set_option_value  repeats true)
P;HTML|
;         (set_option_value  time true)
P;HTML|
;         (set_option_value  synth-unit-tests false)
P;HTML|
;         (set_option_value  optimize true)
P;HTML|
;         (set_option_value  transpiler silent)
P;HTML|
;          (set_debug  transpiler false)
P;HTML|
;         (set_option_value  compile false)
P;HTML|
;         (set_option_value  tabling auto)
P;HTML|
;         (set_option_value  log false)
P;HTML|
;         (set_option_value  output ./)
P;HTML|
;         (set_option_value  exeout ./Sav.gitlab.MeTTaLog)
P;HTML|
;         (set_option_value  halt false)
P;HTML|
;         (set_option_value  trace-length 500)
P;HTML|
;         (set_option_value  trace-on-overtime 4.0)
P;HTML|
;          (set_debug  overtime 4.0)
P;HTML|
;         (set_option_value  trace-on-overflow 1000)
P;HTML|
;          (set_debug  overflow 1000)
P;HTML|
;         (set_option_value  trace-on-eval false)
P;HTML|
;          (set_debug  eval false)
P;HTML|
;         (set_option_value  trace-on-load silent)
P;HTML|
;          (set_debug  load silent)
P;HTML|
;          (set_debug  trace-on-load false)
P;HTML|
;         (set_option_value  trace-on-exec false)
P;HTML|
;          (set_debug  exec false)
P;HTML|
;         (set_option_value  trace-on-error non-type)
P;HTML|
;          (set_debug  error non-type)
P;HTML|
;         (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;         (set_option_value  trace-on-test true)
P;HTML|
;          (set_debug  test true)
P;HTML|
;         (set_option_value  repl-on-error true)
P;HTML|
;         (set_option_value  repl-on-fail false)
P;HTML|
;         (set_option_value  exit-on-fail false)
P;HTML|
;         (set_option_value  repl auto)
P;HTML|
;         (set_option_value  prolog false)
P;HTML|
;         (set_option_value  exec noskip)
P;HTML|
;         (set_option_value  maximum-result-count inf)
P;HTML|
;         (set_option_value  html false)
P;HTML|
;         (set_option_value  python true)
P;HTML|
;         (set_option_value  trace-on-test false)
P;HTML|
;          (set_debug  test false)
P;HTML|
;         (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;         (set_option_value  load show)
P;HTML|
;         (set_option_value  test true)
[()]
[((Error  (got  ((hyperon::space::DynSpace) (hyperon::space::DynSpace) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (()) (DocInformal) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()))) (expected  ((hyperon::space::DynSpace)))))]
[()]
[()]
[()]
[()]
[()]
[()]
[((Error  (got  (&m)) (expected  ((: __g (-> Number))))))]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
P;HTML|
;         (maybe_halt  7)
<span class="ansi31"
>(in  (maybe_halt  7) (unwind  (halt  7)))
</span>
Script done on 2024-11-29 10:53:21+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat/' --timeout=40 --html --repl=false  --test "tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta" --halt=true\033[0m
