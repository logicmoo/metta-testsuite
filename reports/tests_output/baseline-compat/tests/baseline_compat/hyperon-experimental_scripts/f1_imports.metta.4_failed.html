<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi36 { color: #00aaaa; }
.ansi90 { color: #7f7f7f; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-11-26 11:15:52+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;           (set_option_value  compat false)

P;HTML|
;           (set_option_value  compatio false)

P;HTML|
;           (set_option_value  src_indents false)

P;HTML|
;         (set_option_value  devel false)

P;HTML|
;         (set_option_value  stack-max 500)

P;HTML|
;         (set_option_value  limit inf)

P;HTML|
;         (set_option_value  initial-result-count 10)

P;HTML|
;         (set_option_value  answer-format show)

P;HTML|
;         (set_option_value  repeats true)

P;HTML|
;         (set_option_value  time true)

P;HTML|
;         (set_option_value  synth-unit-tests false)

P;HTML|
;         (set_option_value  optimize true)

P;HTML|
;         (set_option_value  transpiler silent)

P;HTML|
;          (set_debug  transpiler false)

P;HTML|
;         (set_option_value  compile false)

P;HTML|
;         (set_option_value  tabling auto)

P;HTML|
;         (set_option_value  log false)

P;HTML|
;         (set_option_value  output ./)

P;HTML|
;         (set_option_value  exeout ./Sav.gitlab.MeTTaLog)

P;HTML|
;         (set_option_value  halt false)

P;HTML|
;         (set_option_value  trace-length 500)

P;HTML|
;         (set_option_value  trace-on-overtime 4.0)

P;HTML|
;          (set_debug  overtime 4.0)

P;HTML|
;         (set_option_value  trace-on-overflow 1000)

P;HTML|
;          (set_debug  overflow 1000)

P;HTML|
;         (set_option_value  trace-on-eval false)

P;HTML|
;          (set_debug  eval false)

P;HTML|
;         (set_option_value  trace-on-load silent)

P;HTML|
;          (set_debug  load silent)

P;HTML|
;          (set_debug  trace-on-load false)

P;HTML|
;         (set_option_value  trace-on-exec false)

P;HTML|
;          (set_debug  exec false)

P;HTML|
;         (set_option_value  trace-on-error non-type)

P;HTML|
;          (set_debug  error non-type)

P;HTML|
;         (set_option_value  trace-on-fail false)

P;HTML|
;          (set_debug  fail false)

P;HTML|
;         (set_option_value  trace-on-test true)

P;HTML|
;          (set_debug  test true)

P;HTML|
;         (set_option_value  repl-on-error true)

P;HTML|
;         (set_option_value  repl-on-fail false)

P;HTML|
;         (set_option_value  exit-on-fail false)

P;HTML|
;         (set_option_value  repl auto)

P;HTML|
;         (set_option_value  prolog false)

P;HTML|
;         (set_option_value  exec noskip)

P;HTML|
;         (set_option_value  maximum-result-count inf)

P;HTML|
;         (set_option_value  html false)

P;HTML|
;         (set_option_value  python true)

P;HTML|
;         (set_option_value  trace-on-test false)

P;HTML|
;         (set_debug  test false)

P;HTML|
;         (set_option_value  trace-on-fail false)

P;HTML|
;         (set_debug  fail false)

P;HTML|
;         (set_option_value  load show)

P;HTML|
;         (set_option_value  test false)
<span class="ansi32"
>
% 45,046 inferences, 0.166 CPU in 0.166 seconds (100% CPU, 271557 Lips)
</span>P;HTML|
;          (is_cmd_option  prescan halt --halt=true true)
P;HTML|
;          (set_option_value  halt true)
P;HTML|
;          (is_cmd_option  prescan stdin --stdin=tty tty)
P;HTML|
;           (set_option_value  stdin tty)
P;HTML|
;          (is_cmd_option  prescan stdout --stdout=tty tty)
P;HTML|
;           (set_option_value  stdout tty)
P;HTML|
;          (is_cmd_option  prescan stderr --stderr=tty tty)
P;HTML|
;           (set_option_value  stderr tty)
P;HTML|
;          (set_option_value  compat false)
P;HTML|
;          (set_option_value  compatio false)
P;HTML|
;          (set_option_value  src_indents false)
P;HTML|
;          (set_option_value  devel false)
P;HTML|
;          (set_option_value  stack-max 500)
P;HTML|
;          (set_option_value  limit inf)
P;HTML|
;          (set_option_value  initial-result-count 10)
P;HTML|
;          (set_option_value  answer-format show)
P;HTML|
;          (set_option_value  repeats true)
P;HTML|
;          (set_option_value  time true)
P;HTML|
;          (set_option_value  synth-unit-tests false)
P;HTML|
;          (set_option_value  optimize true)
P;HTML|
;          (set_option_value  transpiler silent)
P;HTML|
;          (set_debug  transpiler false)
P;HTML|
;          (set_option_value  compile false)
P;HTML|
;          (set_option_value  tabling auto)
P;HTML|
;          (set_option_value  log false)
P;HTML|
;          (set_option_value  output ./)
P;HTML|
;          (set_option_value  exeout ./Sav.gitlab.MeTTaLog)
P;HTML|
;          (set_option_value  halt false)
P;HTML|
;          (set_option_value  trace-length 500)
P;HTML|
;          (set_option_value  trace-on-overtime 4.0)
P;HTML|
;          (set_debug  overtime 4.0)
P;HTML|
;          (set_option_value  trace-on-overflow 1000)
P;HTML|
;          (set_debug  overflow 1000)
P;HTML|
;          (set_option_value  trace-on-eval false)
P;HTML|
;          (set_debug  eval false)
P;HTML|
;          (set_option_value  trace-on-load silent)
P;HTML|
;          (set_debug  load silent)
P;HTML|
;          (set_debug  trace-on-load false)
P;HTML|
;          (set_option_value  trace-on-exec false)
P;HTML|
;          (set_debug  exec false)
P;HTML|
;          (set_option_value  trace-on-error non-type)
P;HTML|
;          (set_debug  error non-type)
P;HTML|
;          (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;          (set_option_value  trace-on-test true)
P;HTML|
;          (set_debug  test true)
P;HTML|
;          (set_option_value  repl-on-error true)
P;HTML|
;          (set_option_value  repl-on-fail false)
P;HTML|
;          (set_option_value  exit-on-fail false)
P;HTML|
;          (set_option_value  repl auto)
P;HTML|
;          (set_option_value  prolog false)
P;HTML|
;          (set_option_value  exec noskip)
P;HTML|
;          (set_option_value  maximum-result-count inf)
P;HTML|
;          (set_option_value  html false)
P;HTML|
;          (set_option_value  python true)
P;HTML|
;         (set_option_value  trace-on-test false)
P;HTML|
;          (set_debug  test false)
P;HTML|
;         (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;         (set_option_value  load show)
P;HTML|
;         (set_option_value  test true)
P;HTML|
;        (is_cmd_option  execute python --python=enable enable)
P;HTML|
;         (set_option_value  python enable)
P;HTML|
;        (is_cmd_option  execute timeout --timeout=40 40)
P;HTML|
;         (set_option_value  timeout 40)
P;HTML|
;         (is_cmd_option  execute output --output=./reports/tests_output/baseline-compat/ ./reports/tests_output/baseline-compat/)
P;HTML|
;         (set_option_value  output ./reports/tests_output/baseline-compat/)
P;HTML|
;         (is_cmd_option  execute html --html true)
P;HTML|
;          (set_option_value  html true)
P;HTML|
;         (is_cmd_option  execute test --test true)
P;HTML|
;          (set_option_value  test true)

; (load_metta_file  &self tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta)
P;HTML|
;                       (track_load_into_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta)
P;HTML|
;                                        (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta)
P;HTML|
;                                         (= 1  "[hyperon::space::DynSpace]")
P;HTML|
;                                         (= 2  "[(Error (assertEqual ((let $x (get-atoms GroundingSpace-top) (get-type $x))) ((get-type GroundingSpace-top))) ")
P;HTML|
;                                         (= 2  "Expected: [(hyperon::space::DynSpace)]")
P;HTML|
;                                         (= 2  "Got: [(hyperon::space::DynSpace), (hyperon::space::DynSpace)]")
P;HTML|
;                                         (= 3  "Excessive result: (hyperon::space::DynSpace))]")
P;HTML|
;                                         (= 3  "0.05user 0.00system 0:00.05elapsed 96%CPU (0avgtext+0avgdata 30952maxresident)k")
P;HTML|
;                                         (= 3  "0inputs+0outputs (0major+3659minor)pagefaults 0swaps")
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta is 4.06K bytes (120 lines)
</span>P;HTML|
;                                        (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta)

;;; NOTE: This test won't work outside the test environment because it relies on
;;;  specific atoms in a specific order in the space, and loading the default environment's
;;;  init.metta will break the assumptions in this test
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Even at the very beginning of the main script `(get-atoms &self)`
;;; returns one atom, which wraps the space of stdlib.
;;; The type of this atom is the same as of `&self`
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;!(get-atoms &self)
;;;;!(get-type (get-atoms &self))
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>!(get-type &self)
</span>;; To unit test case:
<span class="ansi38-013099040"
>!(assertEqualToResult (get-type &self) (hyperon::space::DynSpace))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.01"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.01</h3>
; 
; EVAL TEST
; took 0.000227 secs. (227.48 microseconds) 

!(assertEqualToResult (get-type &self) (hyperon::space::DynSpace))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (hyperon::space::DynSpace) (hyperon::space::DynSpace)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual ((let $x (get-atoms &self) (get-type $x))) ((get-type &self)))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.02"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.02</h3>

(failed  once (if_or_else  (eval  = $_569316 495 &self (let a b never-happens) $_570990) (call  eval (let a b never-happens) $_570990)))


(on_mettalog_error  (failed  once (if_or_else  (eval  = $_569316 495 &self (let a b never-happens) $_570990) (call  eval (let a b never-happens) $_570990))))

^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] call(user:once, user:if_or_else(eval(=, _569316, 495, '&self', [let, a, b, 'never-happens'], _570990), call(eval, [let, a, b, 'never-happens'], _570990)))
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] once(user:if_or_else(eval(=, _569316, 495, '&self', [let, a, b, 'never-happens'], _570990), call(eval, [let, a, b, 'never-happens'], _570990)))
   <span class="ansi1 ansi32"
>Call: </span>(299) [user] if_or_else(eval(=, _569316, 495, '&self', [let, a, b, 'never-happens'], _570990), call(eval, [let, a, b, 'never-happens'], _570990))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] eval(=, _569316, 495, '&self', [let, a, b, 'never-happens'], _570990)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] catch_metta_return(eval_args(=, _569316, 495, '&self', [let, a, b, 'never-happens'], _570990), _570990)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_args(=, _569316, 495, '&self', [let, a, b, 'never-happens'], _570990)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_579400, _579402), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_579400, _579402))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_579400, _579402))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_581488, _581490), once(user:nonvar(_570990)), '$restore_trace'(_581488, _581490))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_581488, _581490))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_583576, _583578), once(user:nonvar(_570990)), '$restore_trace'(_583576, _583578))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_583576, _583578))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] setup_call_cleanup('$notrace'(_590732, _590734), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_590732, _590734))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] sig_atomic(system:'$notrace'(_590732, _590734))
^  <span class="ansi1 ansi31"
>Fail: </span>(304) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] eval_00(=, _569316, 495, '&self', [let, a, b, 'never-happens'], _570990)
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] setup_call_cleanup('$notrace'(_595876, _595878), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_595876, _595878))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] sig_atomic(system:'$notrace'(_595876, _595878))
^  <span class="ansi1 ansi31"
>Fail: </span>(305) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] eval_01(=, _569316, 495, '&self', [let, a, b, 'never-happens'], _570990)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] 495<1
   <span class="ansi1 ansi31"
>Fail: </span>(308) [system] 495<1
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] setup_call_cleanup('$notrace'(_604112, _604114), once(user:(_604088 is 495-1, copy_term([let, a, b, 'never-happens'], _604102))), '$restore_trace'(_604112, _604114))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] sig_atomic(system:'$notrace'(_604112, _604114))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(494 is 495-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] trace_eval(eval_20(=, _569316), e, 494, '&self', [let, a, b, 'never-happens'], _607222)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] must_det_ll((notrace((flag(eval_num, _608276, _608276+1), _608294 is _608276 mod 500, _608312 is 99-494 mod 100, _608336=_608338, option_else('trace-length', _608350, 500), option_else('trace-depth', _608358, 30))), quietly(if_t((nop(stop_rtrace), _608294>_608350), (set_debug(eval, false), _608414 is _608350+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608414])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_608466)))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] once(user:(notrace((flag(eval_num, _608276, _608276+1), _608294 is _608276 mod 500, _608312 is 99-494 mod 100, _608336=_608338, option_else('trace-length', _608350, 500), option_else('trace-depth', _608358, 30))), quietly(if_t((nop(stop_rtrace), _608294>_608350), (set_debug(eval, false), _608414 is _608350+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608414])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_608466)))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] setup_call_cleanup('$notrace'(_610512, _610514), once(user:(flag(eval_num, _608276, _608276+1), _608294 is _608276 mod 500, _608312 is 99-494 mod 100, _608336=_608338, option_else('trace-length', _608350, 500), option_else('trace-depth', _608358, 30))), '$restore_trace'(_610512, _610514))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] sig_atomic(system:'$notrace'(_610512, _610514))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2903, 2903+1), 403 is 2903 mod 500, 5 is 99-494 mod 100, _608336=_608336, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 403>500), (set_debug(eval, false), _608414 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608414])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 403>500), (set_debug(eval, false), _608414 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608414])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] nop(notrace(no_repeats_var(_608466)))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] nop(notrace(no_repeats_var(_608466)))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] once(user:(notrace((flag(eval_num, 2903, 2903+1), 403 is 2903 mod 500, 5 is 99-494 mod 100, _608336=_608336, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 403>500), (set_debug(eval, false), _608414 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608414])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_608466)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] must_det_ll(user:(notrace((flag(eval_num, 2903, 2903+1), 403 is 2903 mod 500, 5 is 99-494 mod 100, _608336=_608336, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 403>500), (set_debug(eval, false), _608414 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608414])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_608466)))))
   <span class="ansi1 ansi32"
>Call: </span>(307) [occurs] occurs:sub_term(_620164, e)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(307) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(308) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(307) [occurs] occurs:sub_term(_620164, e)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _627270=e
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] if_trace((eval;e), (_608336=1, indentq(5, 403, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_630410, _630412), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _608336=1, indentq(5, 403, -->, [e, [let, a, b, 'never-happens']]))), _630368, fbug((_630368-->if_trace((eval;e), (_608336=1, indentq(5, 403, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_630410, _630412))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_630410, _630412))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _608336=1, indentq(5, 403, -->, [e, [let, a, b, 'never-happens']]))), _630368, fbug((_630368-->if_trace((eval;e), (_608336=1, indentq(5, 403, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] if_trace((eval;e), (_608336=1, indentq(5, 403, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _634606=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _636644=(\+ \+ (flag(eval_num, _636664, _636664+1), (retval(fail)\=@=retval(fail), nonvar(_607222)->indentq(5, _636664, <--, [e, _607222]);indentq(5, _636664, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] (\+ \+ (flag(eval_num, _636664, _636664+1), (retval(fail)\=@=retval(fail), nonvar(_607222)->indentq(5, _636664, <--, [e, _607222]);indentq(5, _636664, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _636664, _636664+1), (retval(fail)\=@=retval(fail), nonvar(_607222)->indentq(5, _636664, <--, [e, _607222]);indentq(5, _636664, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] call_cleanup(((call(eval_20(=, _569316), 494, '&self', [let, a, b, 'never-happens'], _607222)*->nb_setarg(1, retval(fail), _607222);fail, trace, call(eval_20(=, _569316), 494, '&self', [let, a, b, 'never-happens'], _607222)), ignore(notrace((\+_607222\=_608466, nb_setarg(1, retval(fail), _607222))))), ignore((_608336==1->ignore(\+ \+ (flag(eval_num, _636664, _636664+1), (retval(fail)\=@=retval(fail), nonvar(_607222)->indentq(5, _636664, <--, [e, _607222]);indentq(5, _636664, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636664, _636664+1), (retval(fail)\=@=retval(fail), nonvar(_607222)->indentq(5, _636664, <--, [e, _607222]);indentq(5, _636664, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_20(=, _569316, 494, '&self', [let, a, b, 'never-happens'], _607222)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] setup_call_cleanup('$notrace'(_644052, _644054), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_644052, _644054))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(system:'$notrace'(_644052, _644054))
^  <span class="ansi1 ansi31"
>Fail: </span>(311) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(311) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] once(expand_eval([let, a, b, 'never-happens'], _666396))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] expand_eval([let, a, b, 'never-happens'], _666396)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _672496)
   <span class="ansi1 ansi32"
>Call: </span>(313) [apply] apply:maplist_([a, b, 'never-happens'], _672496, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] expand_eval(a, _674552)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] a=_674552
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(314) [apply] apply:maplist_([b, 'never-happens'], _674554, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] expand_eval(b, _680654)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] b=_680654
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(315) [apply] apply:maplist_(['never-happens'], _680656, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] expand_eval('never-happens', _686756)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] 'never-happens'=_686756
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(316) [apply] apply:maplist_([], _686758, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(314) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] possible_type('&self', a, _704048)
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] possible_type('&self', a, _704048)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] eval_args(=, _704048, 494, '&self', b, _706090)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_708148, _708150), once(user:self_eval(b)), '$restore_trace'(_708148, _708150))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_708148, _708150))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] _706090=b
   <span class="ansi1 ansi32"
>Exit: </span>(311) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] eval_args(=, _704048, 494, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] eval_20(=, _569316, 494, '&self', [let, a, b, 'never-happens'], _607222)
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(309) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] ignore((_608336==1->ignore(\+ \+ (flag(eval_num, _636664, _636664+1), (retval(fail)\=@=retval(fail), nonvar(_607222)->indentq(5, _636664, <--, [e, _607222]);indentq(5, _636664, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636664, _636664+1), (retval(fail)\=@=retval(fail), nonvar(_607222)->indentq(5, _636664, <--, [e, _607222]);indentq(5, _636664, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] _608336==1
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] _608336==1
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_721478, _721480), once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636664, _636664+1), (retval(fail)\=@=retval(fail), nonvar(_607222)->indentq(5, _636664, <--, [e, _607222]);indentq(5, _636664, <--, [e, retval(fail)])))))))), '$restore_trace'(_721478, _721480))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_721478, _721480))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636664, _636664+1), (retval(fail)\=@=retval(fail), nonvar(_607222)->indentq(5, _636664, <--, [e, _607222]);indentq(5, _636664, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] ignore(user:(_608336==1->ignore(\+ \+ (flag(eval_num, _636664, _636664+1), (retval(fail)\=@=retval(fail), nonvar(_607222)->indentq(5, _636664, <--, [e, _607222]);indentq(5, _636664, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636664, _636664+1), (retval(fail)\=@=retval(fail), nonvar(_607222)->indentq(5, _636664, <--, [e, _607222]);indentq(5, _636664, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(307) [system] call_cleanup(user:((call(eval_20(=, _569316), 494, '&self', [let, a, b, 'never-happens'], _607222)*->nb_setarg(1, retval(fail), _607222);fail, trace, call(eval_20(=, _569316), 494, '&self', [let, a, b, 'never-happens'], _607222)), ignore(notrace((\+_607222\=_608466, nb_setarg(1, retval(fail), _607222))))), user:ignore((_608336==1->ignore(\+ \+ (flag(eval_num, _636664, _636664+1), (retval(fail)\=@=retval(fail), nonvar(_607222)->indentq(5, _636664, <--, [e, _607222]);indentq(5, _636664, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636664, _636664+1), (retval(fail)\=@=retval(fail), nonvar(_607222)->indentq(5, _636664, <--, [e, _607222]);indentq(5, _636664, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(306) [user] trace_eval(eval_20(=, _569316), e, 494, '&self', [let, a, b, 'never-happens'], _607222)
^  <span class="ansi1 ansi31"
>Fail: </span>(303) [user] eval_args(=, _569316, 495, '&self', [let, a, b, 'never-happens'], _570990)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] call(eval, [let, a, b, 'never-happens'], _570990)
   <span class="ansi1 ansi32"
>Call: </span>(301) [user] eval([let, a, b, 'never-happens'], _570990)
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] current_self(_730886)
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] nb_current(self_space, _730886)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(302) [user] eval('&self', [let, a, b, 'never-happens'], _570990)
   <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _570990)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] catch_metta_return(eval_args(=, _739000, 500, '&self', [let, a, b, 'never-happens'], _570990), _570990)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_args(=, _739000, 500, '&self', [let, a, b, 'never-happens'], _570990)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_742110, _742112), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_742110, _742112))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_742110, _742112))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_744198, _744200), once(user:nonvar(_570990)), '$restore_trace'(_744198, _744200))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_744198, _744200))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_746286, _746288), once(user:nonvar(_570990)), '$restore_trace'(_746286, _746288))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_746286, _746288))
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_753442, _753444), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_753442, _753444))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_753442, _753444))
^  <span class="ansi1 ansi31"
>Fail: </span>(307) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] eval_00(=, _739000, 500, '&self', [let, a, b, 'never-happens'], _570990)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_758586, _758588), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_758586, _758588))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_758586, _758588))
^  <span class="ansi1 ansi31"
>Fail: </span>(308) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] eval_01(=, _739000, 500, '&self', [let, a, b, 'never-happens'], _570990)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_766822, _766824), once(user:(_766798 is 500-1, copy_term([let, a, b, 'never-happens'], _766812))), '$restore_trace'(_766822, _766824))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_766822, _766824))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] trace_eval(eval_20(=, _739000), e, 499, '&self', [let, a, b, 'never-happens'], _769932)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] must_det_ll((notrace((flag(eval_num, _770986, _770986+1), _771004 is _770986 mod 500, _771022 is 99-499 mod 100, _771046=_771048, option_else('trace-length', _771060, 500), option_else('trace-depth', _771068, 30))), quietly(if_t((nop(stop_rtrace), _771004>_771060), (set_debug(eval, false), _771124 is _771060+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771124])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_771176)))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] once(user:(notrace((flag(eval_num, _770986, _770986+1), _771004 is _770986 mod 500, _771022 is 99-499 mod 100, _771046=_771048, option_else('trace-length', _771060, 500), option_else('trace-depth', _771068, 30))), quietly(if_t((nop(stop_rtrace), _771004>_771060), (set_debug(eval, false), _771124 is _771060+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771124])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_771176)))))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] setup_call_cleanup('$notrace'(_773222, _773224), once(user:(flag(eval_num, _770986, _770986+1), _771004 is _770986 mod 500, _771022 is 99-499 mod 100, _771046=_771048, option_else('trace-length', _771060, 500), option_else('trace-depth', _771068, 30))), '$restore_trace'(_773222, _773224))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] sig_atomic(system:'$notrace'(_773222, _773224))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2904, 2904+1), 404 is 2904 mod 500, 0 is 99-499 mod 100, _771046=_771046, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 404>500), (set_debug(eval, false), _771124 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771124])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 404>500), (set_debug(eval, false), _771124 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771124])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] nop(notrace(no_repeats_var(_771176)))
   <span class="ansi1 ansi32"
>Exit: </span>(313) [user] nop(notrace(no_repeats_var(_771176)))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] once(user:(notrace((flag(eval_num, 2904, 2904+1), 404 is 2904 mod 500, 0 is 99-499 mod 100, _771046=_771046, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 404>500), (set_debug(eval, false), _771124 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771124])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_771176)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] must_det_ll(user:(notrace((flag(eval_num, 2904, 2904+1), 404 is 2904 mod 500, 0 is 99-499 mod 100, _771046=_771046, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 404>500), (set_debug(eval, false), _771124 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771124])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_771176)))))
   <span class="ansi1 ansi32"
>Call: </span>(310) [occurs] occurs:sub_term(_782874, e)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(310) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(310) [occurs] occurs:sub_term(_782874, e)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _789980=e
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] if_trace((eval;e), (_771046=1, indentq(0, 404, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_793120, _793122), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _771046=1, indentq(0, 404, -->, [e, [let, a, b, 'never-happens']]))), _793078, fbug((_793078-->if_trace((eval;e), (_771046=1, indentq(0, 404, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_793120, _793122))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_793120, _793122))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _771046=1, indentq(0, 404, -->, [e, [let, a, b, 'never-happens']]))), _793078, fbug((_793078-->if_trace((eval;e), (_771046=1, indentq(0, 404, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_trace((eval;e), (_771046=1, indentq(0, 404, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _797316=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _799354=(\+ \+ (flag(eval_num, _799374, _799374+1), (retval(fail)\=@=retval(fail), nonvar(_769932)->indentq(0, _799374, <--, [e, _769932]);indentq(0, _799374, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] (\+ \+ (flag(eval_num, _799374, _799374+1), (retval(fail)\=@=retval(fail), nonvar(_769932)->indentq(0, _799374, <--, [e, _769932]);indentq(0, _799374, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _799374, _799374+1), (retval(fail)\=@=retval(fail), nonvar(_769932)->indentq(0, _799374, <--, [e, _769932]);indentq(0, _799374, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] call_cleanup(((call(eval_20(=, _739000), 499, '&self', [let, a, b, 'never-happens'], _769932)*->nb_setarg(1, retval(fail), _769932);fail, trace, call(eval_20(=, _739000), 499, '&self', [let, a, b, 'never-happens'], _769932)), ignore(notrace((\+_769932\=_771176, nb_setarg(1, retval(fail), _769932))))), ignore((_771046==1->ignore(\+ \+ (flag(eval_num, _799374, _799374+1), (retval(fail)\=@=retval(fail), nonvar(_769932)->indentq(0, _799374, <--, [e, _769932]);indentq(0, _799374, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799374, _799374+1), (retval(fail)\=@=retval(fail), nonvar(_769932)->indentq(0, _799374, <--, [e, _769932]);indentq(0, _799374, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval_20(=, _739000, 499, '&self', [let, a, b, 'never-happens'], _769932)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] setup_call_cleanup('$notrace'(_806762, _806764), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_806762, _806764))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] sig_atomic(system:'$notrace'(_806762, _806764))
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] once(expand_eval([let, a, b, 'never-happens'], _829106))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] expand_eval([let, a, b, 'never-happens'], _829106)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _835206)
   <span class="ansi1 ansi32"
>Call: </span>(316) [apply] apply:maplist_([a, b, 'never-happens'], _835206, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] expand_eval(a, _837262)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] a=_837262
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(317) [apply] apply:maplist_([b, 'never-happens'], _837264, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] expand_eval(b, _843364)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] b=_843364
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(318) [apply] apply:maplist_(['never-happens'], _843366, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] expand_eval('never-happens', _849466)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] 'never-happens'=_849466
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(319) [apply] apply:maplist_([], _849468, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(317) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] possible_type('&self', a, _866758)
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] possible_type('&self', a, _866758)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval_args(=, _866758, 499, '&self', b, _868800)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_870858, _870860), once(user:self_eval(b)), '$restore_trace'(_870858, _870860))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_870858, _870860))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] _868800=b
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] eval_args(=, _866758, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(312) [user] eval_20(=, _739000, 499, '&self', [let, a, b, 'never-happens'], _769932)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(312) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] ignore((_771046==1->ignore(\+ \+ (flag(eval_num, _799374, _799374+1), (retval(fail)\=@=retval(fail), nonvar(_769932)->indentq(0, _799374, <--, [e, _769932]);indentq(0, _799374, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799374, _799374+1), (retval(fail)\=@=retval(fail), nonvar(_769932)->indentq(0, _799374, <--, [e, _769932]);indentq(0, _799374, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] _771046==1
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] _771046==1
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_884188, _884190), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799374, _799374+1), (retval(fail)\=@=retval(fail), nonvar(_769932)->indentq(0, _799374, <--, [e, _769932]);indentq(0, _799374, <--, [e, retval(fail)])))))))), '$restore_trace'(_884188, _884190))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_884188, _884190))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799374, _799374+1), (retval(fail)\=@=retval(fail), nonvar(_769932)->indentq(0, _799374, <--, [e, _769932]);indentq(0, _799374, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] ignore(user:(_771046==1->ignore(\+ \+ (flag(eval_num, _799374, _799374+1), (retval(fail)\=@=retval(fail), nonvar(_769932)->indentq(0, _799374, <--, [e, _769932]);indentq(0, _799374, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799374, _799374+1), (retval(fail)\=@=retval(fail), nonvar(_769932)->indentq(0, _799374, <--, [e, _769932]);indentq(0, _799374, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(310) [system] call_cleanup(user:((call(eval_20(=, _739000), 499, '&self', [let, a, b, 'never-happens'], _769932)*->nb_setarg(1, retval(fail), _769932);fail, trace, call(eval_20(=, _739000), 499, '&self', [let, a, b, 'never-happens'], _769932)), ignore(notrace((\+_769932\=_771176, nb_setarg(1, retval(fail), _769932))))), user:ignore((_771046==1->ignore(\+ \+ (flag(eval_num, _799374, _799374+1), (retval(fail)\=@=retval(fail), nonvar(_769932)->indentq(0, _799374, <--, [e, _769932]);indentq(0, _799374, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799374, _799374+1), (retval(fail)\=@=retval(fail), nonvar(_769932)->indentq(0, _799374, <--, [e, _769932]);indentq(0, _799374, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] trace_eval(eval_20(=, _739000), e, 499, '&self', [let, a, b, 'never-happens'], _769932)
^  <span class="ansi1 ansi31"
>Fail: </span>(306) [user] eval_args(=, _739000, 500, '&self', [let, a, b, 'never-happens'], _570990)
^  <span class="ansi1 ansi31"
>Fail: </span>(297) [system] call(user:once, user:if_or_else(eval(=, _569316, 495, '&self', [let, a, b, 'never-happens'], _570990), call(eval, [let, a, b, 'never-happens'], _570990)))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(299) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] setup_call_cleanup('$notrace'(_895650, _895652), once(rtrace:retract(t_l:tracer_reset(_895640))), '$restore_trace'(_895650, _895652))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] sig_atomic(system:'$notrace'(_895650, _895652))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [rtrace] tAt(false, 271, 271, false)
; 
; EVAL TEST
; took 0.944 secs. (944.12 milliseconds) 

!(assertEqual ((let $x (get-atoms &self) (get-type $x))) ((get-type &self)))

<span class="ansi31"
>(loonit_failureR  (equal_enough_for_test  ((hyperon::space::DynSpace) (hyperon::space::DynSpace) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (())) ((hyperon::space::DynSpace))))
</span>
Deterministic: ((Error  (got  ((hyperon::space::DynSpace) (hyperon::space::DynSpace) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()))) (expected  ((hyperon::space::DynSpace)))))
;;; stdlib is already loaded
<span class="ansi38-013099040"
>!(assertEqual (if (> 1 2) 1 2) 2)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.03"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.03</h3>
; 
; EVAL TEST
; took 0.000278 secs. (278.14 microseconds) 

!(assertEqual (if (> 1 2) 1 2) 2)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (2) (2)))
</span>
Deterministic: ()
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Importing the module into new space
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &m f1_moduleA.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta)
P;HTML|
;                                         (= 1  "[(Error (import! GroundingSpace-top f1_moduleC.metta) Illegal module name: f1_moduleC.metta)]")
P;HTML|
;                                         (= 2  "0.05user 0.00system 0:00.05elapsed 100%CPU (0avgtext+0avgdata 31132maxresident)k")
P;HTML|
;                                         (= 2  "0inputs+0outputs (0major+3659minor)pagefaults 0swaps")
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta is 625 bytes (17 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta is 291 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Numer))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()
;;; FIXME? stdlib space is not available at importing time -
;;; only tokens / grounded operations work, while symbolic functions
;;; (like `if`) don't work.
;;; FIXME? Exceptions are not caught by `importOp`
<span class="ansi38-013099040"
>!(assertEqual (+ 1 2) 3)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.04"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.04</h3>
; 
; EVAL TEST
; took 0.000211 secs. (210.56 microseconds) 

!(assertEqual (+ 1 2) 3)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (3) (3)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (if True "S" "F") "S")

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.05"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.05</h3>
; 
; EVAL TEST
; took 0.000161 secs. (160.82 microseconds) 

!(assertEqual (if True "S" "F") "S")

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  ("S") ("S")))
</span>
Deterministic: ()<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (+ $x 10) (g $x)))
</span><span class="ansi38-255165000"
> (: f (-> Number Number))
</span><span class="ansi38-255165000"
> (= (f $x) (if (< $x 0) (- 0 $x) (g (+ 1 $x))))
</span>
Last Result(2): ()
;;; It's first atom is a space
;;;!(assertEqual
;;;  (let* (($x (collapse (get-atoms &m)))
;;;         ($y (car-atom $x)))
;;;        (get-type $y))
;;;  (get-type &self))
;;; FIXME? Now, it is moduleC space.
;;;        Should it be `stdlib` atom for a separately imported space
;;; !(let $x (collapse (get-atoms &m)) (car-atom $x))
;;; MeTTLog:  xlisting('&m').
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Without additional means like `(&m.f 2)` notation or `(interpret &m (f 2))`,
;;; we cannot execute functions from the separate space - we can only use `match`.
;;; Although `&m` imports another space with definition of `g`, it is not reduced
;;; because it is not defined in the context of `&self`. This is the expected
;;; behavior, but it shows that this way of importing spaces is not too useful
;;; for importing modules with functions.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(assertEqual (match &m (= (f 2) $x) $x) (g 3))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.06"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.06</h3>
; 
; EVAL TEST
; took 0.004 secs. (3.52 milliseconds) 

!(assertEqual (match &m (= (f 2) $x) $x) (g 3))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  ((g 3)) ((g 3))))
</span>
Deterministic: ()
;;; Importing the same space into `&self` should break nothing
;;; TODO? If stdlib space would be in `&m`, which should check that it is not
;;; there anymore since in should be removed after importing it to `&self`
<span class="ansi38-013099040"
>!(import! &self f1_moduleA.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta is 625 bytes (17 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta is 291 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Numer))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()
;;; FIXME? stdlib space is not available at importing time -
;;; only tokens / grounded operations work, while symbolic functions
;;; (like `if`) don't work.
;;; FIXME? Exceptions are not caught by `importOp`
<span class="ansi38-013099040"
>!(assertEqual (+ 1 2) 3)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.07"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.07</h3>
; 
; EVAL TEST
; took 0.000200 secs. (200.34 microseconds) 

!(assertEqual (+ 1 2) 3)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (3) (3)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (if True "S" "F") "S")

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.08"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.08</h3>
; 
; EVAL TEST
; took 0.000156 secs. (156.35 microseconds) 

!(assertEqual (if True "S" "F") "S")

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  ("S") ("S")))
</span>
Deterministic: ()<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (+ $x 10) (g $x)))
</span><span class="ansi38-255165000"
> (: f (-> Number Number))
</span><span class="ansi38-255165000"
> (= (f $x) (if (< $x 0) (- 0 $x) (g (+ 1 $x))))
</span>
Last Result(2): ()
;;; Now indirectly imported `g` works and `f` fully works
<span class="ansi38-013099040"
>!(assertEqual (g 2) 102)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.09"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.09</h3>
; 
; EVAL TEST
; took 0.000991 secs. (990.64 microseconds) 

!(assertEqual (g 2) 102)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102) (102)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (f 2) 103)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.10"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.10</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.41 milliseconds) 

!(assertEqual (f 2) 103)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (103) (103)))
</span>
Deterministic: ()
;;; MeTTLog:  xlisting('&self').
;;; `&self` contains 3 atoms-spaces now:
;;; - stdlib
;;; - moduleC imported by moduleA and removed from A after its import to &self
;;; - moduleA itself, which is the same as &m
<span class="ansi38-013099040"
>!(assertEqual &m (let* (($a (collapse (get-atoms &self))) ($x (cdr-atom $a)) ($y (cdr-atom $x))) (car-atom $y)))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.11"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.11</h3>

(failed  once (if_or_else  (eval  = $_337362 495 &self (let a b never-happens) $_339036) (call  eval (let a b never-happens) $_339036)))


(on_mettalog_error  (failed  once (if_or_else  (eval  = $_337362 495 &self (let a b never-happens) $_339036) (call  eval (let a b never-happens) $_339036))))

^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] call(user:once, user:if_or_else(eval(=, _337362, 495, '&self', [let, a, b, 'never-happens'], _339036), call(eval, [let, a, b, 'never-happens'], _339036)))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] once(user:if_or_else(eval(=, _337362, 495, '&self', [let, a, b, 'never-happens'], _339036), call(eval, [let, a, b, 'never-happens'], _339036)))
   <span class="ansi1 ansi32"
>Call: </span>(312) [user] if_or_else(eval(=, _337362, 495, '&self', [let, a, b, 'never-happens'], _339036), call(eval, [let, a, b, 'never-happens'], _339036))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval(=, _337362, 495, '&self', [let, a, b, 'never-happens'], _339036)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] catch_metta_return(eval_args(=, _337362, 495, '&self', [let, a, b, 'never-happens'], _339036), _339036)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_args(=, _337362, 495, '&self', [let, a, b, 'never-happens'], _339036)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_347446, _347448), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_347446, _347448))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_347446, _347448))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_349534, _349536), once(user:nonvar(_339036)), '$restore_trace'(_349534, _349536))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_349534, _349536))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_351622, _351624), once(user:nonvar(_339036)), '$restore_trace'(_351622, _351624))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_351622, _351624))
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_358778, _358780), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_358778, _358780))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_358778, _358780))
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] eval_00(=, _337362, 495, '&self', [let, a, b, 'never-happens'], _339036)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_363922, _363924), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_363922, _363924))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_363922, _363924))
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] eval_01(=, _337362, 495, '&self', [let, a, b, 'never-happens'], _339036)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] 495<1
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] 495<1
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_372158, _372160), once(user:(_372134 is 495-1, copy_term([let, a, b, 'never-happens'], _372148))), '$restore_trace'(_372158, _372160))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_372158, _372160))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(494 is 495-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] trace_eval(eval_20(=, _337362), e, 494, '&self', [let, a, b, 'never-happens'], _375268)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] must_det_ll((notrace((flag(eval_num, _376322, _376322+1), _376340 is _376322 mod 500, _376358 is 99-494 mod 100, _376382=_376384, option_else('trace-length', _376396, 500), option_else('trace-depth', _376404, 30))), quietly(if_t((nop(stop_rtrace), _376340>_376396), (set_debug(eval, false), _376460 is _376396+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376460])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_376512)))))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] once(user:(notrace((flag(eval_num, _376322, _376322+1), _376340 is _376322 mod 500, _376358 is 99-494 mod 100, _376382=_376384, option_else('trace-length', _376396, 500), option_else('trace-depth', _376404, 30))), quietly(if_t((nop(stop_rtrace), _376340>_376396), (set_debug(eval, false), _376460 is _376396+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376460])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_376512)))))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_378558, _378560), once(user:(flag(eval_num, _376322, _376322+1), _376340 is _376322 mod 500, _376358 is 99-494 mod 100, _376382=_376384, option_else('trace-length', _376396, 500), option_else('trace-depth', _376404, 30))), '$restore_trace'(_378558, _378560))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_378558, _378560))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2077, 2077+1), 77 is 2077 mod 500, 5 is 99-494 mod 100, _376382=_376382, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 77>500), (set_debug(eval, false), _376460 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376460])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 77>500), (set_debug(eval, false), _376460 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376460])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(323) [user] nop(notrace(no_repeats_var(_376512)))
   <span class="ansi1 ansi32"
>Exit: </span>(323) [user] nop(notrace(no_repeats_var(_376512)))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] once(user:(notrace((flag(eval_num, 2077, 2077+1), 77 is 2077 mod 500, 5 is 99-494 mod 100, _376382=_376382, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 77>500), (set_debug(eval, false), _376460 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376460])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_376512)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] must_det_ll(user:(notrace((flag(eval_num, 2077, 2077+1), 77 is 2077 mod 500, 5 is 99-494 mod 100, _376382=_376382, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 77>500), (set_debug(eval, false), _376460 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376460])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_376512)))))
   <span class="ansi1 ansi32"
>Call: </span>(320) [occurs] occurs:sub_term(_388210, e)
   <span class="ansi1 ansi32"
>Exit: </span>(320) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(320) [occurs] occurs:sub_term(_388210, e)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _395316=e
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] if_trace((eval;e), (_376382=1, indentq(5, 77, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_398456, _398458), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _376382=1, indentq(5, 77, -->, [e, [let, a, b, 'never-happens']]))), _398414, fbug((_398414-->if_trace((eval;e), (_376382=1, indentq(5, 77, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_398456, _398458))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_398456, _398458))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _376382=1, indentq(5, 77, -->, [e, [let, a, b, 'never-happens']]))), _398414, fbug((_398414-->if_trace((eval;e), (_376382=1, indentq(5, 77, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_trace((eval;e), (_376382=1, indentq(5, 77, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _402652=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _404690=(\+ \+ (flag(eval_num, _404710, _404710+1), (retval(fail)\=@=retval(fail), nonvar(_375268)->indentq(5, _404710, <--, [e, _375268]);indentq(5, _404710, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] (\+ \+ (flag(eval_num, _404710, _404710+1), (retval(fail)\=@=retval(fail), nonvar(_375268)->indentq(5, _404710, <--, [e, _375268]);indentq(5, _404710, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _404710, _404710+1), (retval(fail)\=@=retval(fail), nonvar(_375268)->indentq(5, _404710, <--, [e, _375268]);indentq(5, _404710, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] call_cleanup(((call(eval_20(=, _337362), 494, '&self', [let, a, b, 'never-happens'], _375268)*->nb_setarg(1, retval(fail), _375268);fail, trace, call(eval_20(=, _337362), 494, '&self', [let, a, b, 'never-happens'], _375268)), ignore(notrace((\+_375268\=_376512, nb_setarg(1, retval(fail), _375268))))), ignore((_376382==1->ignore(\+ \+ (flag(eval_num, _404710, _404710+1), (retval(fail)\=@=retval(fail), nonvar(_375268)->indentq(5, _404710, <--, [e, _375268]);indentq(5, _404710, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404710, _404710+1), (retval(fail)\=@=retval(fail), nonvar(_375268)->indentq(5, _404710, <--, [e, _375268]);indentq(5, _404710, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] eval_20(=, _337362, 494, '&self', [let, a, b, 'never-happens'], _375268)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] setup_call_cleanup('$notrace'(_412098, _412100), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_412098, _412100))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] sig_atomic(system:'$notrace'(_412098, _412100))
^  <span class="ansi1 ansi31"
>Fail: </span>(324) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] once(expand_eval([let, a, b, 'never-happens'], _434442))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] expand_eval([let, a, b, 'never-happens'], _434442)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _440542)
   <span class="ansi1 ansi32"
>Call: </span>(326) [apply] apply:maplist_([a, b, 'never-happens'], _440542, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] expand_eval(a, _442598)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] a=_442598
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(327) [apply] apply:maplist_([b, 'never-happens'], _442600, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] expand_eval(b, _448700)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] b=_448700
   <span class="ansi1 ansi32"
>Exit: </span>(329) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(328) [apply] apply:maplist_(['never-happens'], _448702, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] expand_eval('never-happens', _454802)
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] 'never-happens'=_454802
   <span class="ansi1 ansi32"
>Exit: </span>(330) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(329) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(329) [apply] apply:maplist_([], _454804, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(329) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] possible_type('&self', a, _472094)
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] possible_type('&self', a, _472094)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] eval_args(=, _472094, 494, '&self', b, _474136)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_476194, _476196), once(user:self_eval(b)), '$restore_trace'(_476194, _476196))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_476194, _476196))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] _474136=b
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] eval_args(=, _472094, 494, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(322) [user] eval_20(=, _337362, 494, '&self', [let, a, b, 'never-happens'], _375268)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(322) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] ignore((_376382==1->ignore(\+ \+ (flag(eval_num, _404710, _404710+1), (retval(fail)\=@=retval(fail), nonvar(_375268)->indentq(5, _404710, <--, [e, _375268]);indentq(5, _404710, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404710, _404710+1), (retval(fail)\=@=retval(fail), nonvar(_375268)->indentq(5, _404710, <--, [e, _375268]);indentq(5, _404710, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] _376382==1
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] _376382==1
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_489524, _489526), once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404710, _404710+1), (retval(fail)\=@=retval(fail), nonvar(_375268)->indentq(5, _404710, <--, [e, _375268]);indentq(5, _404710, <--, [e, retval(fail)])))))))), '$restore_trace'(_489524, _489526))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_489524, _489526))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404710, _404710+1), (retval(fail)\=@=retval(fail), nonvar(_375268)->indentq(5, _404710, <--, [e, _375268]);indentq(5, _404710, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] ignore(user:(_376382==1->ignore(\+ \+ (flag(eval_num, _404710, _404710+1), (retval(fail)\=@=retval(fail), nonvar(_375268)->indentq(5, _404710, <--, [e, _375268]);indentq(5, _404710, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404710, _404710+1), (retval(fail)\=@=retval(fail), nonvar(_375268)->indentq(5, _404710, <--, [e, _375268]);indentq(5, _404710, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [system] call_cleanup(user:((call(eval_20(=, _337362), 494, '&self', [let, a, b, 'never-happens'], _375268)*->nb_setarg(1, retval(fail), _375268);fail, trace, call(eval_20(=, _337362), 494, '&self', [let, a, b, 'never-happens'], _375268)), ignore(notrace((\+_375268\=_376512, nb_setarg(1, retval(fail), _375268))))), user:ignore((_376382==1->ignore(\+ \+ (flag(eval_num, _404710, _404710+1), (retval(fail)\=@=retval(fail), nonvar(_375268)->indentq(5, _404710, <--, [e, _375268]);indentq(5, _404710, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404710, _404710+1), (retval(fail)\=@=retval(fail), nonvar(_375268)->indentq(5, _404710, <--, [e, _375268]);indentq(5, _404710, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] trace_eval(eval_20(=, _337362), e, 494, '&self', [let, a, b, 'never-happens'], _375268)
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] eval_args(=, _337362, 495, '&self', [let, a, b, 'never-happens'], _339036)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] call(eval, [let, a, b, 'never-happens'], _339036)
   <span class="ansi1 ansi32"
>Call: </span>(314) [user] eval([let, a, b, 'never-happens'], _339036)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] current_self(_498932)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] nb_current(self_space, _498932)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval('&self', [let, a, b, 'never-happens'], _339036)
   <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _339036)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] catch_metta_return(eval_args(=, _507046, 500, '&self', [let, a, b, 'never-happens'], _339036), _339036)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_args(=, _507046, 500, '&self', [let, a, b, 'never-happens'], _339036)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_510156, _510158), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_510156, _510158))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_510156, _510158))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_512244, _512246), once(user:nonvar(_339036)), '$restore_trace'(_512244, _512246))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_512244, _512246))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_514332, _514334), once(user:nonvar(_339036)), '$restore_trace'(_514332, _514334))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_514332, _514334))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_521488, _521490), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_521488, _521490))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_521488, _521490))
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] eval_00(=, _507046, 500, '&self', [let, a, b, 'never-happens'], _339036)
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] setup_call_cleanup('$notrace'(_526632, _526634), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_526632, _526634))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] sig_atomic(system:'$notrace'(_526632, _526634))
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] eval_01(=, _507046, 500, '&self', [let, a, b, 'never-happens'], _339036)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] setup_call_cleanup('$notrace'(_534868, _534870), once(user:(_534844 is 500-1, copy_term([let, a, b, 'never-happens'], _534858))), '$restore_trace'(_534868, _534870))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] sig_atomic(system:'$notrace'(_534868, _534870))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] trace_eval(eval_20(=, _507046), e, 499, '&self', [let, a, b, 'never-happens'], _537978)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] must_det_ll((notrace((flag(eval_num, _539032, _539032+1), _539050 is _539032 mod 500, _539068 is 99-499 mod 100, _539092=_539094, option_else('trace-length', _539106, 500), option_else('trace-depth', _539114, 30))), quietly(if_t((nop(stop_rtrace), _539050>_539106), (set_debug(eval, false), _539170 is _539106+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539170])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_539222)))))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] once(user:(notrace((flag(eval_num, _539032, _539032+1), _539050 is _539032 mod 500, _539068 is 99-499 mod 100, _539092=_539094, option_else('trace-length', _539106, 500), option_else('trace-depth', _539114, 30))), quietly(if_t((nop(stop_rtrace), _539050>_539106), (set_debug(eval, false), _539170 is _539106+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539170])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_539222)))))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] setup_call_cleanup('$notrace'(_541268, _541270), once(user:(flag(eval_num, _539032, _539032+1), _539050 is _539032 mod 500, _539068 is 99-499 mod 100, _539092=_539094, option_else('trace-length', _539106, 500), option_else('trace-depth', _539114, 30))), '$restore_trace'(_541268, _541270))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] sig_atomic(system:'$notrace'(_541268, _541270))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2078, 2078+1), 78 is 2078 mod 500, 0 is 99-499 mod 100, _539092=_539092, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _539170 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539170])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _539170 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539170])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(326) [user] nop(notrace(no_repeats_var(_539222)))
   <span class="ansi1 ansi32"
>Exit: </span>(326) [user] nop(notrace(no_repeats_var(_539222)))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] once(user:(notrace((flag(eval_num, 2078, 2078+1), 78 is 2078 mod 500, 0 is 99-499 mod 100, _539092=_539092, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _539170 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539170])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_539222)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] must_det_ll(user:(notrace((flag(eval_num, 2078, 2078+1), 78 is 2078 mod 500, 0 is 99-499 mod 100, _539092=_539092, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _539170 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539170])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_539222)))))
   <span class="ansi1 ansi32"
>Call: </span>(323) [occurs] occurs:sub_term(_550920, e)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(323) [occurs] occurs:sub_term(_550920, e)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _558026=e
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] if_trace((eval;e), (_539092=1, indentq(0, 78, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_561166, _561168), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _539092=1, indentq(0, 78, -->, [e, [let, a, b, 'never-happens']]))), _561124, fbug((_561124-->if_trace((eval;e), (_539092=1, indentq(0, 78, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_561166, _561168))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_561166, _561168))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _539092=1, indentq(0, 78, -->, [e, [let, a, b, 'never-happens']]))), _561124, fbug((_561124-->if_trace((eval;e), (_539092=1, indentq(0, 78, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] if_trace((eval;e), (_539092=1, indentq(0, 78, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _565362=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _567400=(\+ \+ (flag(eval_num, _567420, _567420+1), (retval(fail)\=@=retval(fail), nonvar(_537978)->indentq(0, _567420, <--, [e, _537978]);indentq(0, _567420, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] (\+ \+ (flag(eval_num, _567420, _567420+1), (retval(fail)\=@=retval(fail), nonvar(_537978)->indentq(0, _567420, <--, [e, _537978]);indentq(0, _567420, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _567420, _567420+1), (retval(fail)\=@=retval(fail), nonvar(_537978)->indentq(0, _567420, <--, [e, _537978]);indentq(0, _567420, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] call_cleanup(((call(eval_20(=, _507046), 499, '&self', [let, a, b, 'never-happens'], _537978)*->nb_setarg(1, retval(fail), _537978);fail, trace, call(eval_20(=, _507046), 499, '&self', [let, a, b, 'never-happens'], _537978)), ignore(notrace((\+_537978\=_539222, nb_setarg(1, retval(fail), _537978))))), ignore((_539092==1->ignore(\+ \+ (flag(eval_num, _567420, _567420+1), (retval(fail)\=@=retval(fail), nonvar(_537978)->indentq(0, _567420, <--, [e, _537978]);indentq(0, _567420, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567420, _567420+1), (retval(fail)\=@=retval(fail), nonvar(_537978)->indentq(0, _567420, <--, [e, _537978]);indentq(0, _567420, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] eval_20(=, _507046, 499, '&self', [let, a, b, 'never-happens'], _537978)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(329) [system] setup_call_cleanup('$notrace'(_574808, _574810), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_574808, _574810))
^  <span class="ansi1 ansi32"
>Call: </span>(330) [system] sig_atomic(system:'$notrace'(_574808, _574810))
^  <span class="ansi1 ansi31"
>Fail: </span>(327) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] once(expand_eval([let, a, b, 'never-happens'], _597152))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] expand_eval([let, a, b, 'never-happens'], _597152)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _603252)
   <span class="ansi1 ansi32"
>Call: </span>(329) [apply] apply:maplist_([a, b, 'never-happens'], _603252, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] expand_eval(a, _605308)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] a=_605308
   <span class="ansi1 ansi32"
>Exit: </span>(331) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(330) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(330) [apply] apply:maplist_([b, 'never-happens'], _605310, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] expand_eval(b, _611410)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] b=_611410
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(331) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(331) [apply] apply:maplist_(['never-happens'], _611412, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(332) [user] expand_eval('never-happens', _617512)
   <span class="ansi1 ansi32"
>Call: </span>(333) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(333) [system] 'never-happens'=_617512
   <span class="ansi1 ansi32"
>Exit: </span>(333) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(332) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(332) [apply] apply:maplist_([], _617514, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(332) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(331) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(330) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(329) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] possible_type('&self', a, _634804)
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] possible_type('&self', a, _634804)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] eval_args(=, _634804, 499, '&self', b, _636846)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] setup_call_cleanup('$notrace'(_638904, _638906), once(user:self_eval(b)), '$restore_trace'(_638904, _638906))
^  <span class="ansi1 ansi32"
>Call: </span>(329) [system] sig_atomic(system:'$notrace'(_638904, _638906))
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] _636846=b
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] eval_args(=, _634804, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(325) [user] eval_20(=, _507046, 499, '&self', [let, a, b, 'never-happens'], _537978)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(325) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] ignore((_539092==1->ignore(\+ \+ (flag(eval_num, _567420, _567420+1), (retval(fail)\=@=retval(fail), nonvar(_537978)->indentq(0, _567420, <--, [e, _537978]);indentq(0, _567420, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567420, _567420+1), (retval(fail)\=@=retval(fail), nonvar(_537978)->indentq(0, _567420, <--, [e, _537978]);indentq(0, _567420, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] _539092==1
   <span class="ansi1 ansi31"
>Fail: </span>(327) [system] _539092==1
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] setup_call_cleanup('$notrace'(_652234, _652236), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567420, _567420+1), (retval(fail)\=@=retval(fail), nonvar(_537978)->indentq(0, _567420, <--, [e, _537978]);indentq(0, _567420, <--, [e, retval(fail)])))))))), '$restore_trace'(_652234, _652236))
^  <span class="ansi1 ansi32"
>Call: </span>(329) [system] sig_atomic(system:'$notrace'(_652234, _652236))
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567420, _567420+1), (retval(fail)\=@=retval(fail), nonvar(_537978)->indentq(0, _567420, <--, [e, _537978]);indentq(0, _567420, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] ignore(user:(_539092==1->ignore(\+ \+ (flag(eval_num, _567420, _567420+1), (retval(fail)\=@=retval(fail), nonvar(_537978)->indentq(0, _567420, <--, [e, _537978]);indentq(0, _567420, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567420, _567420+1), (retval(fail)\=@=retval(fail), nonvar(_537978)->indentq(0, _567420, <--, [e, _537978]);indentq(0, _567420, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(323) [system] call_cleanup(user:((call(eval_20(=, _507046), 499, '&self', [let, a, b, 'never-happens'], _537978)*->nb_setarg(1, retval(fail), _537978);fail, trace, call(eval_20(=, _507046), 499, '&self', [let, a, b, 'never-happens'], _537978)), ignore(notrace((\+_537978\=_539222, nb_setarg(1, retval(fail), _537978))))), user:ignore((_539092==1->ignore(\+ \+ (flag(eval_num, _567420, _567420+1), (retval(fail)\=@=retval(fail), nonvar(_537978)->indentq(0, _567420, <--, [e, _537978]);indentq(0, _567420, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567420, _567420+1), (retval(fail)\=@=retval(fail), nonvar(_537978)->indentq(0, _567420, <--, [e, _537978]);indentq(0, _567420, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(322) [user] trace_eval(eval_20(=, _507046), e, 499, '&self', [let, a, b, 'never-happens'], _537978)
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] eval_args(=, _507046, 500, '&self', [let, a, b, 'never-happens'], _339036)
^  <span class="ansi1 ansi31"
>Fail: </span>(310) [system] call(user:once, user:if_or_else(eval(=, _337362, 495, '&self', [let, a, b, 'never-happens'], _339036), call(eval, [let, a, b, 'never-happens'], _339036)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(312) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] setup_call_cleanup('$notrace'(_663696, _663698), once(rtrace:retract(t_l:tracer_reset(_663686))), '$restore_trace'(_663696, _663698))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] sig_atomic(system:'$notrace'(_663696, _663698))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [rtrace] tAt(false, 271, 271, false)
; 
; EVAL TEST
; took 4.92 seconds.

!(assertEqual &m (let* (($a (collapse (get-atoms &self))) ($x (cdr-atom $a)) ($y (cdr-atom $x))) (car-atom $y)))

<span class="ansi31"
>(loonit_failureR  (equal_enough_for_test  (&m) ((: __g (-> Number)))))
</span>
Deterministic: ((Error  (got  (&m)) (expected  ((: __g (-> Number))))))
;;; NOTE: now the first atom, which was a space, is removed from `&m`,
;;; because we load modules only once, and we collect atoms-spaces to
;;; prevent duplication
<span class="ansi38-013099040"
>!(assertEqual (== (let* (($x (collapse (get-atoms &m))) ($y (car-atom $x))) (get-type $y)) (get-type &self)) False)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.12"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.12</h3>

(failed  once (if_or_else  (eval  = $_337592 494 &self (let a b never-happens) $_339266) (call  eval (let a b never-happens) $_339266)))


(on_mettalog_error  (failed  once (if_or_else  (eval  = $_337592 494 &self (let a b never-happens) $_339266) (call  eval (let a b never-happens) $_339266))))

^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] call(user:once, user:if_or_else(eval(=, _337592, 494, '&self', [let, a, b, 'never-happens'], _339266), call(eval, [let, a, b, 'never-happens'], _339266)))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] once(user:if_or_else(eval(=, _337592, 494, '&self', [let, a, b, 'never-happens'], _339266), call(eval, [let, a, b, 'never-happens'], _339266)))
   <span class="ansi1 ansi32"
>Call: </span>(324) [user] if_or_else(eval(=, _337592, 494, '&self', [let, a, b, 'never-happens'], _339266), call(eval, [let, a, b, 'never-happens'], _339266))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] eval(=, _337592, 494, '&self', [let, a, b, 'never-happens'], _339266)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] catch_metta_return(eval_args(=, _337592, 494, '&self', [let, a, b, 'never-happens'], _339266), _339266)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] eval_args(=, _337592, 494, '&self', [let, a, b, 'never-happens'], _339266)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(330) [system] setup_call_cleanup('$notrace'(_347676, _347678), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_347676, _347678))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [system] sig_atomic(system:'$notrace'(_347676, _347678))
^  <span class="ansi1 ansi32"
>Call: </span>(330) [system] setup_call_cleanup('$notrace'(_349764, _349766), once(user:nonvar(_339266)), '$restore_trace'(_349764, _349766))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [system] sig_atomic(system:'$notrace'(_349764, _349766))
^  <span class="ansi1 ansi32"
>Call: </span>(330) [system] setup_call_cleanup('$notrace'(_351852, _351854), once(user:nonvar(_339266)), '$restore_trace'(_351852, _351854))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [system] sig_atomic(system:'$notrace'(_351852, _351854))
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(329) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(331) [system] setup_call_cleanup('$notrace'(_359008, _359010), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_359008, _359010))
^  <span class="ansi1 ansi32"
>Call: </span>(332) [system] sig_atomic(system:'$notrace'(_359008, _359010))
^  <span class="ansi1 ansi31"
>Fail: </span>(329) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] eval_00(=, _337592, 494, '&self', [let, a, b, 'never-happens'], _339266)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(332) [system] setup_call_cleanup('$notrace'(_364152, _364154), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_364152, _364154))
^  <span class="ansi1 ansi32"
>Call: </span>(333) [system] sig_atomic(system:'$notrace'(_364152, _364154))
^  <span class="ansi1 ansi31"
>Fail: </span>(330) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] eval_01(=, _337592, 494, '&self', [let, a, b, 'never-happens'], _339266)
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] if_t((494<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(333) [system] 494<1
   <span class="ansi1 ansi31"
>Fail: </span>(333) [system] 494<1
^  <span class="ansi1 ansi32"
>Exit: </span>(331) [user] if_t((494<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(332) [system] setup_call_cleanup('$notrace'(_372388, _372390), once(user:(_372364 is 494-1, copy_term([let, a, b, 'never-happens'], _372378))), '$restore_trace'(_372388, _372390))
^  <span class="ansi1 ansi32"
>Call: </span>(333) [system] sig_atomic(system:'$notrace'(_372388, _372390))
^  <span class="ansi1 ansi32"
>Exit: </span>(332) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(493 is 494-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] trace_eval(eval_20(=, _337592), e, 493, '&self', [let, a, b, 'never-happens'], _375498)
^  <span class="ansi1 ansi32"
>Call: </span>(332) [user] must_det_ll((notrace((flag(eval_num, _376552, _376552+1), _376570 is _376552 mod 500, _376588 is 99-493 mod 100, _376612=_376614, option_else('trace-length', _376626, 500), option_else('trace-depth', _376634, 30))), quietly(if_t((nop(stop_rtrace), _376570>_376626), (set_debug(eval, false), _376690 is _376626+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376690])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_376742)))))
^  <span class="ansi1 ansi32"
>Call: </span>(333) [user] once(user:(notrace((flag(eval_num, _376552, _376552+1), _376570 is _376552 mod 500, _376588 is 99-493 mod 100, _376612=_376614, option_else('trace-length', _376626, 500), option_else('trace-depth', _376634, 30))), quietly(if_t((nop(stop_rtrace), _376570>_376626), (set_debug(eval, false), _376690 is _376626+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376690])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_376742)))))
^  <span class="ansi1 ansi32"
>Call: </span>(336) [system] setup_call_cleanup('$notrace'(_378788, _378790), once(user:(flag(eval_num, _376552, _376552+1), _376570 is _376552 mod 500, _376588 is 99-493 mod 100, _376612=_376614, option_else('trace-length', _376626, 500), option_else('trace-depth', _376634, 30))), '$restore_trace'(_378788, _378790))
^  <span class="ansi1 ansi32"
>Call: </span>(337) [system] sig_atomic(system:'$notrace'(_378788, _378790))
^  <span class="ansi1 ansi32"
>Exit: </span>(336) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2078, 2078+1), 78 is 2078 mod 500, 6 is 99-493 mod 100, _376612=_376612, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(336) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _376690 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376690])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(336) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _376690 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376690])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(335) [user] nop(notrace(no_repeats_var(_376742)))
   <span class="ansi1 ansi32"
>Exit: </span>(335) [user] nop(notrace(no_repeats_var(_376742)))
^  <span class="ansi1 ansi32"
>Exit: </span>(333) [system] once(user:(notrace((flag(eval_num, 2078, 2078+1), 78 is 2078 mod 500, 6 is 99-493 mod 100, _376612=_376612, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _376690 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376690])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_376742)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(332) [user] must_det_ll(user:(notrace((flag(eval_num, 2078, 2078+1), 78 is 2078 mod 500, 6 is 99-493 mod 100, _376612=_376612, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _376690 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376690])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_376742)))))
   <span class="ansi1 ansi32"
>Call: </span>(332) [occurs] occurs:sub_term(_388440, e)
   <span class="ansi1 ansi32"
>Exit: </span>(332) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(332) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(333) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(333) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(332) [occurs] occurs:sub_term(_388440, e)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] _395546=e
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(332) [user] if_trace((eval;e), (_376612=1, indentq(6, 78, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(334) [system] setup_call_cleanup('$notrace'(_398686, _398688), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _376612=1, indentq(6, 78, -->, [e, [let, a, b, 'never-happens']]))), _398644, fbug((_398644-->if_trace((eval;e), (_376612=1, indentq(6, 78, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_398686, _398688))
^  <span class="ansi1 ansi32"
>Call: </span>(335) [system] sig_atomic(system:'$notrace'(_398686, _398688))
^  <span class="ansi1 ansi32"
>Exit: </span>(334) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _376612=1, indentq(6, 78, -->, [e, [let, a, b, 'never-happens']]))), _398644, fbug((_398644-->if_trace((eval;e), (_376612=1, indentq(6, 78, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(332) [user] if_trace((eval;e), (_376612=1, indentq(6, 78, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] _402882=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] _404920=(\+ \+ (flag(eval_num, _404940, _404940+1), (retval(fail)\=@=retval(fail), nonvar(_375498)->indentq(6, _404940, <--, [e, _375498]);indentq(6, _404940, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] (\+ \+ (flag(eval_num, _404940, _404940+1), (retval(fail)\=@=retval(fail), nonvar(_375498)->indentq(6, _404940, <--, [e, _375498]);indentq(6, _404940, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _404940, _404940+1), (retval(fail)\=@=retval(fail), nonvar(_375498)->indentq(6, _404940, <--, [e, _375498]);indentq(6, _404940, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(332) [user] call_cleanup(((call(eval_20(=, _337592), 493, '&self', [let, a, b, 'never-happens'], _375498)*->nb_setarg(1, retval(fail), _375498);fail, trace, call(eval_20(=, _337592), 493, '&self', [let, a, b, 'never-happens'], _375498)), ignore(notrace((\+_375498\=_376742, nb_setarg(1, retval(fail), _375498))))), ignore((_376612==1->ignore(\+ \+ (flag(eval_num, _404940, _404940+1), (retval(fail)\=@=retval(fail), nonvar(_375498)->indentq(6, _404940, <--, [e, _375498]);indentq(6, _404940, <--, [e, retval(fail)]))));notrace(ignore(if_t(6<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404940, _404940+1), (retval(fail)\=@=retval(fail), nonvar(_375498)->indentq(6, _404940, <--, [e, _375498]);indentq(6, _404940, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(334) [user] eval_20(=, _337592, 493, '&self', [let, a, b, 'never-happens'], _375498)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(336) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(338) [system] setup_call_cleanup('$notrace'(_412328, _412330), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_412328, _412330))
^  <span class="ansi1 ansi32"
>Call: </span>(339) [system] sig_atomic(system:'$notrace'(_412328, _412330))
^  <span class="ansi1 ansi31"
>Fail: </span>(336) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(336) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(336) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(337) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] once(expand_eval([let, a, b, 'never-happens'], _434672))
^  <span class="ansi1 ansi32"
>Call: </span>(336) [user] expand_eval([let, a, b, 'never-happens'], _434672)
   <span class="ansi1 ansi32"
>Call: </span>(337) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(337) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(337) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(337) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(337) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _440772)
   <span class="ansi1 ansi32"
>Call: </span>(338) [apply] apply:maplist_([a, b, 'never-happens'], _440772, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(339) [user] expand_eval(a, _442828)
   <span class="ansi1 ansi32"
>Call: </span>(340) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(340) [system] a=_442828
   <span class="ansi1 ansi32"
>Exit: </span>(340) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(339) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(339) [apply] apply:maplist_([b, 'never-happens'], _442830, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(340) [user] expand_eval(b, _448930)
   <span class="ansi1 ansi32"
>Call: </span>(341) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(341) [system] b=_448930
   <span class="ansi1 ansi32"
>Exit: </span>(341) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(340) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(340) [apply] apply:maplist_(['never-happens'], _448932, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(341) [user] expand_eval('never-happens', _455032)
   <span class="ansi1 ansi32"
>Call: </span>(342) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(342) [system] 'never-happens'=_455032
   <span class="ansi1 ansi32"
>Exit: </span>(342) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(341) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(341) [apply] apply:maplist_([], _455034, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(341) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(340) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(339) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(338) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(337) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(336) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(335) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] possible_type('&self', a, _472324)
^  <span class="ansi1 ansi32"
>Exit: </span>(335) [user] possible_type('&self', a, _472324)
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] eval_args(=, _472324, 493, '&self', b, _474366)
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(337) [system] setup_call_cleanup('$notrace'(_476424, _476426), once(user:self_eval(b)), '$restore_trace'(_476424, _476426))
^  <span class="ansi1 ansi32"
>Call: </span>(338) [system] sig_atomic(system:'$notrace'(_476424, _476426))
^  <span class="ansi1 ansi32"
>Exit: </span>(337) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] _474366=b
   <span class="ansi1 ansi32"
>Exit: </span>(336) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(335) [user] eval_args(=, _472324, 493, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(334) [user] eval_20(=, _337592, 493, '&self', [let, a, b, 'never-happens'], _375498)
   <span class="ansi1 ansi32"
>Call: </span>(334) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(334) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(334) [user] ignore((_376612==1->ignore(\+ \+ (flag(eval_num, _404940, _404940+1), (retval(fail)\=@=retval(fail), nonvar(_375498)->indentq(6, _404940, <--, [e, _375498]);indentq(6, _404940, <--, [e, retval(fail)]))));notrace(ignore(if_t(6<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404940, _404940+1), (retval(fail)\=@=retval(fail), nonvar(_375498)->indentq(6, _404940, <--, [e, _375498]);indentq(6, _404940, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] _376612==1
   <span class="ansi1 ansi31"
>Fail: </span>(336) [system] _376612==1
^  <span class="ansi1 ansi32"
>Call: </span>(337) [system] setup_call_cleanup('$notrace'(_489754, _489756), once(user:ignore(if_t(6<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404940, _404940+1), (retval(fail)\=@=retval(fail), nonvar(_375498)->indentq(6, _404940, <--, [e, _375498]);indentq(6, _404940, <--, [e, retval(fail)])))))))), '$restore_trace'(_489754, _489756))
^  <span class="ansi1 ansi32"
>Call: </span>(338) [system] sig_atomic(system:'$notrace'(_489754, _489756))
^  <span class="ansi1 ansi32"
>Exit: </span>(337) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(6<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404940, _404940+1), (retval(fail)\=@=retval(fail), nonvar(_375498)->indentq(6, _404940, <--, [e, _375498]);indentq(6, _404940, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(334) [system] ignore(user:(_376612==1->ignore(\+ \+ (flag(eval_num, _404940, _404940+1), (retval(fail)\=@=retval(fail), nonvar(_375498)->indentq(6, _404940, <--, [e, _375498]);indentq(6, _404940, <--, [e, retval(fail)]))));notrace(ignore(if_t(6<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404940, _404940+1), (retval(fail)\=@=retval(fail), nonvar(_375498)->indentq(6, _404940, <--, [e, _375498]);indentq(6, _404940, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(332) [system] call_cleanup(user:((call(eval_20(=, _337592), 493, '&self', [let, a, b, 'never-happens'], _375498)*->nb_setarg(1, retval(fail), _375498);fail, trace, call(eval_20(=, _337592), 493, '&self', [let, a, b, 'never-happens'], _375498)), ignore(notrace((\+_375498\=_376742, nb_setarg(1, retval(fail), _375498))))), user:ignore((_376612==1->ignore(\+ \+ (flag(eval_num, _404940, _404940+1), (retval(fail)\=@=retval(fail), nonvar(_375498)->indentq(6, _404940, <--, [e, _375498]);indentq(6, _404940, <--, [e, retval(fail)]))));notrace(ignore(if_t(6<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404940, _404940+1), (retval(fail)\=@=retval(fail), nonvar(_375498)->indentq(6, _404940, <--, [e, _375498]);indentq(6, _404940, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(331) [user] trace_eval(eval_20(=, _337592), e, 493, '&self', [let, a, b, 'never-happens'], _375498)
^  <span class="ansi1 ansi31"
>Fail: </span>(328) [user] eval_args(=, _337592, 494, '&self', [let, a, b, 'never-happens'], _339266)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] call(eval, [let, a, b, 'never-happens'], _339266)
   <span class="ansi1 ansi32"
>Call: </span>(326) [user] eval([let, a, b, 'never-happens'], _339266)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] current_self(_499162)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] nb_current(self_space, _499162)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(327) [user] eval('&self', [let, a, b, 'never-happens'], _339266)
   <span class="ansi1 ansi32"
>Call: </span>(328) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _339266)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] catch_metta_return(eval_args(=, _507276, 500, '&self', [let, a, b, 'never-happens'], _339266), _339266)
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] eval_args(=, _507276, 500, '&self', [let, a, b, 'never-happens'], _339266)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(333) [system] setup_call_cleanup('$notrace'(_510386, _510388), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_510386, _510388))
^  <span class="ansi1 ansi32"
>Call: </span>(334) [system] sig_atomic(system:'$notrace'(_510386, _510388))
^  <span class="ansi1 ansi32"
>Call: </span>(333) [system] setup_call_cleanup('$notrace'(_512474, _512476), once(user:nonvar(_339266)), '$restore_trace'(_512474, _512476))
^  <span class="ansi1 ansi32"
>Call: </span>(334) [system] sig_atomic(system:'$notrace'(_512474, _512476))
^  <span class="ansi1 ansi32"
>Call: </span>(333) [system] setup_call_cleanup('$notrace'(_514562, _514564), once(user:nonvar(_339266)), '$restore_trace'(_514562, _514564))
^  <span class="ansi1 ansi32"
>Call: </span>(334) [system] sig_atomic(system:'$notrace'(_514562, _514564))
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(332) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(334) [system] setup_call_cleanup('$notrace'(_521718, _521720), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_521718, _521720))
^  <span class="ansi1 ansi32"
>Call: </span>(335) [system] sig_atomic(system:'$notrace'(_521718, _521720))
^  <span class="ansi1 ansi31"
>Fail: </span>(332) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(332) [user] eval_00(=, _507276, 500, '&self', [let, a, b, 'never-happens'], _339266)
^  <span class="ansi1 ansi32"
>Call: </span>(333) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(335) [system] setup_call_cleanup('$notrace'(_526862, _526864), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_526862, _526864))
^  <span class="ansi1 ansi32"
>Call: </span>(336) [system] sig_atomic(system:'$notrace'(_526862, _526864))
^  <span class="ansi1 ansi31"
>Fail: </span>(333) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(333) [user] eval_01(=, _507276, 500, '&self', [let, a, b, 'never-happens'], _339266)
^  <span class="ansi1 ansi32"
>Call: </span>(334) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(336) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(334) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(335) [system] setup_call_cleanup('$notrace'(_535098, _535100), once(user:(_535074 is 500-1, copy_term([let, a, b, 'never-happens'], _535088))), '$restore_trace'(_535098, _535100))
^  <span class="ansi1 ansi32"
>Call: </span>(336) [system] sig_atomic(system:'$notrace'(_535098, _535100))
^  <span class="ansi1 ansi32"
>Exit: </span>(335) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(334) [user] trace_eval(eval_20(=, _507276), e, 499, '&self', [let, a, b, 'never-happens'], _538208)
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] must_det_ll((notrace((flag(eval_num, _539262, _539262+1), _539280 is _539262 mod 500, _539298 is 99-499 mod 100, _539322=_539324, option_else('trace-length', _539336, 500), option_else('trace-depth', _539344, 30))), quietly(if_t((nop(stop_rtrace), _539280>_539336), (set_debug(eval, false), _539400 is _539336+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539400])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_539452)))))
^  <span class="ansi1 ansi32"
>Call: </span>(336) [user] once(user:(notrace((flag(eval_num, _539262, _539262+1), _539280 is _539262 mod 500, _539298 is 99-499 mod 100, _539322=_539324, option_else('trace-length', _539336, 500), option_else('trace-depth', _539344, 30))), quietly(if_t((nop(stop_rtrace), _539280>_539336), (set_debug(eval, false), _539400 is _539336+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539400])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_539452)))))
^  <span class="ansi1 ansi32"
>Call: </span>(339) [system] setup_call_cleanup('$notrace'(_541498, _541500), once(user:(flag(eval_num, _539262, _539262+1), _539280 is _539262 mod 500, _539298 is 99-499 mod 100, _539322=_539324, option_else('trace-length', _539336, 500), option_else('trace-depth', _539344, 30))), '$restore_trace'(_541498, _541500))
^  <span class="ansi1 ansi32"
>Call: </span>(340) [system] sig_atomic(system:'$notrace'(_541498, _541500))
^  <span class="ansi1 ansi32"
>Exit: </span>(339) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2079, 2079+1), 79 is 2079 mod 500, 0 is 99-499 mod 100, _539322=_539322, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(339) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _539400 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539400])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(339) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _539400 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539400])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(338) [user] nop(notrace(no_repeats_var(_539452)))
   <span class="ansi1 ansi32"
>Exit: </span>(338) [user] nop(notrace(no_repeats_var(_539452)))
^  <span class="ansi1 ansi32"
>Exit: </span>(336) [system] once(user:(notrace((flag(eval_num, 2079, 2079+1), 79 is 2079 mod 500, 0 is 99-499 mod 100, _539322=_539322, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _539400 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539400])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_539452)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(335) [user] must_det_ll(user:(notrace((flag(eval_num, 2079, 2079+1), 79 is 2079 mod 500, 0 is 99-499 mod 100, _539322=_539322, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _539400 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539400])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_539452)))))
   <span class="ansi1 ansi32"
>Call: </span>(335) [occurs] occurs:sub_term(_551150, e)
   <span class="ansi1 ansi32"
>Exit: </span>(335) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(335) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(336) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(335) [occurs] occurs:sub_term(_551150, e)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] _558256=e
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] if_trace((eval;e), (_539322=1, indentq(0, 79, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(337) [system] setup_call_cleanup('$notrace'(_561396, _561398), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _539322=1, indentq(0, 79, -->, [e, [let, a, b, 'never-happens']]))), _561354, fbug((_561354-->if_trace((eval;e), (_539322=1, indentq(0, 79, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_561396, _561398))
^  <span class="ansi1 ansi32"
>Call: </span>(338) [system] sig_atomic(system:'$notrace'(_561396, _561398))
^  <span class="ansi1 ansi32"
>Exit: </span>(337) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _539322=1, indentq(0, 79, -->, [e, [let, a, b, 'never-happens']]))), _561354, fbug((_561354-->if_trace((eval;e), (_539322=1, indentq(0, 79, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(335) [user] if_trace((eval;e), (_539322=1, indentq(0, 79, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] _565592=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] _567630=(\+ \+ (flag(eval_num, _567650, _567650+1), (retval(fail)\=@=retval(fail), nonvar(_538208)->indentq(0, _567650, <--, [e, _538208]);indentq(0, _567650, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] (\+ \+ (flag(eval_num, _567650, _567650+1), (retval(fail)\=@=retval(fail), nonvar(_538208)->indentq(0, _567650, <--, [e, _538208]);indentq(0, _567650, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _567650, _567650+1), (retval(fail)\=@=retval(fail), nonvar(_538208)->indentq(0, _567650, <--, [e, _538208]);indentq(0, _567650, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] call_cleanup(((call(eval_20(=, _507276), 499, '&self', [let, a, b, 'never-happens'], _538208)*->nb_setarg(1, retval(fail), _538208);fail, trace, call(eval_20(=, _507276), 499, '&self', [let, a, b, 'never-happens'], _538208)), ignore(notrace((\+_538208\=_539452, nb_setarg(1, retval(fail), _538208))))), ignore((_539322==1->ignore(\+ \+ (flag(eval_num, _567650, _567650+1), (retval(fail)\=@=retval(fail), nonvar(_538208)->indentq(0, _567650, <--, [e, _538208]);indentq(0, _567650, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567650, _567650+1), (retval(fail)\=@=retval(fail), nonvar(_538208)->indentq(0, _567650, <--, [e, _538208]);indentq(0, _567650, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(337) [user] eval_20(=, _507276, 499, '&self', [let, a, b, 'never-happens'], _538208)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(338) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(339) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(341) [system] setup_call_cleanup('$notrace'(_575038, _575040), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_575038, _575040))
^  <span class="ansi1 ansi32"
>Call: </span>(342) [system] sig_atomic(system:'$notrace'(_575038, _575040))
^  <span class="ansi1 ansi31"
>Fail: </span>(339) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(339) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(339) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(339) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(340) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(338) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(338) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(338) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(338) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(338) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(338) [user] once(expand_eval([let, a, b, 'never-happens'], _597382))
^  <span class="ansi1 ansi32"
>Call: </span>(339) [user] expand_eval([let, a, b, 'never-happens'], _597382)
   <span class="ansi1 ansi32"
>Call: </span>(340) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(340) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(340) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(340) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(340) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _603482)
   <span class="ansi1 ansi32"
>Call: </span>(341) [apply] apply:maplist_([a, b, 'never-happens'], _603482, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(342) [user] expand_eval(a, _605538)
   <span class="ansi1 ansi32"
>Call: </span>(343) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(343) [system] a=_605538
   <span class="ansi1 ansi32"
>Exit: </span>(343) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(342) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(342) [apply] apply:maplist_([b, 'never-happens'], _605540, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(343) [user] expand_eval(b, _611640)
   <span class="ansi1 ansi32"
>Call: </span>(344) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(344) [system] b=_611640
   <span class="ansi1 ansi32"
>Exit: </span>(344) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(343) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(343) [apply] apply:maplist_(['never-happens'], _611642, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(344) [user] expand_eval('never-happens', _617742)
   <span class="ansi1 ansi32"
>Call: </span>(345) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(345) [system] 'never-happens'=_617742
   <span class="ansi1 ansi32"
>Exit: </span>(345) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(344) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(344) [apply] apply:maplist_([], _617744, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(344) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(343) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(342) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(341) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(340) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(339) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(338) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(338) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(339) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(338) [user] possible_type('&self', a, _635034)
^  <span class="ansi1 ansi32"
>Exit: </span>(338) [user] possible_type('&self', a, _635034)
^  <span class="ansi1 ansi32"
>Call: </span>(338) [user] eval_args(=, _635034, 499, '&self', b, _637076)
   <span class="ansi1 ansi32"
>Call: </span>(339) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(340) [system] setup_call_cleanup('$notrace'(_639134, _639136), once(user:self_eval(b)), '$restore_trace'(_639134, _639136))
^  <span class="ansi1 ansi32"
>Call: </span>(341) [system] sig_atomic(system:'$notrace'(_639134, _639136))
^  <span class="ansi1 ansi32"
>Exit: </span>(340) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(339) [system] _637076=b
   <span class="ansi1 ansi32"
>Exit: </span>(339) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(338) [user] eval_args(=, _635034, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(337) [user] eval_20(=, _507276, 499, '&self', [let, a, b, 'never-happens'], _538208)
   <span class="ansi1 ansi32"
>Call: </span>(337) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(337) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(337) [user] ignore((_539322==1->ignore(\+ \+ (flag(eval_num, _567650, _567650+1), (retval(fail)\=@=retval(fail), nonvar(_538208)->indentq(0, _567650, <--, [e, _538208]);indentq(0, _567650, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567650, _567650+1), (retval(fail)\=@=retval(fail), nonvar(_538208)->indentq(0, _567650, <--, [e, _538208]);indentq(0, _567650, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(339) [system] _539322==1
   <span class="ansi1 ansi31"
>Fail: </span>(339) [system] _539322==1
^  <span class="ansi1 ansi32"
>Call: </span>(340) [system] setup_call_cleanup('$notrace'(_652464, _652466), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567650, _567650+1), (retval(fail)\=@=retval(fail), nonvar(_538208)->indentq(0, _567650, <--, [e, _538208]);indentq(0, _567650, <--, [e, retval(fail)])))))))), '$restore_trace'(_652464, _652466))
^  <span class="ansi1 ansi32"
>Call: </span>(341) [system] sig_atomic(system:'$notrace'(_652464, _652466))
^  <span class="ansi1 ansi32"
>Exit: </span>(340) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567650, _567650+1), (retval(fail)\=@=retval(fail), nonvar(_538208)->indentq(0, _567650, <--, [e, _538208]);indentq(0, _567650, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(337) [system] ignore(user:(_539322==1->ignore(\+ \+ (flag(eval_num, _567650, _567650+1), (retval(fail)\=@=retval(fail), nonvar(_538208)->indentq(0, _567650, <--, [e, _538208]);indentq(0, _567650, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567650, _567650+1), (retval(fail)\=@=retval(fail), nonvar(_538208)->indentq(0, _567650, <--, [e, _538208]);indentq(0, _567650, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(335) [system] call_cleanup(user:((call(eval_20(=, _507276), 499, '&self', [let, a, b, 'never-happens'], _538208)*->nb_setarg(1, retval(fail), _538208);fail, trace, call(eval_20(=, _507276), 499, '&self', [let, a, b, 'never-happens'], _538208)), ignore(notrace((\+_538208\=_539452, nb_setarg(1, retval(fail), _538208))))), user:ignore((_539322==1->ignore(\+ \+ (flag(eval_num, _567650, _567650+1), (retval(fail)\=@=retval(fail), nonvar(_538208)->indentq(0, _567650, <--, [e, _538208]);indentq(0, _567650, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567650, _567650+1), (retval(fail)\=@=retval(fail), nonvar(_538208)->indentq(0, _567650, <--, [e, _538208]);indentq(0, _567650, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(334) [user] trace_eval(eval_20(=, _507276), e, 499, '&self', [let, a, b, 'never-happens'], _538208)
^  <span class="ansi1 ansi31"
>Fail: </span>(331) [user] eval_args(=, _507276, 500, '&self', [let, a, b, 'never-happens'], _339266)
^  <span class="ansi1 ansi31"
>Fail: </span>(322) [system] call(user:once, user:if_or_else(eval(=, _337592, 494, '&self', [let, a, b, 'never-happens'], _339266), call(eval, [let, a, b, 'never-happens'], _339266)))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] setup_call_cleanup('$notrace'(_663926, _663928), once(rtrace:retract(t_l:tracer_reset(_663916))), '$restore_trace'(_663926, _663928))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] sig_atomic(system:'$notrace'(_663926, _663928))
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [rtrace] tAt(false, 271, 271, false)
<span class="ansi1 ansi90"
>Info: Processing progress: 100% </span><span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta progress.
</span>; 
; EVAL TEST
; took 4.61 seconds.

!(assertEqual (== (let* (($x (collapse (get-atoms &m))) ($y (car-atom $x))) (get-type $y)) (get-type &self)) False)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (False) (False)))
</span>
Deterministic: ()
;;; Let's check that `if` from stdlib is not duplicated and gives only one result
<span class="ansi38-013099040"
>!(assertEqual (if (> 1 2) 1 2) 2)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.13"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.13</h3>
; 
; EVAL TEST
; took 0.000297 secs. (297.33 microseconds) 

!(assertEqual (if (> 1 2) 1 2) 2)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (2) (2)))
</span>
Deterministic: ()
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Let's import one more module into `&self` with a diamond dependence
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleB.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta is 288 bytes (7 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta is 291 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Numer))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (g $x) (+ $x 10)))
</span>
Last Result(2): ()
;;; `g` from moduleC imported via two paths as well as `f`, which uses `g`,
;;; are not duplicated and produce deterministic results
<span class="ansi38-013099040"
>!(assertEqual (g 2) 102)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.14"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.14</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.11 milliseconds) 

!(assertEqual (g 2) 102)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102) (102)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (f 2) 103)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.15"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.15</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.46 milliseconds) 

!(assertEqual (f 2) 103)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (103) (103)))
</span>
Deterministic: ()
;;; Function declared in different imported modules will still produce
;;; non-deterministic results
<span class="ansi38-013099040"
>!(assertEqualToResult (dup 2) (12 102))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.16"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.16</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.09 milliseconds) 

!(assertEqualToResult (dup 2) (12 102))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102 12) (12 102)))
</span>
Deterministic: ()
;;; Let's import f1_moduleB.metta once more using a different path.
;;; Such import should be ignored and thus f, g and dup should remain
;;; unchanged.
<span class="ansi38-013099040"
>!(import! &self ../hyperon-experimental_scripts/f1_moduleB.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta is 288 bytes (7 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta is 291 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Numer))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (g $x) (+ $x 10)))
</span>
Last Result(2): ()
<span class="ansi38-013099040"
>!(assertEqual (g 2) 102)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.17"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.17</h3>
; 
; EVAL TEST
; took 0.000996 secs. (996.25 microseconds) 

!(assertEqual (g 2) 102)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102) (102)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (f 2) 103)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.18"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.18</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.42 milliseconds) 

!(assertEqual (f 2) 103)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (103) (103)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqualToResult (dup 2) (12 102))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.19"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.19</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.04 milliseconds) 

!(assertEqualToResult (dup 2) (12 102))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102 12) (12 102)))
</span>
Deterministic: ()<span class="ansi32"
>
% 44,243,851 inferences, 10.836 CPU in 10.857 seconds (100% CPU, 4083057 Lips)
</span>P;HTML|
;                       (= /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta  0)
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 17
</span><span class="ansi31"
>Failures: 2
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
P;HTML|
;         (is_cmd_option  execute halt --halt=true true)
P;HTML|
;          (set_option_value  halt true)
P;HTML|
;          (is_cmd_option  execute stdin --stdin=tty tty)
P;HTML|
;          (set_option_value  stdin tty)
P;HTML|
;          (is_cmd_option  execute stdout --stdout=tty tty)
P;HTML|
;           (set_option_value  stdout tty)
P;HTML|
;          (is_cmd_option  execute stderr --stderr=tty tty)
P;HTML|
;           (set_option_value  stderr tty)
P;HTML|
;         (set_option_value  compat false)
P;HTML|
;         (set_option_value  compatio false)
P;HTML|
;         (set_option_value  src_indents false)
P;HTML|
;         (set_option_value  devel false)
P;HTML|
;         (set_option_value  stack-max 500)
P;HTML|
;         (set_option_value  limit inf)
P;HTML|
;         (set_option_value  initial-result-count 10)
P;HTML|
;         (set_option_value  answer-format show)
P;HTML|
;         (set_option_value  repeats true)
P;HTML|
;         (set_option_value  time true)
P;HTML|
;         (set_option_value  synth-unit-tests false)
P;HTML|
;         (set_option_value  optimize true)
P;HTML|
;         (set_option_value  transpiler silent)
P;HTML|
;          (set_debug  transpiler false)
P;HTML|
;         (set_option_value  compile false)
P;HTML|
;         (set_option_value  tabling auto)
P;HTML|
;         (set_option_value  log false)
P;HTML|
;         (set_option_value  output ./)
P;HTML|
;         (set_option_value  exeout ./Sav.gitlab.MeTTaLog)
P;HTML|
;         (set_option_value  halt false)
P;HTML|
;         (set_option_value  trace-length 500)
P;HTML|
;         (set_option_value  trace-on-overtime 4.0)
P;HTML|
;          (set_debug  overtime 4.0)
P;HTML|
;         (set_option_value  trace-on-overflow 1000)
P;HTML|
;          (set_debug  overflow 1000)
P;HTML|
;         (set_option_value  trace-on-eval false)
P;HTML|
;          (set_debug  eval false)
P;HTML|
;         (set_option_value  trace-on-load silent)
P;HTML|
;          (set_debug  load silent)
P;HTML|
;          (set_debug  trace-on-load false)
P;HTML|
;         (set_option_value  trace-on-exec false)
P;HTML|
;          (set_debug  exec false)
P;HTML|
;         (set_option_value  trace-on-error non-type)
P;HTML|
;          (set_debug  error non-type)
P;HTML|
;         (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;         (set_option_value  trace-on-test true)
P;HTML|
;          (set_debug  test true)
P;HTML|
;         (set_option_value  repl-on-error true)
P;HTML|
;         (set_option_value  repl-on-fail false)
P;HTML|
;         (set_option_value  exit-on-fail false)
P;HTML|
;         (set_option_value  repl auto)
P;HTML|
;         (set_option_value  prolog false)
P;HTML|
;         (set_option_value  exec noskip)
P;HTML|
;         (set_option_value  maximum-result-count inf)
P;HTML|
;         (set_option_value  html false)
P;HTML|
;         (set_option_value  python true)
P;HTML|
;         (set_option_value  trace-on-test false)
P;HTML|
;          (set_debug  test false)
P;HTML|
;         (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;         (set_option_value  load show)
P;HTML|
;         (set_option_value  test true)
[()]
[((Error  (got  ((hyperon::space::DynSpace) (hyperon::space::DynSpace) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()))) (expected  ((hyperon::space::DynSpace)))))]
[()]
[()]
[()]
[()]
[()]
[()]
[((Error  (got  (&m)) (expected  ((: __g (-> Number))))))]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
P;HTML|
;         (maybe_halt  7)
<span class="ansi31"
>(in  (maybe_halt  7) (unwind  (halt  7)))
</span>
Script done on 2024-11-26 11:16:10+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat/' --timeout=40 --html --repl=false  --test "tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta" --halt=true\033[0m
