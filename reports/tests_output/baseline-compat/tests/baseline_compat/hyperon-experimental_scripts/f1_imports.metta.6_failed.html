<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi36 { color: #00aaaa; }
.ansi90 { color: #7f7f7f; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-11-23 13:32:03+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;           (set_option_value  compat false)

P;HTML|
;           (set_option_value  compatio false)

P;HTML|
;           (set_option_value  src_indents false)

P;HTML|
;         (set_option_value  devel false)

P;HTML|
;         (set_option_value  stack-max 500)

P;HTML|
;         (set_option_value  limit inf)

P;HTML|
;         (set_option_value  initial-result-count 10)

P;HTML|
;         (set_option_value  answer-format show)

P;HTML|
;         (set_option_value  repeats true)

P;HTML|
;         (set_option_value  time true)

P;HTML|
;         (set_option_value  synth-unit-tests false)

P;HTML|
;         (set_option_value  optimize true)

P;HTML|
;         (set_option_value  transpiler silent)

P;HTML|
;          (set_debug  transpiler false)

P;HTML|
;         (set_option_value  compile false)

P;HTML|
;         (set_option_value  tabling auto)

P;HTML|
;         (set_option_value  log false)

P;HTML|
;         (set_option_value  output ./)

P;HTML|
;         (set_option_value  exeout ./Sav.gitlab.MeTTaLog)

P;HTML|
;         (set_option_value  halt false)

P;HTML|
;         (set_option_value  trace-length 500)

P;HTML|
;         (set_option_value  trace-on-overtime 4.0)

P;HTML|
;          (set_debug  overtime 4.0)

P;HTML|
;         (set_option_value  trace-on-overflow 1000)

P;HTML|
;          (set_debug  overflow 1000)

P;HTML|
;         (set_option_value  trace-on-eval false)

P;HTML|
;          (set_debug  eval false)

P;HTML|
;         (set_option_value  trace-on-load silent)

P;HTML|
;          (set_debug  load silent)

P;HTML|
;          (set_debug  trace-on-load false)

P;HTML|
;         (set_option_value  trace-on-exec false)

P;HTML|
;          (set_debug  exec false)

P;HTML|
;         (set_option_value  trace-on-error non-type)

P;HTML|
;          (set_debug  error non-type)

P;HTML|
;         (set_option_value  trace-on-fail false)

P;HTML|
;          (set_debug  fail false)

P;HTML|
;         (set_option_value  trace-on-test true)

P;HTML|
;          (set_debug  test true)

P;HTML|
;         (set_option_value  repl-on-error true)

P;HTML|
;         (set_option_value  repl-on-fail false)

P;HTML|
;         (set_option_value  exit-on-fail false)

P;HTML|
;         (set_option_value  repl auto)

P;HTML|
;         (set_option_value  prolog false)

P;HTML|
;         (set_option_value  exec noskip)

P;HTML|
;         (set_option_value  maximum-result-count inf)

P;HTML|
;         (set_option_value  html false)

P;HTML|
;         (set_option_value  python true)

P;HTML|
;         (set_option_value  trace-on-test false)

P;HTML|
;         (set_debug  test false)

P;HTML|
;         (set_option_value  trace-on-fail false)

P;HTML|
;         (set_debug  fail false)

P;HTML|
;         (set_option_value  load show)

P;HTML|
;         (set_option_value  test false)
P;HTML|
;          (is_cmd_option  prescan halt --halt=true true)
P;HTML|
;          (set_option_value  halt true)
P;HTML|
;          (is_cmd_option  prescan stdin --stdin=tty tty)
P;HTML|
;           (set_option_value  stdin tty)
P;HTML|
;          (is_cmd_option  prescan stdout --stdout=tty tty)
P;HTML|
;           (set_option_value  stdout tty)
P;HTML|
;          (is_cmd_option  prescan stderr --stderr=tty tty)
P;HTML|
;           (set_option_value  stderr tty)
P;HTML|
;          (set_option_value  compat false)
P;HTML|
;          (set_option_value  compatio false)
P;HTML|
;          (set_option_value  src_indents false)
P;HTML|
;          (set_option_value  devel false)
P;HTML|
;          (set_option_value  stack-max 500)
P;HTML|
;          (set_option_value  limit inf)
P;HTML|
;          (set_option_value  initial-result-count 10)
P;HTML|
;          (set_option_value  answer-format show)
P;HTML|
;          (set_option_value  repeats true)
P;HTML|
;          (set_option_value  time true)
P;HTML|
;          (set_option_value  synth-unit-tests false)
P;HTML|
;          (set_option_value  optimize true)
P;HTML|
;          (set_option_value  transpiler silent)
P;HTML|
;          (set_debug  transpiler false)
P;HTML|
;          (set_option_value  compile false)
P;HTML|
;          (set_option_value  tabling auto)
P;HTML|
;          (set_option_value  log false)
P;HTML|
;          (set_option_value  output ./)
P;HTML|
;          (set_option_value  exeout ./Sav.gitlab.MeTTaLog)
P;HTML|
;          (set_option_value  halt false)
P;HTML|
;          (set_option_value  trace-length 500)
P;HTML|
;          (set_option_value  trace-on-overtime 4.0)
P;HTML|
;          (set_debug  overtime 4.0)
P;HTML|
;          (set_option_value  trace-on-overflow 1000)
P;HTML|
;          (set_debug  overflow 1000)
P;HTML|
;          (set_option_value  trace-on-eval false)
P;HTML|
;          (set_debug  eval false)
P;HTML|
;          (set_option_value  trace-on-load silent)
P;HTML|
;          (set_debug  load silent)
P;HTML|
;          (set_debug  trace-on-load false)
P;HTML|
;          (set_option_value  trace-on-exec false)
P;HTML|
;          (set_debug  exec false)
P;HTML|
;          (set_option_value  trace-on-error non-type)
P;HTML|
;          (set_debug  error non-type)
P;HTML|
;          (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;          (set_option_value  trace-on-test true)
P;HTML|
;          (set_debug  test true)
P;HTML|
;          (set_option_value  repl-on-error true)
P;HTML|
;          (set_option_value  repl-on-fail false)
P;HTML|
;          (set_option_value  exit-on-fail false)
P;HTML|
;          (set_option_value  repl auto)
P;HTML|
;          (set_option_value  prolog false)
P;HTML|
;          (set_option_value  exec noskip)
P;HTML|
;          (set_option_value  maximum-result-count inf)
P;HTML|
;          (set_option_value  html false)
P;HTML|
;          (set_option_value  python true)
P;HTML|
;         (set_option_value  trace-on-test false)
P;HTML|
;          (set_debug  test false)
P;HTML|
;         (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;         (set_option_value  load show)
P;HTML|
;         (set_option_value  test true)
P;HTML|
;        (is_cmd_option  execute python --python=enable enable)
P;HTML|
;         (set_option_value  python enable)
P;HTML|
;        (is_cmd_option  execute timeout --timeout=40 40)
P;HTML|
;         (set_option_value  timeout 40)
P;HTML|
;         (is_cmd_option  execute output --output=./reports/tests_output/baseline-compat/ ./reports/tests_output/baseline-compat/)
P;HTML|
;         (set_option_value  output ./reports/tests_output/baseline-compat/)
P;HTML|
;         (is_cmd_option  execute html --html true)
P;HTML|
;          (set_option_value  html true)
P;HTML|
;         (is_cmd_option  execute test --test true)
P;HTML|
;          (set_option_value  test true)

; (load_metta_file  &self tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta)
P;HTML|
;                       (track_load_into_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta)
P;HTML|
;                                        (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta)
P;HTML|
;                                         (= 1  "[hyperon::space::DynSpace]")
P;HTML|
;                                         (= 2  "[(Error (assertEqual ((let $x (get-atoms GroundingSpace-top) (get-type $x))) ((get-type GroundingSpace-top))) ")
P;HTML|
;                                         (= 2  "Expected: [(hyperon::space::DynSpace)]")
P;HTML|
;                                         (= 2  "Got: [(hyperon::space::DynSpace), (hyperon::space::DynSpace)]")
P;HTML|
;                                         (= 3  "Excessive result: (hyperon::space::DynSpace))]")
P;HTML|
;                                         (= 3  "0.05user 0.00system 0:00.05elapsed 96%CPU (0avgtext+0avgdata 30952maxresident)k")
P;HTML|
;                                         (= 3  "0inputs+0outputs (0major+3659minor)pagefaults 0swaps")
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta is 4.06K bytes (120 lines)
</span>P;HTML|
;                                        (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta)

;;; NOTE: This test won't work outside the test environment because it relies on
;;;  specific atoms in a specific order in the space, and loading the default environment's
;;;  init.metta will break the assumptions in this test
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Even at the very beginning of the main script `(get-atoms &self)`
;;; returns one atom, which wraps the space of stdlib.
;;; The type of this atom is the same as of `&self`
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;!(get-atoms &self)
;;;;!(get-type (get-atoms &self))
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>!(get-type &self)
</span>;; To unit test case:
<span class="ansi38-013099040"
>!(assertEqualToResult (get-type &self) (hyperon::space::DynSpace))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.01"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.01</h3>
; 
; EVAL TEST
; took 0.000233 secs. (233.40 microseconds) 

!(assertEqualToResult (get-type &self) (hyperon::space::DynSpace))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (hyperon::space::DynSpace) (hyperon::space::DynSpace)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual ((let $x (get-atoms &self) (get-type $x))) ((get-type &self)))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.02"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.02</h3>

(failed  once (if_or_else  (eval  = $_569314 495 &self (let a b never-happens) $_570988) (call  eval (let a b never-happens) $_570988)))


(on_mettalog_error  (failed  once (if_or_else  (eval  = $_569314 495 &self (let a b never-happens) $_570988) (call  eval (let a b never-happens) $_570988))))

^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] call(user:once, user:if_or_else(eval(=, _569314, 495, '&self', [let, a, b, 'never-happens'], _570988), call(eval, [let, a, b, 'never-happens'], _570988)))
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] once(user:if_or_else(eval(=, _569314, 495, '&self', [let, a, b, 'never-happens'], _570988), call(eval, [let, a, b, 'never-happens'], _570988)))
   <span class="ansi1 ansi32"
>Call: </span>(299) [user] if_or_else(eval(=, _569314, 495, '&self', [let, a, b, 'never-happens'], _570988), call(eval, [let, a, b, 'never-happens'], _570988))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] eval(=, _569314, 495, '&self', [let, a, b, 'never-happens'], _570988)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] catch_metta_return(eval_args(=, _569314, 495, '&self', [let, a, b, 'never-happens'], _570988), _570988)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_args(=, _569314, 495, '&self', [let, a, b, 'never-happens'], _570988)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_579398, _579400), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_579398, _579400))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_579398, _579400))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_581486, _581488), once(user:nonvar(_570988)), '$restore_trace'(_581486, _581488))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_581486, _581488))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_583574, _583576), once(user:nonvar(_570988)), '$restore_trace'(_583574, _583576))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_583574, _583576))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] setup_call_cleanup('$notrace'(_590730, _590732), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_590730, _590732))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] sig_atomic(system:'$notrace'(_590730, _590732))
^  <span class="ansi1 ansi31"
>Fail: </span>(304) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] eval_00(=, _569314, 495, '&self', [let, a, b, 'never-happens'], _570988)
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] setup_call_cleanup('$notrace'(_595874, _595876), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_595874, _595876))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] sig_atomic(system:'$notrace'(_595874, _595876))
^  <span class="ansi1 ansi31"
>Fail: </span>(305) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] eval_01(=, _569314, 495, '&self', [let, a, b, 'never-happens'], _570988)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] 495<1
   <span class="ansi1 ansi31"
>Fail: </span>(308) [system] 495<1
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] setup_call_cleanup('$notrace'(_604110, _604112), once(user:(_604086 is 495-1, copy_term([let, a, b, 'never-happens'], _604100))), '$restore_trace'(_604110, _604112))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] sig_atomic(system:'$notrace'(_604110, _604112))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(494 is 495-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] trace_eval(eval_20(=, _569314), e, 494, '&self', [let, a, b, 'never-happens'], _607220)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] must_det_ll((notrace((flag(eval_num, _608274, _608274+1), _608292 is _608274 mod 500, _608310 is 99-494 mod 100, _608334=_608336, option_else('trace-length', _608348, 500), option_else('trace-depth', _608356, 30))), quietly(if_t((nop(stop_rtrace), _608292>_608348), (set_debug(eval, false), _608412 is _608348+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608412])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_608464)))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] once(user:(notrace((flag(eval_num, _608274, _608274+1), _608292 is _608274 mod 500, _608310 is 99-494 mod 100, _608334=_608336, option_else('trace-length', _608348, 500), option_else('trace-depth', _608356, 30))), quietly(if_t((nop(stop_rtrace), _608292>_608348), (set_debug(eval, false), _608412 is _608348+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608412])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_608464)))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] setup_call_cleanup('$notrace'(_610510, _610512), once(user:(flag(eval_num, _608274, _608274+1), _608292 is _608274 mod 500, _608310 is 99-494 mod 100, _608334=_608336, option_else('trace-length', _608348, 500), option_else('trace-depth', _608356, 30))), '$restore_trace'(_610510, _610512))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] sig_atomic(system:'$notrace'(_610510, _610512))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2896, 2896+1), 396 is 2896 mod 500, 5 is 99-494 mod 100, _608334=_608334, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 396>500), (set_debug(eval, false), _608412 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608412])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 396>500), (set_debug(eval, false), _608412 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608412])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] nop(notrace(no_repeats_var(_608464)))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] nop(notrace(no_repeats_var(_608464)))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] once(user:(notrace((flag(eval_num, 2896, 2896+1), 396 is 2896 mod 500, 5 is 99-494 mod 100, _608334=_608334, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 396>500), (set_debug(eval, false), _608412 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608412])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_608464)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] must_det_ll(user:(notrace((flag(eval_num, 2896, 2896+1), 396 is 2896 mod 500, 5 is 99-494 mod 100, _608334=_608334, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 396>500), (set_debug(eval, false), _608412 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608412])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_608464)))))
   <span class="ansi1 ansi32"
>Call: </span>(307) [occurs] occurs:sub_term(_620162, e)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(307) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(308) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(307) [occurs] occurs:sub_term(_620162, e)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _627268=e
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] if_trace((eval;e), (_608334=1, indentq(5, 396, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_630408, _630410), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _608334=1, indentq(5, 396, -->, [e, [let, a, b, 'never-happens']]))), _630366, fbug((_630366-->if_trace((eval;e), (_608334=1, indentq(5, 396, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_630408, _630410))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_630408, _630410))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _608334=1, indentq(5, 396, -->, [e, [let, a, b, 'never-happens']]))), _630366, fbug((_630366-->if_trace((eval;e), (_608334=1, indentq(5, 396, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] if_trace((eval;e), (_608334=1, indentq(5, 396, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _634604=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _636642=(\+ \+ (flag(eval_num, _636662, _636662+1), (retval(fail)\=@=retval(fail), nonvar(_607220)->indentq(5, _636662, <--, [e, _607220]);indentq(5, _636662, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] (\+ \+ (flag(eval_num, _636662, _636662+1), (retval(fail)\=@=retval(fail), nonvar(_607220)->indentq(5, _636662, <--, [e, _607220]);indentq(5, _636662, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _636662, _636662+1), (retval(fail)\=@=retval(fail), nonvar(_607220)->indentq(5, _636662, <--, [e, _607220]);indentq(5, _636662, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] call_cleanup(((call(eval_20(=, _569314), 494, '&self', [let, a, b, 'never-happens'], _607220)*->nb_setarg(1, retval(fail), _607220);fail, trace, call(eval_20(=, _569314), 494, '&self', [let, a, b, 'never-happens'], _607220)), ignore(notrace((\+_607220\=_608464, nb_setarg(1, retval(fail), _607220))))), ignore((_608334==1->ignore(\+ \+ (flag(eval_num, _636662, _636662+1), (retval(fail)\=@=retval(fail), nonvar(_607220)->indentq(5, _636662, <--, [e, _607220]);indentq(5, _636662, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636662, _636662+1), (retval(fail)\=@=retval(fail), nonvar(_607220)->indentq(5, _636662, <--, [e, _607220]);indentq(5, _636662, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_20(=, _569314, 494, '&self', [let, a, b, 'never-happens'], _607220)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] setup_call_cleanup('$notrace'(_644050, _644052), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_644050, _644052))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(system:'$notrace'(_644050, _644052))
^  <span class="ansi1 ansi31"
>Fail: </span>(311) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(311) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] once(expand_eval([let, a, b, 'never-happens'], _666394))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] expand_eval([let, a, b, 'never-happens'], _666394)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _672494)
   <span class="ansi1 ansi32"
>Call: </span>(313) [apply] apply:maplist_([a, b, 'never-happens'], _672494, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] expand_eval(a, _674550)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] a=_674550
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(314) [apply] apply:maplist_([b, 'never-happens'], _674552, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] expand_eval(b, _680652)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] b=_680652
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(315) [apply] apply:maplist_(['never-happens'], _680654, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] expand_eval('never-happens', _686754)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] 'never-happens'=_686754
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(316) [apply] apply:maplist_([], _686756, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(314) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] possible_type('&self', a, _704046)
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] possible_type('&self', a, _704046)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] eval_args(=, _704046, 494, '&self', b, _706088)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_708146, _708148), once(user:self_eval(b)), '$restore_trace'(_708146, _708148))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_708146, _708148))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] _706088=b
   <span class="ansi1 ansi32"
>Exit: </span>(311) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] eval_args(=, _704046, 494, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] eval_20(=, _569314, 494, '&self', [let, a, b, 'never-happens'], _607220)
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(309) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] ignore((_608334==1->ignore(\+ \+ (flag(eval_num, _636662, _636662+1), (retval(fail)\=@=retval(fail), nonvar(_607220)->indentq(5, _636662, <--, [e, _607220]);indentq(5, _636662, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636662, _636662+1), (retval(fail)\=@=retval(fail), nonvar(_607220)->indentq(5, _636662, <--, [e, _607220]);indentq(5, _636662, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] _608334==1
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] _608334==1
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_721476, _721478), once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636662, _636662+1), (retval(fail)\=@=retval(fail), nonvar(_607220)->indentq(5, _636662, <--, [e, _607220]);indentq(5, _636662, <--, [e, retval(fail)])))))))), '$restore_trace'(_721476, _721478))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_721476, _721478))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636662, _636662+1), (retval(fail)\=@=retval(fail), nonvar(_607220)->indentq(5, _636662, <--, [e, _607220]);indentq(5, _636662, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] ignore(user:(_608334==1->ignore(\+ \+ (flag(eval_num, _636662, _636662+1), (retval(fail)\=@=retval(fail), nonvar(_607220)->indentq(5, _636662, <--, [e, _607220]);indentq(5, _636662, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636662, _636662+1), (retval(fail)\=@=retval(fail), nonvar(_607220)->indentq(5, _636662, <--, [e, _607220]);indentq(5, _636662, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(307) [system] call_cleanup(user:((call(eval_20(=, _569314), 494, '&self', [let, a, b, 'never-happens'], _607220)*->nb_setarg(1, retval(fail), _607220);fail, trace, call(eval_20(=, _569314), 494, '&self', [let, a, b, 'never-happens'], _607220)), ignore(notrace((\+_607220\=_608464, nb_setarg(1, retval(fail), _607220))))), user:ignore((_608334==1->ignore(\+ \+ (flag(eval_num, _636662, _636662+1), (retval(fail)\=@=retval(fail), nonvar(_607220)->indentq(5, _636662, <--, [e, _607220]);indentq(5, _636662, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636662, _636662+1), (retval(fail)\=@=retval(fail), nonvar(_607220)->indentq(5, _636662, <--, [e, _607220]);indentq(5, _636662, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(306) [user] trace_eval(eval_20(=, _569314), e, 494, '&self', [let, a, b, 'never-happens'], _607220)
^  <span class="ansi1 ansi31"
>Fail: </span>(303) [user] eval_args(=, _569314, 495, '&self', [let, a, b, 'never-happens'], _570988)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] call(eval, [let, a, b, 'never-happens'], _570988)
   <span class="ansi1 ansi32"
>Call: </span>(301) [user] eval([let, a, b, 'never-happens'], _570988)
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] current_self(_730884)
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] nb_current(self_space, _730884)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(302) [user] eval('&self', [let, a, b, 'never-happens'], _570988)
   <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _570988)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] catch_metta_return(eval_args(=, _738998, 500, '&self', [let, a, b, 'never-happens'], _570988), _570988)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_args(=, _738998, 500, '&self', [let, a, b, 'never-happens'], _570988)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_742108, _742110), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_742108, _742110))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_742108, _742110))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_744196, _744198), once(user:nonvar(_570988)), '$restore_trace'(_744196, _744198))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_744196, _744198))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_746284, _746286), once(user:nonvar(_570988)), '$restore_trace'(_746284, _746286))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_746284, _746286))
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_753440, _753442), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_753440, _753442))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_753440, _753442))
^  <span class="ansi1 ansi31"
>Fail: </span>(307) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] eval_00(=, _738998, 500, '&self', [let, a, b, 'never-happens'], _570988)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_758584, _758586), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_758584, _758586))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_758584, _758586))
^  <span class="ansi1 ansi31"
>Fail: </span>(308) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] eval_01(=, _738998, 500, '&self', [let, a, b, 'never-happens'], _570988)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_766820, _766822), once(user:(_766796 is 500-1, copy_term([let, a, b, 'never-happens'], _766810))), '$restore_trace'(_766820, _766822))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_766820, _766822))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] trace_eval(eval_20(=, _738998), e, 499, '&self', [let, a, b, 'never-happens'], _769930)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] must_det_ll((notrace((flag(eval_num, _770984, _770984+1), _771002 is _770984 mod 500, _771020 is 99-499 mod 100, _771044=_771046, option_else('trace-length', _771058, 500), option_else('trace-depth', _771066, 30))), quietly(if_t((nop(stop_rtrace), _771002>_771058), (set_debug(eval, false), _771122 is _771058+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771122])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_771174)))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] once(user:(notrace((flag(eval_num, _770984, _770984+1), _771002 is _770984 mod 500, _771020 is 99-499 mod 100, _771044=_771046, option_else('trace-length', _771058, 500), option_else('trace-depth', _771066, 30))), quietly(if_t((nop(stop_rtrace), _771002>_771058), (set_debug(eval, false), _771122 is _771058+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771122])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_771174)))))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] setup_call_cleanup('$notrace'(_773220, _773222), once(user:(flag(eval_num, _770984, _770984+1), _771002 is _770984 mod 500, _771020 is 99-499 mod 100, _771044=_771046, option_else('trace-length', _771058, 500), option_else('trace-depth', _771066, 30))), '$restore_trace'(_773220, _773222))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] sig_atomic(system:'$notrace'(_773220, _773222))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2897, 2897+1), 397 is 2897 mod 500, 0 is 99-499 mod 100, _771044=_771044, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 397>500), (set_debug(eval, false), _771122 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771122])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 397>500), (set_debug(eval, false), _771122 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771122])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] nop(notrace(no_repeats_var(_771174)))
   <span class="ansi1 ansi32"
>Exit: </span>(313) [user] nop(notrace(no_repeats_var(_771174)))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] once(user:(notrace((flag(eval_num, 2897, 2897+1), 397 is 2897 mod 500, 0 is 99-499 mod 100, _771044=_771044, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 397>500), (set_debug(eval, false), _771122 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771122])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_771174)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] must_det_ll(user:(notrace((flag(eval_num, 2897, 2897+1), 397 is 2897 mod 500, 0 is 99-499 mod 100, _771044=_771044, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 397>500), (set_debug(eval, false), _771122 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771122])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_771174)))))
   <span class="ansi1 ansi32"
>Call: </span>(310) [occurs] occurs:sub_term(_782872, e)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(310) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(310) [occurs] occurs:sub_term(_782872, e)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _789978=e
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] if_trace((eval;e), (_771044=1, indentq(0, 397, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_793118, _793120), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _771044=1, indentq(0, 397, -->, [e, [let, a, b, 'never-happens']]))), _793076, fbug((_793076-->if_trace((eval;e), (_771044=1, indentq(0, 397, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_793118, _793120))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_793118, _793120))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _771044=1, indentq(0, 397, -->, [e, [let, a, b, 'never-happens']]))), _793076, fbug((_793076-->if_trace((eval;e), (_771044=1, indentq(0, 397, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_trace((eval;e), (_771044=1, indentq(0, 397, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _797314=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _799352=(\+ \+ (flag(eval_num, _799372, _799372+1), (retval(fail)\=@=retval(fail), nonvar(_769930)->indentq(0, _799372, <--, [e, _769930]);indentq(0, _799372, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] (\+ \+ (flag(eval_num, _799372, _799372+1), (retval(fail)\=@=retval(fail), nonvar(_769930)->indentq(0, _799372, <--, [e, _769930]);indentq(0, _799372, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _799372, _799372+1), (retval(fail)\=@=retval(fail), nonvar(_769930)->indentq(0, _799372, <--, [e, _769930]);indentq(0, _799372, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] call_cleanup(((call(eval_20(=, _738998), 499, '&self', [let, a, b, 'never-happens'], _769930)*->nb_setarg(1, retval(fail), _769930);fail, trace, call(eval_20(=, _738998), 499, '&self', [let, a, b, 'never-happens'], _769930)), ignore(notrace((\+_769930\=_771174, nb_setarg(1, retval(fail), _769930))))), ignore((_771044==1->ignore(\+ \+ (flag(eval_num, _799372, _799372+1), (retval(fail)\=@=retval(fail), nonvar(_769930)->indentq(0, _799372, <--, [e, _769930]);indentq(0, _799372, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799372, _799372+1), (retval(fail)\=@=retval(fail), nonvar(_769930)->indentq(0, _799372, <--, [e, _769930]);indentq(0, _799372, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval_20(=, _738998, 499, '&self', [let, a, b, 'never-happens'], _769930)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] setup_call_cleanup('$notrace'(_806760, _806762), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_806760, _806762))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] sig_atomic(system:'$notrace'(_806760, _806762))
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] once(expand_eval([let, a, b, 'never-happens'], _829104))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] expand_eval([let, a, b, 'never-happens'], _829104)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _835204)
   <span class="ansi1 ansi32"
>Call: </span>(316) [apply] apply:maplist_([a, b, 'never-happens'], _835204, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] expand_eval(a, _837260)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] a=_837260
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(317) [apply] apply:maplist_([b, 'never-happens'], _837262, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] expand_eval(b, _843362)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] b=_843362
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(318) [apply] apply:maplist_(['never-happens'], _843364, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] expand_eval('never-happens', _849464)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] 'never-happens'=_849464
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(319) [apply] apply:maplist_([], _849466, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(317) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] possible_type('&self', a, _866756)
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] possible_type('&self', a, _866756)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval_args(=, _866756, 499, '&self', b, _868798)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_870856, _870858), once(user:self_eval(b)), '$restore_trace'(_870856, _870858))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_870856, _870858))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] _868798=b
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] eval_args(=, _866756, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(312) [user] eval_20(=, _738998, 499, '&self', [let, a, b, 'never-happens'], _769930)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(312) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] ignore((_771044==1->ignore(\+ \+ (flag(eval_num, _799372, _799372+1), (retval(fail)\=@=retval(fail), nonvar(_769930)->indentq(0, _799372, <--, [e, _769930]);indentq(0, _799372, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799372, _799372+1), (retval(fail)\=@=retval(fail), nonvar(_769930)->indentq(0, _799372, <--, [e, _769930]);indentq(0, _799372, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] _771044==1
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] _771044==1
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_884186, _884188), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799372, _799372+1), (retval(fail)\=@=retval(fail), nonvar(_769930)->indentq(0, _799372, <--, [e, _769930]);indentq(0, _799372, <--, [e, retval(fail)])))))))), '$restore_trace'(_884186, _884188))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_884186, _884188))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799372, _799372+1), (retval(fail)\=@=retval(fail), nonvar(_769930)->indentq(0, _799372, <--, [e, _769930]);indentq(0, _799372, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] ignore(user:(_771044==1->ignore(\+ \+ (flag(eval_num, _799372, _799372+1), (retval(fail)\=@=retval(fail), nonvar(_769930)->indentq(0, _799372, <--, [e, _769930]);indentq(0, _799372, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799372, _799372+1), (retval(fail)\=@=retval(fail), nonvar(_769930)->indentq(0, _799372, <--, [e, _769930]);indentq(0, _799372, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(310) [system] call_cleanup(user:((call(eval_20(=, _738998), 499, '&self', [let, a, b, 'never-happens'], _769930)*->nb_setarg(1, retval(fail), _769930);fail, trace, call(eval_20(=, _738998), 499, '&self', [let, a, b, 'never-happens'], _769930)), ignore(notrace((\+_769930\=_771174, nb_setarg(1, retval(fail), _769930))))), user:ignore((_771044==1->ignore(\+ \+ (flag(eval_num, _799372, _799372+1), (retval(fail)\=@=retval(fail), nonvar(_769930)->indentq(0, _799372, <--, [e, _769930]);indentq(0, _799372, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799372, _799372+1), (retval(fail)\=@=retval(fail), nonvar(_769930)->indentq(0, _799372, <--, [e, _769930]);indentq(0, _799372, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] trace_eval(eval_20(=, _738998), e, 499, '&self', [let, a, b, 'never-happens'], _769930)
^  <span class="ansi1 ansi31"
>Fail: </span>(306) [user] eval_args(=, _738998, 500, '&self', [let, a, b, 'never-happens'], _570988)
^  <span class="ansi1 ansi31"
>Fail: </span>(297) [system] call(user:once, user:if_or_else(eval(=, _569314, 495, '&self', [let, a, b, 'never-happens'], _570988), call(eval, [let, a, b, 'never-happens'], _570988)))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(299) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] setup_call_cleanup('$notrace'(_895648, _895650), once(rtrace:retract(t_l:tracer_reset(_895638))), '$restore_trace'(_895648, _895650))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] sig_atomic(system:'$notrace'(_895648, _895650))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [rtrace] tAt(false, 271, 271, false)
; 
; EVAL TEST
; took 0.909 secs. (908.95 milliseconds) 

!(assertEqual ((let $x (get-atoms &self) (get-type $x))) ((get-type &self)))

<span class="ansi31"
>(loonit_failureR  (equal_enough_for_test  ((hyperon::space::DynSpace) (hyperon::space::DynSpace) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (())) ((hyperon::space::DynSpace))))
</span>
Deterministic: ((Error  (got  ((hyperon::space::DynSpace) (hyperon::space::DynSpace) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()))) (expected  ((hyperon::space::DynSpace)))))
;;; stdlib is already loaded
<span class="ansi38-013099040"
>!(assertEqual (if (> 1 2) 1 2) 2)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.03"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.03</h3>
; 
; EVAL TEST
; took 0.000298 secs. (297.74 microseconds) 

!(assertEqual (if (> 1 2) 1 2) 2)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (2) (2)))
</span>
Deterministic: ()
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Importing the module into new space
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &m f1_moduleA.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta)
P;HTML|
;                                         (= 1  "[(Error (import! GroundingSpace-top f1_moduleC.metta) Illegal module name: f1_moduleC.metta)]")
P;HTML|
;                                         (= 2  "0.05user 0.00system 0:00.05elapsed 100%CPU (0avgtext+0avgdata 31132maxresident)k")
P;HTML|
;                                         (= 2  "0inputs+0outputs (0major+3659minor)pagefaults 0swaps")
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta is 625 bytes (17 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta is 291 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Numer))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()
;;; FIXME? stdlib space is not available at importing time -
;;; only tokens / grounded operations work, while symbolic functions
;;; (like `if`) don't work.
;;; FIXME? Exceptions are not caught by `importOp`
<span class="ansi38-013099040"
>!(assertEqual (+ 1 2) 3)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.04"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.04</h3>
; 
; EVAL TEST
; took 0.000209 secs. (208.88 microseconds) 

!(assertEqual (+ 1 2) 3)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (3) (3)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (if True "S" "F") "S")

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.05"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.05</h3>
; 
; EVAL TEST
; took 0.000151 secs. (150.95 microseconds) 

!(assertEqual (if True "S" "F") "S")

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  ("S") ("S")))
</span>
Deterministic: ()<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (+ $x 10) (g $x)))
</span><span class="ansi38-255165000"
> (: f (-> Number Number))
</span><span class="ansi38-255165000"
> (= (f $x) (if (< $x 0) (- 0 $x) (g (+ 1 $x))))
</span>
Last Result(2): ()
;;; It's first atom is a space
;;;!(assertEqual
;;;  (let* (($x (collapse (get-atoms &m)))
;;;         ($y (car-atom $x)))
;;;        (get-type $y))
;;;  (get-type &self))
;;; FIXME? Now, it is moduleC space.
;;;        Should it be `stdlib` atom for a separately imported space
;;; !(let $x (collapse (get-atoms &m)) (car-atom $x))
;;; MeTTLog:  xlisting('&m').
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Without additional means like `(&m.f 2)` notation or `(interpret &m (f 2))`,
;;; we cannot execute functions from the separate space - we can only use `match`.
;;; Although `&m` imports another space with definition of `g`, it is not reduced
;;; because it is not defined in the context of `&self`. This is the expected
;;; behavior, but it shows that this way of importing spaces is not too useful
;;; for importing modules with functions.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(assertEqual (match &m (= (f 2) $x) $x) (g 3))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.06"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.06</h3>
; 
; EVAL TEST
; took 0.003 secs. (3.50 milliseconds) 

!(assertEqual (match &m (= (f 2) $x) $x) (g 3))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  ((g 3)) ((g 3))))
</span>
Deterministic: ()
;;; Importing the same space into `&self` should break nothing
;;; TODO? If stdlib space would be in `&m`, which should check that it is not
;;; there anymore since in should be removed after importing it to `&self`
<span class="ansi38-013099040"
>!(import! &self f1_moduleA.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta is 625 bytes (17 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleA.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta is 291 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Numer))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()
;;; FIXME? stdlib space is not available at importing time -
;;; only tokens / grounded operations work, while symbolic functions
;;; (like `if`) don't work.
;;; FIXME? Exceptions are not caught by `importOp`
<span class="ansi38-013099040"
>!(assertEqual (+ 1 2) 3)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.07"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.07</h3>
; 
; EVAL TEST
; took 0.000237 secs. (236.57 microseconds) 

!(assertEqual (+ 1 2) 3)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (3) (3)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (if True "S" "F") "S")

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.08"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-MODULEA.08</h3>
; 
; EVAL TEST
; took 0.000147 secs. (147.42 microseconds) 

!(assertEqual (if True "S" "F") "S")

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  ("S") ("S")))
</span>
Deterministic: ()<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (+ $x 10) (g $x)))
</span><span class="ansi38-255165000"
> (: f (-> Number Number))
</span><span class="ansi38-255165000"
> (= (f $x) (if (< $x 0) (- 0 $x) (g (+ 1 $x))))
</span>
Last Result(2): ()
;;; Now indirectly imported `g` works and `f` fully works
<span class="ansi38-013099040"
>!(assertEqual (g 2) 102)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.09"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.09</h3>
; 
; EVAL TEST
; took 0.000948 secs. (947.61 microseconds) 

!(assertEqual (g 2) 102)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102) (102)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (f 2) 103)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.10"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.10</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.35 milliseconds) 

!(assertEqual (f 2) 103)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (103) (103)))
</span>
Deterministic: ()
;;; MeTTLog:  xlisting('&self').
;;; `&self` contains 3 atoms-spaces now:
;;; - stdlib
;;; - moduleC imported by moduleA and removed from A after its import to &self
;;; - moduleA itself, which is the same as &m
<span class="ansi38-013099040"
>!(assertEqual &m (let* (($a (collapse (get-atoms &self))) ($x (cdr-atom $a)) ($y (cdr-atom $x))) (car-atom $y)))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.11"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.11</h3>

(failed  once (if_or_else  (eval  = $_337360 495 &self (let a b never-happens) $_339034) (call  eval (let a b never-happens) $_339034)))


(on_mettalog_error  (failed  once (if_or_else  (eval  = $_337360 495 &self (let a b never-happens) $_339034) (call  eval (let a b never-happens) $_339034))))

^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] call(user:once, user:if_or_else(eval(=, _337360, 495, '&self', [let, a, b, 'never-happens'], _339034), call(eval, [let, a, b, 'never-happens'], _339034)))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] once(user:if_or_else(eval(=, _337360, 495, '&self', [let, a, b, 'never-happens'], _339034), call(eval, [let, a, b, 'never-happens'], _339034)))
   <span class="ansi1 ansi32"
>Call: </span>(312) [user] if_or_else(eval(=, _337360, 495, '&self', [let, a, b, 'never-happens'], _339034), call(eval, [let, a, b, 'never-happens'], _339034))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval(=, _337360, 495, '&self', [let, a, b, 'never-happens'], _339034)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] catch_metta_return(eval_args(=, _337360, 495, '&self', [let, a, b, 'never-happens'], _339034), _339034)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_args(=, _337360, 495, '&self', [let, a, b, 'never-happens'], _339034)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_347444, _347446), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_347444, _347446))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_347444, _347446))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_349532, _349534), once(user:nonvar(_339034)), '$restore_trace'(_349532, _349534))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_349532, _349534))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_351620, _351622), once(user:nonvar(_339034)), '$restore_trace'(_351620, _351622))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_351620, _351622))
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_358776, _358778), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_358776, _358778))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_358776, _358778))
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] eval_00(=, _337360, 495, '&self', [let, a, b, 'never-happens'], _339034)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_363920, _363922), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_363920, _363922))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_363920, _363922))
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] eval_01(=, _337360, 495, '&self', [let, a, b, 'never-happens'], _339034)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] 495<1
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] 495<1
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_372156, _372158), once(user:(_372132 is 495-1, copy_term([let, a, b, 'never-happens'], _372146))), '$restore_trace'(_372156, _372158))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_372156, _372158))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(494 is 495-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] trace_eval(eval_20(=, _337360), e, 494, '&self', [let, a, b, 'never-happens'], _375266)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] must_det_ll((notrace((flag(eval_num, _376320, _376320+1), _376338 is _376320 mod 500, _376356 is 99-494 mod 100, _376380=_376382, option_else('trace-length', _376394, 500), option_else('trace-depth', _376402, 30))), quietly(if_t((nop(stop_rtrace), _376338>_376394), (set_debug(eval, false), _376458 is _376394+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376458])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_376510)))))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] once(user:(notrace((flag(eval_num, _376320, _376320+1), _376338 is _376320 mod 500, _376356 is 99-494 mod 100, _376380=_376382, option_else('trace-length', _376394, 500), option_else('trace-depth', _376402, 30))), quietly(if_t((nop(stop_rtrace), _376338>_376394), (set_debug(eval, false), _376458 is _376394+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376458])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_376510)))))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_378556, _378558), once(user:(flag(eval_num, _376320, _376320+1), _376338 is _376320 mod 500, _376356 is 99-494 mod 100, _376380=_376382, option_else('trace-length', _376394, 500), option_else('trace-depth', _376402, 30))), '$restore_trace'(_378556, _378558))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_378556, _378558))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2059, 2059+1), 59 is 2059 mod 500, 5 is 99-494 mod 100, _376380=_376380, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 59>500), (set_debug(eval, false), _376458 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376458])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 59>500), (set_debug(eval, false), _376458 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376458])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(323) [user] nop(notrace(no_repeats_var(_376510)))
   <span class="ansi1 ansi32"
>Exit: </span>(323) [user] nop(notrace(no_repeats_var(_376510)))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] once(user:(notrace((flag(eval_num, 2059, 2059+1), 59 is 2059 mod 500, 5 is 99-494 mod 100, _376380=_376380, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 59>500), (set_debug(eval, false), _376458 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376458])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_376510)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] must_det_ll(user:(notrace((flag(eval_num, 2059, 2059+1), 59 is 2059 mod 500, 5 is 99-494 mod 100, _376380=_376380, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 59>500), (set_debug(eval, false), _376458 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376458])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_376510)))))
   <span class="ansi1 ansi32"
>Call: </span>(320) [occurs] occurs:sub_term(_388208, e)
   <span class="ansi1 ansi32"
>Exit: </span>(320) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(320) [occurs] occurs:sub_term(_388208, e)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _395314=e
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] if_trace((eval;e), (_376380=1, indentq(5, 59, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_398454, _398456), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _376380=1, indentq(5, 59, -->, [e, [let, a, b, 'never-happens']]))), _398412, fbug((_398412-->if_trace((eval;e), (_376380=1, indentq(5, 59, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_398454, _398456))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_398454, _398456))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _376380=1, indentq(5, 59, -->, [e, [let, a, b, 'never-happens']]))), _398412, fbug((_398412-->if_trace((eval;e), (_376380=1, indentq(5, 59, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_trace((eval;e), (_376380=1, indentq(5, 59, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _402650=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _404688=(\+ \+ (flag(eval_num, _404708, _404708+1), (retval(fail)\=@=retval(fail), nonvar(_375266)->indentq(5, _404708, <--, [e, _375266]);indentq(5, _404708, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] (\+ \+ (flag(eval_num, _404708, _404708+1), (retval(fail)\=@=retval(fail), nonvar(_375266)->indentq(5, _404708, <--, [e, _375266]);indentq(5, _404708, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _404708, _404708+1), (retval(fail)\=@=retval(fail), nonvar(_375266)->indentq(5, _404708, <--, [e, _375266]);indentq(5, _404708, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] call_cleanup(((call(eval_20(=, _337360), 494, '&self', [let, a, b, 'never-happens'], _375266)*->nb_setarg(1, retval(fail), _375266);fail, trace, call(eval_20(=, _337360), 494, '&self', [let, a, b, 'never-happens'], _375266)), ignore(notrace((\+_375266\=_376510, nb_setarg(1, retval(fail), _375266))))), ignore((_376380==1->ignore(\+ \+ (flag(eval_num, _404708, _404708+1), (retval(fail)\=@=retval(fail), nonvar(_375266)->indentq(5, _404708, <--, [e, _375266]);indentq(5, _404708, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404708, _404708+1), (retval(fail)\=@=retval(fail), nonvar(_375266)->indentq(5, _404708, <--, [e, _375266]);indentq(5, _404708, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] eval_20(=, _337360, 494, '&self', [let, a, b, 'never-happens'], _375266)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] setup_call_cleanup('$notrace'(_412096, _412098), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_412096, _412098))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] sig_atomic(system:'$notrace'(_412096, _412098))
^  <span class="ansi1 ansi31"
>Fail: </span>(324) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] once(expand_eval([let, a, b, 'never-happens'], _434440))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] expand_eval([let, a, b, 'never-happens'], _434440)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _440540)
   <span class="ansi1 ansi32"
>Call: </span>(326) [apply] apply:maplist_([a, b, 'never-happens'], _440540, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] expand_eval(a, _442596)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] a=_442596
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(327) [apply] apply:maplist_([b, 'never-happens'], _442598, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] expand_eval(b, _448698)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] b=_448698
   <span class="ansi1 ansi32"
>Exit: </span>(329) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(328) [apply] apply:maplist_(['never-happens'], _448700, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] expand_eval('never-happens', _454800)
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] 'never-happens'=_454800
   <span class="ansi1 ansi32"
>Exit: </span>(330) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(329) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(329) [apply] apply:maplist_([], _454802, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(329) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] possible_type('&self', a, _472092)
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] possible_type('&self', a, _472092)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] eval_args(=, _472092, 494, '&self', b, _474134)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_476192, _476194), once(user:self_eval(b)), '$restore_trace'(_476192, _476194))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_476192, _476194))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] _474134=b
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] eval_args(=, _472092, 494, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(322) [user] eval_20(=, _337360, 494, '&self', [let, a, b, 'never-happens'], _375266)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(322) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] ignore((_376380==1->ignore(\+ \+ (flag(eval_num, _404708, _404708+1), (retval(fail)\=@=retval(fail), nonvar(_375266)->indentq(5, _404708, <--, [e, _375266]);indentq(5, _404708, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404708, _404708+1), (retval(fail)\=@=retval(fail), nonvar(_375266)->indentq(5, _404708, <--, [e, _375266]);indentq(5, _404708, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] _376380==1
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] _376380==1
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_489522, _489524), once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404708, _404708+1), (retval(fail)\=@=retval(fail), nonvar(_375266)->indentq(5, _404708, <--, [e, _375266]);indentq(5, _404708, <--, [e, retval(fail)])))))))), '$restore_trace'(_489522, _489524))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_489522, _489524))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404708, _404708+1), (retval(fail)\=@=retval(fail), nonvar(_375266)->indentq(5, _404708, <--, [e, _375266]);indentq(5, _404708, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] ignore(user:(_376380==1->ignore(\+ \+ (flag(eval_num, _404708, _404708+1), (retval(fail)\=@=retval(fail), nonvar(_375266)->indentq(5, _404708, <--, [e, _375266]);indentq(5, _404708, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404708, _404708+1), (retval(fail)\=@=retval(fail), nonvar(_375266)->indentq(5, _404708, <--, [e, _375266]);indentq(5, _404708, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [system] call_cleanup(user:((call(eval_20(=, _337360), 494, '&self', [let, a, b, 'never-happens'], _375266)*->nb_setarg(1, retval(fail), _375266);fail, trace, call(eval_20(=, _337360), 494, '&self', [let, a, b, 'never-happens'], _375266)), ignore(notrace((\+_375266\=_376510, nb_setarg(1, retval(fail), _375266))))), user:ignore((_376380==1->ignore(\+ \+ (flag(eval_num, _404708, _404708+1), (retval(fail)\=@=retval(fail), nonvar(_375266)->indentq(5, _404708, <--, [e, _375266]);indentq(5, _404708, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404708, _404708+1), (retval(fail)\=@=retval(fail), nonvar(_375266)->indentq(5, _404708, <--, [e, _375266]);indentq(5, _404708, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] trace_eval(eval_20(=, _337360), e, 494, '&self', [let, a, b, 'never-happens'], _375266)
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] eval_args(=, _337360, 495, '&self', [let, a, b, 'never-happens'], _339034)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] call(eval, [let, a, b, 'never-happens'], _339034)
   <span class="ansi1 ansi32"
>Call: </span>(314) [user] eval([let, a, b, 'never-happens'], _339034)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] current_self(_498930)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] nb_current(self_space, _498930)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval('&self', [let, a, b, 'never-happens'], _339034)
   <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _339034)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] catch_metta_return(eval_args(=, _507044, 500, '&self', [let, a, b, 'never-happens'], _339034), _339034)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_args(=, _507044, 500, '&self', [let, a, b, 'never-happens'], _339034)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_510154, _510156), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_510154, _510156))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_510154, _510156))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_512242, _512244), once(user:nonvar(_339034)), '$restore_trace'(_512242, _512244))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_512242, _512244))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_514330, _514332), once(user:nonvar(_339034)), '$restore_trace'(_514330, _514332))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_514330, _514332))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_521486, _521488), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_521486, _521488))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_521486, _521488))
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] eval_00(=, _507044, 500, '&self', [let, a, b, 'never-happens'], _339034)
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] setup_call_cleanup('$notrace'(_526630, _526632), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_526630, _526632))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] sig_atomic(system:'$notrace'(_526630, _526632))
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] eval_01(=, _507044, 500, '&self', [let, a, b, 'never-happens'], _339034)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] setup_call_cleanup('$notrace'(_534866, _534868), once(user:(_534842 is 500-1, copy_term([let, a, b, 'never-happens'], _534856))), '$restore_trace'(_534866, _534868))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] sig_atomic(system:'$notrace'(_534866, _534868))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] trace_eval(eval_20(=, _507044), e, 499, '&self', [let, a, b, 'never-happens'], _537976)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] must_det_ll((notrace((flag(eval_num, _539030, _539030+1), _539048 is _539030 mod 500, _539066 is 99-499 mod 100, _539090=_539092, option_else('trace-length', _539104, 500), option_else('trace-depth', _539112, 30))), quietly(if_t((nop(stop_rtrace), _539048>_539104), (set_debug(eval, false), _539168 is _539104+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539168])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_539220)))))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] once(user:(notrace((flag(eval_num, _539030, _539030+1), _539048 is _539030 mod 500, _539066 is 99-499 mod 100, _539090=_539092, option_else('trace-length', _539104, 500), option_else('trace-depth', _539112, 30))), quietly(if_t((nop(stop_rtrace), _539048>_539104), (set_debug(eval, false), _539168 is _539104+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539168])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_539220)))))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] setup_call_cleanup('$notrace'(_541266, _541268), once(user:(flag(eval_num, _539030, _539030+1), _539048 is _539030 mod 500, _539066 is 99-499 mod 100, _539090=_539092, option_else('trace-length', _539104, 500), option_else('trace-depth', _539112, 30))), '$restore_trace'(_541266, _541268))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] sig_atomic(system:'$notrace'(_541266, _541268))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2060, 2060+1), 60 is 2060 mod 500, 0 is 99-499 mod 100, _539090=_539090, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 60>500), (set_debug(eval, false), _539168 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539168])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 60>500), (set_debug(eval, false), _539168 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539168])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(326) [user] nop(notrace(no_repeats_var(_539220)))
   <span class="ansi1 ansi32"
>Exit: </span>(326) [user] nop(notrace(no_repeats_var(_539220)))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] once(user:(notrace((flag(eval_num, 2060, 2060+1), 60 is 2060 mod 500, 0 is 99-499 mod 100, _539090=_539090, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 60>500), (set_debug(eval, false), _539168 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539168])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_539220)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] must_det_ll(user:(notrace((flag(eval_num, 2060, 2060+1), 60 is 2060 mod 500, 0 is 99-499 mod 100, _539090=_539090, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 60>500), (set_debug(eval, false), _539168 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539168])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_539220)))))
   <span class="ansi1 ansi32"
>Call: </span>(323) [occurs] occurs:sub_term(_550918, e)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(323) [occurs] occurs:sub_term(_550918, e)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _558024=e
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] if_trace((eval;e), (_539090=1, indentq(0, 60, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_561164, _561166), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _539090=1, indentq(0, 60, -->, [e, [let, a, b, 'never-happens']]))), _561122, fbug((_561122-->if_trace((eval;e), (_539090=1, indentq(0, 60, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_561164, _561166))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_561164, _561166))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _539090=1, indentq(0, 60, -->, [e, [let, a, b, 'never-happens']]))), _561122, fbug((_561122-->if_trace((eval;e), (_539090=1, indentq(0, 60, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] if_trace((eval;e), (_539090=1, indentq(0, 60, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _565360=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _567398=(\+ \+ (flag(eval_num, _567418, _567418+1), (retval(fail)\=@=retval(fail), nonvar(_537976)->indentq(0, _567418, <--, [e, _537976]);indentq(0, _567418, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] (\+ \+ (flag(eval_num, _567418, _567418+1), (retval(fail)\=@=retval(fail), nonvar(_537976)->indentq(0, _567418, <--, [e, _537976]);indentq(0, _567418, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _567418, _567418+1), (retval(fail)\=@=retval(fail), nonvar(_537976)->indentq(0, _567418, <--, [e, _537976]);indentq(0, _567418, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] call_cleanup(((call(eval_20(=, _507044), 499, '&self', [let, a, b, 'never-happens'], _537976)*->nb_setarg(1, retval(fail), _537976);fail, trace, call(eval_20(=, _507044), 499, '&self', [let, a, b, 'never-happens'], _537976)), ignore(notrace((\+_537976\=_539220, nb_setarg(1, retval(fail), _537976))))), ignore((_539090==1->ignore(\+ \+ (flag(eval_num, _567418, _567418+1), (retval(fail)\=@=retval(fail), nonvar(_537976)->indentq(0, _567418, <--, [e, _537976]);indentq(0, _567418, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567418, _567418+1), (retval(fail)\=@=retval(fail), nonvar(_537976)->indentq(0, _567418, <--, [e, _537976]);indentq(0, _567418, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] eval_20(=, _507044, 499, '&self', [let, a, b, 'never-happens'], _537976)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(329) [system] setup_call_cleanup('$notrace'(_574806, _574808), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_574806, _574808))
^  <span class="ansi1 ansi32"
>Call: </span>(330) [system] sig_atomic(system:'$notrace'(_574806, _574808))
^  <span class="ansi1 ansi31"
>Fail: </span>(327) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] once(expand_eval([let, a, b, 'never-happens'], _597150))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] expand_eval([let, a, b, 'never-happens'], _597150)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _603250)
   <span class="ansi1 ansi32"
>Call: </span>(329) [apply] apply:maplist_([a, b, 'never-happens'], _603250, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] expand_eval(a, _605306)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] a=_605306
   <span class="ansi1 ansi32"
>Exit: </span>(331) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(330) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(330) [apply] apply:maplist_([b, 'never-happens'], _605308, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] expand_eval(b, _611408)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] b=_611408
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(331) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(331) [apply] apply:maplist_(['never-happens'], _611410, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(332) [user] expand_eval('never-happens', _617510)
   <span class="ansi1 ansi32"
>Call: </span>(333) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(333) [system] 'never-happens'=_617510
   <span class="ansi1 ansi32"
>Exit: </span>(333) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(332) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(332) [apply] apply:maplist_([], _617512, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(332) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(331) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(330) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(329) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] possible_type('&self', a, _634802)
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] possible_type('&self', a, _634802)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] eval_args(=, _634802, 499, '&self', b, _636844)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] setup_call_cleanup('$notrace'(_638902, _638904), once(user:self_eval(b)), '$restore_trace'(_638902, _638904))
^  <span class="ansi1 ansi32"
>Call: </span>(329) [system] sig_atomic(system:'$notrace'(_638902, _638904))
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] _636844=b
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] eval_args(=, _634802, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(325) [user] eval_20(=, _507044, 499, '&self', [let, a, b, 'never-happens'], _537976)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(325) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] ignore((_539090==1->ignore(\+ \+ (flag(eval_num, _567418, _567418+1), (retval(fail)\=@=retval(fail), nonvar(_537976)->indentq(0, _567418, <--, [e, _537976]);indentq(0, _567418, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567418, _567418+1), (retval(fail)\=@=retval(fail), nonvar(_537976)->indentq(0, _567418, <--, [e, _537976]);indentq(0, _567418, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] _539090==1
   <span class="ansi1 ansi31"
>Fail: </span>(327) [system] _539090==1
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] setup_call_cleanup('$notrace'(_652232, _652234), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567418, _567418+1), (retval(fail)\=@=retval(fail), nonvar(_537976)->indentq(0, _567418, <--, [e, _537976]);indentq(0, _567418, <--, [e, retval(fail)])))))))), '$restore_trace'(_652232, _652234))
^  <span class="ansi1 ansi32"
>Call: </span>(329) [system] sig_atomic(system:'$notrace'(_652232, _652234))
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567418, _567418+1), (retval(fail)\=@=retval(fail), nonvar(_537976)->indentq(0, _567418, <--, [e, _537976]);indentq(0, _567418, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] ignore(user:(_539090==1->ignore(\+ \+ (flag(eval_num, _567418, _567418+1), (retval(fail)\=@=retval(fail), nonvar(_537976)->indentq(0, _567418, <--, [e, _537976]);indentq(0, _567418, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567418, _567418+1), (retval(fail)\=@=retval(fail), nonvar(_537976)->indentq(0, _567418, <--, [e, _537976]);indentq(0, _567418, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(323) [system] call_cleanup(user:((call(eval_20(=, _507044), 499, '&self', [let, a, b, 'never-happens'], _537976)*->nb_setarg(1, retval(fail), _537976);fail, trace, call(eval_20(=, _507044), 499, '&self', [let, a, b, 'never-happens'], _537976)), ignore(notrace((\+_537976\=_539220, nb_setarg(1, retval(fail), _537976))))), user:ignore((_539090==1->ignore(\+ \+ (flag(eval_num, _567418, _567418+1), (retval(fail)\=@=retval(fail), nonvar(_537976)->indentq(0, _567418, <--, [e, _537976]);indentq(0, _567418, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567418, _567418+1), (retval(fail)\=@=retval(fail), nonvar(_537976)->indentq(0, _567418, <--, [e, _537976]);indentq(0, _567418, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(322) [user] trace_eval(eval_20(=, _507044), e, 499, '&self', [let, a, b, 'never-happens'], _537976)
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] eval_args(=, _507044, 500, '&self', [let, a, b, 'never-happens'], _339034)
^  <span class="ansi1 ansi31"
>Fail: </span>(310) [system] call(user:once, user:if_or_else(eval(=, _337360, 495, '&self', [let, a, b, 'never-happens'], _339034), call(eval, [let, a, b, 'never-happens'], _339034)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(312) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] setup_call_cleanup('$notrace'(_663694, _663696), once(rtrace:retract(t_l:tracer_reset(_663684))), '$restore_trace'(_663694, _663696))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] sig_atomic(system:'$notrace'(_663694, _663696))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [rtrace] tAt(false, 271, 271, false)
; 
; EVAL TEST
; took 4.71 seconds.

!(assertEqual &m (let* (($a (collapse (get-atoms &self))) ($x (cdr-atom $a)) ($y (cdr-atom $x))) (car-atom $y)))

<span class="ansi31"
>(loonit_failureR  (equal_enough_for_test  (&m) ((: __g (-> Number)))))
</span>
Deterministic: ((Error  (got  (&m)) (expected  ((: __g (-> Number))))))
;;; NOTE: now the first atom, which was a space, is removed from `&m`,
;;; because we load modules only once, and we collect atoms-spaces to
;;; prevent duplication
<span class="ansi38-013099040"
>!(assertEqual (== (let* (($x (collapse (get-atoms &m))) ($y (car-atom $x))) (get-type $y)) (get-type &self)) False)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.12"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.12</h3>

(failed  once (if_or_else  (eval  = $_337590 494 &self (let a b never-happens) $_339264) (call  eval (let a b never-happens) $_339264)))


(on_mettalog_error  (failed  once (if_or_else  (eval  = $_337590 494 &self (let a b never-happens) $_339264) (call  eval (let a b never-happens) $_339264))))

^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] call(user:once, user:if_or_else(eval(=, _337590, 494, '&self', [let, a, b, 'never-happens'], _339264), call(eval, [let, a, b, 'never-happens'], _339264)))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] once(user:if_or_else(eval(=, _337590, 494, '&self', [let, a, b, 'never-happens'], _339264), call(eval, [let, a, b, 'never-happens'], _339264)))
   <span class="ansi1 ansi32"
>Call: </span>(324) [user] if_or_else(eval(=, _337590, 494, '&self', [let, a, b, 'never-happens'], _339264), call(eval, [let, a, b, 'never-happens'], _339264))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] eval(=, _337590, 494, '&self', [let, a, b, 'never-happens'], _339264)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] catch_metta_return(eval_args(=, _337590, 494, '&self', [let, a, b, 'never-happens'], _339264), _339264)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] eval_args(=, _337590, 494, '&self', [let, a, b, 'never-happens'], _339264)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(330) [system] setup_call_cleanup('$notrace'(_347674, _347676), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_347674, _347676))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [system] sig_atomic(system:'$notrace'(_347674, _347676))
^  <span class="ansi1 ansi32"
>Call: </span>(330) [system] setup_call_cleanup('$notrace'(_349762, _349764), once(user:nonvar(_339264)), '$restore_trace'(_349762, _349764))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [system] sig_atomic(system:'$notrace'(_349762, _349764))
^  <span class="ansi1 ansi32"
>Call: </span>(330) [system] setup_call_cleanup('$notrace'(_351850, _351852), once(user:nonvar(_339264)), '$restore_trace'(_351850, _351852))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [system] sig_atomic(system:'$notrace'(_351850, _351852))
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(329) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(331) [system] setup_call_cleanup('$notrace'(_359006, _359008), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_359006, _359008))
^  <span class="ansi1 ansi32"
>Call: </span>(332) [system] sig_atomic(system:'$notrace'(_359006, _359008))
^  <span class="ansi1 ansi31"
>Fail: </span>(329) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] eval_00(=, _337590, 494, '&self', [let, a, b, 'never-happens'], _339264)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(332) [system] setup_call_cleanup('$notrace'(_364150, _364152), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_364150, _364152))
^  <span class="ansi1 ansi32"
>Call: </span>(333) [system] sig_atomic(system:'$notrace'(_364150, _364152))
^  <span class="ansi1 ansi31"
>Fail: </span>(330) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] eval_01(=, _337590, 494, '&self', [let, a, b, 'never-happens'], _339264)
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] if_t((494<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(333) [system] 494<1
   <span class="ansi1 ansi31"
>Fail: </span>(333) [system] 494<1
^  <span class="ansi1 ansi32"
>Exit: </span>(331) [user] if_t((494<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(332) [system] setup_call_cleanup('$notrace'(_372386, _372388), once(user:(_372362 is 494-1, copy_term([let, a, b, 'never-happens'], _372376))), '$restore_trace'(_372386, _372388))
^  <span class="ansi1 ansi32"
>Call: </span>(333) [system] sig_atomic(system:'$notrace'(_372386, _372388))
^  <span class="ansi1 ansi32"
>Exit: </span>(332) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(493 is 494-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] trace_eval(eval_20(=, _337590), e, 493, '&self', [let, a, b, 'never-happens'], _375496)
^  <span class="ansi1 ansi32"
>Call: </span>(332) [user] must_det_ll((notrace((flag(eval_num, _376550, _376550+1), _376568 is _376550 mod 500, _376586 is 99-493 mod 100, _376610=_376612, option_else('trace-length', _376624, 500), option_else('trace-depth', _376632, 30))), quietly(if_t((nop(stop_rtrace), _376568>_376624), (set_debug(eval, false), _376688 is _376624+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376688])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_376740)))))
^  <span class="ansi1 ansi32"
>Call: </span>(333) [user] once(user:(notrace((flag(eval_num, _376550, _376550+1), _376568 is _376550 mod 500, _376586 is 99-493 mod 100, _376610=_376612, option_else('trace-length', _376624, 500), option_else('trace-depth', _376632, 30))), quietly(if_t((nop(stop_rtrace), _376568>_376624), (set_debug(eval, false), _376688 is _376624+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376688])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_376740)))))
^  <span class="ansi1 ansi32"
>Call: </span>(336) [system] setup_call_cleanup('$notrace'(_378786, _378788), once(user:(flag(eval_num, _376550, _376550+1), _376568 is _376550 mod 500, _376586 is 99-493 mod 100, _376610=_376612, option_else('trace-length', _376624, 500), option_else('trace-depth', _376632, 30))), '$restore_trace'(_378786, _378788))
^  <span class="ansi1 ansi32"
>Call: </span>(337) [system] sig_atomic(system:'$notrace'(_378786, _378788))
^  <span class="ansi1 ansi32"
>Exit: </span>(336) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2060, 2060+1), 60 is 2060 mod 500, 6 is 99-493 mod 100, _376610=_376610, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(336) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 60>500), (set_debug(eval, false), _376688 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376688])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(336) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 60>500), (set_debug(eval, false), _376688 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376688])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(335) [user] nop(notrace(no_repeats_var(_376740)))
   <span class="ansi1 ansi32"
>Exit: </span>(335) [user] nop(notrace(no_repeats_var(_376740)))
^  <span class="ansi1 ansi32"
>Exit: </span>(333) [system] once(user:(notrace((flag(eval_num, 2060, 2060+1), 60 is 2060 mod 500, 6 is 99-493 mod 100, _376610=_376610, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 60>500), (set_debug(eval, false), _376688 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376688])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_376740)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(332) [user] must_det_ll(user:(notrace((flag(eval_num, 2060, 2060+1), 60 is 2060 mod 500, 6 is 99-493 mod 100, _376610=_376610, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 60>500), (set_debug(eval, false), _376688 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_376688])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_376740)))))
   <span class="ansi1 ansi32"
>Call: </span>(332) [occurs] occurs:sub_term(_388438, e)
   <span class="ansi1 ansi32"
>Exit: </span>(332) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(332) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(333) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(333) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(332) [occurs] occurs:sub_term(_388438, e)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] _395544=e
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(332) [user] if_trace((eval;e), (_376610=1, indentq(6, 60, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(334) [system] setup_call_cleanup('$notrace'(_398684, _398686), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _376610=1, indentq(6, 60, -->, [e, [let, a, b, 'never-happens']]))), _398642, fbug((_398642-->if_trace((eval;e), (_376610=1, indentq(6, 60, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_398684, _398686))
^  <span class="ansi1 ansi32"
>Call: </span>(335) [system] sig_atomic(system:'$notrace'(_398684, _398686))
^  <span class="ansi1 ansi32"
>Exit: </span>(334) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _376610=1, indentq(6, 60, -->, [e, [let, a, b, 'never-happens']]))), _398642, fbug((_398642-->if_trace((eval;e), (_376610=1, indentq(6, 60, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(332) [user] if_trace((eval;e), (_376610=1, indentq(6, 60, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] _402880=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] _404918=(\+ \+ (flag(eval_num, _404938, _404938+1), (retval(fail)\=@=retval(fail), nonvar(_375496)->indentq(6, _404938, <--, [e, _375496]);indentq(6, _404938, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] (\+ \+ (flag(eval_num, _404938, _404938+1), (retval(fail)\=@=retval(fail), nonvar(_375496)->indentq(6, _404938, <--, [e, _375496]);indentq(6, _404938, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _404938, _404938+1), (retval(fail)\=@=retval(fail), nonvar(_375496)->indentq(6, _404938, <--, [e, _375496]);indentq(6, _404938, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(332) [user] call_cleanup(((call(eval_20(=, _337590), 493, '&self', [let, a, b, 'never-happens'], _375496)*->nb_setarg(1, retval(fail), _375496);fail, trace, call(eval_20(=, _337590), 493, '&self', [let, a, b, 'never-happens'], _375496)), ignore(notrace((\+_375496\=_376740, nb_setarg(1, retval(fail), _375496))))), ignore((_376610==1->ignore(\+ \+ (flag(eval_num, _404938, _404938+1), (retval(fail)\=@=retval(fail), nonvar(_375496)->indentq(6, _404938, <--, [e, _375496]);indentq(6, _404938, <--, [e, retval(fail)]))));notrace(ignore(if_t(6<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404938, _404938+1), (retval(fail)\=@=retval(fail), nonvar(_375496)->indentq(6, _404938, <--, [e, _375496]);indentq(6, _404938, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(334) [user] eval_20(=, _337590, 493, '&self', [let, a, b, 'never-happens'], _375496)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(336) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(338) [system] setup_call_cleanup('$notrace'(_412326, _412328), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_412326, _412328))
^  <span class="ansi1 ansi32"
>Call: </span>(339) [system] sig_atomic(system:'$notrace'(_412326, _412328))
^  <span class="ansi1 ansi31"
>Fail: </span>(336) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(336) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(336) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(337) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] once(expand_eval([let, a, b, 'never-happens'], _434670))
^  <span class="ansi1 ansi32"
>Call: </span>(336) [user] expand_eval([let, a, b, 'never-happens'], _434670)
   <span class="ansi1 ansi32"
>Call: </span>(337) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(337) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(337) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(337) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(337) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _440770)
   <span class="ansi1 ansi32"
>Call: </span>(338) [apply] apply:maplist_([a, b, 'never-happens'], _440770, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(339) [user] expand_eval(a, _442826)
   <span class="ansi1 ansi32"
>Call: </span>(340) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(340) [system] a=_442826
   <span class="ansi1 ansi32"
>Exit: </span>(340) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(339) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(339) [apply] apply:maplist_([b, 'never-happens'], _442828, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(340) [user] expand_eval(b, _448928)
   <span class="ansi1 ansi32"
>Call: </span>(341) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(341) [system] b=_448928
   <span class="ansi1 ansi32"
>Exit: </span>(341) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(340) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(340) [apply] apply:maplist_(['never-happens'], _448930, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(341) [user] expand_eval('never-happens', _455030)
   <span class="ansi1 ansi32"
>Call: </span>(342) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(342) [system] 'never-happens'=_455030
   <span class="ansi1 ansi32"
>Exit: </span>(342) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(341) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(341) [apply] apply:maplist_([], _455032, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(341) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(340) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(339) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(338) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(337) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(336) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(335) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] possible_type('&self', a, _472322)
^  <span class="ansi1 ansi32"
>Exit: </span>(335) [user] possible_type('&self', a, _472322)
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] eval_args(=, _472322, 493, '&self', b, _474364)
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(337) [system] setup_call_cleanup('$notrace'(_476422, _476424), once(user:self_eval(b)), '$restore_trace'(_476422, _476424))
^  <span class="ansi1 ansi32"
>Call: </span>(338) [system] sig_atomic(system:'$notrace'(_476422, _476424))
^  <span class="ansi1 ansi32"
>Exit: </span>(337) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] _474364=b
   <span class="ansi1 ansi32"
>Exit: </span>(336) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(335) [user] eval_args(=, _472322, 493, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(334) [user] eval_20(=, _337590, 493, '&self', [let, a, b, 'never-happens'], _375496)
   <span class="ansi1 ansi32"
>Call: </span>(334) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(334) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(334) [user] ignore((_376610==1->ignore(\+ \+ (flag(eval_num, _404938, _404938+1), (retval(fail)\=@=retval(fail), nonvar(_375496)->indentq(6, _404938, <--, [e, _375496]);indentq(6, _404938, <--, [e, retval(fail)]))));notrace(ignore(if_t(6<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404938, _404938+1), (retval(fail)\=@=retval(fail), nonvar(_375496)->indentq(6, _404938, <--, [e, _375496]);indentq(6, _404938, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] _376610==1
   <span class="ansi1 ansi31"
>Fail: </span>(336) [system] _376610==1
^  <span class="ansi1 ansi32"
>Call: </span>(337) [system] setup_call_cleanup('$notrace'(_489752, _489754), once(user:ignore(if_t(6<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404938, _404938+1), (retval(fail)\=@=retval(fail), nonvar(_375496)->indentq(6, _404938, <--, [e, _375496]);indentq(6, _404938, <--, [e, retval(fail)])))))))), '$restore_trace'(_489752, _489754))
^  <span class="ansi1 ansi32"
>Call: </span>(338) [system] sig_atomic(system:'$notrace'(_489752, _489754))
^  <span class="ansi1 ansi32"
>Exit: </span>(337) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(6<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404938, _404938+1), (retval(fail)\=@=retval(fail), nonvar(_375496)->indentq(6, _404938, <--, [e, _375496]);indentq(6, _404938, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(334) [system] ignore(user:(_376610==1->ignore(\+ \+ (flag(eval_num, _404938, _404938+1), (retval(fail)\=@=retval(fail), nonvar(_375496)->indentq(6, _404938, <--, [e, _375496]);indentq(6, _404938, <--, [e, retval(fail)]))));notrace(ignore(if_t(6<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404938, _404938+1), (retval(fail)\=@=retval(fail), nonvar(_375496)->indentq(6, _404938, <--, [e, _375496]);indentq(6, _404938, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(332) [system] call_cleanup(user:((call(eval_20(=, _337590), 493, '&self', [let, a, b, 'never-happens'], _375496)*->nb_setarg(1, retval(fail), _375496);fail, trace, call(eval_20(=, _337590), 493, '&self', [let, a, b, 'never-happens'], _375496)), ignore(notrace((\+_375496\=_376740, nb_setarg(1, retval(fail), _375496))))), user:ignore((_376610==1->ignore(\+ \+ (flag(eval_num, _404938, _404938+1), (retval(fail)\=@=retval(fail), nonvar(_375496)->indentq(6, _404938, <--, [e, _375496]);indentq(6, _404938, <--, [e, retval(fail)]))));notrace(ignore(if_t(6<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404938, _404938+1), (retval(fail)\=@=retval(fail), nonvar(_375496)->indentq(6, _404938, <--, [e, _375496]);indentq(6, _404938, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(331) [user] trace_eval(eval_20(=, _337590), e, 493, '&self', [let, a, b, 'never-happens'], _375496)
^  <span class="ansi1 ansi31"
>Fail: </span>(328) [user] eval_args(=, _337590, 494, '&self', [let, a, b, 'never-happens'], _339264)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] call(eval, [let, a, b, 'never-happens'], _339264)
   <span class="ansi1 ansi32"
>Call: </span>(326) [user] eval([let, a, b, 'never-happens'], _339264)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] current_self(_499160)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] nb_current(self_space, _499160)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(327) [user] eval('&self', [let, a, b, 'never-happens'], _339264)
   <span class="ansi1 ansi32"
>Call: </span>(328) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _339264)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] catch_metta_return(eval_args(=, _507274, 500, '&self', [let, a, b, 'never-happens'], _339264), _339264)
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] eval_args(=, _507274, 500, '&self', [let, a, b, 'never-happens'], _339264)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(333) [system] setup_call_cleanup('$notrace'(_510384, _510386), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_510384, _510386))
^  <span class="ansi1 ansi32"
>Call: </span>(334) [system] sig_atomic(system:'$notrace'(_510384, _510386))
^  <span class="ansi1 ansi32"
>Call: </span>(333) [system] setup_call_cleanup('$notrace'(_512472, _512474), once(user:nonvar(_339264)), '$restore_trace'(_512472, _512474))
^  <span class="ansi1 ansi32"
>Call: </span>(334) [system] sig_atomic(system:'$notrace'(_512472, _512474))
^  <span class="ansi1 ansi32"
>Call: </span>(333) [system] setup_call_cleanup('$notrace'(_514560, _514562), once(user:nonvar(_339264)), '$restore_trace'(_514560, _514562))
^  <span class="ansi1 ansi32"
>Call: </span>(334) [system] sig_atomic(system:'$notrace'(_514560, _514562))
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(332) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(334) [system] setup_call_cleanup('$notrace'(_521716, _521718), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_521716, _521718))
^  <span class="ansi1 ansi32"
>Call: </span>(335) [system] sig_atomic(system:'$notrace'(_521716, _521718))
^  <span class="ansi1 ansi31"
>Fail: </span>(332) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(332) [user] eval_00(=, _507274, 500, '&self', [let, a, b, 'never-happens'], _339264)
^  <span class="ansi1 ansi32"
>Call: </span>(333) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(335) [system] setup_call_cleanup('$notrace'(_526860, _526862), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_526860, _526862))
^  <span class="ansi1 ansi32"
>Call: </span>(336) [system] sig_atomic(system:'$notrace'(_526860, _526862))
^  <span class="ansi1 ansi31"
>Fail: </span>(333) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(333) [user] eval_01(=, _507274, 500, '&self', [let, a, b, 'never-happens'], _339264)
^  <span class="ansi1 ansi32"
>Call: </span>(334) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(336) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(334) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(335) [system] setup_call_cleanup('$notrace'(_535096, _535098), once(user:(_535072 is 500-1, copy_term([let, a, b, 'never-happens'], _535086))), '$restore_trace'(_535096, _535098))
^  <span class="ansi1 ansi32"
>Call: </span>(336) [system] sig_atomic(system:'$notrace'(_535096, _535098))
^  <span class="ansi1 ansi32"
>Exit: </span>(335) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(334) [user] trace_eval(eval_20(=, _507274), e, 499, '&self', [let, a, b, 'never-happens'], _538206)
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] must_det_ll((notrace((flag(eval_num, _539260, _539260+1), _539278 is _539260 mod 500, _539296 is 99-499 mod 100, _539320=_539322, option_else('trace-length', _539334, 500), option_else('trace-depth', _539342, 30))), quietly(if_t((nop(stop_rtrace), _539278>_539334), (set_debug(eval, false), _539398 is _539334+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539398])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_539450)))))
^  <span class="ansi1 ansi32"
>Call: </span>(336) [user] once(user:(notrace((flag(eval_num, _539260, _539260+1), _539278 is _539260 mod 500, _539296 is 99-499 mod 100, _539320=_539322, option_else('trace-length', _539334, 500), option_else('trace-depth', _539342, 30))), quietly(if_t((nop(stop_rtrace), _539278>_539334), (set_debug(eval, false), _539398 is _539334+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539398])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_539450)))))
^  <span class="ansi1 ansi32"
>Call: </span>(339) [system] setup_call_cleanup('$notrace'(_541496, _541498), once(user:(flag(eval_num, _539260, _539260+1), _539278 is _539260 mod 500, _539296 is 99-499 mod 100, _539320=_539322, option_else('trace-length', _539334, 500), option_else('trace-depth', _539342, 30))), '$restore_trace'(_541496, _541498))
^  <span class="ansi1 ansi32"
>Call: </span>(340) [system] sig_atomic(system:'$notrace'(_541496, _541498))
^  <span class="ansi1 ansi32"
>Exit: </span>(339) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2061, 2061+1), 61 is 2061 mod 500, 0 is 99-499 mod 100, _539320=_539320, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(339) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 61>500), (set_debug(eval, false), _539398 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539398])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(339) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 61>500), (set_debug(eval, false), _539398 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539398])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(338) [user] nop(notrace(no_repeats_var(_539450)))
   <span class="ansi1 ansi32"
>Exit: </span>(338) [user] nop(notrace(no_repeats_var(_539450)))
^  <span class="ansi1 ansi32"
>Exit: </span>(336) [system] once(user:(notrace((flag(eval_num, 2061, 2061+1), 61 is 2061 mod 500, 0 is 99-499 mod 100, _539320=_539320, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 61>500), (set_debug(eval, false), _539398 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539398])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_539450)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(335) [user] must_det_ll(user:(notrace((flag(eval_num, 2061, 2061+1), 61 is 2061 mod 500, 0 is 99-499 mod 100, _539320=_539320, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 61>500), (set_debug(eval, false), _539398 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_539398])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_539450)))))
   <span class="ansi1 ansi32"
>Call: </span>(335) [occurs] occurs:sub_term(_551148, e)
   <span class="ansi1 ansi32"
>Exit: </span>(335) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(335) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(336) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(336) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(335) [occurs] occurs:sub_term(_551148, e)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] _558254=e
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] if_trace((eval;e), (_539320=1, indentq(0, 61, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(337) [system] setup_call_cleanup('$notrace'(_561394, _561396), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _539320=1, indentq(0, 61, -->, [e, [let, a, b, 'never-happens']]))), _561352, fbug((_561352-->if_trace((eval;e), (_539320=1, indentq(0, 61, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_561394, _561396))
^  <span class="ansi1 ansi32"
>Call: </span>(338) [system] sig_atomic(system:'$notrace'(_561394, _561396))
^  <span class="ansi1 ansi32"
>Exit: </span>(337) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _539320=1, indentq(0, 61, -->, [e, [let, a, b, 'never-happens']]))), _561352, fbug((_561352-->if_trace((eval;e), (_539320=1, indentq(0, 61, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(335) [user] if_trace((eval;e), (_539320=1, indentq(0, 61, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] _565590=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(335) [system] _567628=(\+ \+ (flag(eval_num, _567648, _567648+1), (retval(fail)\=@=retval(fail), nonvar(_538206)->indentq(0, _567648, <--, [e, _538206]);indentq(0, _567648, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(335) [system] (\+ \+ (flag(eval_num, _567648, _567648+1), (retval(fail)\=@=retval(fail), nonvar(_538206)->indentq(0, _567648, <--, [e, _538206]);indentq(0, _567648, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _567648, _567648+1), (retval(fail)\=@=retval(fail), nonvar(_538206)->indentq(0, _567648, <--, [e, _538206]);indentq(0, _567648, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(335) [user] call_cleanup(((call(eval_20(=, _507274), 499, '&self', [let, a, b, 'never-happens'], _538206)*->nb_setarg(1, retval(fail), _538206);fail, trace, call(eval_20(=, _507274), 499, '&self', [let, a, b, 'never-happens'], _538206)), ignore(notrace((\+_538206\=_539450, nb_setarg(1, retval(fail), _538206))))), ignore((_539320==1->ignore(\+ \+ (flag(eval_num, _567648, _567648+1), (retval(fail)\=@=retval(fail), nonvar(_538206)->indentq(0, _567648, <--, [e, _538206]);indentq(0, _567648, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567648, _567648+1), (retval(fail)\=@=retval(fail), nonvar(_538206)->indentq(0, _567648, <--, [e, _538206]);indentq(0, _567648, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(337) [user] eval_20(=, _507274, 499, '&self', [let, a, b, 'never-happens'], _538206)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(338) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(339) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(341) [system] setup_call_cleanup('$notrace'(_575036, _575038), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_575036, _575038))
^  <span class="ansi1 ansi32"
>Call: </span>(342) [system] sig_atomic(system:'$notrace'(_575036, _575038))
^  <span class="ansi1 ansi31"
>Fail: </span>(339) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(339) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(339) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(339) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(340) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(338) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(338) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(338) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(338) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(338) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(338) [user] once(expand_eval([let, a, b, 'never-happens'], _597380))
^  <span class="ansi1 ansi32"
>Call: </span>(339) [user] expand_eval([let, a, b, 'never-happens'], _597380)
   <span class="ansi1 ansi32"
>Call: </span>(340) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(340) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(340) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(340) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(340) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _603480)
   <span class="ansi1 ansi32"
>Call: </span>(341) [apply] apply:maplist_([a, b, 'never-happens'], _603480, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(342) [user] expand_eval(a, _605536)
   <span class="ansi1 ansi32"
>Call: </span>(343) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(343) [system] a=_605536
   <span class="ansi1 ansi32"
>Exit: </span>(343) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(342) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(342) [apply] apply:maplist_([b, 'never-happens'], _605538, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(343) [user] expand_eval(b, _611638)
   <span class="ansi1 ansi32"
>Call: </span>(344) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(344) [system] b=_611638
   <span class="ansi1 ansi32"
>Exit: </span>(344) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(343) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(343) [apply] apply:maplist_(['never-happens'], _611640, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(344) [user] expand_eval('never-happens', _617740)
   <span class="ansi1 ansi32"
>Call: </span>(345) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(345) [system] 'never-happens'=_617740
   <span class="ansi1 ansi32"
>Exit: </span>(345) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(344) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(344) [apply] apply:maplist_([], _617742, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(344) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(343) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(342) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(341) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(340) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(339) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(338) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(338) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(339) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(338) [user] possible_type('&self', a, _635032)
^  <span class="ansi1 ansi32"
>Exit: </span>(338) [user] possible_type('&self', a, _635032)
^  <span class="ansi1 ansi32"
>Call: </span>(338) [user] eval_args(=, _635032, 499, '&self', b, _637074)
   <span class="ansi1 ansi32"
>Call: </span>(339) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(340) [system] setup_call_cleanup('$notrace'(_639132, _639134), once(user:self_eval(b)), '$restore_trace'(_639132, _639134))
^  <span class="ansi1 ansi32"
>Call: </span>(341) [system] sig_atomic(system:'$notrace'(_639132, _639134))
^  <span class="ansi1 ansi32"
>Exit: </span>(340) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(339) [system] _637074=b
   <span class="ansi1 ansi32"
>Exit: </span>(339) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(338) [user] eval_args(=, _635032, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(338) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(337) [user] eval_20(=, _507274, 499, '&self', [let, a, b, 'never-happens'], _538206)
   <span class="ansi1 ansi32"
>Call: </span>(337) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(337) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(337) [user] ignore((_539320==1->ignore(\+ \+ (flag(eval_num, _567648, _567648+1), (retval(fail)\=@=retval(fail), nonvar(_538206)->indentq(0, _567648, <--, [e, _538206]);indentq(0, _567648, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567648, _567648+1), (retval(fail)\=@=retval(fail), nonvar(_538206)->indentq(0, _567648, <--, [e, _538206]);indentq(0, _567648, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(339) [system] _539320==1
   <span class="ansi1 ansi31"
>Fail: </span>(339) [system] _539320==1
^  <span class="ansi1 ansi32"
>Call: </span>(340) [system] setup_call_cleanup('$notrace'(_652462, _652464), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567648, _567648+1), (retval(fail)\=@=retval(fail), nonvar(_538206)->indentq(0, _567648, <--, [e, _538206]);indentq(0, _567648, <--, [e, retval(fail)])))))))), '$restore_trace'(_652462, _652464))
^  <span class="ansi1 ansi32"
>Call: </span>(341) [system] sig_atomic(system:'$notrace'(_652462, _652464))
^  <span class="ansi1 ansi32"
>Exit: </span>(340) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567648, _567648+1), (retval(fail)\=@=retval(fail), nonvar(_538206)->indentq(0, _567648, <--, [e, _538206]);indentq(0, _567648, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(337) [system] ignore(user:(_539320==1->ignore(\+ \+ (flag(eval_num, _567648, _567648+1), (retval(fail)\=@=retval(fail), nonvar(_538206)->indentq(0, _567648, <--, [e, _538206]);indentq(0, _567648, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567648, _567648+1), (retval(fail)\=@=retval(fail), nonvar(_538206)->indentq(0, _567648, <--, [e, _538206]);indentq(0, _567648, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(335) [system] call_cleanup(user:((call(eval_20(=, _507274), 499, '&self', [let, a, b, 'never-happens'], _538206)*->nb_setarg(1, retval(fail), _538206);fail, trace, call(eval_20(=, _507274), 499, '&self', [let, a, b, 'never-happens'], _538206)), ignore(notrace((\+_538206\=_539450, nb_setarg(1, retval(fail), _538206))))), user:ignore((_539320==1->ignore(\+ \+ (flag(eval_num, _567648, _567648+1), (retval(fail)\=@=retval(fail), nonvar(_538206)->indentq(0, _567648, <--, [e, _538206]);indentq(0, _567648, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _567648, _567648+1), (retval(fail)\=@=retval(fail), nonvar(_538206)->indentq(0, _567648, <--, [e, _538206]);indentq(0, _567648, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(334) [user] trace_eval(eval_20(=, _507274), e, 499, '&self', [let, a, b, 'never-happens'], _538206)
^  <span class="ansi1 ansi31"
>Fail: </span>(331) [user] eval_args(=, _507274, 500, '&self', [let, a, b, 'never-happens'], _339264)
^  <span class="ansi1 ansi31"
>Fail: </span>(322) [system] call(user:once, user:if_or_else(eval(=, _337590, 494, '&self', [let, a, b, 'never-happens'], _339264), call(eval, [let, a, b, 'never-happens'], _339264)))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] setup_call_cleanup('$notrace'(_663924, _663926), once(rtrace:retract(t_l:tracer_reset(_663914))), '$restore_trace'(_663924, _663926))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] sig_atomic(system:'$notrace'(_663924, _663926))
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [rtrace] tAt(false, 271, 271, false)
<span class="ansi1 ansi90"
>Info: Processing progress: 100% </span><span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta progress.
</span>; 
; EVAL TEST
; took 4.38 seconds.

!(assertEqual (== (let* (($x (collapse (get-atoms &m))) ($y (car-atom $x))) (get-type $y)) (get-type &self)) False)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (False) (False)))
</span>
Deterministic: ()
;;; Let's check that `if` from stdlib is not duplicated and gives only one result
<span class="ansi38-013099040"
>!(assertEqual (if (> 1 2) 1 2) 2)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.13"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.13</h3>
; 
; EVAL TEST
; took 0.000242 secs. (241.69 microseconds) 

!(assertEqual (if (> 1 2) 1 2) 2)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (2) (2)))
</span>
Deterministic: ()
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Let's import one more module into `&self` with a diamond dependence
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleB.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta is 288 bytes (7 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta is 291 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Numer))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (g $x) (+ $x 10)))
</span>
Last Result(2): ()
;;; `g` from moduleC imported via two paths as well as `f`, which uses `g`,
;;; are not duplicated and produce deterministic results
<span class="ansi38-013099040"
>!(assertEqual (g 2) 102)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.14"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.14</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.05 milliseconds) 

!(assertEqual (g 2) 102)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102) (102)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (f 2) 103)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.15"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.15</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.33 milliseconds) 

!(assertEqual (f 2) 103)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (103) (103)))
</span>
Deterministic: ()
;;; Function declared in different imported modules will still produce
;;; non-deterministic results
<span class="ansi38-013099040"
>!(assertEqualToResult (dup 2) (12 102))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.16"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.16</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.99 milliseconds) 

!(assertEqualToResult (dup 2) (12 102))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102 12) (12 102)))
</span>
Deterministic: ()
;;; Let's import f1_moduleB.metta once more using a different path.
;;; Such import should be ignored and thus f, g and dup should remain
;;; unchanged.
<span class="ansi38-013099040"
>!(import! &self ../hyperon-experimental_scripts/f1_moduleB.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta is 288 bytes (7 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleB.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC.metta)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta is 291 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Numer))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (g $x) (+ $x 10)))
</span>
Last Result(2): ()
<span class="ansi38-013099040"
>!(assertEqual (g 2) 102)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.17"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.17</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.04 milliseconds) 

!(assertEqual (g 2) 102)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102) (102)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (f 2) 103)

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.18"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.18</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.30 milliseconds) 

!(assertEqual (f 2) 103)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (103) (103)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqualToResult (dup 2) (12 102))

</span>
;<h3 id="HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.19"
>;; HYPERON-EXPERIMENTAL-SCRIPTS.F1-IMPORTS.19</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.03 milliseconds) 

!(assertEqualToResult (dup 2) (12 102))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102 12) (12 102)))
</span>
Deterministic: ()<span class="ansi32"
>
% 43,272,963 inferences, 10.403 CPU in 10.426 seconds (100% CPU, 4159506 Lips)
</span>P;HTML|
;                       (= /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta  0)
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 17
</span><span class="ansi31"
>Failures: 2
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
P;HTML|
;         (is_cmd_option  execute halt --halt=true true)
P;HTML|
;          (set_option_value  halt true)
P;HTML|
;          (is_cmd_option  execute stdin --stdin=tty tty)
P;HTML|
;          (set_option_value  stdin tty)
P;HTML|
;          (is_cmd_option  execute stdout --stdout=tty tty)
P;HTML|
;           (set_option_value  stdout tty)
P;HTML|
;          (is_cmd_option  execute stderr --stderr=tty tty)
P;HTML|
;           (set_option_value  stderr tty)
P;HTML|
;         (set_option_value  compat false)
P;HTML|
;         (set_option_value  compatio false)
P;HTML|
;         (set_option_value  src_indents false)
P;HTML|
;         (set_option_value  devel false)
P;HTML|
;         (set_option_value  stack-max 500)
P;HTML|
;         (set_option_value  limit inf)
P;HTML|
;         (set_option_value  initial-result-count 10)
P;HTML|
;         (set_option_value  answer-format show)
P;HTML|
;         (set_option_value  repeats true)
P;HTML|
;         (set_option_value  time true)
P;HTML|
;         (set_option_value  synth-unit-tests false)
P;HTML|
;         (set_option_value  optimize true)
P;HTML|
;         (set_option_value  transpiler silent)
P;HTML|
;          (set_debug  transpiler false)
P;HTML|
;         (set_option_value  compile false)
P;HTML|
;         (set_option_value  tabling auto)
P;HTML|
;         (set_option_value  log false)
P;HTML|
;         (set_option_value  output ./)
P;HTML|
;         (set_option_value  exeout ./Sav.gitlab.MeTTaLog)
P;HTML|
;         (set_option_value  halt false)
P;HTML|
;         (set_option_value  trace-length 500)
P;HTML|
;         (set_option_value  trace-on-overtime 4.0)
P;HTML|
;          (set_debug  overtime 4.0)
P;HTML|
;         (set_option_value  trace-on-overflow 1000)
P;HTML|
;          (set_debug  overflow 1000)
P;HTML|
;         (set_option_value  trace-on-eval false)
P;HTML|
;          (set_debug  eval false)
P;HTML|
;         (set_option_value  trace-on-load silent)
P;HTML|
;          (set_debug  load silent)
P;HTML|
;          (set_debug  trace-on-load false)
P;HTML|
;         (set_option_value  trace-on-exec false)
P;HTML|
;          (set_debug  exec false)
P;HTML|
;         (set_option_value  trace-on-error non-type)
P;HTML|
;          (set_debug  error non-type)
P;HTML|
;         (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;         (set_option_value  trace-on-test true)
P;HTML|
;          (set_debug  test true)
P;HTML|
;         (set_option_value  repl-on-error true)
P;HTML|
;         (set_option_value  repl-on-fail false)
P;HTML|
;         (set_option_value  exit-on-fail false)
P;HTML|
;         (set_option_value  repl auto)
P;HTML|
;         (set_option_value  prolog false)
P;HTML|
;         (set_option_value  exec noskip)
P;HTML|
;         (set_option_value  maximum-result-count inf)
P;HTML|
;         (set_option_value  html false)
P;HTML|
;         (set_option_value  python true)
P;HTML|
;         (set_option_value  trace-on-test false)
P;HTML|
;          (set_debug  test false)
P;HTML|
;         (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;         (set_option_value  load show)
P;HTML|
;         (set_option_value  test true)
[()]
[((Error  (got  ((hyperon::space::DynSpace) (hyperon::space::DynSpace) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()))) (expected  ((hyperon::space::DynSpace)))))]
[()]
[()]
[()]
[()]
[()]
[()]
[((Error  (got  (&m)) (expected  ((: __g (-> Number))))))]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
P;HTML|
;         (maybe_halt  7)
<span class="ansi31"
>(in  (maybe_halt  7) (unwind  (halt  7)))
</span>
Script done on 2024-11-23 13:32:21+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat/' --timeout=40 --html --repl=false  --test "tests/baseline_compat/hyperon-experimental_scripts/f1_imports.metta" --halt=true\033[0m
