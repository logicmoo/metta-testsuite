<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi36 { color: #00aaaa; }
.ansi90 { color: #7f7f7f; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-12-01 11:00:13+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
^@
/*
P;HTML|
;           #(set_option_value compat false)

P;HTML|
;           #(set_option_value compatio false)

P;HTML|
;           #(set_option_value src_indents false)

P;HTML|
;         #(set_option_value devel false)

P;HTML|
;         #(set_option_value stack-max 500)

P;HTML|
;         #(set_option_value limit inf)

P;HTML|
;         #(set_option_value initial-result-count 10)

P;HTML|
;         #(set_option_value answer-format show)

P;HTML|
;         #(set_option_value repeats true)

P;HTML|
;         #(set_option_value time true)

P;HTML|
;         #(set_option_value synth-unit-tests false)

P;HTML|
;         #(set_option_value optimize true)

P;HTML|
;         #(set_option_value transpiler silent)

P;HTML|
;          #(set_debug transpiler false)

P;HTML|
;         #(set_option_value compile false)

P;HTML|
;         #(set_option_value tabling auto)

P;HTML|
;         #(set_option_value log false)

P;HTML|
;         #(set_option_value output ./)

P;HTML|
;         #(set_option_value exeout ./Sav.gitlab.MeTTaLog)

P;HTML|
;         #(set_option_value halt false)

P;HTML|
;         #(set_option_value trace-length 500)

P;HTML|
;         #(set_option_value trace-on-overtime 4.0)

P;HTML|
;          #(set_debug overtime 4.0)

P;HTML|
;         #(set_option_value trace-on-overflow 1000)

P;HTML|
;          #(set_debug overflow 1000)

P;HTML|
;         #(set_option_value trace-on-eval false)

P;HTML|
;          #(set_debug eval false)

P;HTML|
;         #(set_option_value trace-on-load silent)

P;HTML|
;          #(set_debug load silent)

P;HTML|
;          #(set_debug trace-on-load false)

P;HTML|
;         #(set_option_value trace-on-exec false)

P;HTML|
;          #(set_debug exec false)

P;HTML|
;         #(set_option_value trace-on-error non-type)

P;HTML|
;          #(set_debug error non-type)

P;HTML|
;         #(set_option_value trace-on-fail false)

P;HTML|
;          #(set_debug fail false)

P;HTML|
;         #(set_option_value trace-on-test true)

P;HTML|
;          #(set_debug test true)

P;HTML|
;         #(set_option_value repl-on-error true)

P;HTML|
;         #(set_option_value repl-on-fail false)

P;HTML|
;         #(set_option_value exit-on-fail false)

P;HTML|
;         #(set_option_value repl auto)

P;HTML|
;         #(set_option_value prolog false)

P;HTML|
;         #(set_option_value exec noskip)

P;HTML|
;         #(set_option_value maximum-result-count inf)

P;HTML|
;         #(set_option_value html false)

P;HTML|
;         #(set_option_value python true)

P;HTML|
;         #(set_option_value trace-on-test false)

P;HTML|
;         #(set_debug test false)

P;HTML|
;         #(set_option_value trace-on-fail false)

P;HTML|
;         #(set_debug fail false)

P;HTML|
;         #(set_option_value load show)

P;HTML|
;         #(set_option_value test false)
<span class="ansi31"
>
Warning: /home/runner/work/metta-wam/metta-wam/src/canary/metta_interp.pl:1856:
Warning:    Singleton variables: [StackMax,Self,Term,X]
</span><span class="ansi32"
>% 23,950 inferences, 0.005 CPU in 0.005 seconds (100% CPU, 4614788 Lips)
</span>P;HTML|
;          #(is_cmd_option prescan halt --halt=true true)
P;HTML|
;          #(set_option_value halt true)
P;HTML|
;          #(is_cmd_option prescan stdin --stdin=tty tty)
P;HTML|
;           #(set_option_value stdin tty)
P;HTML|
;          #(is_cmd_option prescan stdout --stdout=tty tty)
P;HTML|
;           #(set_option_value stdout tty)
P;HTML|
;          #(is_cmd_option prescan stderr --stderr=tty tty)
P;HTML|
;           #(set_option_value stderr tty)
P;HTML|
;          #(set_option_value compat false)
P;HTML|
;          #(set_option_value compatio false)
P;HTML|
;          #(set_option_value src_indents false)
P;HTML|
;          #(set_option_value devel false)
P;HTML|
;          #(set_option_value stack-max 500)
P;HTML|
;          #(set_option_value limit inf)
P;HTML|
;          #(set_option_value initial-result-count 10)
P;HTML|
;          #(set_option_value answer-format show)
P;HTML|
;          #(set_option_value repeats true)
P;HTML|
;          #(set_option_value time true)
P;HTML|
;          #(set_option_value synth-unit-tests false)
P;HTML|
;          #(set_option_value optimize true)
P;HTML|
;          #(set_option_value transpiler silent)
P;HTML|
;          #(set_debug transpiler false)
P;HTML|
;          #(set_option_value compile false)
P;HTML|
;          #(set_option_value tabling auto)
P;HTML|
;          #(set_option_value log false)
P;HTML|
;          #(set_option_value output ./)
P;HTML|
;          #(set_option_value exeout ./Sav.gitlab.MeTTaLog)
P;HTML|
;          #(set_option_value halt false)
P;HTML|
;          #(set_option_value trace-length 500)
P;HTML|
;          #(set_option_value trace-on-overtime 4.0)
P;HTML|
;          #(set_debug overtime 4.0)
P;HTML|
;          #(set_option_value trace-on-overflow 1000)
P;HTML|
;          #(set_debug overflow 1000)
P;HTML|
;          #(set_option_value trace-on-eval false)
P;HTML|
;          #(set_debug eval false)
P;HTML|
;          #(set_option_value trace-on-load silent)
P;HTML|
;          #(set_debug load silent)
P;HTML|
;          #(set_debug trace-on-load false)
P;HTML|
;          #(set_option_value trace-on-exec false)
P;HTML|
;          #(set_debug exec false)
P;HTML|
;          #(set_option_value trace-on-error non-type)
P;HTML|
;          #(set_debug error non-type)
P;HTML|
;          #(set_option_value trace-on-fail false)
P;HTML|
;          #(set_debug fail false)
P;HTML|
;          #(set_option_value trace-on-test true)
P;HTML|
;          #(set_debug test true)
P;HTML|
;          #(set_option_value repl-on-error true)
P;HTML|
;          #(set_option_value repl-on-fail false)
P;HTML|
;          #(set_option_value exit-on-fail false)
P;HTML|
;          #(set_option_value repl auto)
P;HTML|
;          #(set_option_value prolog false)
P;HTML|
;          #(set_option_value exec noskip)
P;HTML|
;          #(set_option_value maximum-result-count inf)
P;HTML|
;          #(set_option_value html false)
P;HTML|
;          #(set_option_value python true)
P;HTML|
;         #(set_option_value trace-on-test false)
P;HTML|
;          #(set_debug test false)
P;HTML|
;         #(set_option_value trace-on-fail false)
P;HTML|
;          #(set_debug fail false)
P;HTML|
;         #(set_option_value load show)
P;HTML|
;         #(set_option_value test true)
P;HTML|
;        #(is_cmd_option execute python --python=enable enable)
P;HTML|
;         #(set_option_value python enable)
P;HTML|
;        #(is_cmd_option execute timeout --timeout=40 40)
P;HTML|
;         #(set_option_value timeout 40)
P;HTML|
;         #(is_cmd_option execute output --output=./reports/tests_output/baseline-compat/ ./reports/tests_output/baseline-compat/)
P;HTML|
;         #(set_option_value output ./reports/tests_output/baseline-compat/)
P;HTML|
;         #(is_cmd_option execute html --html true)
P;HTML|
;          #(set_option_value html true)
P;HTML|
;         #(is_cmd_option execute test --test true)
P;HTML|
;          #(set_option_value test true)

; #( : user #(load_metta_file &self tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta) )
P;HTML|
;                       #(track_load_into_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta)
P;HTML|
;                                        #(load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta)
P;HTML|
;                                         #( = 1 "[()]" )
P;HTML|
;                                         #( = 2 "[()]" )
P;HTML|
;                                         #( = 3 "[()]" )
P;HTML|
;                                         #( = 4 "[()]" )
P;HTML|
;                                         #( = 5 "[()]" )
P;HTML|
;                                         #( = 6 "[()]" )
P;HTML|
;                                         #( = 7 "[()]" )
P;HTML|
;                                         #( = 8 "[()]" )
P;HTML|
;                                         #( = 9 "[()]" )
P;HTML|
;                                         #( = 10 "[()]" )
P;HTML|
;                                         #( = 11 "[(Error (assertEqualToResult (superpose ((nop 1))) ()) " )
P;HTML|
;                                         #( = 11 "Expected: []" )
P;HTML|
;                                         #( = 11 "Got: [()]" )
P;HTML|
;                                         #( = 12 "Excessive result: ())]" )
P;HTML|
;                                         #( = 12 "0.05user 0.00system 0:00.06elapsed 97%CPU (0avgtext+0avgdata 30948maxresident)k" )
P;HTML|
;                                         #( = 12 "0inputs+0outputs (0major+3671minor)pagefaults 0swaps" )
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta is 1.97K bytes (116 lines)
</span>P;HTML|
;                                        #(load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta)

;;; cases are processed sequentially
```
```metta
*/

<span class="ansi38-013099040"
>!(assertEqual (+ 1 (superpose (1 2 3))) (+ 1 (superpose (1 2 3))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.01"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.01</h3>
; 
; EVAL TEST
; took 0.000674 secs. (674.11 microseconds) 

!(assertEqual (+ 1 (superpose (1 2 3))) (+ 1 (superpose (1 2 3))))

<span class="ansi36"
>#(loonit_success #(equal_enough_for_test (2 3 4) (2 3 4)))
</span>
/*
```
```answers

Deterministic: <span class="ansi33"
>()
</span>```
```metta
*/

<span class="ansi38-013099040"
>!(assertEqual (+ 1 (superpose (1 2 3))) (+ 1 (superpose (1 (superpose (2 3))))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.02"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.02</h3>
; 
; EVAL TEST
; took 0.000838 secs. (837.77 microseconds) 

!(assertEqual (+ 1 (superpose (1 2 3))) (+ 1 (superpose (1 (superpose (2 3))))))

<span class="ansi36"
>#(loonit_success #(equal_enough_for_test (2 3 4) (2 3 4)))
</span>
/*
```
```answers

Deterministic: <span class="ansi33"
>()
</span>```
```metta
*/

<span class="ansi38-013099040"
>!(assertEqual ((superpose (1 2 3))) ((superpose (1 (superpose ((+ 1 1) 3))))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.03"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.03</h3>
; 
; EVAL TEST
; took 0.000906 secs. (906.47 microseconds) 

!(assertEqual ((superpose (1 2 3))) ((superpose (1 (superpose ((+ 1 1) 3))))))

<span class="ansi36"
>#(loonit_success #(equal_enough_for_test ((1) (2) (3)) ((1) (2) (3))))
</span>
/*
```
```answers

Deterministic: <span class="ansi33"
>()
</span>;;; cases are processed sequentially
```
```metta
*/

<span class="ansi38-013099040"
>!(assertEqual (case (+ 1 5) ((5 Error) (6 OK) (6 Error))) OK)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.04"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.04</h3>
; 
; EVAL TEST
; took 0.000307 secs. (307.13 microseconds) 

!(assertEqual (case (+ 1 5) ((5 Error) (6 OK) (6 Error))) OK)

<span class="ansi36"
>#(loonit_success #(equal_enough_for_test (OK) (OK)))
</span>
/*
```
```answers

Deterministic: <span class="ansi33"
>()
</span>;;; we can use variables as cases
```
```metta
*/

<span class="ansi38-013099040"
>!(assertEqual (case (+ 1 5) (($x (+ 1 $x)))) 7)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.05"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.05</h3>
; 
; EVAL TEST
; took 0.000441 secs. (441.28 microseconds) 

!(assertEqual (case (+ 1 5) (($x (+ 1 $x)))) 7)

<span class="ansi36"
>#(loonit_success #(equal_enough_for_test (7) (7)))
</span>
/*
```
```answers

Deterministic: <span class="ansi33"
>()
</span>;;; cases are not necessarily exhaustive,
;;; and the result can be empty
```
```metta
*/

<span class="ansi38-013099040"
>!(assertEqual (case 5 ((6 OK))) (superpose ()))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.06"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.06</h3>
; 
; EVAL TEST
; took 0.000275 secs. (274.82 microseconds) 

!(assertEqual (case 5 ((6 OK))) (superpose ()))

<span class="ansi36"
>#(loonit_success #(equal_enough_for_test () ()))
</span>
/*
```
```answers

Deterministic: <span class="ansi33"
>()
</span>;;; it is non-deterministic: each value is matched against all cases
```
```metta
*/

<span class="ansi38-013099040"
>!(assertEqual (case (+ 1 (superpose (1 2 3))) ((3 OK-3) (4 OK-4))) (superpose (OK-3 OK-4)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.07"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.07</h3>
; 
; EVAL TEST
; took 0.000749 secs. (748.82 microseconds) 

!(assertEqual (case (+ 1 (superpose (1 2 3))) ((3 OK-3) (4 OK-4))) (superpose (OK-3 OK-4)))

<span class="ansi36"
>#(loonit_success #(equal_enough_for_test (OK-3 OK-4) (OK-3 OK-4)))
</span>
/*
```
```answers

Deterministic: <span class="ansi33"
>()
</span>;;; one case can produce multiple results
```
```metta
*/

<span class="ansi38-013099040"
>!(assertEqual (case (+ 1 (superpose (1 2 3))) (($x (+ 1 $x)))) (superpose (3 4 5)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.08"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.08</h3>
; 
; EVAL TEST
; took 0.000741 secs. (741.32 microseconds) 

!(assertEqual (case (+ 1 (superpose (1 2 3))) (($x (+ 1 $x)))) (superpose (3 4 5)))

<span class="ansi36"
>#(loonit_success #(equal_enough_for_test (3 4 5) (3 4 5)))
</span>
/*
```
```answers

Deterministic: <span class="ansi33"
>()
</span>```
```metta
*/

<span class="ansi38-013099040"
>!(assertEqualToResult (superpose ()) ())

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.09"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.09</h3>
; 
; EVAL TEST
; took 0.000133 secs. (133.32 microseconds) 

!(assertEqualToResult (superpose ()) ())

<span class="ansi36"
>#(loonit_success #(equal_enough_for_test () ()))
</span>
/*
```
```answers

Deterministic: <span class="ansi33"
>()
</span>```
```metta
*/

<span class="ansi38-013099040"
>!(assertEqualToResult (collapse (superpose ())) (()))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.10"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.10</h3>
; 
; EVAL TEST
; took 0.000237 secs. (237.03 microseconds) 

!(assertEqualToResult (collapse (superpose ())) (()))

<span class="ansi36"
>#(loonit_success #(equal_enough_for_test (()) (())))
</span>
/*
```
```answers

Deterministic: <span class="ansi33"
>()
</span>```
```metta
*/

<span class="ansi38-013099040"
>!(assertEqualToResult (superpose ((nop 1))) ())

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.11"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.11</h3>
; 
; EVAL TEST
; took 0.000246 secs. (245.84 microseconds) 

!(assertEqualToResult (superpose ((nop 1))) ())

<span class="ansi36"
>#(loonit_success #(equal_enough_for_test (()) ()))
</span>
/*
```
```answers

Deterministic: <span class="ansi33"
>()
</span>```
```metta
*/

<span class="ansi38-013099040"
>!(assertEqualToResult (collapse (superpose ((nop 1)))) (()))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.12"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.12</h3>
; 
; EVAL TEST
; took 0.000422 secs. (422.12 microseconds) 

!(assertEqualToResult (collapse (superpose ((nop 1)))) (()))

<span class="ansi36"
>#(loonit_success #(equal_enough_for_test ((())) (())))
</span>
/*
```
```answers

Deterministic: <span class="ansi33"
>()
</span>```
```metta
*/

<span class="ansi38-255165000"
> (= (Rel-P P P P)  10)
</span>
/*
```
```load
```
```metta
*/

<span class="ansi38-255165000"
> (Rel-P A B)
</span>
/*
```
```load
```
```metta
*/

<span class="ansi38-255165000"
> (Rel-Q A C)
</span>
/*
```
```load
```
```metta
*/

<span class="ansi38-013099040"
>!(match &self $1 $1)

</span>
/*
```
```answers

NDet Result(1): <span class="ansi33"
>&corelib
</span>$1 = &corelib

NDet Result(2): <span class="ansi33"
>&stdlib
</span>$1 = &stdlib

NDet Result(3): <span class="ansi33"
>(= (Rel-P P P P)  10)
</span>$1 = (= (Rel-P P P P)  10)

NDet Result(4): <span class="ansi33"
>(Rel-P A B)
</span>$1 = (Rel-P A B)

NDet Result(5): <span class="ansi33"
>(Rel-Q A C)
</span>$1 = (Rel-Q A C)

NDet Result(6): <span class="ansi33"
>(@doc Any (@desc "The universal type; any value belongs to this type."))
</span>$1 = (@doc Any (@desc "The universal type; any value belongs to this type."))

NDet Result(7): <span class="ansi33"
>(: Any Type)
</span>$1 = (: Any Type)

NDet Result(8): <span class="ansi33"
>(@doc Atom (@desc "Type representing any atom."))
</span>$1 = (@doc Atom (@desc "Type representing any atom."))

NDet Result(9): <span class="ansi33"
>(: Atom Type)
</span>$1 = (: Atom Type)

NDet Result(10): <span class="ansi33"
>(@doc LazyEvaluatable (@desc "A type of Atom/Value that hyperon does not implicitly evaluate"))
</span>$1 = (@doc LazyEvaluatable (@desc "A type of Atom/Value that hyperon does not implicitly evaluate"))

NDet Result(11): <span class="ansi33"
>(: LazyEvaluatable Type)
</span>$1 = (: LazyEvaluatable Type)

NDet Result(12): <span class="ansi33"
>(:> Atom LazyEvaluatable)
</span>$1 = (:> Atom LazyEvaluatable)

NDet Result(13): <span class="ansi33"
>(@doc Bool (@desc "Boolean type of True or False."))
</span>$1 = (@doc Bool (@desc "Boolean type of True or False."))

NDet Result(14): <span class="ansi33"
>(: Bool Type)
</span>$1 = (: Bool Type)

NDet Result(15): <span class="ansi33"
>(@doc LazyBool (@desc "A LazyEvaluatable that when evaluated returns True or False."))
</span>$1 = (@doc LazyBool (@desc "A LazyEvaluatable that when evaluated returns True or False."))

NDet Result(16): <span class="ansi33"
>(: LazyBool Type)
</span>$1 = (: LazyBool Type)

NDet Result(17): <span class="ansi33"
>(:> LazyBool LazyEvaluatable)
</span>$1 = (:> LazyBool LazyEvaluatable)

NDet Result(18): <span class="ansi33"
>(@doc Expression (@desc "Type representing an S-Expression, which is a combination of atoms."))
</span>$1 = (@doc Expression (@desc "Type representing an S-Expression, which is a combination of atoms."))

NDet Result(19): <span class="ansi33"
>(: Expression Type)
</span>$1 = (: Expression Type)

NDet Result(20): <span class="ansi33"
>(:> Expression LazyEvaluatable)
</span>$1 = (:> Expression LazyEvaluatable)

NDet Result(21): <span class="ansi33"
>(@doc Number (@desc "Numeric type, including integers and floating-point numbers."))
</span>$1 = (@doc Number (@desc "Numeric type, including integers and floating-point numbers."))

NDet Result(22): <span class="ansi33"
>(: Number Type)
</span>$1 = (: Number Type)

NDet Result(23): <span class="ansi33"
>(@doc hyperon::space::DynSpace (@desc "Dynamic space type, representing an Atomspace."))
</span>$1 = (@doc hyperon::space::DynSpace (@desc "Dynamic space type, representing an Atomspace."))

NDet Result(24): <span class="ansi33"
>(: hyperon::space::DynSpace Type)
</span>$1 = (: hyperon::space::DynSpace Type)

NDet Result(25): <span class="ansi33"
>(@doc ReturnType (@desc "Type representing a function's return value."))
</span>$1 = (@doc ReturnType (@desc "Type representing a function's return value."))

NDet Result(26): <span class="ansi33"
>(: ReturnType Type)
</span>$1 = (: ReturnType Type)

NDet Result(27): <span class="ansi33"
>(@doc Symbol (@desc "Type representing a symbol or identifier."))
</span>$1 = (@doc Symbol (@desc "Type representing a symbol or identifier."))

NDet Result(28): <span class="ansi33"
>(: Symbol Type)
</span>$1 = (: Symbol Type)

NDet Result(29): <span class="ansi33"
>(@doc StateMonad (@desc "Type representing a state monad, used for encapsulating stateful computations."))
</span>$1 = (@doc StateMonad (@desc "Type representing a state monad, used for encapsulating stateful computations."))

NDet Result(30): <span class="ansi33"
>(: StateMonad Type)
</span>$1 = (: StateMonad Type)

NDet Result(31): <span class="ansi33"
>(@doc Type (@desc "Type representing a type."))
</span>$1 = (@doc Type (@desc "Type representing a type."))

NDet Result(32): <span class="ansi33"
>(: Type Type)
</span>$1 = (: Type Type)

NDet Result(33): <span class="ansi33"
>(@doc True (@desc "Boolean value representing truth."))
</span>$1 = (@doc True (@desc "Boolean value representing truth."))

NDet Result(34): <span class="ansi33"
>(: True Bool)
</span>$1 = (: True Bool)

NDet Result(35): <span class="ansi33"
>(@doc False (@desc "Boolean value representing falsehood."))
</span>$1 = (@doc False (@desc "Boolean value representing falsehood."))

NDet Result(36): <span class="ansi33"
>(: False Bool)
</span>$1 = (: False Bool)

NDet Result(37): <span class="ansi33"
>(@doc %Undefined% (@desc "Special type representing an undefined value or type."))
</span>$1 = (@doc %Undefined% (@desc "Special type representing an undefined value or type."))

NDet Result(38): <span class="ansi33"
>(: %Undefined% Type)
</span>$1 = (: %Undefined% Type)

NDet Result(39): <span class="ansi33"
>(@doc Variable (@desc "Type representing a variable in the language."))
</span>$1 = (@doc Variable (@desc "Type representing a variable in the language."))

NDet Result(40): <span class="ansi33"
>(: Variable Type)
</span>$1 = (: Variable Type)

NDet Result(41): <span class="ansi33"
>(@doc : (@desc "Type declarion operator"))
</span>$1 = (@doc : (@desc "Type declarion operator"))

NDet Result(42): <span class="ansi33"
>(@doc <: (@desc "Super Type declarion operator"))
</span>$1 = (@doc <: (@desc "Super Type declarion operator"))

NDet Result(43): <span class="ansi33"
>(: : %Undefined%)
</span>$1 = (: : %Undefined%)

NDet Result(44): <span class="ansi33"
>(: if-empty (-> Atom Atom Atom Atom))
</span>$1 = (: if-empty (-> Atom Atom Atom Atom))

NDet Result(45): <span class="ansi33"
>(: if-non-empty-expression (-> Atom Atom Atom Atom))
</span>$1 = (: if-non-empty-expression (-> Atom Atom Atom Atom))

NDet Result(46): <span class="ansi33"
>(: if-not-reducible (-> Atom Atom Atom Atom))
</span>$1 = (: if-not-reducible (-> Atom Atom Atom Atom))

NDet Result(47): <span class="ansi33"
>(: return (-> Atom ReturnType))
</span>$1 = (: return (-> Atom ReturnType))

NDet Result(48): <span class="ansi33"
>(: switch (-> %Undefined% Expression Atom))
</span>$1 = (: switch (-> %Undefined% Expression Atom))

NDet Result(49): <span class="ansi33"
>(: unify (-> Atom Atom Atom Atom %Undefined%))
</span>$1 = (: unify (-> Atom Atom Atom Atom %Undefined%))

NDet Result(50): <span class="ansi33"
>(: get-type (-> Atom Type))
</span>$1 = (: get-type (-> Atom Type))

NDet Result(51): <span class="ansi33"
>(: get-type0 (-> Atom Atom))
</span>$1 = (: get-type0 (-> Atom Atom))

NDet Result(52): <span class="ansi33"
>(: get-ftype (-> Atom Atom))
</span>$1 = (: get-ftype (-> Atom Atom))

NDet Result(53): <span class="ansi33"
>(: pragma! (-> Atom Atom (->)))
</span>$1 = (: pragma! (-> Atom Atom (->)))

NDet Result(54): <span class="ansi33"
>(: = (-> Atom Atom %Undefined%))
</span>$1 = (: = (-> Atom Atom %Undefined%))

NDet Result(55): <span class="ansi33"
>(: match (-> hyperon::space::DynSpace Atom Atom %Undefined%))
</span>$1 = (: match (-> hyperon::space::DynSpace Atom Atom %Undefined%))

NDet Result(56): <span class="ansi33"
>(: case (-> Expression Atom Atom))
</span>$1 = (: case (-> Expression Atom Atom))

NDet Result(57): <span class="ansi33"
>(: combine (-> $10000 $10000 $10000))
</span>$1 = (: combine (-> $10000 $10000 $10000))

NDet Result(58): <span class="ansi33"
>(: import! (-> hyperon::space::DynSpace Atom (->)))
</span>$1 = (: import! (-> hyperon::space::DynSpace Atom (->)))

NDet Result(59): <span class="ansi33"
>(: If (-> Bool Atom Atom Atom))
</span>$1 = (: If (-> Bool Atom Atom Atom))

NDet Result(60): <span class="ansi33"
>(: If (-> Bool Atom Atom))
</span>$1 = (: If (-> Bool Atom Atom))

NDet Result(61): <span class="ansi33"
>(= (If True $10000)  $10000)
</span>$1 = (= (If True $10000)  $10000)

NDet Result(62): <span class="ansi33"
>(= (If False $10000)  
  (let $10001 0 
    (let $10001 1 $10001)))
</span>$1 = (= (If False $10000)  
  (let $10001 0 
    (let $10001 1 $10001)))

NDet Result(63): <span class="ansi33"
>(= (If $10000 $10001 $10002)  
  (if $10000 $10001 $10002))
</span>$1 = (= (If $10000 $10001 $10002)  
  (if $10000 $10001 $10002))

NDet Result(64): <span class="ansi33"
>(iz predicate-arity MeTTaLog)
</span>$1 = (iz predicate-arity MeTTaLog)

NDet Result(65): <span class="ansi33"
>(@doc predicate-arity (@desc "Specifies the arity (number of arguments) for a given predicate, allowing it to be queriable in the system's match framework. This is particularly useful for enabling built-in functions, such as `size-atom`, to be used as predicates in declarative contexts and run in reverse to compute inputs based on outputs.\n\nFor example:\n  ; Enable the built-in function `size-atom` that takes an atom and returns the size\n    as a predicate with arity 2\n  (add-atom &dyn-space (predicate-arity size-atom 2))\n\n  ; Now `size-atom` can be used as a predicate in pattern matching\n  (match &dyn-space '(size-atom (a b c) $size) \n         (The abc tuple was len $size))\n  ; This pattern will resolve `Size = 3` and execute the action.\n\nAdditionally, by running `size-atom` in reverse, you can compute a new atom based on a desired size:\n  (match &dyn-space '(size-atom $new-atom 4) \n         (The new atom is $new-atom))\n  ; This resolves `$new-atom` to a tuple of size 4, such as ($1 $2 $3 $4).\n\nThis reverse functionality is made possible because predicates can describe relationships, allowing you to infer inputs from outputs.") (@params ((@param "Predicate symbol" "The name of the predicate whose arity is being defined."))) (@return "The number of arguments required for the predicate."))
</span>$1 = (@doc predicate-arity (@desc "Specifies the arity (number of arguments) for a given predicate, allowing it to be queriable in the system's match framework. This is particularly useful for enabling built-in functions, such as `size-atom`, to be used as predicates in declarative contexts and run in reverse to compute inputs based on outputs.\n\nFor example:\n  ; Enable the built-in function `size-atom` that takes an atom and returns the size\n    as a predicate with arity 2\n  (add-atom &dyn-space (predicate-arity size-atom 2))\n\n  ; Now `size-atom` can be used as a predicate in pattern matching\n  (match &dyn-space '(size-atom (a b c) $size) \n         (The abc tuple was len $size))\n  ; This pattern will resolve `Size = 3` and execute the action.\n\nAdditionally, by running `size-atom` in reverse, you can compute a new atom based on a desired size:\n  (match &dyn-space '(size-atom $new-atom 4) \n         (The new atom is $new-atom))\n  ; This resolves `$new-atom` to a tuple of size 4, such as ($1 $2 $3 $4).\n\nThis reverse functionality is made possible because predicates can describe relationships, allowing you to infer inputs from outputs.") (@params ((@param "Predicate symbol" "The name of the predicate whose arity is being defined."))) (@return "The number of arguments required for the predicate."))

NDet Result(66): <span class="ansi33"
>(: predicate-arity (-> Symbol Number))
</span>$1 = (: predicate-arity (-> Symbol Number))

NDet Result(67): <span class="ansi33"
>(predicate-arity predicate-arity 2)
</span>$1 = (predicate-arity predicate-arity 2)

NDet Result(68): <span class="ansi33"
>(function-arity predicate-arity 1)
</span>$1 = (function-arity predicate-arity 1)

NDet Result(69): <span class="ansi33"
>(@doc function-arity (@desc "Defines the arity of a function, allowing predicates or built-in facts to also behave as callable functions. This enables procedural-style execution where the last argument of the predicate becomes the function's return value, and the system internally resolves the function using a `match` query. \n\nFor example:\n  ; Declare the built-in predicate `max` with arity 2\n  (predicate-arity max 2)\n\n  ; Enable `max` as a function\n  (add-atom &dyn-space (function-arity max 2))\n\n  ; Define the rules for `max`\n  (add-atom &dyn-space (max $X $Y $X) (<= $X $Y))\n  (add-atom &dyn-space (max $X $Y $Y) (> $X $Y))\n\n  ; Using `max` declaratively as a predicate\n  (match &dyn-space (max (5 10) $max)\n         (The maximum is $max))\n  ; This resolves `$max = 10`.\n\n  ; Using `max` procedurally as a function\n  (max 5 10)\n  ; Returns: 10.\n\n  ; Reverse execution with `max`\n  (max $pair 10)\n  ; Returns: a pair such as (8 10) or (10 5) where the maximum is 10.\n\n  This dual behavior allows predicates to act as functions, bridging procedural and declarative paradigms. By defining `function-arity`, the function automatically resolves using the logic of the associated predicate.") (@params ((@param "Function symbol" "The name of the function or predicate to enable as a callable function."))) (@return "The number of arguments expected by the function."))
</span>$1 = (@doc function-arity (@desc "Defines the arity of a function, allowing predicates or built-in facts to also behave as callable functions. This enables procedural-style execution where the last argument of the predicate becomes the function's return value, and the system internally resolves the function using a `match` query. \n\nFor example:\n  ; Declare the built-in predicate `max` with arity 2\n  (predicate-arity max 2)\n\n  ; Enable `max` as a function\n  (add-atom &dyn-space (function-arity max 2))\n\n  ; Define the rules for `max`\n  (add-atom &dyn-space (max $X $Y $X) (<= $X $Y))\n  (add-atom &dyn-space (max $X $Y $Y) (> $X $Y))\n\n  ; Using `max` declaratively as a predicate\n  (match &dyn-space (max (5 10) $max)\n         (The maximum is $max))\n  ; This resolves `$max = 10`.\n\n  ; Using `max` procedurally as a function\n  (max 5 10)\n  ; Returns: 10.\n\n  ; Reverse execution with `max`\n  (max $pair 10)\n  ; Returns: a pair such as (8 10) or (10 5) where the maximum is 10.\n\n  This dual behavior allows predicates to act as functions, bridging procedural and declarative paradigms. By defining `function-arity`, the function automatically resolves using the logic of the associated predicate.") (@params ((@param "Function symbol" "The name of the function or predicate to enable as a callable function."))) (@return "The number of arguments expected by the function."))

NDet Result(70): <span class="ansi33"
>(: function-arity (-> Symbol Number))
</span>$1 = (: function-arity (-> Symbol Number))

NDet Result(71): <span class="ansi33"
>(predicate-arity function-arity 2)
</span>$1 = (predicate-arity function-arity 2)

NDet Result(72): <span class="ansi33"
>(function-arity function-arity 1)
</span>$1 = (function-arity function-arity 1)

NDet Result(73): <span class="ansi33"
>(iz If MeTTa)
</span>$1 = (iz If MeTTa)

NDet Result(74): <span class="ansi33"
>(@doc If (@desc "Conditional function that evaluates and returns one of the provided atoms based on a boolean condition.") (@params ((@param "Boolean condition") (@param "Atom to return if condition is True") (@param "Atom to return if condition is False (optional)"))) (@return "Either the second or third argument depending on the condition"))
</span>$1 = (@doc If (@desc "Conditional function that evaluates and returns one of the provided atoms based on a boolean condition.") (@params ((@param "Boolean condition") (@param "Atom to return if condition is True") (@param "Atom to return if condition is False (optional)"))) (@return "Either the second or third argument depending on the condition"))

NDet Result(75): <span class="ansi33"
>(predicate-arity : 2)
</span>$1 = (predicate-arity : 2)

NDet Result(76): <span class="ansi33"
>(= (: $10000 P1)  
  (predicate-arity $10000 1))
</span>$1 = (= (: $10000 P1)  
  (predicate-arity $10000 1))

NDet Result(77): <span class="ansi33"
>(iz SrcPredicate MeTTa)
</span>$1 = (iz SrcPredicate MeTTa)

NDet Result(78): <span class="ansi33"
>(@doc SrcPredicate (@desc "Type representing a source predicate."))
</span>$1 = (@doc SrcPredicate (@desc "Type representing a source predicate."))

NDet Result(79): <span class="ansi33"
>(: SrcPredicate Type)
</span>$1 = (: SrcPredicate Type)

NDet Result(80): <span class="ansi33"
>(iz SrcFunction MeTTa)
</span>$1 = (iz SrcFunction MeTTa)

NDet Result(81): <span class="ansi33"
>(@doc SrcFunction (@desc "Type representing a source function."))
</span>$1 = (@doc SrcFunction (@desc "Type representing a source function."))

NDet Result(82): <span class="ansi33"
>(: SrcFunction Type)
</span>$1 = (: SrcFunction Type)

NDet Result(83): <span class="ansi33"
>(iz MeTTaResult MeTTa)
</span>$1 = (iz MeTTaResult MeTTa)

NDet Result(84): <span class="ansi33"
>(@doc MeTTaResult (@desc "Type representing the result of a MeTTa evaluation."))
</span>$1 = (@doc MeTTaResult (@desc "Type representing the result of a MeTTa evaluation."))

NDet Result(85): <span class="ansi33"
>(: MeTTaResult Type)
</span>$1 = (: MeTTaResult Type)

NDet Result(86): <span class="ansi33"
>(iz NotReducible MeTTaResult)
</span>$1 = (iz NotReducible MeTTaResult)

NDet Result(87): <span class="ansi33"
>(@doc NotReducible (@desc "Result indicating that an atom cannot be reduced further."))
</span>$1 = (@doc NotReducible (@desc "Result indicating that an atom cannot be reduced further."))

NDet Result(88): <span class="ansi33"
>(: NotReducible MeTTaResult)
</span>$1 = (: NotReducible MeTTaResult)

NDet Result(89): <span class="ansi33"
>Empty
</span>$1 = (iz  MeTTaResult)

NDet Result(90): <span class="ansi33"
>Empty
</span>$1 = (@doc  (@desc "Result indicating an empty evaluation result."))

NDet Result(91): <span class="ansi33"
>Empty
</span>$1 = (:  MeTTaResult)

NDet Result(92): <span class="ansi33"
>(iz ValueAtom MeTTa)
</span>$1 = (iz ValueAtom MeTTa)

NDet Result(93): <span class="ansi33"
>(@doc ValueAtom (@desc "Type representing a value atom."))
</span>$1 = (@doc ValueAtom (@desc "Type representing a value atom."))

NDet Result(94): <span class="ansi33"
>(:> ValueAtom Atom)
</span>$1 = (:> ValueAtom Atom)

NDet Result(95): <span class="ansi33"
>(iz ForeignObject MeTTa)
</span>$1 = (iz ForeignObject MeTTa)

NDet Result(96): <span class="ansi33"
>(@doc ForeignObject (@desc "Type representing a foreign object, such as a Python object."))
</span>$1 = (@doc ForeignObject (@desc "Type representing a foreign object, such as a Python object."))

NDet Result(97): <span class="ansi33"
>(: ForeignObject Type)
</span>$1 = (: ForeignObject Type)

NDet Result(98): <span class="ansi33"
>(:> ValueAtom Grounded)
</span>$1 = (:> ValueAtom Grounded)

NDet Result(99): <span class="ansi33"
>(:> ForeignObject ValueAtom)
</span>$1 = (:> ForeignObject ValueAtom)

NDet Result(100): <span class="ansi33"
>(iz PyObject MeTTa)
</span>$1 = (iz PyObject MeTTa)

NDet Result(101): <span class="ansi33"
>(@doc PyObject (@desc "Type representing a Python object."))
</span>$1 = (@doc PyObject (@desc "Type representing a Python object."))

NDet Result(102): <span class="ansi33"
>(:> PyObject ForeignObject)
</span>$1 = (:> PyObject ForeignObject)

NDet Result(103): <span class="ansi33"
>(:> hyperon::space::DynSpace Grounded)
</span>$1 = (:> hyperon::space::DynSpace Grounded)

NDet Result(104): <span class="ansi33"
>(iz py-list MeTTa)
</span>$1 = (iz py-list MeTTa)

NDet Result(105): <span class="ansi33"
>(@doc py-list (@desc "Converts a MeTTa Expression into a Python list and returns it as a PyObject.") (@params ((@param (@desc "A MeTTa List that will be converted into a Python list")))) (@return (@desc "A Python list object that represents the given MeTTa Expression as a PyObject")))
</span>$1 = (@doc py-list (@desc "Converts a MeTTa Expression into a Python list and returns it as a PyObject.") (@params ((@param (@desc "A MeTTa List that will be converted into a Python list")))) (@return (@desc "A Python list object that represents the given MeTTa Expression as a PyObject")))

NDet Result(106): <span class="ansi33"
>(: py-list (-> Expression PyObject))
</span>$1 = (: py-list (-> Expression PyObject))

NDet Result(107): <span class="ansi33"
>(iz py-chain MeTTa)
</span>$1 = (iz py-chain MeTTa)

NDet Result(108): <span class="ansi33"
>(@doc py-chain (@desc "Chains together a list of Python objects contained in a MeTTa Expression, applying the Python vertical bar | OR operation jointly to all elements.") (@params ((@param (@desc "A MeTTa list of atoms, each embedding a Python object.")))) (@return (@desc "A MeTTa atom which embeds the result of applying the Python OR | operator to all elements of the list.")))
</span>$1 = (@doc py-chain (@desc "Chains together a list of Python objects contained in a MeTTa Expression, applying the Python vertical bar | OR operation jointly to all elements.") (@params ((@param (@desc "A MeTTa list of atoms, each embedding a Python object.")))) (@return (@desc "A MeTTa atom which embeds the result of applying the Python OR | operator to all elements of the list.")))

NDet Result(109): <span class="ansi33"
>(: py-chain (-> Expression PyObject))
</span>$1 = (: py-chain (-> Expression PyObject))

NDet Result(110): <span class="ansi33"
>(iz py-eval MeTTaLog)
</span>$1 = (iz py-eval MeTTaLog)

NDet Result(111): <span class="ansi33"
>(@doc py-eval (@desc "Evaluates a Python expression from a string and returns the result as a PyObject.") (@params ((@param (@desc "A string representing a Python expression that will be evaluated")))) (@return (@desc "The result of evaluating the Python expression as a PyObject")))
</span>$1 = (@doc py-eval (@desc "Evaluates a Python expression from a string and returns the result as a PyObject.") (@params ((@param (@desc "A string representing a Python expression that will be evaluated")))) (@return (@desc "The result of evaluating the Python expression as a PyObject")))

NDet Result(112): <span class="ansi33"
>(: py-eval (-> String PyObject))
</span>$1 = (: py-eval (-> String PyObject))

NDet Result(113): <span class="ansi33"
>(iz py-exec! MeTTaLog)
</span>$1 = (iz py-exec! MeTTaLog)

NDet Result(114): <span class="ansi33"
>(@doc py-exec! (@desc "Executes some Python sourcecode from a string !(py-exec! \"import torch\") -> True.  !(py-exec! \"import torche\") -> False. ") (@params ((@param (@type String) (@desc "A string representing a Python sourcecode that will be executed")))) (@return (@desc "The True|False results of executing the Python expression")))
</span>$1 = (@doc py-exec! (@desc "Executes some Python sourcecode from a string !(py-exec! \"import torch\") -> True.  !(py-exec! \"import torche\") -> False. ") (@params ((@param (@type String) (@desc "A string representing a Python sourcecode that will be executed")))) (@return (@desc "The True|False results of executing the Python expression")))

NDet Result(115): <span class="ansi33"
>(: py-exec! (-> String Bool))
</span>$1 = (: py-exec! (-> String Bool))

NDet Result(116): <span class="ansi33"
>(iz = MeTTa)
</span>$1 = (iz = MeTTa)

NDet Result(117): <span class="ansi33"
>(@doc = (@desc "A symbol used to define reduction rules for expressions.") (@params ((@param "Pattern to be matched against expression to be reduced") (@param "Result of reduction or transformation of the first pattern"))) (@return "Not reduced itself unless custom equalities over equalities are added"))
</span>$1 = (@doc = (@desc "A symbol used to define reduction rules for expressions.") (@params ((@param "Pattern to be matched against expression to be reduced") (@param "Result of reduction or transformation of the first pattern"))) (@return "Not reduced itself unless custom equalities over equalities are added"))

NDet Result(118): <span class="ansi33"
>(: = (-> $10000 $10000 Atom))
</span>$1 = (: = (-> $10000 $10000 Atom))

NDet Result(119): <span class="ansi33"
>(: = (-> Atom Atom Atom))
</span>$1 = (: = (-> Atom Atom Atom))

NDet Result(120): <span class="ansi33"
>(iz ErrorType MeTTa)
</span>$1 = (iz ErrorType MeTTa)

NDet Result(121): <span class="ansi33"
>(@doc ErrorType (@desc "Type of the atom which contains error"))
</span>$1 = (@doc ErrorType (@desc "Type of the atom which contains error"))

NDet Result(122): <span class="ansi33"
>(: ErrorType Type)
</span>$1 = (: ErrorType Type)

NDet Result(123): <span class="ansi33"
>(iz Error MeTTa)
</span>$1 = (iz Error MeTTa)

NDet Result(124): <span class="ansi33"
>(@doc Error (@desc "Error constructor") (@params ((@param "Atom which contains error") (@param "Error message, can be one of the reserved symbols: BadType, IncorrectNumberOfArguments"))) (@return "Instance of the error atom"))
</span>$1 = (@doc Error (@desc "Error constructor") (@params ((@param "Atom which contains error") (@param "Error message, can be one of the reserved symbols: BadType, IncorrectNumberOfArguments"))) (@return "Instance of the error atom"))

NDet Result(125): <span class="ansi33"
>(: Error (-> Atom Atom ErrorType))
</span>$1 = (: Error (-> Atom Atom ErrorType))

NDet Result(126): <span class="ansi33"
>(iz return MinimalMeTTa)
</span>$1 = (iz return MinimalMeTTa)

NDet Result(127): <span class="ansi33"
>(@doc return (@desc "Returns value from the (function ...) expression") (@params ((@param "Value to be returned"))) (@return "Passed argument"))
</span>$1 = (@doc return (@desc "Returns value from the (function ...) expression") (@params ((@param "Value to be returned"))) (@return "Passed argument"))

NDet Result(128): <span class="ansi33"
>(: return (-> $10000 $10000))
</span>$1 = (: return (-> $10000 $10000))

NDet Result(129): <span class="ansi33"
>(iz function MinimalMeTTa)
</span>$1 = (iz function MinimalMeTTa)

NDet Result(130): <span class="ansi33"
>(@doc function (@desc "Evaluates the argument until it becomes (return <result>). Then (function (return <result>)) is reduced to the <result>.") (@params ((@param "Atom to be evaluated"))) (@return "Result of atom's evaluation"))
</span>$1 = (@doc function (@desc "Evaluates the argument until it becomes (return <result>). Then (function (return <result>)) is reduced to the <result>.") (@params ((@param "Atom to be evaluated"))) (@return "Result of atom's evaluation"))

NDet Result(131): <span class="ansi33"
>(: function (-> Atom Atom))
</span>$1 = (: function (-> Atom Atom))

NDet Result(132): <span class="ansi33"
>(iz eval MinimalMeTTa)
</span>$1 = (iz eval MinimalMeTTa)

NDet Result(133): <span class="ansi33"
>(@doc eval (@desc "Evaluates input Atom, performs one step of the evaluation. Empty results (Empty, ()) are removed from the result set. If no results are produced for a non-grounded function, eval returns NotReducible.") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function"))) (@return "Result of evaluation"))
</span>$1 = (@doc eval (@desc "Evaluates input Atom, performs one step of the evaluation. Empty results (Empty, ()) are removed from the result set. If no results are produced for a non-grounded function, eval returns NotReducible.") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function"))) (@return "Result of evaluation"))

NDet Result(134): <span class="ansi33"
>(: eval (-> Atom Atom))
</span>$1 = (: eval (-> Atom Atom))

NDet Result(135): <span class="ansi33"
>(@doc evalc (@desc "Evaluates input atom, makes one step of the evaluation") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function") (@param "Space to evaluate atom in its context"))) (@return "Result of evaluation"))
</span>$1 = (@doc evalc (@desc "Evaluates input atom, makes one step of the evaluation") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function") (@param "Space to evaluate atom in its context"))) (@return "Result of evaluation"))

NDet Result(136): <span class="ansi33"
>(: evalc (-> Atom Grounded Atom))
</span>$1 = (: evalc (-> Atom Grounded Atom))

NDet Result(137): <span class="ansi33"
>(iz chain MinimalMeTTa)
</span>$1 = (iz chain MinimalMeTTa)

NDet Result(138): <span class="ansi33"
>(@doc chain (@desc "Evaluates first argument Atom, binds it to the Variable (second argument) and then evaluates third argument Template with Variable substituted in. When evaluation of the first Atom brings more than a single result, chain returns one instance of the Template expression for each result. The first argument Atom is only evaluated if it is part of the Minimal MeTTa specification; evaluation of non-Minimal MeTTa atoms can be controlled by wrapping in a call to eval (for one evaluation step) or metta (for full evaluation).") (@params ((@param "Atom to be evaluated") (@param "Variable") (@param "Template which will be evaluated at the end with Variable substituted"))) (@return "Result of evaluating third input argument"))
</span>$1 = (@doc chain (@desc "Evaluates first argument Atom, binds it to the Variable (second argument) and then evaluates third argument Template with Variable substituted in. When evaluation of the first Atom brings more than a single result, chain returns one instance of the Template expression for each result. The first argument Atom is only evaluated if it is part of the Minimal MeTTa specification; evaluation of non-Minimal MeTTa atoms can be controlled by wrapping in a call to eval (for one evaluation step) or metta (for full evaluation).") (@params ((@param "Atom to be evaluated") (@param "Variable") (@param "Template which will be evaluated at the end with Variable substituted"))) (@return "Result of evaluating third input argument"))

NDet Result(139): <span class="ansi33"
>(: chain (-> Atom Variable Atom Atom))
</span>$1 = (: chain (-> Atom Variable Atom Atom))

NDet Result(140): <span class="ansi33"
>(iz unify MeTTa)
</span>$1 = (iz unify MeTTa)

NDet Result(141): <span class="ansi33"
>(@doc unify (@desc "Like Match but allows any sort of container for the first argument. (Match only allows MeTTa spaces.)") (@params ((@param "The collection or space to match") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when found or fourth one otherwise"))
</span>$1 = (@doc unify (@desc "Like Match but allows any sort of container for the first argument. (Match only allows MeTTa spaces.)") (@params ((@param "The collection or space to match") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when found or fourth one otherwise"))

NDet Result(142): <span class="ansi33"
>(: unify (-> Atom Atom Atom Atom Atom))
</span>$1 = (: unify (-> Atom Atom Atom Atom Atom))

NDet Result(143): <span class="ansi33"
>(iz if-unify MinimalMeTTaHelper)
</span>$1 = (iz if-unify MinimalMeTTaHelper)

NDet Result(144): <span class="ansi33"
>(@doc if-unify (@desc "Matches two first terms and returns third argument if they are matched and fourth argument otherwise") (@params ((@param "First term to unify with") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when first two atoms are unifiable or fourth one otherwise"))
</span>$1 = (@doc if-unify (@desc "Matches two first terms and returns third argument if they are matched and fourth argument otherwise") (@params ((@param "First term to unify with") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when first two atoms are unifiable or fourth one otherwise"))

NDet Result(145): <span class="ansi33"
>(: if-unify (-> Atom Atom Atom Atom %Undefined%))
</span>$1 = (: if-unify (-> Atom Atom Atom Atom %Undefined%))

NDet Result(146): <span class="ansi33"
>(ALT= $10000 $10000)
</span>$1 = (ALT= (if-unify $10000 $10000 $10001 $10002) $10001)

NDet Result(147): <span class="ansi33"
>Empty
</span>$1 = (ALT= (if-unify $10000 $10000 $10001 $10002) (case (if-unify-or-empty $10000 $10000) (( $10002))))

NDet Result(148): <span class="ansi33"
>(iz if-unify-or-empty MinimalMeTTaHelper)
</span>$1 = (iz if-unify-or-empty MinimalMeTTaHelper)

NDet Result(149): <span class="ansi33"
>(@doc if-unify-or-empty (@desc "Attempts to unify two atoms and returns a result. Returns Empty if they cannot be unified.") (@params ((@param "First atom") (@param "Second atom"))) (@return "Unification result or Empty"))
</span>$1 = (@doc if-unify-or-empty (@desc "Attempts to unify two atoms and returns a result. Returns Empty if they cannot be unified.") (@params ((@param "First atom") (@param "Second atom"))) (@return "Unification result or Empty"))

NDet Result(150): <span class="ansi33"
>(: if-unify-or-empty (-> Atom Atom Atom))
</span>$1 = (: if-unify-or-empty (-> Atom Atom Atom))

NDet Result(151): <span class="ansi33"
>(= (if-unify-or-empty $10000 $10000)  unified)
</span>$1 = (= (if-unify-or-empty $10000 $10000)  unified)

NDet Result(152): <span class="ansi33"
>(= (if-unify-or-empty $10000 $10001)  
  (empty))
</span>$1 = (= (if-unify-or-empty $10000 $10001)  
  (empty))

NDet Result(153): <span class="ansi33"
>(iz cons-atom MinimalMeTTa)
</span>$1 = (iz cons-atom MinimalMeTTa)

NDet Result(154): <span class="ansi33"
>(@doc cons-atom (@desc "Constructs an expression using two arguments") (@params ((@param "Head of an expression") (@param "Tail of an expression"))) (@return "New expression consisting of the two input arguments"))
</span>$1 = (@doc cons-atom (@desc "Constructs an expression using two arguments") (@params ((@param "Head of an expression") (@param "Tail of an expression"))) (@return "New expression consisting of the two input arguments"))

NDet Result(155): <span class="ansi33"
>(: cons-atom (-> Atom Expression Expression))
</span>$1 = (: cons-atom (-> Atom Expression Expression))

NDet Result(156): <span class="ansi33"
>(iz decons-atom MinimalMeTTa)
</span>$1 = (iz decons-atom MinimalMeTTa)

NDet Result(157): <span class="ansi33"
>(@doc decons-atom (@desc "Works as a reverse to cons-atom function. It gets Expression as an input and returns it split into head and tail, e.g. (decons-atom (Cons X Nil)) -> (Cons (X Nil))") (@params ((@param "Expression to be Deconsed"))) (@return "Deconsed expression"))
</span>$1 = (@doc decons-atom (@desc "Works as a reverse to cons-atom function. It gets Expression as an input and returns it split into head and tail, e.g. (decons-atom (Cons X Nil)) -> (Cons (X Nil))") (@params ((@param "Expression to be Deconsed"))) (@return "Deconsed expression"))

NDet Result(158): <span class="ansi33"
>(: decons-atom (-> Expression Expression))
</span>$1 = (: decons-atom (-> Expression Expression))

NDet Result(159): <span class="ansi33"
>(iz min-atom MeTTa)
</span>$1 = (iz min-atom MeTTa)

NDet Result(160): <span class="ansi33"
>(@doc min-atom (@desc "Returns atom with minimum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Minimum value in the expression. Error if expression contains non-numeric value or is empty."))
</span>$1 = (@doc min-atom (@desc "Returns atom with minimum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Minimum value in the expression. Error if expression contains non-numeric value or is empty."))

NDet Result(161): <span class="ansi33"
>(: min-atom (-> Expression Number))
</span>$1 = (: min-atom (-> Expression Number))

NDet Result(162): <span class="ansi33"
>(= (min-atom $10000)  
  (call-fn! min_list $10000))
</span>$1 = (= (min-atom $10000)  
  (call-fn! min_list $10000))

NDet Result(163): <span class="ansi33"
>(iz max-atom MeTTa)
</span>$1 = (iz max-atom MeTTa)

NDet Result(164): <span class="ansi33"
>(@doc max-atom (@desc "Returns atom with maximum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Maximum value in the expression. Error if expression contains non-numeric value or is empty."))
</span>$1 = (@doc max-atom (@desc "Returns atom with maximum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Maximum value in the expression. Error if expression contains non-numeric value or is empty."))

NDet Result(165): <span class="ansi33"
>(: max-atom (-> Expression Number))
</span>$1 = (: max-atom (-> Expression Number))

NDet Result(166): <span class="ansi33"
>(is-fn-1 max-atom max_list)
</span>$1 = (is-fn-1 max-atom max_list)

NDet Result(167): <span class="ansi33"
>(iz size-atom MeTTa)
</span>$1 = (iz size-atom MeTTa)

NDet Result(168): <span class="ansi33"
>(@doc size-atom (@desc "Returns the size of an expression (first argument).") (@params ((@param "Expression to measure the size of"))) (@return "Size of the expression"))
</span>$1 = (@doc size-atom (@desc "Returns the size of an expression (first argument).") (@params ((@param "Expression to measure the size of"))) (@return "Size of the expression"))

NDet Result(169): <span class="ansi33"
>(: size-atom (-> Expression Integer))
</span>$1 = (: size-atom (-> Expression Integer))

NDet Result(170): <span class="ansi33"
>(is-fn-1 size-atom length)
</span>$1 = (is-fn-1 size-atom length)

NDet Result(171): <span class="ansi33"
>(iz index-atom MeTTa)
</span>$1 = (iz index-atom MeTTa)

NDet Result(172): <span class="ansi33"
>(@doc index-atom (@desc "Returns atom from an expression (first argument) using index (second argument) or error if index is out of bounds.") (@params ((@param "Expression") (@param "Index"))) (@return "Atom at the specified index in the expression. Error if index is out of bounds."))
</span>$1 = (@doc index-atom (@desc "Returns atom from an expression (first argument) using index (second argument) or error if index is out of bounds.") (@params ((@param "Expression") (@param "Index"))) (@return "Atom at the specified index in the expression. Error if index is out of bounds."))

NDet Result(173): <span class="ansi33"
>(: index-atom (-> Expression Number Atom))
</span>$1 = (: index-atom (-> Expression Number Atom))

NDet Result(174): <span class="ansi33"
>(is-fn-21 index-atom nth0)
</span>$1 = (is-fn-21 index-atom nth0)

NDet Result(175): <span class="ansi33"
>(iz powi MeTTa)
</span>$1 = (iz powi MeTTa)

NDet Result(176): <span class="ansi33"
>(@doc powi (@desc "Takes base (first argument) and power (second argument) and returns the result of raising the base to the power.") (@params ((@param "Base. Could be a float.") (@param "Power. Must be an integer."))) (@return "Result of base raised to the power"))
</span>$1 = (@doc powi (@desc "Takes base (first argument) and power (second argument) and returns the result of raising the base to the power.") (@params ((@param "Base. Could be a float.") (@param "Power. Must be an integer."))) (@return "Result of base raised to the power"))

NDet Result(177): <span class="ansi33"
>(= (powi $10000 $10001)  
  (call-fn! pow $10000 $10001))
</span>$1 = (= (powi $10000 $10001)  
  (call-fn! pow $10000 $10001))

Last Result(178): <span class="ansi33"
>(==> (is-op-1 $10000 $10001) (is-fn-1 $10000 $10001))
</span>$1 = (==> (is-op-1 $10000 $10001) (is-fn-1 $10000 $10001))
```
```metta
*/

<span class="ansi38-013099040"
>!(get-atoms &self)

</span>
/*
```
```answers

NDet Result(1): <span class="ansi33"
>&corelib
</span>
NDet Result(2): <span class="ansi33"
>&stdlib
</span>
NDet Result(3): <span class="ansi33"
>(= (Rel-P P P P)  10)
</span>
NDet Result(4): <span class="ansi33"
>(Rel-P A B)
</span>
NDet Result(5): <span class="ansi33"
>(Rel-Q A C)
</span>
NDet Result(6): <span class="ansi33"
>(@doc Any (@desc "The universal type; any value belongs to this type."))
</span>
NDet Result(7): <span class="ansi33"
>(: Any Type)
</span>
NDet Result(8): <span class="ansi33"
>(@doc Atom (@desc "Type representing any atom."))
</span>
NDet Result(9): <span class="ansi33"
>(: Atom Type)
</span>
NDet Result(10): <span class="ansi33"
>(@doc LazyEvaluatable (@desc "A type of Atom/Value that hyperon does not implicitly evaluate"))
</span>
NDet Result(11): <span class="ansi33"
>(: LazyEvaluatable Type)
</span>
NDet Result(12): <span class="ansi33"
>(:> Atom LazyEvaluatable)
</span>
NDet Result(13): <span class="ansi33"
>(@doc Bool (@desc "Boolean type of True or False."))
</span>
NDet Result(14): <span class="ansi33"
>(: Bool Type)
</span>
NDet Result(15): <span class="ansi33"
>(@doc LazyBool (@desc "A LazyEvaluatable that when evaluated returns True or False."))
</span>
NDet Result(16): <span class="ansi33"
>(: LazyBool Type)
</span>
NDet Result(17): <span class="ansi33"
>(:> LazyBool LazyEvaluatable)
</span>
NDet Result(18): <span class="ansi33"
>(@doc Expression (@desc "Type representing an S-Expression, which is a combination of atoms."))
</span>
NDet Result(19): <span class="ansi33"
>(: Expression Type)
</span>
NDet Result(20): <span class="ansi33"
>(:> Expression LazyEvaluatable)
</span>
NDet Result(21): <span class="ansi33"
>(@doc Number (@desc "Numeric type, including integers and floating-point numbers."))
</span>
NDet Result(22): <span class="ansi33"
>(: Number Type)
</span>
NDet Result(23): <span class="ansi33"
>(@doc hyperon::space::DynSpace (@desc "Dynamic space type, representing an Atomspace."))
</span>
NDet Result(24): <span class="ansi33"
>(: hyperon::space::DynSpace Type)
</span>
NDet Result(25): <span class="ansi33"
>(@doc ReturnType (@desc "Type representing a function's return value."))
</span>
NDet Result(26): <span class="ansi33"
>(: ReturnType Type)
</span>
NDet Result(27): <span class="ansi33"
>(@doc Symbol (@desc "Type representing a symbol or identifier."))
</span>
NDet Result(28): <span class="ansi33"
>(: Symbol Type)
</span>
NDet Result(29): <span class="ansi33"
>(@doc StateMonad (@desc "Type representing a state monad, used for encapsulating stateful computations."))
</span>
NDet Result(30): <span class="ansi33"
>(: StateMonad Type)
</span>
NDet Result(31): <span class="ansi33"
>(@doc Type (@desc "Type representing a type."))
</span>
NDet Result(32): <span class="ansi33"
>(: Type Type)
</span>
NDet Result(33): <span class="ansi33"
>(@doc True (@desc "Boolean value representing truth."))
</span>
NDet Result(34): <span class="ansi33"
>(: True Bool)
</span>
NDet Result(35): <span class="ansi33"
>(@doc False (@desc "Boolean value representing falsehood."))
</span>
NDet Result(36): <span class="ansi33"
>(: False Bool)
</span>
NDet Result(37): <span class="ansi33"
>(@doc %Undefined% (@desc "Special type representing an undefined value or type."))
</span>
NDet Result(38): <span class="ansi33"
>(: %Undefined% Type)
</span>
NDet Result(39): <span class="ansi33"
>(@doc Variable (@desc "Type representing a variable in the language."))
</span>
NDet Result(40): <span class="ansi33"
>(: Variable Type)
</span>
NDet Result(41): <span class="ansi33"
>(@doc : (@desc "Type declarion operator"))
</span>
NDet Result(42): <span class="ansi33"
>(@doc <: (@desc "Super Type declarion operator"))
</span>
NDet Result(43): <span class="ansi33"
>(: : %Undefined%)
</span>
NDet Result(44): <span class="ansi33"
>(: if-empty (-> Atom Atom Atom Atom))
</span>
NDet Result(45): <span class="ansi33"
>(: if-non-empty-expression (-> Atom Atom Atom Atom))
</span>
NDet Result(46): <span class="ansi33"
>(: if-not-reducible (-> Atom Atom Atom Atom))
</span>
NDet Result(47): <span class="ansi33"
>(: return (-> Atom ReturnType))
</span>
NDet Result(48): <span class="ansi33"
>(: switch (-> %Undefined% Expression Atom))
</span>
NDet Result(49): <span class="ansi33"
>(: unify (-> Atom Atom Atom Atom %Undefined%))
</span>
NDet Result(50): <span class="ansi33"
>(: get-type (-> Atom Type))
</span>
NDet Result(51): <span class="ansi33"
>(: get-type0 (-> Atom Atom))
</span>
NDet Result(52): <span class="ansi33"
>(: get-ftype (-> Atom Atom))
</span>
NDet Result(53): <span class="ansi33"
>(: pragma! (-> Atom Atom (->)))
</span>
NDet Result(54): <span class="ansi33"
>(: = (-> Atom Atom %Undefined%))
</span>
NDet Result(55): <span class="ansi33"
>(: match (-> hyperon::space::DynSpace Atom Atom %Undefined%))
</span>
NDet Result(56): <span class="ansi33"
>(: case (-> Expression Atom Atom))
</span>
NDet Result(57): <span class="ansi33"
>(: combine (-> $10000 $10000 $10000))
</span>
NDet Result(58): <span class="ansi33"
>(: import! (-> hyperon::space::DynSpace Atom (->)))
</span>
NDet Result(59): <span class="ansi33"
>(: If (-> Bool Atom Atom Atom))
</span>
NDet Result(60): <span class="ansi33"
>(: If (-> Bool Atom Atom))
</span>
NDet Result(61): <span class="ansi33"
>(= (If True $10000)  $10000)
</span>
NDet Result(62): <span class="ansi33"
>(= (If False $10000)  
  (let $10001 0 
    (let $10001 1 $10001)))
</span>
NDet Result(63): <span class="ansi33"
>(= (If $10000 $10001 $10002)  
  (if $10000 $10001 $10002))
</span>
NDet Result(64): <span class="ansi33"
>(iz predicate-arity MeTTaLog)
</span>
NDet Result(65): <span class="ansi33"
>(@doc predicate-arity (@desc "Specifies the arity (number of arguments) for a given predicate, allowing it to be queriable in the system's match framework. This is particularly useful for enabling built-in functions, such as `size-atom`, to be used as predicates in declarative contexts and run in reverse to compute inputs based on outputs.\n\nFor example:\n  ; Enable the built-in function `size-atom` that takes an atom and returns the size\n    as a predicate with arity 2\n  (add-atom &dyn-space (predicate-arity size-atom 2))\n\n  ; Now `size-atom` can be used as a predicate in pattern matching\n  (match &dyn-space '(size-atom (a b c) $size) \n         (The abc tuple was len $size))\n  ; This pattern will resolve `Size = 3` and execute the action.\n\nAdditionally, by running `size-atom` in reverse, you can compute a new atom based on a desired size:\n  (match &dyn-space '(size-atom $new-atom 4) \n         (The new atom is $new-atom))\n  ; This resolves `$new-atom` to a tuple of size 4, such as ($1 $2 $3 $4).\n\nThis reverse functionality is made possible because predicates can describe relationships, allowing you to infer inputs from outputs.") (@params ((@param "Predicate symbol" "The name of the predicate whose arity is being defined."))) (@return "The number of arguments required for the predicate."))
</span>
NDet Result(66): <span class="ansi33"
>(: predicate-arity (-> Symbol Number))
</span>
NDet Result(67): <span class="ansi33"
>(predicate-arity predicate-arity 2)
</span>
NDet Result(68): <span class="ansi33"
>(function-arity predicate-arity 1)
</span>
NDet Result(69): <span class="ansi33"
>(@doc function-arity (@desc "Defines the arity of a function, allowing predicates or built-in facts to also behave as callable functions. This enables procedural-style execution where the last argument of the predicate becomes the function's return value, and the system internally resolves the function using a `match` query. \n\nFor example:\n  ; Declare the built-in predicate `max` with arity 2\n  (predicate-arity max 2)\n\n  ; Enable `max` as a function\n  (add-atom &dyn-space (function-arity max 2))\n\n  ; Define the rules for `max`\n  (add-atom &dyn-space (max $X $Y $X) (<= $X $Y))\n  (add-atom &dyn-space (max $X $Y $Y) (> $X $Y))\n\n  ; Using `max` declaratively as a predicate\n  (match &dyn-space (max (5 10) $max)\n         (The maximum is $max))\n  ; This resolves `$max = 10`.\n\n  ; Using `max` procedurally as a function\n  (max 5 10)\n  ; Returns: 10.\n\n  ; Reverse execution with `max`\n  (max $pair 10)\n  ; Returns: a pair such as (8 10) or (10 5) where the maximum is 10.\n\n  This dual behavior allows predicates to act as functions, bridging procedural and declarative paradigms. By defining `function-arity`, the function automatically resolves using the logic of the associated predicate.") (@params ((@param "Function symbol" "The name of the function or predicate to enable as a callable function."))) (@return "The number of arguments expected by the function."))
</span>
NDet Result(70): <span class="ansi33"
>(: function-arity (-> Symbol Number))
</span>
NDet Result(71): <span class="ansi33"
>(predicate-arity function-arity 2)
</span>
NDet Result(72): <span class="ansi33"
>(function-arity function-arity 1)
</span>
NDet Result(73): <span class="ansi33"
>(iz If MeTTa)
</span>
NDet Result(74): <span class="ansi33"
>(@doc If (@desc "Conditional function that evaluates and returns one of the provided atoms based on a boolean condition.") (@params ((@param "Boolean condition") (@param "Atom to return if condition is True") (@param "Atom to return if condition is False (optional)"))) (@return "Either the second or third argument depending on the condition"))
</span>
NDet Result(75): <span class="ansi33"
>(predicate-arity : 2)
</span>
NDet Result(76): <span class="ansi33"
>(= (: $10000 P1)  
  (predicate-arity $10000 1))
</span>
NDet Result(77): <span class="ansi33"
>(iz SrcPredicate MeTTa)
</span>
NDet Result(78): <span class="ansi33"
>(@doc SrcPredicate (@desc "Type representing a source predicate."))
</span>
NDet Result(79): <span class="ansi33"
>(: SrcPredicate Type)
</span>
NDet Result(80): <span class="ansi33"
>(iz SrcFunction MeTTa)
</span>
NDet Result(81): <span class="ansi33"
>(@doc SrcFunction (@desc "Type representing a source function."))
</span>
NDet Result(82): <span class="ansi33"
>(: SrcFunction Type)
</span>
NDet Result(83): <span class="ansi33"
>(iz MeTTaResult MeTTa)
</span>
NDet Result(84): <span class="ansi33"
>(@doc MeTTaResult (@desc "Type representing the result of a MeTTa evaluation."))
</span>
NDet Result(85): <span class="ansi33"
>(: MeTTaResult Type)
</span>
NDet Result(86): <span class="ansi33"
>(iz NotReducible MeTTaResult)
</span>
NDet Result(87): <span class="ansi33"
>(@doc NotReducible (@desc "Result indicating that an atom cannot be reduced further."))
</span>
NDet Result(88): <span class="ansi33"
>(: NotReducible MeTTaResult)
</span>
NDet Result(89): <span class="ansi33"
>Empty
</span>
NDet Result(90): <span class="ansi33"
>Empty
</span>
NDet Result(91): <span class="ansi33"
>Empty
</span>
NDet Result(92): <span class="ansi33"
>(iz ValueAtom MeTTa)
</span>
NDet Result(93): <span class="ansi33"
>(@doc ValueAtom (@desc "Type representing a value atom."))
</span>
NDet Result(94): <span class="ansi33"
>(:> ValueAtom Atom)
</span>
NDet Result(95): <span class="ansi33"
>(iz ForeignObject MeTTa)
</span>
NDet Result(96): <span class="ansi33"
>(@doc ForeignObject (@desc "Type representing a foreign object, such as a Python object."))
</span>
NDet Result(97): <span class="ansi33"
>(: ForeignObject Type)
</span>
NDet Result(98): <span class="ansi33"
>(:> ValueAtom Grounded)
</span>
NDet Result(99): <span class="ansi33"
>(:> ForeignObject ValueAtom)
</span>
NDet Result(100): <span class="ansi33"
>(iz PyObject MeTTa)
</span>
NDet Result(101): <span class="ansi33"
>(@doc PyObject (@desc "Type representing a Python object."))
</span>
NDet Result(102): <span class="ansi33"
>(:> PyObject ForeignObject)
</span>
NDet Result(103): <span class="ansi33"
>(:> hyperon::space::DynSpace Grounded)
</span>
NDet Result(104): <span class="ansi33"
>(iz py-list MeTTa)
</span>
NDet Result(105): <span class="ansi33"
>(@doc py-list (@desc "Converts a MeTTa Expression into a Python list and returns it as a PyObject.") (@params ((@param (@desc "A MeTTa List that will be converted into a Python list")))) (@return (@desc "A Python list object that represents the given MeTTa Expression as a PyObject")))
</span>
NDet Result(106): <span class="ansi33"
>(: py-list (-> Expression PyObject))
</span>
NDet Result(107): <span class="ansi33"
>(iz py-chain MeTTa)
</span>
NDet Result(108): <span class="ansi33"
>(@doc py-chain (@desc "Chains together a list of Python objects contained in a MeTTa Expression, applying the Python vertical bar | OR operation jointly to all elements.") (@params ((@param (@desc "A MeTTa list of atoms, each embedding a Python object.")))) (@return (@desc "A MeTTa atom which embeds the result of applying the Python OR | operator to all elements of the list.")))
</span>
NDet Result(109): <span class="ansi33"
>(: py-chain (-> Expression PyObject))
</span>
NDet Result(110): <span class="ansi33"
>(iz py-eval MeTTaLog)
</span>
NDet Result(111): <span class="ansi33"
>(@doc py-eval (@desc "Evaluates a Python expression from a string and returns the result as a PyObject.") (@params ((@param (@desc "A string representing a Python expression that will be evaluated")))) (@return (@desc "The result of evaluating the Python expression as a PyObject")))
</span>
NDet Result(112): <span class="ansi33"
>(: py-eval (-> String PyObject))
</span>
NDet Result(113): <span class="ansi33"
>(iz py-exec! MeTTaLog)
</span>
NDet Result(114): <span class="ansi33"
>(@doc py-exec! (@desc "Executes some Python sourcecode from a string !(py-exec! \"import torch\") -> True.  !(py-exec! \"import torche\") -> False. ") (@params ((@param (@type String) (@desc "A string representing a Python sourcecode that will be executed")))) (@return (@desc "The True|False results of executing the Python expression")))
</span>
NDet Result(115): <span class="ansi33"
>(: py-exec! (-> String Bool))
</span>
NDet Result(116): <span class="ansi33"
>(iz = MeTTa)
</span>
NDet Result(117): <span class="ansi33"
>(@doc = (@desc "A symbol used to define reduction rules for expressions.") (@params ((@param "Pattern to be matched against expression to be reduced") (@param "Result of reduction or transformation of the first pattern"))) (@return "Not reduced itself unless custom equalities over equalities are added"))
</span>
NDet Result(118): <span class="ansi33"
>(: = (-> $10000 $10000 Atom))
</span>
NDet Result(119): <span class="ansi33"
>(: = (-> Atom Atom Atom))
</span>
NDet Result(120): <span class="ansi33"
>(iz ErrorType MeTTa)
</span>
NDet Result(121): <span class="ansi33"
>(@doc ErrorType (@desc "Type of the atom which contains error"))
</span>
NDet Result(122): <span class="ansi33"
>(: ErrorType Type)
</span>
NDet Result(123): <span class="ansi33"
>(iz Error MeTTa)
</span>
NDet Result(124): <span class="ansi33"
>(@doc Error (@desc "Error constructor") (@params ((@param "Atom which contains error") (@param "Error message, can be one of the reserved symbols: BadType, IncorrectNumberOfArguments"))) (@return "Instance of the error atom"))
</span>
NDet Result(125): <span class="ansi33"
>(: Error (-> Atom Atom ErrorType))
</span>
NDet Result(126): <span class="ansi33"
>(iz return MinimalMeTTa)
</span>
NDet Result(127): <span class="ansi33"
>(@doc return (@desc "Returns value from the (function ...) expression") (@params ((@param "Value to be returned"))) (@return "Passed argument"))
</span>
NDet Result(128): <span class="ansi33"
>(: return (-> $10000 $10000))
</span>
NDet Result(129): <span class="ansi33"
>(iz function MinimalMeTTa)
</span>
NDet Result(130): <span class="ansi33"
>(@doc function (@desc "Evaluates the argument until it becomes (return <result>). Then (function (return <result>)) is reduced to the <result>.") (@params ((@param "Atom to be evaluated"))) (@return "Result of atom's evaluation"))
</span>
NDet Result(131): <span class="ansi33"
>(: function (-> Atom Atom))
</span>
NDet Result(132): <span class="ansi33"
>(iz eval MinimalMeTTa)
</span>
NDet Result(133): <span class="ansi33"
>(@doc eval (@desc "Evaluates input Atom, performs one step of the evaluation. Empty results (Empty, ()) are removed from the result set. If no results are produced for a non-grounded function, eval returns NotReducible.") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function"))) (@return "Result of evaluation"))
</span>
NDet Result(134): <span class="ansi33"
>(: eval (-> Atom Atom))
</span>
NDet Result(135): <span class="ansi33"
>(@doc evalc (@desc "Evaluates input atom, makes one step of the evaluation") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function") (@param "Space to evaluate atom in its context"))) (@return "Result of evaluation"))
</span>
NDet Result(136): <span class="ansi33"
>(: evalc (-> Atom Grounded Atom))
</span>
NDet Result(137): <span class="ansi33"
>(iz chain MinimalMeTTa)
</span>
NDet Result(138): <span class="ansi33"
>(@doc chain (@desc "Evaluates first argument Atom, binds it to the Variable (second argument) and then evaluates third argument Template with Variable substituted in. When evaluation of the first Atom brings more than a single result, chain returns one instance of the Template expression for each result. The first argument Atom is only evaluated if it is part of the Minimal MeTTa specification; evaluation of non-Minimal MeTTa atoms can be controlled by wrapping in a call to eval (for one evaluation step) or metta (for full evaluation).") (@params ((@param "Atom to be evaluated") (@param "Variable") (@param "Template which will be evaluated at the end with Variable substituted"))) (@return "Result of evaluating third input argument"))
</span>
NDet Result(139): <span class="ansi33"
>(: chain (-> Atom Variable Atom Atom))
</span>
NDet Result(140): <span class="ansi33"
>(iz unify MeTTa)
</span>
NDet Result(141): <span class="ansi33"
>(@doc unify (@desc "Like Match but allows any sort of container for the first argument. (Match only allows MeTTa spaces.)") (@params ((@param "The collection or space to match") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when found or fourth one otherwise"))
</span>
NDet Result(142): <span class="ansi33"
>(: unify (-> Atom Atom Atom Atom Atom))
</span>
NDet Result(143): <span class="ansi33"
>(iz if-unify MinimalMeTTaHelper)
</span>
NDet Result(144): <span class="ansi33"
>(@doc if-unify (@desc "Matches two first terms and returns third argument if they are matched and fourth argument otherwise") (@params ((@param "First term to unify with") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when first two atoms are unifiable or fourth one otherwise"))
</span>
NDet Result(145): <span class="ansi33"
>(: if-unify (-> Atom Atom Atom Atom %Undefined%))
</span>
NDet Result(146): <span class="ansi33"
>(ALT= $10000 $10000)
</span>
#(failed #( : user once ) #( : user #(if_or_else #(eval = $10000 498 &self (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003) #(call eval (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003)) ))


#(on_mettalog_error #(failed #( : user once ) #( : user #(if_or_else #(eval = $10000 498 &self (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003) #(call eval (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003)) )))

^  <span class="ansi1 ansi32"
>Call: </span>(249) [user] call(user:once, user:if_or_else(eval(=, _854744, 498, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002), call(eval, [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002)))
^  <span class="ansi1 ansi32"
>Call: </span>(250) [user] once(user:if_or_else(eval(=, _854744, 498, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002), call(eval, [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002)))
   <span class="ansi1 ansi32"
>Call: </span>(251) [user] if_or_else(eval(=, _854744, 498, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002), call(eval, [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002))
^  <span class="ansi1 ansi32"
>Call: </span>(252) [user] eval(=, _854744, 498, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002)
^  <span class="ansi1 ansi32"
>Call: </span>(253) [user] catch_metta_return(eval_args(=, _854744, 498, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002), _858002)
^  <span class="ansi1 ansi32"
>Call: </span>(255) [user] eval_args(=, _854744, 498, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002)
   <span class="ansi1 ansi32"
>Call: </span>(256) [system] var([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
^  <span class="ansi1 ansi32"
>Call: </span>(257) [system] setup_call_cleanup('$notrace'(_876868, _876870), once(user:self_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])), '$restore_trace'(_876868, _876870))
^  <span class="ansi1 ansi32"
>Call: </span>(258) [system] sig_atomic(system:'$notrace'(_876868, _876870))
^  <span class="ansi1 ansi32"
>Call: </span>(257) [system] setup_call_cleanup('$notrace'(_878956, _878958), once(user:nonvar(_858002)), '$restore_trace'(_878956, _878958))
^  <span class="ansi1 ansi32"
>Call: </span>(258) [system] sig_atomic(system:'$notrace'(_878956, _878958))
^  <span class="ansi1 ansi32"
>Call: </span>(257) [system] setup_call_cleanup('$notrace'(_881044, _881046), once(user:nonvar(_858002)), '$restore_trace'(_881044, _881046))
^  <span class="ansi1 ansi32"
>Call: </span>(258) [system] sig_atomic(system:'$notrace'(_881044, _881046))
   <span class="ansi1 ansi32"
>Call: </span>(256) [system] [['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(256) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(256) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(256) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(256) [user] self_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
^  <span class="ansi1 ansi32"
>Call: </span>(258) [system] setup_call_cleanup('$notrace'(_888200, _888202), once(user:self_eval0([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])), '$restore_trace'(_888200, _888202))
^  <span class="ansi1 ansi32"
>Call: </span>(259) [system] sig_atomic(system:'$notrace'(_888200, _888202))
^  <span class="ansi1 ansi31"
>Fail: </span>(256) [user] self_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
^  <span class="ansi1 ansi32"
>Call: </span>(256) [user] eval_00(=, _854744, 498, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002)
^  <span class="ansi1 ansi32"
>Call: </span>(257) [user] self_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
^  <span class="ansi1 ansi32"
>Call: </span>(259) [system] setup_call_cleanup('$notrace'(_893344, _893346), once(user:self_eval0([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])), '$restore_trace'(_893344, _893346))
^  <span class="ansi1 ansi32"
>Call: </span>(260) [system] sig_atomic(system:'$notrace'(_893344, _893346))
^  <span class="ansi1 ansi31"
>Fail: </span>(257) [user] self_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
^  <span class="ansi1 ansi32"
>Call: </span>(257) [user] eval_01(=, _854744, 498, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002)
   <span class="ansi1 ansi32"
>Call: </span>(258) [system] [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(258) [system] [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(258) [user] if_t((498<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(260) [system] 498<1
   <span class="ansi1 ansi31"
>Fail: </span>(260) [system] 498<1
^  <span class="ansi1 ansi32"
>Exit: </span>(258) [user] if_t((498<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(259) [system] setup_call_cleanup('$notrace'(_903618, _903620), once(user:(_903594 is 498-1, copy_term([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _903608))), '$restore_trace'(_903618, _903620))
^  <span class="ansi1 ansi32"
>Call: </span>(260) [system] sig_atomic(system:'$notrace'(_903618, _903620))
^  <span class="ansi1 ansi32"
>Exit: </span>(259) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(497 is 498-1, copy_term([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], [case, ['if-unify-or-empty', _905716, _905716], [['Empty', _905746]]]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(258) [user] trace_eval(eval_20(=, _854744), e, 497, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _906782)
^  <span class="ansi1 ansi32"
>Call: </span>(259) [user] must_det_ll((notrace((flag(eval_num, _907836, _907836+1), _907854 is _907836 mod 500, _907872 is 99-497 mod 100, _907896=_907898, option_else('trace-length', _907910, 500), option_else('trace-depth', _907918, 30))), quietly(if_t((nop(stop_rtrace), _907854>_907910), (set_debug(eval, false), _907974 is _907910+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_907974])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_908026)))))
^  <span class="ansi1 ansi32"
>Call: </span>(260) [user] once(user:(notrace((flag(eval_num, _907836, _907836+1), _907854 is _907836 mod 500, _907872 is 99-497 mod 100, _907896=_907898, option_else('trace-length', _907910, 500), option_else('trace-depth', _907918, 30))), quietly(if_t((nop(stop_rtrace), _907854>_907910), (set_debug(eval, false), _907974 is _907910+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_907974])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_908026)))))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [system] setup_call_cleanup('$notrace'(_910072, _910074), once(user:(flag(eval_num, _907836, _907836+1), _907854 is _907836 mod 500, _907872 is 99-497 mod 100, _907896=_907898, option_else('trace-length', _907910, 500), option_else('trace-depth', _907918, 30))), '$restore_trace'(_910072, _910074))
^  <span class="ansi1 ansi32"
>Call: </span>(264) [system] sig_atomic(system:'$notrace'(_910072, _910074))
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 14, 14+1), 14 is 14 mod 500, 2 is 99-497 mod 100, _907896=_907896, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 14>500), (set_debug(eval, false), _907974 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_907974])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 14>500), (set_debug(eval, false), _907974 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_907974])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(262) [user] nop(notrace(no_repeats_var(_908026)))
   <span class="ansi1 ansi32"
>Exit: </span>(262) [user] nop(notrace(no_repeats_var(_908026)))
^  <span class="ansi1 ansi32"
>Exit: </span>(260) [system] once(user:(notrace((flag(eval_num, 14, 14+1), 14 is 14 mod 500, 2 is 99-497 mod 100, _907896=_907896, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 14>500), (set_debug(eval, false), _907974 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_907974])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_908026)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(259) [user] must_det_ll(user:(notrace((flag(eval_num, 14, 14+1), 14 is 14 mod 500, 2 is 99-497 mod 100, _907896=_907896, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 14>500), (set_debug(eval, false), _907974 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_907974])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_908026)))))
   <span class="ansi1 ansi32"
>Call: </span>(259) [occurs] occurs:sub_term(_919724, e)
   <span class="ansi1 ansi32"
>Exit: </span>(259) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(259) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(259) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(260) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(260) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(259) [occurs] occurs:sub_term(_919724, e)
   <span class="ansi1 ansi32"
>Call: </span>(259) [system] _926830=e
   <span class="ansi1 ansi32"
>Exit: </span>(259) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(259) [user] if_trace((eval;e), (_907896=1, indentq(2, 14, -->, [e, [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(261) [system] setup_call_cleanup('$notrace'(_929970, _929972), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _907896=1, indentq(2, 14, -->, [e, [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]]))), _929928, fbug((_929928-->if_trace((eval;e), (_907896=1, indentq(2, 14, -->, [e, [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]])))))))), '$restore_trace'(_929970, _929972))
^  <span class="ansi1 ansi32"
>Call: </span>(262) [system] sig_atomic(system:'$notrace'(_929970, _929972))
^  <span class="ansi1 ansi32"
>Exit: </span>(261) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _907896=1, indentq(2, 14, -->, [e, [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]]))), _929928, fbug((_929928-->if_trace((eval;e), (_907896=1, indentq(2, 14, -->, [e, [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(259) [user] if_trace((eval;e), (_907896=1, indentq(2, 14, -->, [e, [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]])))
   <span class="ansi1 ansi32"
>Call: </span>(259) [system] _934166=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(259) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(259) [system] _936204=(\+ \+ (flag(eval_num, _936224, _936224+1), (retval(fail)\=@=retval(fail), nonvar(_906782)->indentq(2, _936224, <--, [e, _906782]);indentq(2, _936224, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(259) [system] (\+ \+ (flag(eval_num, _936224, _936224+1), (retval(fail)\=@=retval(fail), nonvar(_906782)->indentq(2, _936224, <--, [e, _906782]);indentq(2, _936224, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _936224, _936224+1), (retval(fail)\=@=retval(fail), nonvar(_906782)->indentq(2, _936224, <--, [e, _906782]);indentq(2, _936224, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(259) [user] call_cleanup(((call(eval_20(=, _854744), 497, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _906782)*->nb_setarg(1, retval(fail), _906782);fail, trace, call(eval_20(=, _854744), 497, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _906782)), ignore(notrace((\+_906782\=_908026, nb_setarg(1, retval(fail), _906782))))), ignore((_907896==1->ignore(\+ \+ (flag(eval_num, _936224, _936224+1), (retval(fail)\=@=retval(fail), nonvar(_906782)->indentq(2, _936224, <--, [e, _906782]);indentq(2, _936224, <--, [e, retval(fail)]))));notrace(ignore(if_t(2<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _936224, _936224+1), (retval(fail)\=@=retval(fail), nonvar(_906782)->indentq(2, _936224, <--, [e, _906782]);indentq(2, _936224, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(261) [user] eval_20(=, _854744, 497, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _906782)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] atom([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] no_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] self_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
^  <span class="ansi1 ansi32"
>Call: </span>(265) [system] setup_call_cleanup('$notrace'(_943612, _943614), once(user:self_eval0([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])), '$restore_trace'(_943612, _943614))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [system] sig_atomic(system:'$notrace'(_943612, _943614))
^  <span class="ansi1 ansi31"
>Fail: </span>(263) [user] self_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
   <span class="ansi1 ansi32"
>Call: </span>(263) [system] atomic(case)
   <span class="ansi1 ansi32"
>Exit: </span>(263) [system] atomic(case)
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] is_sl(case)
   <span class="ansi1 ansi32"
>Call: </span>(264) [system] number(case)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] [['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(262) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] callable(case)
   <span class="ansi1 ansi32"
>Exit: </span>(262) [system] callable(case)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] [['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] is_list([['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
   <span class="ansi1 ansi32"
>Exit: </span>(262) [system] is_list([['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] is_list(case)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] is_list([['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
   <span class="ansi1 ansi32"
>Exit: </span>(262) [system] is_list([['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] is_list([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
   <span class="ansi1 ansi32"
>Exit: </span>(262) [system] is_list([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] once(expand_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _965956))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] expand_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _965956)
   <span class="ansi1 ansi32"
>Call: </span>(264) [system] is_list([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
   <span class="ansi1 ansi32"
>Exit: </span>(264) [system] is_list([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
   <span class="ansi1 ansi32"
>Call: </span>(264) [system] ground(case)
   <span class="ansi1 ansi32"
>Exit: </span>(264) [system] ground(case)
^  <span class="ansi1 ansi32"
>Call: </span>(264) [user] apply:maplist(expand_eval, [['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _972056)
   <span class="ansi1 ansi32"
>Call: </span>(265) [apply] apply:maplist_([['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _972056, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] expand_eval(['if-unify-or-empty', _845060, _845060], _974112)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] is_list(['if-unify-or-empty', _845060, _845060])
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] is_list(['if-unify-or-empty', _845060, _845060])
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] apply:maplist(expand_eval, [_845060, _845060], _979190)
   <span class="ansi1 ansi32"
>Call: </span>(268) [apply] apply:maplist_([_845060, _845060], _979190, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] expand_eval(_845060, _981246)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] is_list(_845060)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] _845060=_981246
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] _845060=_845060
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] expand_eval(_845060, _845060)
   <span class="ansi1 ansi32"
>Call: </span>(269) [apply] apply:maplist_([_845060], _981248, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] expand_eval(_845060, _987348)
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] is_list(_845060)
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] _845060=_987348
   <span class="ansi1 ansi32"
>Exit: </span>(271) [system] _845060=_845060
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [user] expand_eval(_845060, _845060)
   <span class="ansi1 ansi32"
>Call: </span>(270) [apply] apply:maplist_([], _987350, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(270) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(269) [apply] apply:maplist_([_845060], [_845060], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(268) [apply] apply:maplist_([_845060, _845060], [_845060, _845060], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [apply] apply:maplist(user:expand_eval, [_845060, _845060], [_845060, _845060])
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] expand_eval(['if-unify-or-empty', _845060, _845060], ['if-unify-or-empty', _845060, _845060])
   <span class="ansi1 ansi32"
>Call: </span>(266) [apply] apply:maplist_([[['Empty', _845078]]], _974114, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] expand_eval([['Empty', _845078]], _999572)
   <span class="ansi1 ansi32"
>Call: </span>(268) [system] is_list([['Empty', _845078]])
   <span class="ansi1 ansi32"
>Exit: </span>(268) [system] is_list([['Empty', _845078]])
   <span class="ansi1 ansi32"
>Call: </span>(268) [system] ground(['Empty', _845078])
^  <span class="ansi1 ansi32"
>Call: </span>(268) [user] apply:maplist(expand_eval, [], _1002620)
   <span class="ansi1 ansi32"
>Call: </span>(269) [apply] apply:maplist_([], _1002620, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(269) [apply] apply:maplist_([], [], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [apply] apply:maplist(user:expand_eval, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [user] expand_eval([['Empty', _845078]], [['Empty', _845078]])
   <span class="ansi1 ansi32"
>Call: </span>(267) [apply] apply:maplist_([], _999574, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(267) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(266) [apply] apply:maplist_([[['Empty', _845078]]], [[['Empty', _845078]]], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(265) [apply] apply:maplist_([['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], [['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(264) [apply] apply:maplist(user:expand_eval, [['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], [['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [user] expand_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(262) [system] once(user:expand_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]))
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]\==[case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] is_progn(case)
   <span class="ansi1 ansi32"
>Call: </span>(263) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] is_space_op(case)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] must_det_ll([]==[])
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] once(user:([]==[]))
   <span class="ansi1 ansi32"
>Call: </span>(264) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(264) [system] []==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [system] once(user:([]==[]))
^  <span class="ansi1 ansi32"
>Exit: </span>(262) [user] must_det_ll(user:([]==[]))
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] into_case_list([['Empty', _845078]], _1028064)
   <span class="ansi1 ansi32"
>Call: </span>(263) [system] is_list([['Empty', _845078]])
   <span class="ansi1 ansi32"
>Exit: </span>(263) [system] is_list([['Empty', _845078]])
^  <span class="ansi1 ansi32"
>Exit: </span>(262) [user] into_case_list([['Empty', _845078]], [['Empty', _845078]])
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] into_case_keys(1, [['Empty', _845078]], _1032122)
   <span class="ansi1 ansi32"
>Call: </span>(263) [system] _1033162 is 1+1
   <span class="ansi1 ansi32"
>Exit: </span>(263) [system] 2 is 1+1
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] is_case(_1033152, ['Empty', _845078], _1033154)
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [user] is_case('Empty', ['Empty', _845078], _845078)
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_845078)))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [system] setup_call_cleanup('$notrace'(_1038328, _1038330), once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_845078))), _1038286, fbug((_1038286-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_845078)))))))), '$restore_trace'(_1038328, _1038330))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [system] sig_atomic(system:'$notrace'(_1038328, _1038330))
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_845078))), _1038286, fbug((_1038286-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_845078)))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_845078)))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] into_case_keys(2, [], _1033148)
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [user] into_case_keys(2, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(262) [user] into_case_keys(1, [['Empty', _845078]], ['Empty'-_845078])
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] eval_case(=, _854744, 497, '&self', ['if-unify-or-empty', _845060, _845060], ['Empty'-_845078], _906782)
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _845060, _845060]))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [system] setup_call_cleanup('$notrace'(_1047696, _1047698), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _845060, _845060]))), _1047654, fbug((_1047654-->if_trace(case, writeqln(case=['if-unify-or-empty', _845060, _845060]))))))), '$restore_trace'(_1047696, _1047698))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [system] sig_atomic(system:'$notrace'(_1047696, _1047698))
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _845060, _845060]))), _1047654, fbug((_1047654-->if_trace(case, writeqln(case=['if-unify-or-empty', _845060, _845060]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _845060, _845060]))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] eval_args(=, _1052018, 497, '&self', ['if-unify-or-empty', _845060, _845060], _1051892)
   <span class="ansi1 ansi32"
>Call: </span>(264) [system] var(['if-unify-or-empty', _845060, _845060])
^  <span class="ansi1 ansi32"
>Call: </span>(265) [system] setup_call_cleanup('$notrace'(_1053950, _1053952), once(user:self_eval(['if-unify-or-empty', _845060, _845060])), '$restore_trace'(_1053950, _1053952))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [system] sig_atomic(system:'$notrace'(_1053950, _1053952))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [system] setup_call_cleanup('$notrace'(_1056038, _1056040), once(user:nonvar(_1051892)), '$restore_trace'(_1056038, _1056040))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [system] sig_atomic(system:'$notrace'(_1056038, _1056040))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [system] setup_call_cleanup('$notrace'(_1058126, _1058128), once(user:nonvar(_1051892)), '$restore_trace'(_1058126, _1058128))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [system] sig_atomic(system:'$notrace'(_1058126, _1058128))
   <span class="ansi1 ansi32"
>Call: </span>(264) [system] [_845060, _845060]==[]
   <span class="ansi1 ansi32"
>Call: </span>(264) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(264) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(264) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(264) [user] self_eval(['if-unify-or-empty', _845060, _845060])
^  <span class="ansi1 ansi32"
>Call: </span>(266) [system] setup_call_cleanup('$notrace'(_1065282, _1065284), once(user:self_eval0(['if-unify-or-empty', _845060, _845060])), '$restore_trace'(_1065282, _1065284))
^  <span class="ansi1 ansi32"
>Call: </span>(267) [system] sig_atomic(system:'$notrace'(_1065282, _1065284))
^  <span class="ansi1 ansi31"
>Fail: </span>(264) [user] self_eval(['if-unify-or-empty', _845060, _845060])
^  <span class="ansi1 ansi32"
>Call: </span>(264) [user] eval_00(=, _1068370, 497, '&self', ['if-unify-or-empty', _845060, _845060], _1051892)
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] self_eval(['if-unify-or-empty', _845060, _845060])
^  <span class="ansi1 ansi32"
>Call: </span>(267) [system] setup_call_cleanup('$notrace'(_1070428, _1070430), once(user:self_eval0(['if-unify-or-empty', _845060, _845060])), '$restore_trace'(_1070428, _1070430))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] sig_atomic(system:'$notrace'(_1070428, _1070430))
^  <span class="ansi1 ansi31"
>Fail: </span>(265) [user] self_eval(['if-unify-or-empty', _845060, _845060])
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] eval_01(=, _1068370, 497, '&self', ['if-unify-or-empty', _845060, _845060], _1051892)
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] ['if-unify-or-empty', _845060, _845060]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(266) [system] ['if-unify-or-empty', _845060, _845060]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] if_t((497<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(268) [system] 497<1
   <span class="ansi1 ansi31"
>Fail: </span>(268) [system] 497<1
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] if_t((497<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(267) [system] setup_call_cleanup('$notrace'(_1080702, _1080704), once(user:(_1080678 is 497-1, copy_term(['if-unify-or-empty', _845060, _845060], _1080692))), '$restore_trace'(_1080702, _1080704))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] sig_atomic(system:'$notrace'(_1080702, _1080704))
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(496 is 497-1, copy_term(['if-unify-or-empty', _845060, _845060], ['if-unify-or-empty', _1082788, _1082788]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] trace_eval(eval_20(=, _1068370), e, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1083830)
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] must_det_ll((notrace((flag(eval_num, _1084884, _1084884+1), _1084902 is _1084884 mod 500, _1084920 is 99-496 mod 100, _1084944=_1084946, option_else('trace-length', _1084958, 500), option_else('trace-depth', _1084966, 30))), quietly(if_t((nop(stop_rtrace), _1084902>_1084958), (set_debug(eval, false), _1085022 is _1084958+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1085022])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1085074)))))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [user] once(user:(notrace((flag(eval_num, _1084884, _1084884+1), _1084902 is _1084884 mod 500, _1084920 is 99-496 mod 100, _1084944=_1084946, option_else('trace-length', _1084958, 500), option_else('trace-depth', _1084966, 30))), quietly(if_t((nop(stop_rtrace), _1084902>_1084958), (set_debug(eval, false), _1085022 is _1084958+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1085022])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1085074)))))
^  <span class="ansi1 ansi32"
>Call: </span>(271) [system] setup_call_cleanup('$notrace'(_1087120, _1087122), once(user:(flag(eval_num, _1084884, _1084884+1), _1084902 is _1084884 mod 500, _1084920 is 99-496 mod 100, _1084944=_1084946, option_else('trace-length', _1084958, 500), option_else('trace-depth', _1084966, 30))), '$restore_trace'(_1087120, _1087122))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] sig_atomic(system:'$notrace'(_1087120, _1087122))
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 15, 15+1), 15 is 15 mod 500, 3 is 99-496 mod 100, _1084944=_1084944, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(271) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 15>500), (set_debug(eval, false), _1085022 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1085022])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 15>500), (set_debug(eval, false), _1085022 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1085022])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(270) [user] nop(notrace(no_repeats_var(_1085074)))
   <span class="ansi1 ansi32"
>Exit: </span>(270) [user] nop(notrace(no_repeats_var(_1085074)))
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [system] once(user:(notrace((flag(eval_num, 15, 15+1), 15 is 15 mod 500, 3 is 99-496 mod 100, _1084944=_1084944, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 15>500), (set_debug(eval, false), _1085022 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1085022])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1085074)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [user] must_det_ll(user:(notrace((flag(eval_num, 15, 15+1), 15 is 15 mod 500, 3 is 99-496 mod 100, _1084944=_1084944, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 15>500), (set_debug(eval, false), _1085022 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1085022])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1085074)))))
   <span class="ansi1 ansi32"
>Call: </span>(267) [occurs] occurs:sub_term(_1096772, e)
   <span class="ansi1 ansi32"
>Exit: </span>(267) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(267) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(268) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(268) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(267) [occurs] occurs:sub_term(_1096772, e)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] _1103878=e
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] if_trace((eval;e), (_1084944=1, indentq(3, 15, -->, [e, ['if-unify-or-empty', _845060, _845060]])))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] setup_call_cleanup('$notrace'(_1107018, _1107020), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _1084944=1, indentq(3, 15, -->, [e, ['if-unify-or-empty', _845060, _845060]]))), _1106976, fbug((_1106976-->if_trace((eval;e), (_1084944=1, indentq(3, 15, -->, [e, ['if-unify-or-empty', _845060, _845060]])))))))), '$restore_trace'(_1107018, _1107020))
^  <span class="ansi1 ansi32"
>Call: </span>(270) [system] sig_atomic(system:'$notrace'(_1107018, _1107020))
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _1084944=1, indentq(3, 15, -->, [e, ['if-unify-or-empty', _845060, _845060]]))), _1106976, fbug((_1106976-->if_trace((eval;e), (_1084944=1, indentq(3, 15, -->, [e, ['if-unify-or-empty', _845060, _845060]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [user] if_trace((eval;e), (_1084944=1, indentq(3, 15, -->, [e, ['if-unify-or-empty', _845060, _845060]])))
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] _1111214=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] _1113252=(\+ \+ (flag(eval_num, _1113272, _1113272+1), (retval(fail)\=@=retval(fail), nonvar(_1083830)->indentq(3, _1113272, <--, [e, _1083830]);indentq(3, _1113272, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] (\+ \+ (flag(eval_num, _1113272, _1113272+1), (retval(fail)\=@=retval(fail), nonvar(_1083830)->indentq(3, _1113272, <--, [e, _1083830]);indentq(3, _1113272, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _1113272, _1113272+1), (retval(fail)\=@=retval(fail), nonvar(_1083830)->indentq(3, _1113272, <--, [e, _1083830]);indentq(3, _1113272, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] call_cleanup(((call(eval_20(=, _1068370), 496, '&self', ['if-unify-or-empty', _845060, _845060], _1083830)*->nb_setarg(1, retval(fail), _1083830);fail, trace, call(eval_20(=, _1068370), 496, '&self', ['if-unify-or-empty', _845060, _845060], _1083830)), ignore(notrace((\+_1083830\=_1085074, nb_setarg(1, retval(fail), _1083830))))), ignore((_1084944==1->ignore(\+ \+ (flag(eval_num, _1113272, _1113272+1), (retval(fail)\=@=retval(fail), nonvar(_1083830)->indentq(3, _1113272, <--, [e, _1083830]);indentq(3, _1113272, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1113272, _1113272+1), (retval(fail)\=@=retval(fail), nonvar(_1083830)->indentq(3, _1113272, <--, [e, _1083830]);indentq(3, _1113272, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] eval_20(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1083830)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] atom(['if-unify-or-empty', _845060, _845060])
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] no_eval(['if-unify-or-empty', _845060, _845060])
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] self_eval(['if-unify-or-empty', _845060, _845060])
^  <span class="ansi1 ansi32"
>Call: </span>(273) [system] setup_call_cleanup('$notrace'(_1120660, _1120662), once(user:self_eval0(['if-unify-or-empty', _845060, _845060])), '$restore_trace'(_1120660, _1120662))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [system] sig_atomic(system:'$notrace'(_1120660, _1120662))
^  <span class="ansi1 ansi31"
>Fail: </span>(271) [user] self_eval(['if-unify-or-empty', _845060, _845060])
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] atomic('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(271) [system] atomic('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] is_sl('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(272) [system] number('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] [_845060, _845060]==[]
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] _1131854==eval
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] [_845060, _845060]==[]
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] is_list([_845060, _845060])
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] is_list([_845060, _845060])
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] is_list('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] is_list([_845060, _845060])
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] is_list([_845060, _845060])
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] is_list(['if-unify-or-empty', _845060, _845060])
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] is_list(['if-unify-or-empty', _845060, _845060])
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] once(expand_eval(['if-unify-or-empty', _845060, _845060], _1144032))
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] expand_eval(['if-unify-or-empty', _845060, _845060], _1144032)
   <span class="ansi1 ansi32"
>Call: </span>(272) [system] is_list(['if-unify-or-empty', _845060, _845060])
   <span class="ansi1 ansi32"
>Exit: </span>(272) [system] is_list(['if-unify-or-empty', _845060, _845060])
   <span class="ansi1 ansi32"
>Call: </span>(272) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(272) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] apply:maplist(expand_eval, [_845060, _845060], _1150132)
   <span class="ansi1 ansi32"
>Call: </span>(273) [apply] apply:maplist_([_845060, _845060], _1150132, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] expand_eval(_845060, _1152188)
   <span class="ansi1 ansi32"
>Call: </span>(275) [system] is_list(_845060)
   <span class="ansi1 ansi32"
>Call: </span>(275) [system] _845060=_1152188
   <span class="ansi1 ansi32"
>Exit: </span>(275) [system] _845060=_845060
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [user] expand_eval(_845060, _845060)
   <span class="ansi1 ansi32"
>Call: </span>(274) [apply] apply:maplist_([_845060], _1152190, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] expand_eval(_845060, _1158290)
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] is_list(_845060)
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] _845060=_1158290
   <span class="ansi1 ansi32"
>Exit: </span>(276) [system] _845060=_845060
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] expand_eval(_845060, _845060)
   <span class="ansi1 ansi32"
>Call: </span>(275) [apply] apply:maplist_([], _1158292, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(275) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(274) [apply] apply:maplist_([_845060], [_845060], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(273) [apply] apply:maplist_([_845060, _845060], [_845060, _845060], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [apply] apply:maplist(user:expand_eval, [_845060, _845060], [_845060, _845060])
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [user] expand_eval(['if-unify-or-empty', _845060, _845060], ['if-unify-or-empty', _845060, _845060])
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [system] once(user:expand_eval(['if-unify-or-empty', _845060, _845060], ['if-unify-or-empty', _845060, _845060]))
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] ['if-unify-or-empty', _845060, _845060]\==['if-unify-or-empty', _845060, _845060]
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] is_progn('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] is_space_op('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] arg(_1175712, v('catch!', 'throw!', 'number-of!', 'limit!', 'offset!', 'max-time!', 'findall!', 'setup-call-cleanup!', 'call-cleanup!', 'call-cleanup!', 'with-output-to!'), 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] _1176610='if-unify-or-empty'
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] 'if-unify-or-empty'='if-unify-or-empty'
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _1178644)
^  <span class="ansi1 ansi31"
>Fail: </span>(270) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _1178644)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] is_list(['if-unify-or-empty', _845060, _845060])
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] is_list(['if-unify-or-empty', _845060, _845060])
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] apply:maplist(self_eval, ['if-unify-or-empty', _845060, _845060])
   <span class="ansi1 ansi32"
>Call: </span>(271) [apply] apply:maplist_(['if-unify-or-empty', _845060, _845060], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] self_eval('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(274) [system] setup_call_cleanup('$notrace'(_1185778, _1185780), once(user:self_eval0('if-unify-or-empty')), '$restore_trace'(_1185778, _1185780))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] sig_atomic(system:'$notrace'(_1185778, _1185780))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0('if-unify-or-empty')), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] self_eval('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(272) [apply] apply:maplist_([_845060, _845060], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] self_eval(_845060)
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] setup_call_cleanup('$notrace'(_1191932, _1191934), once(user:self_eval0(_845060)), '$restore_trace'(_1191932, _1191934))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [system] sig_atomic(system:'$notrace'(_1191932, _1191934))
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_845060)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(273) [user] self_eval(_845060)
   <span class="ansi1 ansi32"
>Call: </span>(273) [apply] apply:maplist_([_845060], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] self_eval(_845060)
^  <span class="ansi1 ansi32"
>Call: </span>(276) [system] setup_call_cleanup('$notrace'(_1198086, _1198088), once(user:self_eval0(_845060)), '$restore_trace'(_1198086, _1198088))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [system] sig_atomic(system:'$notrace'(_1198086, _1198088))
^  <span class="ansi1 ansi32"
>Exit: </span>(276) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_845060)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [user] self_eval(_845060)
   <span class="ansi1 ansi32"
>Call: </span>(274) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(274) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(273) [apply] apply:maplist_([_845060], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(272) [apply] apply:maplist_([_845060, _845060], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(271) [apply] apply:maplist_(['if-unify-or-empty', _845060, _845060], user:self_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [apply] apply:maplist(user:self_eval, ['if-unify-or-empty', _845060, _845060])
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] ['if-unify-or-empty', _845060, _845060]=[_1208304|_1208306]
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] ['if-unify-or-empty', _845060, _845060]=['if-unify-or-empty', _845060, _845060]
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] _1212364=do_more_defs(true)
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] do_more_defs(true)=do_more_defs(true)
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] clause(eval_21(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1083830), _1214416)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] 'if-unify-or-empty'==(/)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] 'if-unify-or-empty'== ===
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] 'if-unify-or-empty'== ====
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] eval_40(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488)
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] eval_selfless(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488)
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] eval_selfless_0(['if-unify-or-empty', _845060, _845060], _1218488)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] is_assignment('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(274) [system] atom('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] eval_selfless_1(['if-unify-or-empty', _845060, _845060], _1218488)
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] allow_clp
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] false_flag
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(276) [system] fail
^  <span class="ansi1 ansi31"
>Fail: </span>(275) [user] false_flag
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] eval_selfless_2(['if-unify-or-empty', _845060, _845060], _1218488)
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] fake_notrace((ground(['if-unify-or-empty', _845060, _845060]), ['if-unify-or-empty', _845060, _845060]=[_1233712, _1233718, _1233724], atom(_1233712), catch_warn(current_op(_1233750, yfx, _1233712)), ['if-unify-or-empty', _845060, _845060]\=[_1233770], s2ps(['if-unify-or-empty', _845060, _845060], _1233778)))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] real_notrace(user:(ground(['if-unify-or-empty', _845060, _845060]), ['if-unify-or-empty', _845060, _845060]=[_1233712, _1233718, _1233724], atom(_1233712), catch_warn(current_op(_1233750, yfx, _1233712)), ['if-unify-or-empty', _845060, _845060]\=[_1233770], s2ps(['if-unify-or-empty', _845060, _845060], _1233778)))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] setup_call_cleanup('$notrace'(_1235812, _1235814), once(user:(ground(['if-unify-or-empty', _845060, _845060]), ['if-unify-or-empty', _845060, _845060]=[_1233712, _1233718, _1233724], atom(_1233712), catch_warn(current_op(_1233750, yfx, _1233712)), ['if-unify-or-empty', _845060, _845060]\=[_1233770], s2ps(['if-unify-or-empty', _845060, _845060], _1233778))), '$restore_trace'(_1235812, _1235814))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [system] sig_atomic(user:'$notrace'(_1235812, _1235814))
^  <span class="ansi1 ansi31"
>Fail: </span>(275) [user] real_notrace(user:(ground(['if-unify-or-empty', _845060, _845060]), ['if-unify-or-empty', _845060, _845060]=[_1233712, _1233718, _1233724], atom(_1233712), catch_warn(current_op(_1233750, yfx, _1233712)), ['if-unify-or-empty', _845060, _845060]\=[_1233770], s2ps(['if-unify-or-empty', _845060, _845060], _1233778)))
^  <span class="ansi1 ansi31"
>Fail: </span>(274) [user] fake_notrace(user:(ground(['if-unify-or-empty', _845060, _845060]), ['if-unify-or-empty', _845060, _845060]=[_1233712, _1233718, _1233724], atom(_1233712), catch_warn(current_op(_1233750, yfx, _1233712)), ['if-unify-or-empty', _845060, _845060]\=[_1233770], s2ps(['if-unify-or-empty', _845060, _845060], _1233778)))
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] 'if-unify-or-empty'==(==)
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] 'if-unify-or-empty'==(==)
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] eval_41(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488)
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] eval_adjust_args(=, _1068370, _1249000, _1218488, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1249002)
   <span class="ansi1 ansi32"
>Call: </span>(273) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _1068370, _1249000, _1218488, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1249002)), eval_adjust_args1(=, _1068370, _1249000, _1218488, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1249002))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(276) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] eval_adjust_args2(=, _1068370, _1249000, _1218488, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1249002)
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] apply:maplist(must_eval_args(=, _1256156, 496, '&self'), [_845060, _845060], _1256150)
   <span class="ansi1 ansi32"
>Call: </span>(277) [apply] apply:maplist_([_845060, _845060], _1256150, user:must_eval_args(=, _1256156, 496, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] must_eval_args(=, _1256156, 496, '&self', _845060, _1258216)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(280) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(282) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] was_option_value(nodebug, _1269380)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] current_prolog_flag(nodebug, _1270398)
   <span class="ansi1 ansi31"
>Fail: </span>(284) [system] current_prolog_flag(nodebug, _1270398)
   <span class="ansi1 ansi32"
>Call: </span>(284) [$syspreds] prolog_load_context(nodebug, _1272432)
   <span class="ansi1 ansi31"
>Fail: </span>(284) [$syspreds] prolog_load_context(nodebug, _1272432)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] nb_current(nodebug, _1274466)
   <span class="ansi1 ansi31"
>Fail: </span>(284) [system] nb_current(nodebug, _1274466)
^  <span class="ansi1 ansi31"
>Fail: </span>(283) [user] was_option_value(nodebug, _1269380)
^  <span class="ansi1 ansi31"
>Fail: </span>(282) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(282) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(283) [system] setup_call_cleanup('$notrace'(_1280578, _1280580), once(user:option_value0(nodebug, true)), '$restore_trace'(_1280578, _1280580))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] sig_atomic(system:'$notrace'(_1280578, _1280580))
^  <span class="ansi1 ansi31"
>Fail: </span>(281) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(280) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(280) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(280) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(281) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(280) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(281) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(280) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(280) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1300918)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1300918, _1302062)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_1306028, _1306030, _1306032), defined)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(283) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(283) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1306028, _1306030, _1306032))
   <span class="ansi1 ansi32"
>Call: </span>(284) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1306028, _1306030, _1306032))
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] callable(debugging_logicmoo_setting(_1306028, _1306030, _1306032))
   <span class="ansi1 ansi32"
>Exit: </span>(285) [system] callable(debugging_logicmoo_setting(_1306028, _1306030, _1306032))
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(285) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(284) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1306028, _1306030, _1306032))
   <span class="ansi1 ansi32"
>Exit: </span>(283) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1306028, _1306030, _1306032))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_1306028, _1306030, _1306032), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _1300918, _1318212)
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(280) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] eval_args(=, _1256156, 496, '&self', _845060, _1258216)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] var(_845060)
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] var(_845060)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] nonvar(_1258216)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [system] setup_call_cleanup('$notrace'(_1329438, _1329440), once(user:self_eval(_845060)), '$restore_trace'(_1329438, _1329440))
^  <span class="ansi1 ansi32"
>Call: </span>(282) [system] sig_atomic(system:'$notrace'(_1329438, _1329440))
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_845060)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] _1258216=_845060
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] _845060=_845060
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] eval_args(=, _1256156, 496, '&self', _845060, _845060)
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [user] must_eval_args(=, _1256156, 496, '&self', _845060, _845060)
   <span class="ansi1 ansi32"
>Call: </span>(278) [apply] apply:maplist_([_845060], _1258218, user:must_eval_args(=, _1256156, 496, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] must_eval_args(=, _1256156, 496, '&self', _845060, _1337702)
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(281) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(283) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(283) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] was_option_value(nodebug, _1348866)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] current_prolog_flag(nodebug, _1349884)
   <span class="ansi1 ansi31"
>Fail: </span>(285) [system] current_prolog_flag(nodebug, _1349884)
   <span class="ansi1 ansi32"
>Call: </span>(285) [$syspreds] prolog_load_context(nodebug, _1351918)
   <span class="ansi1 ansi31"
>Fail: </span>(285) [$syspreds] prolog_load_context(nodebug, _1351918)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] nb_current(nodebug, _1353952)
   <span class="ansi1 ansi31"
>Fail: </span>(285) [system] nb_current(nodebug, _1353952)
^  <span class="ansi1 ansi31"
>Fail: </span>(284) [user] was_option_value(nodebug, _1348866)
^  <span class="ansi1 ansi31"
>Fail: </span>(283) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(283) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] setup_call_cleanup('$notrace'(_1360064, _1360066), once(user:option_value0(nodebug, true)), '$restore_trace'(_1360064, _1360066))
^  <span class="ansi1 ansi32"
>Call: </span>(285) [system] sig_atomic(system:'$notrace'(_1360064, _1360066))
^  <span class="ansi1 ansi31"
>Fail: </span>(282) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(281) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(281) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(281) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(282) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(281) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(282) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(281) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(281) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1380404)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1380404, _1381548)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_1385514, _1385516, _1385518), defined)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(284) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(284) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1385514, _1385516, _1385518))
   <span class="ansi1 ansi32"
>Call: </span>(285) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1385514, _1385516, _1385518))
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] callable(debugging_logicmoo_setting(_1385514, _1385516, _1385518))
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] callable(debugging_logicmoo_setting(_1385514, _1385516, _1385518))
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(285) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1385514, _1385516, _1385518))
   <span class="ansi1 ansi32"
>Exit: </span>(284) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1385514, _1385516, _1385518))
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_1385514, _1385516, _1385518), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _1380404, _1397698)
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(281) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(280) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] eval_args(=, _1256156, 496, '&self', _845060, _1337702)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] var(_845060)
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] var(_845060)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] nonvar(_1337702)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [system] setup_call_cleanup('$notrace'(_1408924, _1408926), once(user:self_eval(_845060)), '$restore_trace'(_1408924, _1408926))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [system] sig_atomic(system:'$notrace'(_1408924, _1408926))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_845060)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] _1337702=_845060
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] _845060=_845060
^  <span class="ansi1 ansi32"
>Exit: </span>(280) [user] eval_args(=, _1256156, 496, '&self', _845060, _845060)
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] must_eval_args(=, _1256156, 496, '&self', _845060, _845060)
   <span class="ansi1 ansi32"
>Call: </span>(279) [apply] apply:maplist_([], _1337704, user:must_eval_args(=, _1256156, 496, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(279) [apply] apply:maplist_([], [], user:must_eval_args(=, _1256156, 496, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(278) [apply] apply:maplist_([_845060], [_845060], user:must_eval_args(=, _1256156, 496, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(277) [apply] apply:maplist_([_845060, _845060], [_845060, _845060], user:must_eval_args(=, _1256156, 496, '&self'))
^  <span class="ansi1 ansi32"
>Exit: </span>(276) [apply] apply:maplist(user:must_eval_args(=, _1256156, 496, '&self'), [_845060, _845060], [_845060, _845060])
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] _1249000=_1218488
   <span class="ansi1 ansi32"
>Exit: </span>(276) [system] _1218488=_1218488
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] eval_adjust_args2(=, _1068370, _1218488, _1218488, 496, '&self', ['if-unify-or-empty', _845060, _845060], ['if-unify-or-empty', _845060, _845060])
   <span class="ansi1 ansi32"
>Exit: </span>(273) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _1068370, _1218488, _1218488, 496, '&self', ['if-unify-or-empty', _845060, _845060], ['if-unify-or-empty', _845060, _845060])), eval_adjust_args1(=, _1068370, _1218488, _1218488, 496, '&self', ['if-unify-or-empty', _845060, _845060], ['if-unify-or-empty', _845060, _845060]))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] eval_adjust_args(=, _1068370, _1218488, _1218488, 496, '&self', ['if-unify-or-empty', _845060, _845060], ['if-unify-or-empty', _845060, _845060])
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] if_trace((e;args), (['if-unify-or-empty', _845060, _845060]\==['if-unify-or-empty', _845060, _845060]->color_g_mesg('#773733', indentq2(496, (['if-unify-or-empty', _845060, _845060]->['if-unify-or-empty', _845060, _845060])));nop(indentq2(496, same(['if-unify-or-empty', _845060, _845060])))))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [system] setup_call_cleanup('$notrace'(_1427510, _1427512), once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _845060, _845060]\==['if-unify-or-empty', _845060, _845060]->color_g_mesg('#773733', indentq2(496, (['if-unify-or-empty', _845060, _845060]->['if-unify-or-empty', _845060, _845060])));nop(indentq2(496, same(['if-unify-or-empty', _845060, _845060])))))), _1427468, fbug((_1427468-->if_trace((e;args), (['if-unify-or-empty', _845060, _845060]\==['if-unify-or-empty', _845060, _845060]->color_g_mesg('#773733', indentq2(496, (['if-unify-or-empty', _845060, _845060]->['if-unify-or-empty', _845060, _845060])));nop(indentq2(496, same(['if-unify-or-empty', _845060, _845060])))))))))), '$restore_trace'(_1427510, _1427512))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] sig_atomic(system:'$notrace'(_1427510, _1427512))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _845060, _845060]\==['if-unify-or-empty', _845060, _845060]->color_g_mesg('#773733', indentq2(496, (['if-unify-or-empty', _845060, _845060]->['if-unify-or-empty', _845060, _845060])));nop(indentq2(496, same(['if-unify-or-empty', _845060, _845060])))))), _1427468, fbug((_1427468-->if_trace((e;args), (['if-unify-or-empty', _845060, _845060]\==['if-unify-or-empty', _845060, _845060]->color_g_mesg('#773733', indentq2(496, (['if-unify-or-empty', _845060, _845060]->['if-unify-or-empty', _845060, _845060])));nop(indentq2(496, same(['if-unify-or-empty', _845060, _845060])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] if_trace((e;args), (['if-unify-or-empty', _845060, _845060]\==['if-unify-or-empty', _845060, _845060]->color_g_mesg('#773733', indentq2(496, (['if-unify-or-empty', _845060, _845060]->['if-unify-or-empty', _845060, _845060])));nop(indentq2(496, same(['if-unify-or-empty', _845060, _845060])))))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] eval_70(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488)
   <span class="ansi1 ansi32"
>Call: </span>(273) [user] if_or_else(eval_maybe_python(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488), if_or_else(eval_maybe_host_predicate(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488), if_or_else(eval_maybe_host_function(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488), if_or_else(eval_maybe_defn(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488), eval_maybe_subst(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488)))))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] eval_maybe_python(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488)
   <span class="ansi1 ansi32"
>Call: </span>(275) [user] metta_atom('&self', ['registered-python-function', _1434870, _1434876, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] typed_list('&self', _1436016, _1435890)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(277) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(276) [user] typed_list('&self', _1439060, _1435890)
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] metta_atom_in_file('&self', ['registered-python-function', _1434870, _1434876, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] metta_atom_in_file('&self', ['registered-python-function', _1434870, _1434876, 'if-unify-or-empty'], _1442114, _1442116)
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] loaded_into_kb('&self', _1443012)
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [user] loaded_into_kb('&self', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] once(user:asserted_metta_pred(_1466020, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] asserted_metta_pred(_1466020, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(279) [user] asserted_metta_pred(_1466020, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(276) [user] metta_atom_asserted('&self', ['registered-python-function', _1434870, _1434876, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] metta_atom_asserted_deduced('&self', ['registered-python-function', _1434870, _1434876, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(276) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(276) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(276) [user] metta_atom('&corelib', ['registered-python-function', _1434870, _1434876, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] typed_list('&corelib', _1490062, _1489936)
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(278) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(277) [user] typed_list('&corelib', _1493106, _1489936)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] metta_atom_in_file('&corelib', ['registered-python-function', _1434870, _1434876, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] metta_atom_in_file('&corelib', ['registered-python-function', _1434870, _1434876, 'if-unify-or-empty'], _1496160, _1496162)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] loaded_into_kb('&corelib', _1497058)
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] once(user:asserted_metta_pred(_1503002, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] asserted_metta_pred(_1503002, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(280) [user] asserted_metta_pred(_1503002, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] once(user:asserted_metta_pred(_1522684, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] asserted_metta_pred(_1522684, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(280) [user] asserted_metta_pred(_1522684, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(277) [user] metta_atom_asserted('&corelib', ['registered-python-function', _1434870, _1434876, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] metta_atom_asserted_deduced('&corelib', ['registered-python-function', _1434870, _1434876, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(274) [user] if_or_else(eval_maybe_host_predicate(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488), if_or_else(eval_maybe_host_function(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488), if_or_else(eval_maybe_defn(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488), eval_maybe_subst(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488))))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] eval_maybe_host_predicate(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488)
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(276) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] once((is_system_pred('if-unify-or-empty'), length([_845060, _845060], _1547568), is_syspred('if-unify-or-empty', _1547568, _1547576)))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] atom_concat(_1551760, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] atom_concat(_1554804, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] atom_concat(_1557848, '-p', 'if-unify-or-empty')
^  <span class="ansi1 ansi31"
>Fail: </span>(278) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(275) [user] if_or_else(eval_maybe_host_function(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488), if_or_else(eval_maybe_defn(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488), eval_maybe_subst(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488)))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] eval_maybe_host_function(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488)
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(278) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] atom_concat(_1566960, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(278) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] atom_concat(_1570004, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(278) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] atom_concat(_1573048, '-p', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(276) [user] if_or_else(eval_maybe_defn(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488), eval_maybe_subst(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] eval_maybe_defn(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488)
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _845060, _845060])
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _845060, _845060])
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] trace_eval(eval_defn_choose_candidates(=, _1068370), defn, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] must_det_ll((notrace((flag(eval_num, _1583088, _1583088+1), _1583106 is _1583088 mod 500, _1583124 is 99-496 mod 100, _1583148=_1583150, option_else('trace-length', _1583162, 500), option_else('trace-depth', _1583170, 30))), quietly(if_t((nop(stop_rtrace), _1583106>_1583162), (set_debug(eval, false), _1583226 is _1583162+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1583226])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1583278)))))
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] once(user:(notrace((flag(eval_num, _1583088, _1583088+1), _1583106 is _1583088 mod 500, _1583124 is 99-496 mod 100, _1583148=_1583150, option_else('trace-length', _1583162, 500), option_else('trace-depth', _1583170, 30))), quietly(if_t((nop(stop_rtrace), _1583106>_1583162), (set_debug(eval, false), _1583226 is _1583162+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1583226])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1583278)))))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [system] setup_call_cleanup('$notrace'(_1585324, _1585326), once(user:(flag(eval_num, _1583088, _1583088+1), _1583106 is _1583088 mod 500, _1583124 is 99-496 mod 100, _1583148=_1583150, option_else('trace-length', _1583162, 500), option_else('trace-depth', _1583170, 30))), '$restore_trace'(_1585324, _1585326))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] sig_atomic(system:'$notrace'(_1585324, _1585326))
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 16, 16+1), 16 is 16 mod 500, 3 is 99-496 mod 100, _1583148=_1583148, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 16>500), (set_debug(eval, false), _1583226 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1583226])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 16>500), (set_debug(eval, false), _1583226 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1583226])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(282) [user] nop(notrace(no_repeats_var(_1583278)))
   <span class="ansi1 ansi32"
>Exit: </span>(282) [user] nop(notrace(no_repeats_var(_1583278)))
^  <span class="ansi1 ansi32"
>Exit: </span>(280) [system] once(user:(notrace((flag(eval_num, 16, 16+1), 16 is 16 mod 500, 3 is 99-496 mod 100, _1583148=_1583148, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 16>500), (set_debug(eval, false), _1583226 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1583226])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1583278)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] must_det_ll(user:(notrace((flag(eval_num, 16, 16+1), 16 is 16 mod 500, 3 is 99-496 mod 100, _1583148=_1583148, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 16>500), (set_debug(eval, false), _1583226 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1583226])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1583278)))))
   <span class="ansi1 ansi32"
>Call: </span>(279) [occurs] occurs:sub_term(_1594976, defn)
   <span class="ansi1 ansi32"
>Exit: </span>(279) [occurs] occurs:sub_term(defn, defn)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] defn\=defn
   <span class="ansi1 ansi31"
>Fail: </span>(279) [system] defn\=defn
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(280) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(279) [occurs] occurs:sub_term(_1594976, defn)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] _1602082=defn
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] defn=defn
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] if_trace((eval;defn), (_1583148=1, indentq(3, 16, -->, [defn, ['if-unify-or-empty', _845060, _845060]])))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [system] setup_call_cleanup('$notrace'(_1605222, _1605224), once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _1583148=1, indentq(3, 16, -->, [defn, ['if-unify-or-empty', _845060, _845060]]))), _1605180, fbug((_1605180-->if_trace((eval;defn), (_1583148=1, indentq(3, 16, -->, [defn, ['if-unify-or-empty', _845060, _845060]])))))))), '$restore_trace'(_1605222, _1605224))
^  <span class="ansi1 ansi32"
>Call: </span>(282) [system] sig_atomic(system:'$notrace'(_1605222, _1605224))
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _1583148=1, indentq(3, 16, -->, [defn, ['if-unify-or-empty', _845060, _845060]]))), _1605180, fbug((_1605180-->if_trace((eval;defn), (_1583148=1, indentq(3, 16, -->, [defn, ['if-unify-or-empty', _845060, _845060]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] if_trace((eval;defn), (_1583148=1, indentq(3, 16, -->, [defn, ['if-unify-or-empty', _845060, _845060]])))
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] _1609418=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] _1611456=(\+ \+ (flag(eval_num, _1611476, _1611476+1), (retval(fail)\=@=retval(fail), nonvar(_1218488)->indentq(3, _1611476, <--, [defn, _1218488]);indentq(3, _1611476, <--, [defn, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] (\+ \+ (flag(eval_num, _1611476, _1611476+1), (retval(fail)\=@=retval(fail), nonvar(_1218488)->indentq(3, _1611476, <--, [defn, _1218488]);indentq(3, _1611476, <--, [defn, retval(fail)]))))=(\+ \+ (flag(eval_num, _1611476, _1611476+1), (retval(fail)\=@=retval(fail), nonvar(_1218488)->indentq(3, _1611476, <--, [defn, _1218488]);indentq(3, _1611476, <--, [defn, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] call_cleanup(((call(eval_defn_choose_candidates(=, _1068370), 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488)*->nb_setarg(1, retval(fail), _1218488);fail, trace, call(eval_defn_choose_candidates(=, _1068370), 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488)), ignore(notrace((\+_1218488\=_1583278, nb_setarg(1, retval(fail), _1218488))))), ignore((_1583148==1->ignore(\+ \+ (flag(eval_num, _1611476, _1611476+1), (retval(fail)\=@=retval(fail), nonvar(_1218488)->indentq(3, _1611476, <--, [defn, _1218488]);indentq(3, _1611476, <--, [defn, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1611476, _1611476+1), (retval(fail)\=@=retval(fail), nonvar(_1218488)->indentq(3, _1611476, <--, [defn, _1218488]);indentq(3, _1611476, <--, [defn, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] eval_defn_choose_candidates(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] findall((_1615818->_1615820), get_defn_expansions(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1615818, _1615820), _1615838)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [$bags] findall((_1615818->_1615820), user:get_defn_expansions(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1615818, _1615820), _1615838, [])
^  <span class="ansi1 ansi32"
>Call: </span>(284) [$bags] cleanup_bag(findall_loop((_1615818->_1615820), user:get_defn_expansions(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1615818, _1615820), _1615838, []), '$destroy_findall_bag')
   <span class="ansi1 ansi32"
>Call: </span>(285) [$bags] findall_loop((_1615818->_1615820), user:get_defn_expansions(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1615818, _1615820), _1615838, [])
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] get_defn_expansions(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1615818, _1615820)
^  <span class="ansi1 ansi32"
>Call: </span>(287) [user] same_len_copy([_845060, _845060], _1621010)
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] length([_845060, _845060], _1622028)
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] var(_1622028)
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] var(_1622028)
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] []==[]
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] _1622028=2
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] 2=2
   <span class="ansi1 ansi32"
>Exit: </span>(288) [system] length([_845060, _845060], 2)
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] length(_1621010, 2)
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] var(2)
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] integer(2)
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] integer(2)
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] _1621010==[]
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] var(_1621010)
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] var(_1621010)
   <span class="ansi1 ansi32"
>Exit: </span>(288) [system] length([_1637252, _1637258], 2)
^  <span class="ansi1 ansi32"
>Exit: </span>(287) [user] same_len_copy([_845060, _845060], [_1637252, _1637258])
   <span class="ansi1 ansi32"
>Call: </span>(287) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _1637252, _1637258], _1615820)
^  <span class="ansi1 ansi32"
>Call: </span>(288) [user] ignore((=)=(=))
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] (=)=(=)
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] (=)=(=)
^  <span class="ansi1 ansi32"
>Exit: </span>(288) [system] ignore(user:((=)=(=)))
   <span class="ansi1 ansi32"
>Call: </span>(288) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _1637252, _1637258], _1615820]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _1637252, _1637258], _1615820]))
   <span class="ansi1 ansi32"
>Call: </span>(289) [user] metta_atom('&self', [=, ['if-unify-or-empty', _1637252, _1637258], _1615820])
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] typed_list('&self', _1646574, _1646448)
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(291) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(290) [user] typed_list('&self', _1649618, _1646448)
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _1637252, _1637258], _1615820])
^  <span class="ansi1 ansi32"
>Call: </span>(291) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _1637252, _1637258], _1615820], _1652672, _1652674)
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] loaded_into_kb('&self', _1653570)
^  <span class="ansi1 ansi32"
>Exit: </span>(292) [user] loaded_into_kb('&self', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] once(user:asserted_metta_pred(_1659530, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] asserted_metta_pred(_1659530, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(293) [user] asserted_metta_pred(_1659530, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(290) [user] metta_atom_asserted('&self', [=, ['if-unify-or-empty', _1637252, _1637258], _1615820])
^  <span class="ansi1 ansi32"
>Call: </span>(291) [user] metta_atom_asserted_deduced('&self', [=, ['if-unify-or-empty', _1637252, _1637258], _1615820])
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(290) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(290) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(290) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _1637252, _1637258], _1615820])
^  <span class="ansi1 ansi32"
>Call: </span>(291) [user] typed_list('&corelib', _1683572, _1683446)
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(292) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(291) [user] typed_list('&corelib', _1686616, _1683446)
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(291) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _1637252, _1637258], _1615820])
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _1637252, _1637258], _1615820], _1689670, _1689672)
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] loaded_into_kb('&corelib', _1690568)
^  <span class="ansi1 ansi32"
>Exit: </span>(293) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] once(user:asserted_metta_pred(_1696512, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] asserted_metta_pred(_1696512, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(294) [user] asserted_metta_pred(_1696512, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Exit: </span>(293) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] once(user:asserted_metta_pred(_1716194, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] asserted_metta_pred(_1716194, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(294) [user] asserted_metta_pred(_1716194, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(291) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _1637252, _1637258], _1615820])
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] metta_atom_asserted_deduced('&corelib', [=, ['if-unify-or-empty', _1637252, _1637258], _1615820])
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] fail
   <span class="ansi1 ansi32"
>Exit: </span>(291) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _1637252, _1637252], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(290) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _1637252, _1637252], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(289) [user] metta_atom('&self', [=, ['if-unify-or-empty', _1637252, _1637252], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(288) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _1637252, _1637252], unified]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _1637252, _1637252], unified]))
   <span class="ansi1 ansi32"
>Exit: </span>(287) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _1637252, _1637252], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [user] get_defn_expansions(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], ['if-unify-or-empty', _1637252, _1637252], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(291) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _1637252, _1637258], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(290) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _1637252, _1637258], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(289) [user] metta_atom('&self', [=, ['if-unify-or-empty', _1637252, _1637258], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(288) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _1637252, _1637258], [empty]]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _1637252, _1637258], [empty]]))
   <span class="ansi1 ansi32"
>Exit: </span>(287) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _1637252, _1637258], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [user] get_defn_expansions(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], ['if-unify-or-empty', _1637252, _1637258], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(285) [$bags] findall_loop((_1615818->_1615820), user:get_defn_expansions(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1615818, _1615820), [(['if-unify-or-empty', _1749198, _1749198]->unified), (['if-unify-or-empty', _1749162, _1749168]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [$bags] cleanup_bag('$bags':findall_loop((_1615818->_1615820), user:get_defn_expansions(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1615818, _1615820), [(['if-unify-or-empty', _1749198, _1749198]->unified), (['if-unify-or-empty', _1749162, _1749168]->[empty])], []), '$bags':'$destroy_findall_bag')
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [$bags] findall((_1615818->_1615820), user:get_defn_expansions(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1615818, _1615820), [(['if-unify-or-empty', _1749198, _1749198]->unified), (['if-unify-or-empty', _1749162, _1749168]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [$bags] findall((_1615818->_1615820), user:get_defn_expansions(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1615818, _1615820), [(['if-unify-or-empty', _1749198, _1749198]->unified), (['if-unify-or-empty', _1749162, _1749168]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] eval_defn_bodies(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488, [(['if-unify-or-empty', _1749198, _1749198]->unified), (['if-unify-or-empty', _1749162, _1749168]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] if_trace(e, maplist(print_templates(496, '   '), [(['if-unify-or-empty', _1749198, _1749198]->unified), (['if-unify-or-empty', _1749162, _1749168]->[empty])]))
^  <span class="ansi1 ansi32"
>Call: </span>(285) [system] setup_call_cleanup('$notrace'(_1755430, _1755432), once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(496, '   '), [(['if-unify-or-empty', _1749198, _1749198]->unified), (['if-unify-or-empty', _1749162, _1749168]->[empty])]))), _1755388, fbug((_1755388-->if_trace(e, maplist(print_templates(496, '   '), [(['if-unify-or-empty', _1749198, _1749198]->unified), (['if-unify-or-empty', _1749162, _1749168]->[empty])]))))))), '$restore_trace'(_1755430, _1755432))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [system] sig_atomic(system:'$notrace'(_1755430, _1755432))
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(496, '   '), [(['if-unify-or-empty', _1749198, _1749198]->unified), (['if-unify-or-empty', _1749162, _1749168]->[empty])]))), _1755388, fbug((_1755388-->if_trace(e, maplist(print_templates(496, '   '), [(['if-unify-or-empty', _1749198, _1749198]->unified), (['if-unify-or-empty', _1749162, _1749168]->[empty])]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [user] if_trace(e, maplist(print_templates(496, '   '), [(['if-unify-or-empty', _1749198, _1749198]->unified), (['if-unify-or-empty', _1749162, _1749168]->[empty])]))
   <span class="ansi1 ansi32"
>Call: </span>(283) [user] if_or_else((member((_1759640->_1759642), [(['if-unify-or-empty', _1749198, _1749198]->unified), (['if-unify-or-empty', _1749162, _1749168]->[empty])]), copy_term((_1759640->_1759642), _1759654), eval_defn_success(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488, _1759640, _1759642, _1759654)), eval_defn_failure(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488))
   <span class="ansi1 ansi32"
>Call: </span>(285) [lists] lists:member((_1759640->_1759642), [(['if-unify-or-empty', _1749198, _1749198]->unified), (['if-unify-or-empty', _1749162, _1749168]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(286) [lists] lists:member_([(['if-unify-or-empty', _1749162, _1749168]->[empty])], (_1759640->_1759642), (['if-unify-or-empty', _1749198, _1749198]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(286) [lists] lists:member_([(['if-unify-or-empty', _1749162, _1749168]->[empty])], (['if-unify-or-empty', _1749198, _1749198]->unified), (['if-unify-or-empty', _1749198, _1749198]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(285) [lists] lists:member((['if-unify-or-empty', _1749198, _1749198]->unified), [(['if-unify-or-empty', _1749198, _1749198]->unified), (['if-unify-or-empty', _1749162, _1749168]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] copy_term((['if-unify-or-empty', _1749198, _1749198]->unified), _1759654)
   <span class="ansi1 ansi32"
>Exit: </span>(285) [system] copy_term((['if-unify-or-empty', _1749198, _1749198]->unified), (['if-unify-or-empty', _1765804, _1765804]->unified))
^  <span class="ansi1 ansi32"
>Call: </span>(285) [user] eval_defn_success(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488, ['if-unify-or-empty', _1749198, _1749198], unified, (['if-unify-or-empty', _1765804, _1765804]->unified))
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] ['if-unify-or-empty', _845060, _845060]=['if-unify-or-empty', _1749198, _1749198]
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] ['if-unify-or-empty', _845060, _845060]=['if-unify-or-empty', _845060, _845060]
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] _1218488=unified
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] unified=unified
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] ['if-unify-or-empty', _845060, _845060]\=@=unified
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] ['if-unify-or-empty', _845060, _845060]\=@=unified
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] if_trace(e, color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1765804, _1765804]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(288) [system] setup_call_cleanup('$notrace'(_1775052, _1775054), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1765804, _1765804]->unified)))))), _1775010, fbug((_1775010-->if_trace(e, color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1765804, _1765804]->unified)))))))))), '$restore_trace'(_1775052, _1775054))
^  <span class="ansi1 ansi32"
>Call: </span>(289) [system] sig_atomic(system:'$notrace'(_1775052, _1775054))
^  <span class="ansi1 ansi32"
>Exit: </span>(288) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1765804, _1765804]->unified)))))), _1775010, fbug((_1775010-->if_trace(e, color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1765804, _1765804]->unified)))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [user] if_trace(e, color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1765804, _1765804]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] light_eval(=, _1068370, 496, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [user] light_eval(=, _1068370, 496, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [user] eval_defn_success(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified, ['if-unify-or-empty', _845060, _845060], unified, (['if-unify-or-empty', _1765804, _1765804]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(283) [user] if_or_else((member((['if-unify-or-empty', _845060, _845060]->unified), [(['if-unify-or-empty', _845060, _845060]->unified), (['if-unify-or-empty', _1749162, _1749168]->[empty])]), copy_term((['if-unify-or-empty', _845060, _845060]->unified), (['if-unify-or-empty', _1765804, _1765804]->unified)), eval_defn_success(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified, ['if-unify-or-empty', _845060, _845060], unified, (['if-unify-or-empty', _1765804, _1765804]->unified))), eval_defn_failure(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] eval_defn_bodies(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified, [(['if-unify-or-empty', _845060, _845060]->unified), (['if-unify-or-empty', _1749162, _1749168]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [user] eval_defn_choose_candidates(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] ignore(notrace((\+unified\=_1583278, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [system] setup_call_cleanup('$notrace'(_1788500, _1788502), once(user:(\+unified\=_1583278, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_1788500, _1788502))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] sig_atomic(system:'$notrace'(_1788500, _1788502))
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_1583278, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [system] ignore(user:notrace((\+unified\=_1583278, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _1068370), 496, '&self', ['if-unify-or-empty', _845060, _845060], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_defn_choose_candidates(=, _1068370), 496, '&self', ['if-unify-or-empty', _845060, _845060], unified)), ignore(notrace((\+unified\=_1583278, nb_setarg(1, retval(unified), unified))))), user:ignore((_1583148==1->ignore(\+ \+ (flag(eval_num, _1611476, _1611476+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(3, _1611476, <--, [defn, unified]);indentq(3, _1611476, <--, [defn, retval(unified)]))));notrace(ignore(if_t(3<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1611476, _1611476+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(3, _1611476, <--, [defn, unified]);indentq(3, _1611476, <--, [defn, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [user] trace_eval(eval_defn_choose_candidates(=, _1068370), defn, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [user] eval_maybe_defn(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(276) [user] if_or_else(eval_maybe_defn(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified), eval_maybe_subst(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified))
   <span class="ansi1 ansi32"
>Exit: </span>(275) [user] if_or_else(eval_maybe_host_function(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified), if_or_else(eval_maybe_defn(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified), eval_maybe_subst(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified)))
   <span class="ansi1 ansi32"
>Exit: </span>(274) [user] if_or_else(eval_maybe_host_predicate(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified), if_or_else(eval_maybe_host_function(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified), if_or_else(eval_maybe_defn(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified), eval_maybe_subst(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified))))
   <span class="ansi1 ansi32"
>Exit: </span>(273) [user] if_or_else(eval_maybe_python(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified), if_or_else(eval_maybe_host_predicate(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified), if_or_else(eval_maybe_host_function(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified), if_or_else(eval_maybe_defn(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified), eval_maybe_subst(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] eval_70(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] check_returnval(=, _1068370, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] check_returnval(=, _1068370, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [user] eval_41(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [user] eval_40(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] unified=_1083830
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] eval_20(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified)
   <span class="ansi1 ansi32"
>Call: </span>(269) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(269) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] ignore(notrace((\+unified\=_1085074, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(271) [system] setup_call_cleanup('$notrace'(_1813030, _1813032), once(user:(\+unified\=_1085074, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_1813030, _1813032))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] sig_atomic(system:'$notrace'(_1813030, _1813032))
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_1085074, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [system] ignore(user:notrace((\+unified\=_1085074, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [system] call_cleanup(user:((call(eval_20(=, _1068370), 496, '&self', ['if-unify-or-empty', _845060, _845060], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_20(=, _1068370), 496, '&self', ['if-unify-or-empty', _845060, _845060], unified)), ignore(notrace((\+unified\=_1085074, nb_setarg(1, retval(unified), unified))))), user:ignore((_1084944==1->ignore(\+ \+ (flag(eval_num, _1113272, _1113272+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(3, _1113272, <--, [e, unified]);indentq(3, _1113272, <--, [e, retval(unified)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1113272, _1113272+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(3, _1113272, <--, [e, unified]);indentq(3, _1113272, <--, [e, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] trace_eval(eval_20(=, _1068370), e, 496, '&self', ['if-unify-or-empty', _845060, _845060], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] self_eval(unified)
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_1822264, _1822266), once(user:self_eval0(unified)), '$restore_trace'(_1822264, _1822266))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_1822264, _1822266))
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(unified)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] self_eval(unified)
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] _1051892=unified
   <span class="ansi1 ansi32"
>Exit: </span>(266) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [user] eval_01(=, _1068370, 497, '&self', ['if-unify-or-empty', _845060, _845060], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(264) [user] eval_00(=, _1068370, 497, '&self', ['if-unify-or-empty', _845060, _845060], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [user] eval_args(=, _1068370, 497, '&self', ['if-unify-or-empty', _845060, _845060], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [system] setup_call_cleanup('$notrace'(_1832582, _1832584), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _1832540, fbug((_1832540-->if_trace(case, writeqln(switch=unified))))))), '$restore_trace'(_1832582, _1832584))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [system] sig_atomic(system:'$notrace'(_1832582, _1832584))
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _1832540, fbug((_1832540-->if_trace(case, writeqln(switch=unified))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] select_case(497, '&self', unified, ['Empty'-_845078], _1836778)
^  <span class="ansi1 ansi32"
>Call: </span>(264) [user] best_key(unified, ['Empty'-_845078], _1836778)
   <span class="ansi1 ansi32"
>Call: </span>(265) [lists] lists:member(_1838830-_1836778, ['Empty'-_845078])
   <span class="ansi1 ansi32"
>Call: </span>(266) [lists] lists:member_([], _1838830-_1836778, 'Empty'-_845078)
   <span class="ansi1 ansi32"
>Exit: </span>(266) [lists] lists:member_([], 'Empty'-_845078, 'Empty'-_845078)
   <span class="ansi1 ansi32"
>Exit: </span>(265) [lists] lists:member('Empty'-_845078, ['Empty'-_845078])
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] unified='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(265) [lists] lists:member(_1843924-_1836778, ['Empty'-_845078])
   <span class="ansi1 ansi32"
>Call: </span>(266) [lists] lists:member_([], _1843924-_1836778, 'Empty'-_845078)
   <span class="ansi1 ansi32"
>Exit: </span>(266) [lists] lists:member_([], 'Empty'-_845078, 'Empty'-_845078)
   <span class="ansi1 ansi32"
>Exit: </span>(265) [lists] lists:member('Empty'-_845078, ['Empty'-_845078])
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] unified=='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(265) [lists] lists:member(_1849018-_1836778, ['Empty'-_845078])
   <span class="ansi1 ansi32"
>Call: </span>(266) [lists] lists:member_([], _1849018-_1836778, 'Empty'-_845078)
   <span class="ansi1 ansi32"
>Exit: </span>(266) [lists] lists:member_([], 'Empty'-_845078, 'Empty'-_845078)
   <span class="ansi1 ansi32"
>Exit: </span>(265) [lists] lists:member('Empty'-_845078, ['Empty'-_845078])
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] unified=@='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(265) [lists] lists:member(_1854112-_1836778, ['Empty'-_845078])
   <span class="ansi1 ansi32"
>Call: </span>(266) [lists] lists:member_([], _1854112-_1836778, 'Empty'-_845078)
   <span class="ansi1 ansi32"
>Exit: </span>(266) [lists] lists:member_([], 'Empty'-_845078, 'Empty'-_845078)
   <span class="ansi1 ansi32"
>Exit: </span>(265) [lists] lists:member('Empty'-_845078, ['Empty'-_845078])
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] unified='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(264) [user] maybe_special_keys(497, '&self', ['Empty'-_845078], _1859204)
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] eval_args(497, '&self', 'Empty', _1860238)
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] eval_args(=, _1861390, 497, '&self', 'Empty', _1860238)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] var('Empty')
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_1863322, _1863324), once(user:self_eval('Empty')), '$restore_trace'(_1863322, _1863324))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_1863322, _1863324))
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval('Empty')), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] _1860238='Empty'
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] 'Empty'='Empty'
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] eval_args(=, _1868624, 497, '&self', 'Empty', 'Empty')
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [user] eval_args(497, '&self', 'Empty', 'Empty')
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] 'Empty'\=@='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] maybe_special_keys(497, '&self', [], _1859204)
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [user] maybe_special_keys(497, '&self', [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(264) [user] maybe_special_keys(497, '&self', ['Empty'-_845078], [])
^  <span class="ansi1 ansi32"
>Call: </span>(264) [user] best_key(unified, [], _1836778)
   <span class="ansi1 ansi32"
>Call: </span>(265) [lists] lists:member(_1875666-_1836778, [])
   <span class="ansi1 ansi32"
>Call: </span>(265) [lists] lists:member(_1876688-_1836778, [])
   <span class="ansi1 ansi32"
>Call: </span>(265) [lists] lists:member(_1877710-_1836778, [])
   <span class="ansi1 ansi32"
>Call: </span>(265) [lists] lists:member(_1878732-_1836778, [])
   <span class="ansi1 ansi32"
>Call: </span>(264) [lists] lists:member(_1879754-_1836778, [])
   <span class="ansi1 ansi32"
>Call: </span>(263) [lists] lists:member(_1880776-_1880778, ['Empty'-_845078])
   <span class="ansi1 ansi32"
>Call: </span>(264) [lists] lists:member_([], _1880776-_1880778, 'Empty'-_845078)
   <span class="ansi1 ansi32"
>Exit: </span>(264) [lists] lists:member_([], 'Empty'-_845078, 'Empty'-_845078)
   <span class="ansi1 ansi32"
>Exit: </span>(263) [lists] lists:member('Empty'-_845078, ['Empty'-_845078])
   <span class="ansi1 ansi32"
>Call: </span>(263) [system] 'Empty'=='%void%'
   <span class="ansi1 ansi32"
>Call: </span>(287) [lists] lists:member_([], (_1759640->_1759642), (['if-unify-or-empty', _1749162, _1749168]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(287) [lists] lists:member_([], (['if-unify-or-empty', _1749162, _1749168]->[empty]), (['if-unify-or-empty', _1749162, _1749168]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(286) [lists] lists:member_([(['if-unify-or-empty', _1749162, _1749168]->[empty])], (['if-unify-or-empty', _1749162, _1749168]->[empty]), (['if-unify-or-empty', _1749198, _1749198]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(285) [lists] lists:member((['if-unify-or-empty', _1749162, _1749168]->[empty]), [(['if-unify-or-empty', _1749198, _1749198]->unified), (['if-unify-or-empty', _1749162, _1749168]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] copy_term((['if-unify-or-empty', _1749162, _1749168]->[empty]), _1759654)
   <span class="ansi1 ansi32"
>Exit: </span>(285) [system] copy_term((['if-unify-or-empty', _1749162, _1749168]->[empty]), (['if-unify-or-empty', _1890976, _1890982]->[empty]))
^  <span class="ansi1 ansi32"
>Call: </span>(285) [user] eval_defn_success(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], _1218488, ['if-unify-or-empty', _1749162, _1749168], [empty], (['if-unify-or-empty', _1890976, _1890982]->[empty]))
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] ['if-unify-or-empty', _845060, _845060]=['if-unify-or-empty', _1749162, _1749168]
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] ['if-unify-or-empty', _845060, _845060]=['if-unify-or-empty', _845060, _845060]
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] _1218488=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] [empty]=[empty]
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] ['if-unify-or-empty', _845060, _845060]\=@=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] ['if-unify-or-empty', _845060, _845060]\=@=[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] if_trace(e, color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1890976, _1890982]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(288) [system] setup_call_cleanup('$notrace'(_1900224, _1900226), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1890976, _1890982]->[empty])))))), _1900182, fbug((_1900182-->if_trace(e, color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1890976, _1890982]->[empty])))))))))), '$restore_trace'(_1900224, _1900226))
^  <span class="ansi1 ansi32"
>Call: </span>(289) [system] sig_atomic(system:'$notrace'(_1900224, _1900226))
^  <span class="ansi1 ansi32"
>Exit: </span>(288) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1890976, _1890982]->[empty])))))), _1900182, fbug((_1900182-->if_trace(e, color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1890976, _1890982]->[empty])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [user] if_trace(e, color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1890976, _1890982]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] light_eval(=, _1068370, 496, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [user] light_eval(=, _1068370, 496, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [user] eval_defn_success(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty], ['if-unify-or-empty', _845060, _845060], [empty], (['if-unify-or-empty', _1890976, _1890982]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(283) [user] if_or_else((member((['if-unify-or-empty', _845060, _845060]->[empty]), [(['if-unify-or-empty', _1749198, _1749198]->unified), (['if-unify-or-empty', _845060, _845060]->[empty])]), copy_term((['if-unify-or-empty', _845060, _845060]->[empty]), (['if-unify-or-empty', _1890976, _1890982]->[empty])), eval_defn_success(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty], ['if-unify-or-empty', _845060, _845060], [empty], (['if-unify-or-empty', _1890976, _1890982]->[empty]))), eval_defn_failure(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty]))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] eval_defn_bodies(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty], [(['if-unify-or-empty', _1749198, _1749198]->unified), (['if-unify-or-empty', _845060, _845060]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [user] eval_defn_choose_candidates(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] ignore(notrace((\+[empty]\=_1583278, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [system] setup_call_cleanup('$notrace'(_1913680, _1913682), once(user:(\+[empty]\=_1583278, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_1913680, _1913682))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] sig_atomic(system:'$notrace'(_1913680, _1913682))
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_1583278, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [system] ignore(user:notrace((\+[empty]\=_1583278, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] ignore((_1583148==1->ignore(\+ \+ (flag(eval_num, _1611476, _1611476+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1611476, <--, [defn, [empty]]);indentq(3, _1611476, <--, [defn, retval([empty])]))));notrace(ignore(if_t(3<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1611476, _1611476+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1611476, <--, [defn, [empty]]);indentq(3, _1611476, <--, [defn, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] _1583148==1
   <span class="ansi1 ansi31"
>Fail: </span>(283) [system] _1583148==1
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] setup_call_cleanup('$notrace'(_1920872, _1920874), once(user:ignore(if_t(3<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1611476, _1611476+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1611476, <--, [defn, [empty]]);indentq(3, _1611476, <--, [defn, retval([empty])])))))))), '$restore_trace'(_1920872, _1920874))
^  <span class="ansi1 ansi32"
>Call: </span>(285) [system] sig_atomic(system:'$notrace'(_1920872, _1920874))
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(3<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1611476, _1611476+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1611476, <--, [defn, [empty]]);indentq(3, _1611476, <--, [defn, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [system] ignore(user:(_1583148==1->ignore(\+ \+ (flag(eval_num, _1611476, _1611476+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1611476, <--, [defn, [empty]]);indentq(3, _1611476, <--, [defn, retval([empty])]))));notrace(ignore(if_t(3<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1611476, _1611476+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1611476, <--, [defn, [empty]]);indentq(3, _1611476, <--, [defn, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _1068370), 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_defn_choose_candidates(=, _1068370), 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty])), ignore(notrace((\+[empty]\=_1583278, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_1583148==1->ignore(\+ \+ (flag(eval_num, _1611476, _1611476+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1611476, <--, [defn, [empty]]);indentq(3, _1611476, <--, [defn, retval([empty])]))));notrace(ignore(if_t(3<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1611476, _1611476+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1611476, <--, [defn, [empty]]);indentq(3, _1611476, <--, [defn, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [user] trace_eval(eval_defn_choose_candidates(=, _1068370), defn, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [user] eval_maybe_defn(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(276) [user] if_or_else(eval_maybe_defn(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty]), eval_maybe_subst(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(275) [user] if_or_else(eval_maybe_host_function(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty]), if_or_else(eval_maybe_defn(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty]), eval_maybe_subst(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty])))
   <span class="ansi1 ansi32"
>Exit: </span>(274) [user] if_or_else(eval_maybe_host_predicate(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty]), if_or_else(eval_maybe_host_function(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty]), if_or_else(eval_maybe_defn(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty]), eval_maybe_subst(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty]))))
   <span class="ansi1 ansi32"
>Exit: </span>(273) [user] if_or_else(eval_maybe_python(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty]), if_or_else(eval_maybe_host_predicate(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty]), if_or_else(eval_maybe_host_function(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty]), if_or_else(eval_maybe_defn(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty]), eval_maybe_subst(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty])))))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] eval_70(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] check_returnval(=, _1068370, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] check_returnval(=, _1068370, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [user] eval_41(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [user] eval_40(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] [empty]=_1083830
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] [empty]=[empty]
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] eval_20(=, _1068370, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(269) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(269) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] ignore(notrace((\+[empty]\=_1085074, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(271) [system] setup_call_cleanup('$notrace'(_1945576, _1945578), once(user:(\+[empty]\=_1085074, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_1945576, _1945578))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] sig_atomic(system:'$notrace'(_1945576, _1945578))
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_1085074, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [system] ignore(user:notrace((\+[empty]\=_1085074, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] ignore((_1084944==1->ignore(\+ \+ (flag(eval_num, _1113272, _1113272+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1113272, <--, [e, [empty]]);indentq(3, _1113272, <--, [e, retval([empty])]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1113272, _1113272+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1113272, <--, [e, [empty]]);indentq(3, _1113272, <--, [e, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] _1084944==1
   <span class="ansi1 ansi31"
>Fail: </span>(271) [system] _1084944==1
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] setup_call_cleanup('$notrace'(_1952768, _1952770), once(user:ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1113272, _1113272+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1113272, <--, [e, [empty]]);indentq(3, _1113272, <--, [e, retval([empty])])))))))), '$restore_trace'(_1952768, _1952770))
^  <span class="ansi1 ansi32"
>Call: </span>(273) [system] sig_atomic(system:'$notrace'(_1952768, _1952770))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1113272, _1113272+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1113272, <--, [e, [empty]]);indentq(3, _1113272, <--, [e, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [system] ignore(user:(_1084944==1->ignore(\+ \+ (flag(eval_num, _1113272, _1113272+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1113272, <--, [e, [empty]]);indentq(3, _1113272, <--, [e, retval([empty])]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1113272, _1113272+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1113272, <--, [e, [empty]]);indentq(3, _1113272, <--, [e, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [system] call_cleanup(user:((call(eval_20(=, _1068370), 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_20(=, _1068370), 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty])), ignore(notrace((\+[empty]\=_1085074, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_1084944==1->ignore(\+ \+ (flag(eval_num, _1113272, _1113272+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1113272, <--, [e, [empty]]);indentq(3, _1113272, <--, [e, retval([empty])]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1113272, _1113272+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1113272, <--, [e, [empty]]);indentq(3, _1113272, <--, [e, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] trace_eval(eval_20(=, _1068370), e, 496, '&self', ['if-unify-or-empty', _845060, _845060], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_1962168, _1962170), once(user:self_eval0([empty])), '$restore_trace'(_1962168, _1962170))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_1962168, _1962170))
^  <span class="ansi1 ansi31"
>Fail: </span>(266) [user] self_eval([empty])
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] [empty]=@=['if-unify-or-empty', _1082788, _1082788]
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] eval_01(=, _1068370, 496, '&self', [empty], _1966272)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] [empty]\==[empty]
   <span class="ansi1 ansi32"
>Call: </span>(263) [lists] lists:member(_1968330-_1968332, ['Empty'-_845078])
   <span class="ansi1 ansi32"
>Call: </span>(264) [lists] lists:member_([], _1968330-_1968332, 'Empty'-_845078)
   <span class="ansi1 ansi32"
>Exit: </span>(264) [lists] lists:member_([], 'Empty'-_845078, 'Empty'-_845078)
   <span class="ansi1 ansi32"
>Exit: </span>(263) [lists] lists:member('Empty'-_845078, ['Empty'-_845078])
   <span class="ansi1 ansi32"
>Call: </span>(263) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi31"
>Fail: </span>(261) [user] eval_20(=, _854744, 497, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _906782)
   <span class="ansi1 ansi32"
>Call: </span>(261) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(261) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(261) [user] ignore((_907896==1->ignore(\+ \+ (flag(eval_num, _936224, _936224+1), (retval(fail)\=@=retval(fail), nonvar(_906782)->indentq(2, _936224, <--, [e, _906782]);indentq(2, _936224, <--, [e, retval(fail)]))));notrace(ignore(if_t(2<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _936224, _936224+1), (retval(fail)\=@=retval(fail), nonvar(_906782)->indentq(2, _936224, <--, [e, _906782]);indentq(2, _936224, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(263) [system] _907896==1
   <span class="ansi1 ansi31"
>Fail: </span>(263) [system] _907896==1
^  <span class="ansi1 ansi32"
>Call: </span>(264) [system] setup_call_cleanup('$notrace'(_1979526, _1979528), once(user:ignore(if_t(2<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _936224, _936224+1), (retval(fail)\=@=retval(fail), nonvar(_906782)->indentq(2, _936224, <--, [e, _906782]);indentq(2, _936224, <--, [e, retval(fail)])))))))), '$restore_trace'(_1979526, _1979528))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [system] sig_atomic(system:'$notrace'(_1979526, _1979528))
^  <span class="ansi1 ansi32"
>Exit: </span>(264) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(2<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _936224, _936224+1), (retval(fail)\=@=retval(fail), nonvar(_906782)->indentq(2, _936224, <--, [e, _906782]);indentq(2, _936224, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(261) [system] ignore(user:(_907896==1->ignore(\+ \+ (flag(eval_num, _936224, _936224+1), (retval(fail)\=@=retval(fail), nonvar(_906782)->indentq(2, _936224, <--, [e, _906782]);indentq(2, _936224, <--, [e, retval(fail)]))));notrace(ignore(if_t(2<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _936224, _936224+1), (retval(fail)\=@=retval(fail), nonvar(_906782)->indentq(2, _936224, <--, [e, _906782]);indentq(2, _936224, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(259) [system] call_cleanup(user:((call(eval_20(=, _854744), 497, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _906782)*->nb_setarg(1, retval(fail), _906782);fail, trace, call(eval_20(=, _854744), 497, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _906782)), ignore(notrace((\+_906782\=_908026, nb_setarg(1, retval(fail), _906782))))), user:ignore((_907896==1->ignore(\+ \+ (flag(eval_num, _936224, _936224+1), (retval(fail)\=@=retval(fail), nonvar(_906782)->indentq(2, _936224, <--, [e, _906782]);indentq(2, _936224, <--, [e, retval(fail)]))));notrace(ignore(if_t(2<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _936224, _936224+1), (retval(fail)\=@=retval(fail), nonvar(_906782)->indentq(2, _936224, <--, [e, _906782]);indentq(2, _936224, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(258) [user] trace_eval(eval_20(=, _854744), e, 497, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _906782)
^  <span class="ansi1 ansi31"
>Fail: </span>(255) [user] eval_args(=, _854744, 498, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002)
^  <span class="ansi1 ansi32"
>Call: </span>(252) [user] call(eval, [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002)
   <span class="ansi1 ansi32"
>Call: </span>(253) [user] eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002)
^  <span class="ansi1 ansi32"
>Call: </span>(254) [user] current_self(_1988934)
   <span class="ansi1 ansi32"
>Call: </span>(255) [system] nb_current(self_space, _1988934)
   <span class="ansi1 ansi32"
>Exit: </span>(255) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(255) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(255) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(254) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(254) [user] eval('&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002)
   <span class="ansi1 ansi32"
>Call: </span>(255) [user] eval_H(500, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002)
^  <span class="ansi1 ansi32"
>Call: </span>(256) [user] fast_option_value(compile, save)
   <span class="ansi1 ansi32"
>Call: </span>(257) [system] atom(compile)
   <span class="ansi1 ansi32"
>Exit: </span>(257) [system] atom(compile)
   <span class="ansi1 ansi32"
>Call: </span>(257) [system] current_prolog_flag(compile, save)
   <span class="ansi1 ansi31"
>Fail: </span>(257) [system] current_prolog_flag(compile, save)
^  <span class="ansi1 ansi31"
>Fail: </span>(256) [user] fast_option_value(compile, save)
^  <span class="ansi1 ansi32"
>Call: </span>(256) [user] catch_metta_return(eval_args(=, _2003136, 500, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002), _858002)
^  <span class="ansi1 ansi32"
>Call: </span>(258) [user] eval_args(=, _2003136, 500, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002)
   <span class="ansi1 ansi32"
>Call: </span>(259) [system] var([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
^  <span class="ansi1 ansi32"
>Call: </span>(260) [system] setup_call_cleanup('$notrace'(_2006246, _2006248), once(user:self_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])), '$restore_trace'(_2006246, _2006248))
^  <span class="ansi1 ansi32"
>Call: </span>(261) [system] sig_atomic(system:'$notrace'(_2006246, _2006248))
^  <span class="ansi1 ansi32"
>Call: </span>(260) [system] setup_call_cleanup('$notrace'(_2008334, _2008336), once(user:nonvar(_858002)), '$restore_trace'(_2008334, _2008336))
^  <span class="ansi1 ansi32"
>Call: </span>(261) [system] sig_atomic(system:'$notrace'(_2008334, _2008336))
^  <span class="ansi1 ansi32"
>Call: </span>(260) [system] setup_call_cleanup('$notrace'(_2010422, _2010424), once(user:nonvar(_858002)), '$restore_trace'(_2010422, _2010424))
^  <span class="ansi1 ansi32"
>Call: </span>(261) [system] sig_atomic(system:'$notrace'(_2010422, _2010424))
   <span class="ansi1 ansi32"
>Call: </span>(259) [system] [['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(259) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(259) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(259) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(259) [user] self_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
^  <span class="ansi1 ansi32"
>Call: </span>(261) [system] setup_call_cleanup('$notrace'(_2017578, _2017580), once(user:self_eval0([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])), '$restore_trace'(_2017578, _2017580))
^  <span class="ansi1 ansi32"
>Call: </span>(262) [system] sig_atomic(system:'$notrace'(_2017578, _2017580))
^  <span class="ansi1 ansi31"
>Fail: </span>(259) [user] self_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
^  <span class="ansi1 ansi32"
>Call: </span>(259) [user] eval_00(=, _2003136, 500, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002)
^  <span class="ansi1 ansi32"
>Call: </span>(260) [user] self_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
^  <span class="ansi1 ansi32"
>Call: </span>(262) [system] setup_call_cleanup('$notrace'(_2022722, _2022724), once(user:self_eval0([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])), '$restore_trace'(_2022722, _2022724))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [system] sig_atomic(system:'$notrace'(_2022722, _2022724))
^  <span class="ansi1 ansi31"
>Fail: </span>(260) [user] self_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
^  <span class="ansi1 ansi32"
>Call: </span>(260) [user] eval_01(=, _2003136, 500, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _858002)
   <span class="ansi1 ansi32"
>Call: </span>(261) [system] [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(261) [system] [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(261) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(263) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(263) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(261) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(262) [system] setup_call_cleanup('$notrace'(_2032996, _2032998), once(user:(_2032972 is 500-1, copy_term([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _2032986))), '$restore_trace'(_2032996, _2032998))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [system] sig_atomic(system:'$notrace'(_2032996, _2032998))
^  <span class="ansi1 ansi32"
>Exit: </span>(262) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], [case, ['if-unify-or-empty', _2035094, _2035094], [['Empty', _2035124]]]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(261) [user] trace_eval(eval_20(=, _2003136), e, 499, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _2036160)
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] must_det_ll((notrace((flag(eval_num, _2037214, _2037214+1), _2037232 is _2037214 mod 500, _2037250 is 99-499 mod 100, _2037274=_2037276, option_else('trace-length', _2037288, 500), option_else('trace-depth', _2037296, 30))), quietly(if_t((nop(stop_rtrace), _2037232>_2037288), (set_debug(eval, false), _2037352 is _2037288+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2037352])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2037404)))))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] once(user:(notrace((flag(eval_num, _2037214, _2037214+1), _2037232 is _2037214 mod 500, _2037250 is 99-499 mod 100, _2037274=_2037276, option_else('trace-length', _2037288, 500), option_else('trace-depth', _2037296, 30))), quietly(if_t((nop(stop_rtrace), _2037232>_2037288), (set_debug(eval, false), _2037352 is _2037288+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2037352])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2037404)))))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [system] setup_call_cleanup('$notrace'(_2039450, _2039452), once(user:(flag(eval_num, _2037214, _2037214+1), _2037232 is _2037214 mod 500, _2037250 is 99-499 mod 100, _2037274=_2037276, option_else('trace-length', _2037288, 500), option_else('trace-depth', _2037296, 30))), '$restore_trace'(_2039450, _2039452))
^  <span class="ansi1 ansi32"
>Call: </span>(267) [system] sig_atomic(system:'$notrace'(_2039450, _2039452))
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 17, 17+1), 17 is 17 mod 500, 0 is 99-499 mod 100, _2037274=_2037274, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 17>500), (set_debug(eval, false), _2037352 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2037352])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 17>500), (set_debug(eval, false), _2037352 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2037352])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(265) [user] nop(notrace(no_repeats_var(_2037404)))
   <span class="ansi1 ansi32"
>Exit: </span>(265) [user] nop(notrace(no_repeats_var(_2037404)))
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [system] once(user:(notrace((flag(eval_num, 17, 17+1), 17 is 17 mod 500, 0 is 99-499 mod 100, _2037274=_2037274, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 17>500), (set_debug(eval, false), _2037352 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2037352])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2037404)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(262) [user] must_det_ll(user:(notrace((flag(eval_num, 17, 17+1), 17 is 17 mod 500, 0 is 99-499 mod 100, _2037274=_2037274, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 17>500), (set_debug(eval, false), _2037352 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2037352])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2037404)))))
   <span class="ansi1 ansi32"
>Call: </span>(262) [occurs] occurs:sub_term(_2049102, e)
   <span class="ansi1 ansi32"
>Exit: </span>(262) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(262) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(263) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(263) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(262) [occurs] occurs:sub_term(_2049102, e)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] _2056208=e
   <span class="ansi1 ansi32"
>Exit: </span>(262) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] if_trace((eval;e), (_2037274=1, indentq(0, 17, -->, [e, [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(264) [system] setup_call_cleanup('$notrace'(_2059348, _2059350), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _2037274=1, indentq(0, 17, -->, [e, [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]]))), _2059306, fbug((_2059306-->if_trace((eval;e), (_2037274=1, indentq(0, 17, -->, [e, [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]])))))))), '$restore_trace'(_2059348, _2059350))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [system] sig_atomic(system:'$notrace'(_2059348, _2059350))
^  <span class="ansi1 ansi32"
>Exit: </span>(264) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _2037274=1, indentq(0, 17, -->, [e, [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]]))), _2059306, fbug((_2059306-->if_trace((eval;e), (_2037274=1, indentq(0, 17, -->, [e, [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(262) [user] if_trace((eval;e), (_2037274=1, indentq(0, 17, -->, [e, [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]])))
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] _2063544=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(262) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] _2065582=(\+ \+ (flag(eval_num, _2065602, _2065602+1), (retval(fail)\=@=retval(fail), nonvar(_2036160)->indentq(0, _2065602, <--, [e, _2036160]);indentq(0, _2065602, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(262) [system] (\+ \+ (flag(eval_num, _2065602, _2065602+1), (retval(fail)\=@=retval(fail), nonvar(_2036160)->indentq(0, _2065602, <--, [e, _2036160]);indentq(0, _2065602, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _2065602, _2065602+1), (retval(fail)\=@=retval(fail), nonvar(_2036160)->indentq(0, _2065602, <--, [e, _2036160]);indentq(0, _2065602, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] call_cleanup(((call(eval_20(=, _2003136), 499, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _2036160)*->nb_setarg(1, retval(fail), _2036160);fail, trace, call(eval_20(=, _2003136), 499, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _2036160)), ignore(notrace((\+_2036160\=_2037404, nb_setarg(1, retval(fail), _2036160))))), ignore((_2037274==1->ignore(\+ \+ (flag(eval_num, _2065602, _2065602+1), (retval(fail)\=@=retval(fail), nonvar(_2036160)->indentq(0, _2065602, <--, [e, _2036160]);indentq(0, _2065602, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _2065602, _2065602+1), (retval(fail)\=@=retval(fail), nonvar(_2036160)->indentq(0, _2065602, <--, [e, _2036160]);indentq(0, _2065602, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(264) [user] eval_20(=, _2003136, 499, '&self', [case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _2036160)
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] atom([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] no_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] self_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_2072990, _2072992), once(user:self_eval0([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])), '$restore_trace'(_2072990, _2072992))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_2072990, _2072992))
^  <span class="ansi1 ansi31"
>Fail: </span>(266) [user] self_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] atomic(case)
   <span class="ansi1 ansi32"
>Exit: </span>(266) [system] atomic(case)
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] is_sl(case)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] number(case)
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] [['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(265) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] callable(case)
   <span class="ansi1 ansi32"
>Exit: </span>(265) [system] callable(case)
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] [['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] is_list([['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
   <span class="ansi1 ansi32"
>Exit: </span>(265) [system] is_list([['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] is_list(case)
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] is_list([['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
   <span class="ansi1 ansi32"
>Exit: </span>(265) [system] is_list([['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] is_list([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
   <span class="ansi1 ansi32"
>Exit: </span>(265) [system] is_list([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]])
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] once(expand_eval([case, ['if-unify-or-empty', _845060, _845060], [['Empty', _845078]]], _2095334))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] expand_eval([case, ['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]], _7316)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] is_list([case, ['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]])
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] is_list([case, ['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]])
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] ground(case)
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] ground(case)
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] apply:maplist(expand_eval, [['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]], _12010)
   <span class="ansi1 ansi32"
>Call: </span>(268) [apply] apply:maplist_([['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]], _12010, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] expand_eval(['if-unify-or-empty', _5640, _5640], _14066)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] is_list(['if-unify-or-empty', _5640, _5640])
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] is_list(['if-unify-or-empty', _5640, _5640])
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] apply:maplist(expand_eval, [_5640, _5640], _19144)
   <span class="ansi1 ansi32"
>Call: </span>(271) [apply] apply:maplist_([_5640, _5640], _19144, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] expand_eval(_5640, _21200)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] is_list(_5640)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] _5640=_21200
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] _5640=_5640
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] expand_eval(_5640, _5640)
   <span class="ansi1 ansi32"
>Call: </span>(272) [apply] apply:maplist_([_5640], _21202, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] expand_eval(_5640, _27302)
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] is_list(_5640)
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] _5640=_27302
   <span class="ansi1 ansi32"
>Exit: </span>(274) [system] _5640=_5640
^  <span class="ansi1 ansi32"
>Exit: </span>(273) [user] expand_eval(_5640, _5640)
   <span class="ansi1 ansi32"
>Call: </span>(273) [apply] apply:maplist_([], _27304, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(273) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(272) [apply] apply:maplist_([_5640], [_5640], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(271) [apply] apply:maplist_([_5640, _5640], [_5640, _5640], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [apply] apply:maplist(user:expand_eval, [_5640, _5640], [_5640, _5640])
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] expand_eval(['if-unify-or-empty', _5640, _5640], ['if-unify-or-empty', _5640, _5640])
   <span class="ansi1 ansi32"
>Call: </span>(269) [apply] apply:maplist_([[['Empty', _5658]]], _14068, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] expand_eval([['Empty', _5658]], _39526)
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] is_list([['Empty', _5658]])
   <span class="ansi1 ansi32"
>Exit: </span>(271) [system] is_list([['Empty', _5658]])
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] ground(['Empty', _5658])
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] apply:maplist(expand_eval, [], _42574)
   <span class="ansi1 ansi32"
>Call: </span>(272) [apply] apply:maplist_([], _42574, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(272) [apply] apply:maplist_([], [], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [apply] apply:maplist(user:expand_eval, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [user] expand_eval([['Empty', _5658]], [['Empty', _5658]])
   <span class="ansi1 ansi32"
>Call: </span>(270) [apply] apply:maplist_([], _39528, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(270) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(269) [apply] apply:maplist_([[['Empty', _5658]]], [[['Empty', _5658]]], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(268) [apply] apply:maplist_([['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]], [['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [apply] apply:maplist(user:expand_eval, [['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]], [['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] expand_eval([case, ['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]], [case, ['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [system] once(user:expand_eval([case, ['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]], [case, ['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]]))
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] [case, ['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]]\==[case, ['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]]
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] is_progn(case)
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] is_space_op(case)
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] must_det_ll([]==[])
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] once(user:([]==[]))
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] []==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [system] once(user:([]==[]))
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [user] must_det_ll(user:([]==[]))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] into_case_list([['Empty', _5658]], _68018)
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] is_list([['Empty', _5658]])
   <span class="ansi1 ansi32"
>Exit: </span>(266) [system] is_list([['Empty', _5658]])
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [user] into_case_list([['Empty', _5658]], [['Empty', _5658]])
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] into_case_keys(1, [['Empty', _5658]], _72076)
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] _73116 is 1+1
   <span class="ansi1 ansi32"
>Exit: </span>(266) [system] 2 is 1+1
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] is_case(_73106, ['Empty', _5658], _73108)
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] is_case('Empty', ['Empty', _5658], _5658)
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_5658)))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_78282, _78284), once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_5658))), _78240, fbug((_78240-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_5658)))))))), '$restore_trace'(_78282, _78284))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_78282, _78284))
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_5658))), _78240, fbug((_78240-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_5658)))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_5658)))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] into_case_keys(2, [], _73102)
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] into_case_keys(2, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [user] into_case_keys(1, [['Empty', _5658]], ['Empty'-_5658])
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] eval_case(=, _6910, 499, '&self', ['if-unify-or-empty', _5640, _5640], ['Empty'-_5658], _7012)
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _5640, _5640]))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_87650, _87652), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _5640, _5640]))), _87608, fbug((_87608-->if_trace(case, writeqln(case=['if-unify-or-empty', _5640, _5640]))))))), '$restore_trace'(_87650, _87652))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_87650, _87652))
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _5640, _5640]))), _87608, fbug((_87608-->if_trace(case, writeqln(case=['if-unify-or-empty', _5640, _5640]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _5640, _5640]))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] eval_args(=, _91972, 499, '&self', ['if-unify-or-empty', _5640, _5640], _91846)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] var(['if-unify-or-empty', _5640, _5640])
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_93904, _93906), once(user:self_eval(['if-unify-or-empty', _5640, _5640])), '$restore_trace'(_93904, _93906))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_93904, _93906))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_95992, _95994), once(user:nonvar(_91846)), '$restore_trace'(_95992, _95994))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_95992, _95994))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_98080, _98082), once(user:nonvar(_91846)), '$restore_trace'(_98080, _98082))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_98080, _98082))
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] [_5640, _5640]==[]
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] self_eval(['if-unify-or-empty', _5640, _5640])
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] setup_call_cleanup('$notrace'(_105236, _105238), once(user:self_eval0(['if-unify-or-empty', _5640, _5640])), '$restore_trace'(_105236, _105238))
^  <span class="ansi1 ansi32"
>Call: </span>(270) [system] sig_atomic(system:'$notrace'(_105236, _105238))
^  <span class="ansi1 ansi31"
>Fail: </span>(267) [user] self_eval(['if-unify-or-empty', _5640, _5640])
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] eval_00(=, _108324, 499, '&self', ['if-unify-or-empty', _5640, _5640], _91846)
^  <span class="ansi1 ansi32"
>Call: </span>(268) [user] self_eval(['if-unify-or-empty', _5640, _5640])
^  <span class="ansi1 ansi32"
>Call: </span>(270) [system] setup_call_cleanup('$notrace'(_110382, _110384), once(user:self_eval0(['if-unify-or-empty', _5640, _5640])), '$restore_trace'(_110382, _110384))
^  <span class="ansi1 ansi32"
>Call: </span>(271) [system] sig_atomic(system:'$notrace'(_110382, _110384))
^  <span class="ansi1 ansi31"
>Fail: </span>(268) [user] self_eval(['if-unify-or-empty', _5640, _5640])
^  <span class="ansi1 ansi32"
>Call: </span>(268) [user] eval_01(=, _108324, 499, '&self', ['if-unify-or-empty', _5640, _5640], _91846)
   <span class="ansi1 ansi32"
>Call: </span>(269) [system] ['if-unify-or-empty', _5640, _5640]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(269) [system] ['if-unify-or-empty', _5640, _5640]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] if_t((499<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] 499<1
   <span class="ansi1 ansi31"
>Fail: </span>(271) [system] 499<1
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] if_t((499<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(270) [system] setup_call_cleanup('$notrace'(_120656, _120658), once(user:(_120632 is 499-1, copy_term(['if-unify-or-empty', _5640, _5640], _120646))), '$restore_trace'(_120656, _120658))
^  <span class="ansi1 ansi32"
>Call: </span>(271) [system] sig_atomic(system:'$notrace'(_120656, _120658))
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(498 is 499-1, copy_term(['if-unify-or-empty', _5640, _5640], ['if-unify-or-empty', _122742, _122742]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] trace_eval(eval_20(=, _108324), e, 498, '&self', ['if-unify-or-empty', _5640, _5640], _123784)
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] must_det_ll((notrace((flag(eval_num, _124838, _124838+1), _124856 is _124838 mod 500, _124874 is 99-498 mod 100, _124898=_124900, option_else('trace-length', _124912, 500), option_else('trace-depth', _124920, 30))), quietly(if_t((nop(stop_rtrace), _124856>_124912), (set_debug(eval, false), _124976 is _124912+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_124976])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_125028)))))
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] once(user:(notrace((flag(eval_num, _124838, _124838+1), _124856 is _124838 mod 500, _124874 is 99-498 mod 100, _124898=_124900, option_else('trace-length', _124912, 500), option_else('trace-depth', _124920, 30))), quietly(if_t((nop(stop_rtrace), _124856>_124912), (set_debug(eval, false), _124976 is _124912+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_124976])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_125028)))))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [system] setup_call_cleanup('$notrace'(_127074, _127076), once(user:(flag(eval_num, _124838, _124838+1), _124856 is _124838 mod 500, _124874 is 99-498 mod 100, _124898=_124900, option_else('trace-length', _124912, 500), option_else('trace-depth', _124920, 30))), '$restore_trace'(_127074, _127076))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] sig_atomic(system:'$notrace'(_127074, _127076))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 18, 18+1), 18 is 18 mod 500, 1 is 99-498 mod 100, _124898=_124898, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 18>500), (set_debug(eval, false), _124976 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_124976])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 18>500), (set_debug(eval, false), _124976 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_124976])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(273) [user] nop(notrace(no_repeats_var(_125028)))
   <span class="ansi1 ansi32"
>Exit: </span>(273) [user] nop(notrace(no_repeats_var(_125028)))
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [system] once(user:(notrace((flag(eval_num, 18, 18+1), 18 is 18 mod 500, 1 is 99-498 mod 100, _124898=_124898, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 18>500), (set_debug(eval, false), _124976 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_124976])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_125028)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [user] must_det_ll(user:(notrace((flag(eval_num, 18, 18+1), 18 is 18 mod 500, 1 is 99-498 mod 100, _124898=_124898, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 18>500), (set_debug(eval, false), _124976 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_124976])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_125028)))))
   <span class="ansi1 ansi32"
>Call: </span>(270) [occurs] occurs:sub_term(_136726, e)
   <span class="ansi1 ansi32"
>Exit: </span>(270) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(270) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(271) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(270) [occurs] occurs:sub_term(_136726, e)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] _143832=e
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] if_trace((eval;e), (_124898=1, indentq(1, 18, -->, [e, ['if-unify-or-empty', _5640, _5640]])))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] setup_call_cleanup('$notrace'(_146972, _146974), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _124898=1, indentq(1, 18, -->, [e, ['if-unify-or-empty', _5640, _5640]]))), _146930, fbug((_146930-->if_trace((eval;e), (_124898=1, indentq(1, 18, -->, [e, ['if-unify-or-empty', _5640, _5640]])))))))), '$restore_trace'(_146972, _146974))
^  <span class="ansi1 ansi32"
>Call: </span>(273) [system] sig_atomic(system:'$notrace'(_146972, _146974))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _124898=1, indentq(1, 18, -->, [e, ['if-unify-or-empty', _5640, _5640]]))), _146930, fbug((_146930-->if_trace((eval;e), (_124898=1, indentq(1, 18, -->, [e, ['if-unify-or-empty', _5640, _5640]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [user] if_trace((eval;e), (_124898=1, indentq(1, 18, -->, [e, ['if-unify-or-empty', _5640, _5640]])))
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] _151168=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] _153206=(\+ \+ (flag(eval_num, _153226, _153226+1), (retval(fail)\=@=retval(fail), nonvar(_123784)->indentq(1, _153226, <--, [e, _123784]);indentq(1, _153226, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] (\+ \+ (flag(eval_num, _153226, _153226+1), (retval(fail)\=@=retval(fail), nonvar(_123784)->indentq(1, _153226, <--, [e, _123784]);indentq(1, _153226, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _153226, _153226+1), (retval(fail)\=@=retval(fail), nonvar(_123784)->indentq(1, _153226, <--, [e, _123784]);indentq(1, _153226, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] call_cleanup(((call(eval_20(=, _108324), 498, '&self', ['if-unify-or-empty', _5640, _5640], _123784)*->nb_setarg(1, retval(fail), _123784);fail, trace, call(eval_20(=, _108324), 498, '&self', ['if-unify-or-empty', _5640, _5640], _123784)), ignore(notrace((\+_123784\=_125028, nb_setarg(1, retval(fail), _123784))))), ignore((_124898==1->ignore(\+ \+ (flag(eval_num, _153226, _153226+1), (retval(fail)\=@=retval(fail), nonvar(_123784)->indentq(1, _153226, <--, [e, _123784]);indentq(1, _153226, <--, [e, retval(fail)]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _153226, _153226+1), (retval(fail)\=@=retval(fail), nonvar(_123784)->indentq(1, _153226, <--, [e, _123784]);indentq(1, _153226, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] eval_20(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _123784)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] atom(['if-unify-or-empty', _5640, _5640])
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] no_eval(['if-unify-or-empty', _5640, _5640])
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] self_eval(['if-unify-or-empty', _5640, _5640])
^  <span class="ansi1 ansi32"
>Call: </span>(276) [system] setup_call_cleanup('$notrace'(_160614, _160616), once(user:self_eval0(['if-unify-or-empty', _5640, _5640])), '$restore_trace'(_160614, _160616))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [system] sig_atomic(system:'$notrace'(_160614, _160616))
^  <span class="ansi1 ansi31"
>Fail: </span>(274) [user] self_eval(['if-unify-or-empty', _5640, _5640])
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] atomic('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(274) [system] atomic('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] is_sl('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(275) [system] number('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] [_5640, _5640]==[]
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] _171808==eval
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] [_5640, _5640]==[]
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] is_list([_5640, _5640])
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] is_list([_5640, _5640])
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] is_list('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] is_list([_5640, _5640])
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] is_list([_5640, _5640])
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] is_list(['if-unify-or-empty', _5640, _5640])
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] is_list(['if-unify-or-empty', _5640, _5640])
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] once(expand_eval(['if-unify-or-empty', _5640, _5640], _183986))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] expand_eval(['if-unify-or-empty', _5640, _5640], _183986)
   <span class="ansi1 ansi32"
>Call: </span>(275) [system] is_list(['if-unify-or-empty', _5640, _5640])
   <span class="ansi1 ansi32"
>Exit: </span>(275) [system] is_list(['if-unify-or-empty', _5640, _5640])
   <span class="ansi1 ansi32"
>Call: </span>(275) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(275) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] apply:maplist(expand_eval, [_5640, _5640], _190086)
   <span class="ansi1 ansi32"
>Call: </span>(276) [apply] apply:maplist_([_5640, _5640], _190086, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] expand_eval(_5640, _192142)
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] is_list(_5640)
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] _5640=_192142
   <span class="ansi1 ansi32"
>Exit: </span>(278) [system] _5640=_5640
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [user] expand_eval(_5640, _5640)
   <span class="ansi1 ansi32"
>Call: </span>(277) [apply] apply:maplist_([_5640], _192144, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] expand_eval(_5640, _198244)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] is_list(_5640)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] _5640=_198244
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] _5640=_5640
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [user] expand_eval(_5640, _5640)
   <span class="ansi1 ansi32"
>Call: </span>(278) [apply] apply:maplist_([], _198246, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(278) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(277) [apply] apply:maplist_([_5640], [_5640], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(276) [apply] apply:maplist_([_5640, _5640], [_5640, _5640], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [apply] apply:maplist(user:expand_eval, [_5640, _5640], [_5640, _5640])
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [user] expand_eval(['if-unify-or-empty', _5640, _5640], ['if-unify-or-empty', _5640, _5640])
^  <span class="ansi1 ansi32"
>Exit: </span>(273) [system] once(user:expand_eval(['if-unify-or-empty', _5640, _5640], ['if-unify-or-empty', _5640, _5640]))
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] ['if-unify-or-empty', _5640, _5640]\==['if-unify-or-empty', _5640, _5640]
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] is_progn('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] is_space_op('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] arg(_215666, v('catch!', 'throw!', 'number-of!', 'limit!', 'offset!', 'max-time!', 'findall!', 'setup-call-cleanup!', 'call-cleanup!', 'call-cleanup!', 'with-output-to!'), 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] _216564='if-unify-or-empty'
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] 'if-unify-or-empty'='if-unify-or-empty'
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _218598)
^  <span class="ansi1 ansi31"
>Fail: </span>(273) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _218598)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] is_list(['if-unify-or-empty', _5640, _5640])
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] is_list(['if-unify-or-empty', _5640, _5640])
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] apply:maplist(self_eval, ['if-unify-or-empty', _5640, _5640])
   <span class="ansi1 ansi32"
>Call: </span>(274) [apply] apply:maplist_(['if-unify-or-empty', _5640, _5640], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] self_eval('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(277) [system] setup_call_cleanup('$notrace'(_225732, _225734), once(user:self_eval0('if-unify-or-empty')), '$restore_trace'(_225732, _225734))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [system] sig_atomic(system:'$notrace'(_225732, _225734))
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0('if-unify-or-empty')), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] self_eval('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(275) [apply] apply:maplist_([_5640, _5640], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] self_eval(_5640)
^  <span class="ansi1 ansi32"
>Call: </span>(278) [system] setup_call_cleanup('$notrace'(_231886, _231888), once(user:self_eval0(_5640)), '$restore_trace'(_231886, _231888))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [system] sig_atomic(system:'$notrace'(_231886, _231888))
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_5640)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(276) [user] self_eval(_5640)
   <span class="ansi1 ansi32"
>Call: </span>(276) [apply] apply:maplist_([_5640], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] self_eval(_5640)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [system] setup_call_cleanup('$notrace'(_238040, _238042), once(user:self_eval0(_5640)), '$restore_trace'(_238040, _238042))
^  <span class="ansi1 ansi32"
>Call: </span>(280) [system] sig_atomic(system:'$notrace'(_238040, _238042))
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_5640)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [user] self_eval(_5640)
   <span class="ansi1 ansi32"
>Call: </span>(277) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(277) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(276) [apply] apply:maplist_([_5640], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(275) [apply] apply:maplist_([_5640, _5640], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(274) [apply] apply:maplist_(['if-unify-or-empty', _5640, _5640], user:self_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(273) [apply] apply:maplist(user:self_eval, ['if-unify-or-empty', _5640, _5640])
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] ['if-unify-or-empty', _5640, _5640]=[_248258|_248260]
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] ['if-unify-or-empty', _5640, _5640]=['if-unify-or-empty', _5640, _5640]
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] _252318=do_more_defs(true)
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] do_more_defs(true)=do_more_defs(true)
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] clause(eval_21(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _123784), _254370)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] 'if-unify-or-empty'==(/)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] 'if-unify-or-empty'== ===
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] 'if-unify-or-empty'== ====
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] eval_40(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442)
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] eval_selfless(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442)
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] eval_selfless_0(['if-unify-or-empty', _5640, _5640], _258442)
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] is_assignment('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(277) [system] atom('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] eval_selfless_1(['if-unify-or-empty', _5640, _5640], _258442)
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] allow_clp
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] false_flag
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(279) [system] fail
^  <span class="ansi1 ansi31"
>Fail: </span>(278) [user] false_flag
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] eval_selfless_2(['if-unify-or-empty', _5640, _5640], _258442)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] fake_notrace((ground(['if-unify-or-empty', _5640, _5640]), ['if-unify-or-empty', _5640, _5640]=[_273666, _273672, _273678], atom(_273666), catch_warn(current_op(_273704, yfx, _273666)), ['if-unify-or-empty', _5640, _5640]\=[_273724], s2ps(['if-unify-or-empty', _5640, _5640], _273732)))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] real_notrace(user:(ground(['if-unify-or-empty', _5640, _5640]), ['if-unify-or-empty', _5640, _5640]=[_273666, _273672, _273678], atom(_273666), catch_warn(current_op(_273704, yfx, _273666)), ['if-unify-or-empty', _5640, _5640]\=[_273724], s2ps(['if-unify-or-empty', _5640, _5640], _273732)))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] setup_call_cleanup('$notrace'(_275766, _275768), once(user:(ground(['if-unify-or-empty', _5640, _5640]), ['if-unify-or-empty', _5640, _5640]=[_273666, _273672, _273678], atom(_273666), catch_warn(current_op(_273704, yfx, _273666)), ['if-unify-or-empty', _5640, _5640]\=[_273724], s2ps(['if-unify-or-empty', _5640, _5640], _273732))), '$restore_trace'(_275766, _275768))
^  <span class="ansi1 ansi32"
>Call: </span>(280) [system] sig_atomic(user:'$notrace'(_275766, _275768))
^  <span class="ansi1 ansi31"
>Fail: </span>(278) [user] real_notrace(user:(ground(['if-unify-or-empty', _5640, _5640]), ['if-unify-or-empty', _5640, _5640]=[_273666, _273672, _273678], atom(_273666), catch_warn(current_op(_273704, yfx, _273666)), ['if-unify-or-empty', _5640, _5640]\=[_273724], s2ps(['if-unify-or-empty', _5640, _5640], _273732)))
^  <span class="ansi1 ansi31"
>Fail: </span>(277) [user] fake_notrace(user:(ground(['if-unify-or-empty', _5640, _5640]), ['if-unify-or-empty', _5640, _5640]=[_273666, _273672, _273678], atom(_273666), catch_warn(current_op(_273704, yfx, _273666)), ['if-unify-or-empty', _5640, _5640]\=[_273724], s2ps(['if-unify-or-empty', _5640, _5640], _273732)))
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] 'if-unify-or-empty'==(==)
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] 'if-unify-or-empty'==(==)
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] eval_41(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442)
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] eval_adjust_args(=, _108324, _288954, _258442, 498, '&self', ['if-unify-or-empty', _5640, _5640], _288956)
   <span class="ansi1 ansi32"
>Call: </span>(276) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _108324, _288954, _258442, 498, '&self', ['if-unify-or-empty', _5640, _5640], _288956)), eval_adjust_args1(=, _108324, _288954, _258442, 498, '&self', ['if-unify-or-empty', _5640, _5640], _288956))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] eval_adjust_args2(=, _108324, _288954, _258442, 498, '&self', ['if-unify-or-empty', _5640, _5640], _288956)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] apply:maplist(must_eval_args(=, _296110, 498, '&self'), [_5640, _5640], _296104)
   <span class="ansi1 ansi32"
>Call: </span>(280) [apply] apply:maplist_([_5640, _5640], _296104, user:must_eval_args(=, _296110, 498, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] must_eval_args(=, _296110, 498, '&self', _5640, _298170)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(283) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(285) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(285) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(285) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] was_option_value(nodebug, _309334)
   <span class="ansi1 ansi32"
>Call: </span>(287) [system] current_prolog_flag(nodebug, _310352)
   <span class="ansi1 ansi31"
>Fail: </span>(287) [system] current_prolog_flag(nodebug, _310352)
   <span class="ansi1 ansi32"
>Call: </span>(287) [$syspreds] prolog_load_context(nodebug, _312386)
   <span class="ansi1 ansi31"
>Fail: </span>(287) [$syspreds] prolog_load_context(nodebug, _312386)
   <span class="ansi1 ansi32"
>Call: </span>(287) [system] nb_current(nodebug, _314420)
   <span class="ansi1 ansi31"
>Fail: </span>(287) [system] nb_current(nodebug, _314420)
^  <span class="ansi1 ansi31"
>Fail: </span>(286) [user] was_option_value(nodebug, _309334)
^  <span class="ansi1 ansi31"
>Fail: </span>(285) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(285) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(286) [system] setup_call_cleanup('$notrace'(_320532, _320534), once(user:option_value0(nodebug, true)), '$restore_trace'(_320532, _320534))
^  <span class="ansi1 ansi32"
>Call: </span>(287) [system] sig_atomic(system:'$notrace'(_320532, _320534))
^  <span class="ansi1 ansi31"
>Fail: </span>(284) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(283) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(283) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(283) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(284) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(284) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(283) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(284) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(284) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(283) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(283) [prolog_debug] prolog_debug:debugging(metta(eval_args), _340872)
^  <span class="ansi1 ansi32"
>Call: </span>(284) [prolog_debug] prolog_debug:debugging(metta(eval_args), _340872, _342016)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(285) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(285) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_345982, _345984, _345986), defined)
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(286) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_345982, _345984, _345986))
   <span class="ansi1 ansi32"
>Call: </span>(287) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_345982, _345984, _345986))
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] callable(debugging_logicmoo_setting(_345982, _345984, _345986))
   <span class="ansi1 ansi32"
>Exit: </span>(288) [system] callable(debugging_logicmoo_setting(_345982, _345984, _345986))
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(288) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(287) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_345982, _345984, _345986))
   <span class="ansi1 ansi32"
>Exit: </span>(286) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_345982, _345984, _345986))
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_345982, _345984, _345986), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(285) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _340872, _358166)
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(283) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(283) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] eval_args(=, _296110, 498, '&self', _5640, _298170)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] var(_5640)
   <span class="ansi1 ansi32"
>Exit: </span>(283) [system] var(_5640)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] nonvar(_298170)
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] setup_call_cleanup('$notrace'(_369392, _369394), once(user:self_eval(_5640)), '$restore_trace'(_369392, _369394))
^  <span class="ansi1 ansi32"
>Call: </span>(285) [system] sig_atomic(system:'$notrace'(_369392, _369394))
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_5640)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] _298170=_5640
   <span class="ansi1 ansi32"
>Exit: </span>(283) [system] _5640=_5640
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] eval_args(=, _296110, 498, '&self', _5640, _5640)
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [user] must_eval_args(=, _296110, 498, '&self', _5640, _5640)
   <span class="ansi1 ansi32"
>Call: </span>(281) [apply] apply:maplist_([_5640], _298172, user:must_eval_args(=, _296110, 498, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] must_eval_args(=, _296110, 498, '&self', _5640, _377656)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(284) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(285) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(286) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(287) [user] was_option_value(nodebug, _388820)
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] current_prolog_flag(nodebug, _389838)
   <span class="ansi1 ansi31"
>Fail: </span>(288) [system] current_prolog_flag(nodebug, _389838)
   <span class="ansi1 ansi32"
>Call: </span>(288) [$syspreds] prolog_load_context(nodebug, _391872)
   <span class="ansi1 ansi31"
>Fail: </span>(288) [$syspreds] prolog_load_context(nodebug, _391872)
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] nb_current(nodebug, _393906)
   <span class="ansi1 ansi31"
>Fail: </span>(288) [system] nb_current(nodebug, _393906)
^  <span class="ansi1 ansi31"
>Fail: </span>(287) [user] was_option_value(nodebug, _388820)
^  <span class="ansi1 ansi31"
>Fail: </span>(286) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(286) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(287) [system] setup_call_cleanup('$notrace'(_400018, _400020), once(user:option_value0(nodebug, true)), '$restore_trace'(_400018, _400020))
^  <span class="ansi1 ansi32"
>Call: </span>(288) [system] sig_atomic(system:'$notrace'(_400018, _400020))
^  <span class="ansi1 ansi31"
>Fail: </span>(285) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(284) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(284) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(284) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(285) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(285) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(284) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(285) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(285) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(284) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(284) [prolog_debug] prolog_debug:debugging(metta(eval_args), _420358)
^  <span class="ansi1 ansi32"
>Call: </span>(285) [prolog_debug] prolog_debug:debugging(metta(eval_args), _420358, _421502)
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(286) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(286) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_425468, _425470, _425472), defined)
   <span class="ansi1 ansi32"
>Call: </span>(287) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(287) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(287) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_425468, _425470, _425472))
   <span class="ansi1 ansi32"
>Call: </span>(288) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_425468, _425470, _425472))
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] callable(debugging_logicmoo_setting(_425468, _425470, _425472))
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] callable(debugging_logicmoo_setting(_425468, _425470, _425472))
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(288) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_425468, _425470, _425472))
   <span class="ansi1 ansi32"
>Exit: </span>(287) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_425468, _425470, _425472))
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_425468, _425470, _425472), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(286) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _420358, _437652)
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(284) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(284) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] eval_args(=, _296110, 498, '&self', _5640, _377656)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] var(_5640)
   <span class="ansi1 ansi32"
>Exit: </span>(284) [system] var(_5640)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] nonvar(_377656)
^  <span class="ansi1 ansi32"
>Call: </span>(285) [system] setup_call_cleanup('$notrace'(_448878, _448880), once(user:self_eval(_5640)), '$restore_trace'(_448878, _448880))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [system] sig_atomic(system:'$notrace'(_448878, _448880))
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_5640)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] _377656=_5640
   <span class="ansi1 ansi32"
>Exit: </span>(284) [system] _5640=_5640
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [user] eval_args(=, _296110, 498, '&self', _5640, _5640)
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] must_eval_args(=, _296110, 498, '&self', _5640, _5640)
   <span class="ansi1 ansi32"
>Call: </span>(282) [apply] apply:maplist_([], _377658, user:must_eval_args(=, _296110, 498, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(282) [apply] apply:maplist_([], [], user:must_eval_args(=, _296110, 498, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(281) [apply] apply:maplist_([_5640], [_5640], user:must_eval_args(=, _296110, 498, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(280) [apply] apply:maplist_([_5640, _5640], [_5640, _5640], user:must_eval_args(=, _296110, 498, '&self'))
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [apply] apply:maplist(user:must_eval_args(=, _296110, 498, '&self'), [_5640, _5640], [_5640, _5640])
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] _288954=_258442
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] _258442=_258442
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [user] eval_adjust_args2(=, _108324, _258442, _258442, 498, '&self', ['if-unify-or-empty', _5640, _5640], ['if-unify-or-empty', _5640, _5640])
   <span class="ansi1 ansi32"
>Exit: </span>(276) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _108324, _258442, _258442, 498, '&self', ['if-unify-or-empty', _5640, _5640], ['if-unify-or-empty', _5640, _5640])), eval_adjust_args1(=, _108324, _258442, _258442, 498, '&self', ['if-unify-or-empty', _5640, _5640], ['if-unify-or-empty', _5640, _5640]))
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] eval_adjust_args(=, _108324, _258442, _258442, 498, '&self', ['if-unify-or-empty', _5640, _5640], ['if-unify-or-empty', _5640, _5640])
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] if_trace((e;args), (['if-unify-or-empty', _5640, _5640]\==['if-unify-or-empty', _5640, _5640]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _5640, _5640]->['if-unify-or-empty', _5640, _5640])));nop(indentq2(498, same(['if-unify-or-empty', _5640, _5640])))))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [system] setup_call_cleanup('$notrace'(_467464, _467466), once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _5640, _5640]\==['if-unify-or-empty', _5640, _5640]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _5640, _5640]->['if-unify-or-empty', _5640, _5640])));nop(indentq2(498, same(['if-unify-or-empty', _5640, _5640])))))), _467422, fbug((_467422-->if_trace((e;args), (['if-unify-or-empty', _5640, _5640]\==['if-unify-or-empty', _5640, _5640]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _5640, _5640]->['if-unify-or-empty', _5640, _5640])));nop(indentq2(498, same(['if-unify-or-empty', _5640, _5640])))))))))), '$restore_trace'(_467464, _467466))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [system] sig_atomic(system:'$notrace'(_467464, _467466))
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _5640, _5640]\==['if-unify-or-empty', _5640, _5640]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _5640, _5640]->['if-unify-or-empty', _5640, _5640])));nop(indentq2(498, same(['if-unify-or-empty', _5640, _5640])))))), _467422, fbug((_467422-->if_trace((e;args), (['if-unify-or-empty', _5640, _5640]\==['if-unify-or-empty', _5640, _5640]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _5640, _5640]->['if-unify-or-empty', _5640, _5640])));nop(indentq2(498, same(['if-unify-or-empty', _5640, _5640])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] if_trace((e;args), (['if-unify-or-empty', _5640, _5640]\==['if-unify-or-empty', _5640, _5640]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _5640, _5640]->['if-unify-or-empty', _5640, _5640])));nop(indentq2(498, same(['if-unify-or-empty', _5640, _5640])))))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] eval_70(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442)
   <span class="ansi1 ansi32"
>Call: </span>(276) [user] if_or_else(eval_maybe_python(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442), if_or_else(eval_maybe_host_predicate(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442), if_or_else(eval_maybe_host_function(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442), if_or_else(eval_maybe_defn(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442), eval_maybe_subst(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442)))))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] eval_maybe_python(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442)
   <span class="ansi1 ansi32"
>Call: </span>(278) [user] metta_atom('&self', ['registered-python-function', _474824, _474830, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] typed_list('&self', _475970, _475844)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(280) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(279) [user] typed_list('&self', _479014, _475844)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] metta_atom_in_file('&self', ['registered-python-function', _474824, _474830, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] metta_atom_in_file('&self', ['registered-python-function', _474824, _474830, 'if-unify-or-empty'], _482068, _482070)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] loaded_into_kb('&self', _482966)
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [user] loaded_into_kb('&self', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] once(user:asserted_metta_pred(_488926, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] asserted_metta_pred(_488926, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(282) [user] asserted_metta_pred(_488926, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(279) [user] metta_atom_asserted('&self', ['registered-python-function', _474824, _474830, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] metta_atom_asserted_deduced('&self', ['registered-python-function', _474824, _474830, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(279) [user] metta_atom('&corelib', ['registered-python-function', _474824, _474830, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] typed_list('&corelib', _512968, _512842)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(281) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(280) [user] typed_list('&corelib', _516012, _512842)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] metta_atom_in_file('&corelib', ['registered-python-function', _474824, _474830, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] metta_atom_in_file('&corelib', ['registered-python-function', _474824, _474830, 'if-unify-or-empty'], _519066, _519068)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] loaded_into_kb('&corelib', _519964)
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] once(user:asserted_metta_pred(_525908, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] asserted_metta_pred(_525908, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(283) [user] asserted_metta_pred(_525908, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] once(user:asserted_metta_pred(_545590, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] asserted_metta_pred(_545590, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(283) [user] asserted_metta_pred(_545590, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(280) [user] metta_atom_asserted('&corelib', ['registered-python-function', _474824, _474830, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] metta_atom_asserted_deduced('&corelib', ['registered-python-function', _474824, _474830, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(277) [user] if_or_else(eval_maybe_host_predicate(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442), if_or_else(eval_maybe_host_function(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442), if_or_else(eval_maybe_defn(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442), eval_maybe_subst(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442))))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] eval_maybe_host_predicate(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] once((is_system_pred('if-unify-or-empty'), length([_5640, _5640], _570474), is_syspred('if-unify-or-empty', _570474, _570482)))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] atom_concat(_574666, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] atom_concat(_577710, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] atom_concat(_580754, '-p', 'if-unify-or-empty')
^  <span class="ansi1 ansi31"
>Fail: </span>(281) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(278) [user] if_or_else(eval_maybe_host_function(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442), if_or_else(eval_maybe_defn(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442), eval_maybe_subst(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442)))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] eval_maybe_host_function(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442)
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(280) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] atom_concat(_589866, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] atom_concat(_592910, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] atom_concat(_595954, '-p', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(279) [user] if_or_else(eval_maybe_defn(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442), eval_maybe_subst(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442))
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] eval_maybe_defn(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _5640, _5640])
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _5640, _5640])
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] trace_eval(eval_defn_choose_candidates(=, _108324), defn, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] must_det_ll((notrace((flag(eval_num, _605994, _605994+1), _606012 is _605994 mod 500, _606030 is 99-498 mod 100, _606054=_606056, option_else('trace-length', _606068, 500), option_else('trace-depth', _606076, 30))), quietly(if_t((nop(stop_rtrace), _606012>_606068), (set_debug(eval, false), _606132 is _606068+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_606132])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_606184)))))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] once(user:(notrace((flag(eval_num, _605994, _605994+1), _606012 is _605994 mod 500, _606030 is 99-498 mod 100, _606054=_606056, option_else('trace-length', _606068, 500), option_else('trace-depth', _606076, 30))), quietly(if_t((nop(stop_rtrace), _606012>_606068), (set_debug(eval, false), _606132 is _606068+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_606132])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_606184)))))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [system] setup_call_cleanup('$notrace'(_608230, _608232), once(user:(flag(eval_num, _605994, _605994+1), _606012 is _605994 mod 500, _606030 is 99-498 mod 100, _606054=_606056, option_else('trace-length', _606068, 500), option_else('trace-depth', _606076, 30))), '$restore_trace'(_608230, _608232))
^  <span class="ansi1 ansi32"
>Call: </span>(287) [system] sig_atomic(system:'$notrace'(_608230, _608232))
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 19, 19+1), 19 is 19 mod 500, 1 is 99-498 mod 100, _606054=_606054, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 19>500), (set_debug(eval, false), _606132 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_606132])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 19>500), (set_debug(eval, false), _606132 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_606132])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(285) [user] nop(notrace(no_repeats_var(_606184)))
   <span class="ansi1 ansi32"
>Exit: </span>(285) [user] nop(notrace(no_repeats_var(_606184)))
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [system] once(user:(notrace((flag(eval_num, 19, 19+1), 19 is 19 mod 500, 1 is 99-498 mod 100, _606054=_606054, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 19>500), (set_debug(eval, false), _606132 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_606132])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_606184)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] must_det_ll(user:(notrace((flag(eval_num, 19, 19+1), 19 is 19 mod 500, 1 is 99-498 mod 100, _606054=_606054, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 19>500), (set_debug(eval, false), _606132 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_606132])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_606184)))))
   <span class="ansi1 ansi32"
>Call: </span>(282) [occurs] occurs:sub_term(_617882, defn)
   <span class="ansi1 ansi32"
>Exit: </span>(282) [occurs] occurs:sub_term(defn, defn)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] defn\=defn
   <span class="ansi1 ansi31"
>Fail: </span>(282) [system] defn\=defn
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(283) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(282) [occurs] occurs:sub_term(_617882, defn)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] _624988=defn
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] defn=defn
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] if_trace((eval;defn), (_606054=1, indentq(1, 19, -->, [defn, ['if-unify-or-empty', _5640, _5640]])))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] setup_call_cleanup('$notrace'(_628128, _628130), once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _606054=1, indentq(1, 19, -->, [defn, ['if-unify-or-empty', _5640, _5640]]))), _628086, fbug((_628086-->if_trace((eval;defn), (_606054=1, indentq(1, 19, -->, [defn, ['if-unify-or-empty', _5640, _5640]])))))))), '$restore_trace'(_628128, _628130))
^  <span class="ansi1 ansi32"
>Call: </span>(285) [system] sig_atomic(system:'$notrace'(_628128, _628130))
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _606054=1, indentq(1, 19, -->, [defn, ['if-unify-or-empty', _5640, _5640]]))), _628086, fbug((_628086-->if_trace((eval;defn), (_606054=1, indentq(1, 19, -->, [defn, ['if-unify-or-empty', _5640, _5640]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] if_trace((eval;defn), (_606054=1, indentq(1, 19, -->, [defn, ['if-unify-or-empty', _5640, _5640]])))
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] _632324=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] _634362=(\+ \+ (flag(eval_num, _634382, _634382+1), (retval(fail)\=@=retval(fail), nonvar(_258442)->indentq(1, _634382, <--, [defn, _258442]);indentq(1, _634382, <--, [defn, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] (\+ \+ (flag(eval_num, _634382, _634382+1), (retval(fail)\=@=retval(fail), nonvar(_258442)->indentq(1, _634382, <--, [defn, _258442]);indentq(1, _634382, <--, [defn, retval(fail)]))))=(\+ \+ (flag(eval_num, _634382, _634382+1), (retval(fail)\=@=retval(fail), nonvar(_258442)->indentq(1, _634382, <--, [defn, _258442]);indentq(1, _634382, <--, [defn, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] call_cleanup(((call(eval_defn_choose_candidates(=, _108324), 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442)*->nb_setarg(1, retval(fail), _258442);fail, trace, call(eval_defn_choose_candidates(=, _108324), 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442)), ignore(notrace((\+_258442\=_606184, nb_setarg(1, retval(fail), _258442))))), ignore((_606054==1->ignore(\+ \+ (flag(eval_num, _634382, _634382+1), (retval(fail)\=@=retval(fail), nonvar(_258442)->indentq(1, _634382, <--, [defn, _258442]);indentq(1, _634382, <--, [defn, retval(fail)]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _634382, _634382+1), (retval(fail)\=@=retval(fail), nonvar(_258442)->indentq(1, _634382, <--, [defn, _258442]);indentq(1, _634382, <--, [defn, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] eval_defn_choose_candidates(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442)
^  <span class="ansi1 ansi32"
>Call: </span>(285) [user] findall((_638724->_638726), get_defn_expansions(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _638724, _638726), _638744)
^  <span class="ansi1 ansi32"
>Call: </span>(286) [$bags] findall((_638724->_638726), user:get_defn_expansions(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _638724, _638726), _638744, [])
^  <span class="ansi1 ansi32"
>Call: </span>(287) [$bags] cleanup_bag(findall_loop((_638724->_638726), user:get_defn_expansions(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _638724, _638726), _638744, []), '$destroy_findall_bag')
   <span class="ansi1 ansi32"
>Call: </span>(288) [$bags] findall_loop((_638724->_638726), user:get_defn_expansions(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _638724, _638726), _638744, [])
^  <span class="ansi1 ansi32"
>Call: </span>(289) [user] get_defn_expansions(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _638724, _638726)
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] same_len_copy([_5640, _5640], _643916)
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] length([_5640, _5640], _644934)
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] var(_644934)
   <span class="ansi1 ansi32"
>Exit: </span>(292) [system] var(_644934)
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(292) [system] []==[]
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] _644934=2
   <span class="ansi1 ansi32"
>Exit: </span>(292) [system] 2=2
   <span class="ansi1 ansi32"
>Exit: </span>(291) [system] length([_5640, _5640], 2)
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] length(_643916, 2)
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] var(2)
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] integer(2)
   <span class="ansi1 ansi32"
>Exit: </span>(292) [system] integer(2)
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] _643916==[]
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] var(_643916)
   <span class="ansi1 ansi32"
>Exit: </span>(292) [system] var(_643916)
   <span class="ansi1 ansi32"
>Exit: </span>(291) [system] length([_660158, _660164], 2)
^  <span class="ansi1 ansi32"
>Exit: </span>(290) [user] same_len_copy([_5640, _5640], [_660158, _660164])
   <span class="ansi1 ansi32"
>Call: </span>(290) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _660158, _660164], _638726)
^  <span class="ansi1 ansi32"
>Call: </span>(291) [user] ignore((=)=(=))
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] (=)=(=)
   <span class="ansi1 ansi32"
>Exit: </span>(292) [system] (=)=(=)
^  <span class="ansi1 ansi32"
>Exit: </span>(291) [system] ignore(user:((=)=(=)))
   <span class="ansi1 ansi32"
>Call: </span>(291) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _660158, _660164], _638726]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _660158, _660164], _638726]))
   <span class="ansi1 ansi32"
>Call: </span>(292) [user] metta_atom('&self', [=, ['if-unify-or-empty', _660158, _660164], _638726])
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] typed_list('&self', _669480, _669354)
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(294) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(293) [user] typed_list('&self', _672524, _669354)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _660158, _660164], _638726])
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _660158, _660164], _638726], _675578, _675580)
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] loaded_into_kb('&self', _676476)
^  <span class="ansi1 ansi32"
>Exit: </span>(295) [user] loaded_into_kb('&self', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] once(user:asserted_metta_pred(_682436, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] asserted_metta_pred(_682436, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(296) [user] asserted_metta_pred(_682436, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(293) [user] metta_atom_asserted('&self', [=, ['if-unify-or-empty', _660158, _660164], _638726])
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] metta_atom_asserted_deduced('&self', [=, ['if-unify-or-empty', _660158, _660164], _638726])
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(293) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _660158, _660164], _638726])
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] typed_list('&corelib', _706478, _706352)
   <span class="ansi1 ansi32"
>Call: </span>(295) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(295) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(294) [user] typed_list('&corelib', _709522, _706352)
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _660158, _660164], _638726])
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _660158, _660164], _638726], _712576, _712578)
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] loaded_into_kb('&corelib', _713474)
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] once(user:asserted_metta_pred(_719418, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] asserted_metta_pred(_719418, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(297) [user] asserted_metta_pred(_719418, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] once(user:asserted_metta_pred(_739100, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] asserted_metta_pred(_739100, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(297) [user] asserted_metta_pred(_739100, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(294) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _660158, _660164], _638726])
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] metta_atom_asserted_deduced('&corelib', [=, ['if-unify-or-empty', _660158, _660164], _638726])
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] fail
   <span class="ansi1 ansi32"
>Exit: </span>(294) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _660158, _660158], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(293) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _660158, _660158], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(292) [user] metta_atom('&self', [=, ['if-unify-or-empty', _660158, _660158], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(291) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _660158, _660158], unified]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _660158, _660158], unified]))
   <span class="ansi1 ansi32"
>Exit: </span>(290) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _660158, _660158], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(289) [user] get_defn_expansions(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], ['if-unify-or-empty', _660158, _660158], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(294) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _660158, _660164], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(293) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _660158, _660164], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(292) [user] metta_atom('&self', [=, ['if-unify-or-empty', _660158, _660164], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(291) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _660158, _660164], [empty]]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _660158, _660164], [empty]]))
   <span class="ansi1 ansi32"
>Exit: </span>(290) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _660158, _660164], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(289) [user] get_defn_expansions(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], ['if-unify-or-empty', _660158, _660164], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(288) [$bags] findall_loop((_638724->_638726), user:get_defn_expansions(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _638724, _638726), [(['if-unify-or-empty', _772104, _772104]->unified), (['if-unify-or-empty', _772068, _772074]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(287) [$bags] cleanup_bag('$bags':findall_loop((_638724->_638726), user:get_defn_expansions(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _638724, _638726), [(['if-unify-or-empty', _772104, _772104]->unified), (['if-unify-or-empty', _772068, _772074]->[empty])], []), '$bags':'$destroy_findall_bag')
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [$bags] findall((_638724->_638726), user:get_defn_expansions(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _638724, _638726), [(['if-unify-or-empty', _772104, _772104]->unified), (['if-unify-or-empty', _772068, _772074]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [$bags] findall((_638724->_638726), user:get_defn_expansions(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _638724, _638726), [(['if-unify-or-empty', _772104, _772104]->unified), (['if-unify-or-empty', _772068, _772074]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(285) [user] eval_defn_bodies(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442, [(['if-unify-or-empty', _772104, _772104]->unified), (['if-unify-or-empty', _772068, _772074]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _772104, _772104]->unified), (['if-unify-or-empty', _772068, _772074]->[empty])]))
^  <span class="ansi1 ansi32"
>Call: </span>(288) [system] setup_call_cleanup('$notrace'(_778336, _778338), once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(498, '   '), [(['if-unify-or-empty', _772104, _772104]->unified), (['if-unify-or-empty', _772068, _772074]->[empty])]))), _778294, fbug((_778294-->if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _772104, _772104]->unified), (['if-unify-or-empty', _772068, _772074]->[empty])]))))))), '$restore_trace'(_778336, _778338))
^  <span class="ansi1 ansi32"
>Call: </span>(289) [system] sig_atomic(system:'$notrace'(_778336, _778338))
^  <span class="ansi1 ansi32"
>Exit: </span>(288) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(498, '   '), [(['if-unify-or-empty', _772104, _772104]->unified), (['if-unify-or-empty', _772068, _772074]->[empty])]))), _778294, fbug((_778294-->if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _772104, _772104]->unified), (['if-unify-or-empty', _772068, _772074]->[empty])]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [user] if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _772104, _772104]->unified), (['if-unify-or-empty', _772068, _772074]->[empty])]))
   <span class="ansi1 ansi32"
>Call: </span>(286) [user] if_or_else((member((_782546->_782548), [(['if-unify-or-empty', _772104, _772104]->unified), (['if-unify-or-empty', _772068, _772074]->[empty])]), copy_term((_782546->_782548), _782560), eval_defn_success(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442, _782546, _782548, _782560)), eval_defn_failure(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442))
   <span class="ansi1 ansi32"
>Call: </span>(288) [lists] lists:member((_782546->_782548), [(['if-unify-or-empty', _772104, _772104]->unified), (['if-unify-or-empty', _772068, _772074]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(289) [lists] lists:member_([(['if-unify-or-empty', _772068, _772074]->[empty])], (_782546->_782548), (['if-unify-or-empty', _772104, _772104]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(289) [lists] lists:member_([(['if-unify-or-empty', _772068, _772074]->[empty])], (['if-unify-or-empty', _772104, _772104]->unified), (['if-unify-or-empty', _772104, _772104]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(288) [lists] lists:member((['if-unify-or-empty', _772104, _772104]->unified), [(['if-unify-or-empty', _772104, _772104]->unified), (['if-unify-or-empty', _772068, _772074]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] copy_term((['if-unify-or-empty', _772104, _772104]->unified), _782560)
   <span class="ansi1 ansi32"
>Exit: </span>(288) [system] copy_term((['if-unify-or-empty', _772104, _772104]->unified), (['if-unify-or-empty', _788710, _788710]->unified))
^  <span class="ansi1 ansi32"
>Call: </span>(288) [user] eval_defn_success(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442, ['if-unify-or-empty', _772104, _772104], unified, (['if-unify-or-empty', _788710, _788710]->unified))
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] ['if-unify-or-empty', _5640, _5640]=['if-unify-or-empty', _772104, _772104]
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] ['if-unify-or-empty', _5640, _5640]=['if-unify-or-empty', _5640, _5640]
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] _258442=unified
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] unified=unified
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] ['if-unify-or-empty', _5640, _5640]\=@=unified
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] ['if-unify-or-empty', _5640, _5640]\=@=unified
^  <span class="ansi1 ansi32"
>Call: </span>(289) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _788710, _788710]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] setup_call_cleanup('$notrace'(_797958, _797960), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _788710, _788710]->unified)))))), _797916, fbug((_797916-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _788710, _788710]->unified)))))))))), '$restore_trace'(_797958, _797960))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] sig_atomic(system:'$notrace'(_797958, _797960))
^  <span class="ansi1 ansi32"
>Exit: </span>(291) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _788710, _788710]->unified)))))), _797916, fbug((_797916-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _788710, _788710]->unified)))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(289) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _788710, _788710]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(289) [user] light_eval(=, _108324, 498, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(289) [user] light_eval(=, _108324, 498, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(288) [user] eval_defn_success(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified, ['if-unify-or-empty', _5640, _5640], unified, (['if-unify-or-empty', _788710, _788710]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(286) [user] if_or_else((member((['if-unify-or-empty', _5640, _5640]->unified), [(['if-unify-or-empty', _5640, _5640]->unified), (['if-unify-or-empty', _772068, _772074]->[empty])]), copy_term((['if-unify-or-empty', _5640, _5640]->unified), (['if-unify-or-empty', _788710, _788710]->unified)), eval_defn_success(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified, ['if-unify-or-empty', _5640, _5640], unified, (['if-unify-or-empty', _788710, _788710]->unified))), eval_defn_failure(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified))
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [user] eval_defn_bodies(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified, [(['if-unify-or-empty', _5640, _5640]->unified), (['if-unify-or-empty', _772068, _772074]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [user] eval_defn_choose_candidates(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(284) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] ignore(notrace((\+unified\=_606184, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [system] setup_call_cleanup('$notrace'(_811406, _811408), once(user:(\+unified\=_606184, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_811406, _811408))
^  <span class="ansi1 ansi32"
>Call: </span>(287) [system] sig_atomic(system:'$notrace'(_811406, _811408))
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_606184, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [system] ignore(user:notrace((\+unified\=_606184, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _108324), 498, '&self', ['if-unify-or-empty', _5640, _5640], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_defn_choose_candidates(=, _108324), 498, '&self', ['if-unify-or-empty', _5640, _5640], unified)), ignore(notrace((\+unified\=_606184, nb_setarg(1, retval(unified), unified))))), user:ignore((_606054==1->ignore(\+ \+ (flag(eval_num, _634382, _634382+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _634382, <--, [defn, unified]);indentq(1, _634382, <--, [defn, retval(unified)]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _634382, _634382+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _634382, <--, [defn, unified]);indentq(1, _634382, <--, [defn, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [user] trace_eval(eval_defn_choose_candidates(=, _108324), defn, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(280) [user] eval_maybe_defn(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(279) [user] if_or_else(eval_maybe_defn(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified), eval_maybe_subst(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified))
   <span class="ansi1 ansi32"
>Exit: </span>(278) [user] if_or_else(eval_maybe_host_function(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified), if_or_else(eval_maybe_defn(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified), eval_maybe_subst(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified)))
   <span class="ansi1 ansi32"
>Exit: </span>(277) [user] if_or_else(eval_maybe_host_predicate(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified), if_or_else(eval_maybe_host_function(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified), if_or_else(eval_maybe_defn(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified), eval_maybe_subst(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified))))
   <span class="ansi1 ansi32"
>Exit: </span>(276) [user] if_or_else(eval_maybe_python(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified), if_or_else(eval_maybe_host_predicate(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified), if_or_else(eval_maybe_host_function(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified), if_or_else(eval_maybe_defn(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified), eval_maybe_subst(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] eval_70(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] check_returnval(=, _108324, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] check_returnval(=, _108324, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [user] eval_41(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(273) [user] eval_40(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] unified=_123784
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] eval_20(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified)
   <span class="ansi1 ansi32"
>Call: </span>(272) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(272) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] ignore(notrace((\+unified\=_125028, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [system] setup_call_cleanup('$notrace'(_835936, _835938), once(user:(\+unified\=_125028, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_835936, _835938))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] sig_atomic(system:'$notrace'(_835936, _835938))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_125028, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [system] ignore(user:notrace((\+unified\=_125028, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [system] call_cleanup(user:((call(eval_20(=, _108324), 498, '&self', ['if-unify-or-empty', _5640, _5640], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_20(=, _108324), 498, '&self', ['if-unify-or-empty', _5640, _5640], unified)), ignore(notrace((\+unified\=_125028, nb_setarg(1, retval(unified), unified))))), user:ignore((_124898==1->ignore(\+ \+ (flag(eval_num, _153226, _153226+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _153226, <--, [e, unified]);indentq(1, _153226, <--, [e, retval(unified)]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _153226, _153226+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _153226, <--, [e, unified]);indentq(1, _153226, <--, [e, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] trace_eval(eval_20(=, _108324), e, 498, '&self', ['if-unify-or-empty', _5640, _5640], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] self_eval(unified)
^  <span class="ansi1 ansi32"
>Call: </span>(271) [system] setup_call_cleanup('$notrace'(_845170, _845172), once(user:self_eval0(unified)), '$restore_trace'(_845170, _845172))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] sig_atomic(system:'$notrace'(_845170, _845172))
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(unified)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] self_eval(unified)
   <span class="ansi1 ansi32"
>Call: </span>(269) [system] _91846=unified
   <span class="ansi1 ansi32"
>Exit: </span>(269) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [user] eval_01(=, _108324, 499, '&self', ['if-unify-or-empty', _5640, _5640], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [user] eval_00(=, _108324, 499, '&self', ['if-unify-or-empty', _5640, _5640], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] eval_args(=, _108324, 499, '&self', ['if-unify-or-empty', _5640, _5640], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_855488, _855490), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _855446, fbug((_855446-->if_trace(case, writeqln(switch=unified))))))), '$restore_trace'(_855488, _855490))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_855488, _855490))
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _855446, fbug((_855446-->if_trace(case, writeqln(switch=unified))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] select_case(499, '&self', unified, ['Empty'-_5658], _859684)
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] best_key(unified, ['Empty'-_5658], _859684)
   <span class="ansi1 ansi32"
>Call: </span>(268) [lists] lists:member(_861736-_859684, ['Empty'-_5658])
   <span class="ansi1 ansi32"
>Call: </span>(269) [lists] lists:member_([], _861736-_859684, 'Empty'-_5658)
   <span class="ansi1 ansi32"
>Exit: </span>(269) [lists] lists:member_([], 'Empty'-_5658, 'Empty'-_5658)
   <span class="ansi1 ansi32"
>Exit: </span>(268) [lists] lists:member('Empty'-_5658, ['Empty'-_5658])
   <span class="ansi1 ansi32"
>Call: </span>(268) [system] unified='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(268) [lists] lists:member(_866830-_859684, ['Empty'-_5658])
   <span class="ansi1 ansi32"
>Call: </span>(269) [lists] lists:member_([], _866830-_859684, 'Empty'-_5658)
   <span class="ansi1 ansi32"
>Exit: </span>(269) [lists] lists:member_([], 'Empty'-_5658, 'Empty'-_5658)
   <span class="ansi1 ansi32"
>Exit: </span>(268) [lists] lists:member('Empty'-_5658, ['Empty'-_5658])
   <span class="ansi1 ansi32"
>Call: </span>(268) [system] unified=='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(268) [lists] lists:member(_871924-_859684, ['Empty'-_5658])
   <span class="ansi1 ansi32"
>Call: </span>(269) [lists] lists:member_([], _871924-_859684, 'Empty'-_5658)
   <span class="ansi1 ansi32"
>Exit: </span>(269) [lists] lists:member_([], 'Empty'-_5658, 'Empty'-_5658)
   <span class="ansi1 ansi32"
>Exit: </span>(268) [lists] lists:member('Empty'-_5658, ['Empty'-_5658])
   <span class="ansi1 ansi32"
>Call: </span>(268) [system] unified=@='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(268) [lists] lists:member(_877018-_859684, ['Empty'-_5658])
   <span class="ansi1 ansi32"
>Call: </span>(269) [lists] lists:member_([], _877018-_859684, 'Empty'-_5658)
   <span class="ansi1 ansi32"
>Exit: </span>(269) [lists] lists:member_([], 'Empty'-_5658, 'Empty'-_5658)
   <span class="ansi1 ansi32"
>Exit: </span>(268) [lists] lists:member('Empty'-_5658, ['Empty'-_5658])
   <span class="ansi1 ansi32"
>Call: </span>(268) [system] unified='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] maybe_special_keys(499, '&self', ['Empty'-_5658], _882110)
^  <span class="ansi1 ansi32"
>Call: </span>(268) [user] eval_args(499, '&self', 'Empty', _883144)
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] eval_args(=, _884296, 499, '&self', 'Empty', _883144)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] var('Empty')
^  <span class="ansi1 ansi32"
>Call: </span>(271) [system] setup_call_cleanup('$notrace'(_886228, _886230), once(user:self_eval('Empty')), '$restore_trace'(_886228, _886230))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] sig_atomic(system:'$notrace'(_886228, _886230))
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval('Empty')), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] _883144='Empty'
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] 'Empty'='Empty'
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] eval_args(=, _891530, 499, '&self', 'Empty', 'Empty')
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [user] eval_args(499, '&self', 'Empty', 'Empty')
   <span class="ansi1 ansi32"
>Call: </span>(268) [system] 'Empty'\=@='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(268) [user] maybe_special_keys(499, '&self', [], _882110)
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [user] maybe_special_keys(499, '&self', [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [user] maybe_special_keys(499, '&self', ['Empty'-_5658], [])
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] best_key(unified, [], _859684)
   <span class="ansi1 ansi32"
>Call: </span>(268) [lists] lists:member(_898572-_859684, [])
   <span class="ansi1 ansi32"
>Call: </span>(268) [lists] lists:member(_899594-_859684, [])
   <span class="ansi1 ansi32"
>Call: </span>(268) [lists] lists:member(_900616-_859684, [])
   <span class="ansi1 ansi32"
>Call: </span>(268) [lists] lists:member(_901638-_859684, [])
   <span class="ansi1 ansi32"
>Call: </span>(267) [lists] lists:member(_902660-_859684, [])
   <span class="ansi1 ansi32"
>Call: </span>(266) [lists] lists:member(_903682-_903684, ['Empty'-_5658])
   <span class="ansi1 ansi32"
>Call: </span>(267) [lists] lists:member_([], _903682-_903684, 'Empty'-_5658)
   <span class="ansi1 ansi32"
>Exit: </span>(267) [lists] lists:member_([], 'Empty'-_5658, 'Empty'-_5658)
   <span class="ansi1 ansi32"
>Exit: </span>(266) [lists] lists:member('Empty'-_5658, ['Empty'-_5658])
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] 'Empty'=='%void%'
   <span class="ansi1 ansi32"
>Call: </span>(290) [lists] lists:member_([], (_782546->_782548), (['if-unify-or-empty', _772068, _772074]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(290) [lists] lists:member_([], (['if-unify-or-empty', _772068, _772074]->[empty]), (['if-unify-or-empty', _772068, _772074]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(289) [lists] lists:member_([(['if-unify-or-empty', _772068, _772074]->[empty])], (['if-unify-or-empty', _772068, _772074]->[empty]), (['if-unify-or-empty', _772104, _772104]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(288) [lists] lists:member((['if-unify-or-empty', _772068, _772074]->[empty]), [(['if-unify-or-empty', _772104, _772104]->unified), (['if-unify-or-empty', _772068, _772074]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] copy_term((['if-unify-or-empty', _772068, _772074]->[empty]), _782560)
   <span class="ansi1 ansi32"
>Exit: </span>(288) [system] copy_term((['if-unify-or-empty', _772068, _772074]->[empty]), (['if-unify-or-empty', _913882, _913888]->[empty]))
^  <span class="ansi1 ansi32"
>Call: </span>(288) [user] eval_defn_success(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], _258442, ['if-unify-or-empty', _772068, _772074], [empty], (['if-unify-or-empty', _913882, _913888]->[empty]))
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] ['if-unify-or-empty', _5640, _5640]=['if-unify-or-empty', _772068, _772074]
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] ['if-unify-or-empty', _5640, _5640]=['if-unify-or-empty', _5640, _5640]
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] _258442=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] [empty]=[empty]
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] ['if-unify-or-empty', _5640, _5640]\=@=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] ['if-unify-or-empty', _5640, _5640]\=@=[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(289) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _913882, _913888]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] setup_call_cleanup('$notrace'(_923130, _923132), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _913882, _913888]->[empty])))))), _923088, fbug((_923088-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _913882, _913888]->[empty])))))))))), '$restore_trace'(_923130, _923132))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] sig_atomic(system:'$notrace'(_923130, _923132))
^  <span class="ansi1 ansi32"
>Exit: </span>(291) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _913882, _913888]->[empty])))))), _923088, fbug((_923088-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _913882, _913888]->[empty])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(289) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _913882, _913888]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(289) [user] light_eval(=, _108324, 498, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(289) [user] light_eval(=, _108324, 498, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(288) [user] eval_defn_success(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty], ['if-unify-or-empty', _5640, _5640], [empty], (['if-unify-or-empty', _913882, _913888]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(286) [user] if_or_else((member((['if-unify-or-empty', _5640, _5640]->[empty]), [(['if-unify-or-empty', _772104, _772104]->unified), (['if-unify-or-empty', _5640, _5640]->[empty])]), copy_term((['if-unify-or-empty', _5640, _5640]->[empty]), (['if-unify-or-empty', _913882, _913888]->[empty])), eval_defn_success(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty], ['if-unify-or-empty', _5640, _5640], [empty], (['if-unify-or-empty', _913882, _913888]->[empty]))), eval_defn_failure(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty]))
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [user] eval_defn_bodies(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty], [(['if-unify-or-empty', _772104, _772104]->unified), (['if-unify-or-empty', _5640, _5640]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [user] eval_defn_choose_candidates(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(284) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] ignore(notrace((\+[empty]\=_606184, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [system] setup_call_cleanup('$notrace'(_936586, _936588), once(user:(\+[empty]\=_606184, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_936586, _936588))
^  <span class="ansi1 ansi32"
>Call: </span>(287) [system] sig_atomic(system:'$notrace'(_936586, _936588))
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_606184, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [system] ignore(user:notrace((\+[empty]\=_606184, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] ignore((_606054==1->ignore(\+ \+ (flag(eval_num, _634382, _634382+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _634382, <--, [defn, [empty]]);indentq(1, _634382, <--, [defn, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _634382, _634382+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _634382, <--, [defn, [empty]]);indentq(1, _634382, <--, [defn, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] _606054==1
   <span class="ansi1 ansi31"
>Fail: </span>(286) [system] _606054==1
^  <span class="ansi1 ansi32"
>Call: </span>(287) [system] setup_call_cleanup('$notrace'(_943778, _943780), once(user:ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _634382, _634382+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _634382, <--, [defn, [empty]]);indentq(1, _634382, <--, [defn, retval([empty])])))))))), '$restore_trace'(_943778, _943780))
^  <span class="ansi1 ansi32"
>Call: </span>(288) [system] sig_atomic(system:'$notrace'(_943778, _943780))
^  <span class="ansi1 ansi32"
>Exit: </span>(287) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _634382, _634382+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _634382, <--, [defn, [empty]]);indentq(1, _634382, <--, [defn, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [system] ignore(user:(_606054==1->ignore(\+ \+ (flag(eval_num, _634382, _634382+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _634382, <--, [defn, [empty]]);indentq(1, _634382, <--, [defn, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _634382, _634382+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _634382, <--, [defn, [empty]]);indentq(1, _634382, <--, [defn, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _108324), 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_defn_choose_candidates(=, _108324), 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty])), ignore(notrace((\+[empty]\=_606184, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_606054==1->ignore(\+ \+ (flag(eval_num, _634382, _634382+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _634382, <--, [defn, [empty]]);indentq(1, _634382, <--, [defn, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _634382, _634382+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _634382, <--, [defn, [empty]]);indentq(1, _634382, <--, [defn, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [user] trace_eval(eval_defn_choose_candidates(=, _108324), defn, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(280) [user] eval_maybe_defn(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(279) [user] if_or_else(eval_maybe_defn(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty]), eval_maybe_subst(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(278) [user] if_or_else(eval_maybe_host_function(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty]), if_or_else(eval_maybe_defn(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty]), eval_maybe_subst(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty])))
   <span class="ansi1 ansi32"
>Exit: </span>(277) [user] if_or_else(eval_maybe_host_predicate(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty]), if_or_else(eval_maybe_host_function(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty]), if_or_else(eval_maybe_defn(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty]), eval_maybe_subst(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty]))))
   <span class="ansi1 ansi32"
>Exit: </span>(276) [user] if_or_else(eval_maybe_python(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty]), if_or_else(eval_maybe_host_predicate(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty]), if_or_else(eval_maybe_host_function(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty]), if_or_else(eval_maybe_defn(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty]), eval_maybe_subst(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty])))))
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] eval_70(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] check_returnval(=, _108324, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] check_returnval(=, _108324, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [user] eval_41(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(273) [user] eval_40(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] [empty]=_123784
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] [empty]=[empty]
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] eval_20(=, _108324, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(272) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(272) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] ignore(notrace((\+[empty]\=_125028, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [system] setup_call_cleanup('$notrace'(_968482, _968484), once(user:(\+[empty]\=_125028, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_968482, _968484))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] sig_atomic(system:'$notrace'(_968482, _968484))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_125028, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [system] ignore(user:notrace((\+[empty]\=_125028, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] ignore((_124898==1->ignore(\+ \+ (flag(eval_num, _153226, _153226+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _153226, <--, [e, [empty]]);indentq(1, _153226, <--, [e, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _153226, _153226+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _153226, <--, [e, [empty]]);indentq(1, _153226, <--, [e, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] _124898==1
   <span class="ansi1 ansi31"
>Fail: </span>(274) [system] _124898==1
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] setup_call_cleanup('$notrace'(_975674, _975676), once(user:ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _153226, _153226+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _153226, <--, [e, [empty]]);indentq(1, _153226, <--, [e, retval([empty])])))))))), '$restore_trace'(_975674, _975676))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [system] sig_atomic(system:'$notrace'(_975674, _975676))
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _153226, _153226+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _153226, <--, [e, [empty]]);indentq(1, _153226, <--, [e, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [system] ignore(user:(_124898==1->ignore(\+ \+ (flag(eval_num, _153226, _153226+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _153226, <--, [e, [empty]]);indentq(1, _153226, <--, [e, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _153226, _153226+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _153226, <--, [e, [empty]]);indentq(1, _153226, <--, [e, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [system] call_cleanup(user:((call(eval_20(=, _108324), 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_20(=, _108324), 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty])), ignore(notrace((\+[empty]\=_125028, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_124898==1->ignore(\+ \+ (flag(eval_num, _153226, _153226+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _153226, <--, [e, [empty]]);indentq(1, _153226, <--, [e, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _153226, _153226+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _153226, <--, [e, [empty]]);indentq(1, _153226, <--, [e, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] trace_eval(eval_20(=, _108324), e, 498, '&self', ['if-unify-or-empty', _5640, _5640], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(271) [system] setup_call_cleanup('$notrace'(_985074, _985076), once(user:self_eval0([empty])), '$restore_trace'(_985074, _985076))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] sig_atomic(system:'$notrace'(_985074, _985076))
^  <span class="ansi1 ansi31"
>Fail: </span>(269) [user] self_eval([empty])
   <span class="ansi1 ansi32"
>Call: </span>(269) [system] [empty]=@=['if-unify-or-empty', _122742, _122742]
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] eval_01(=, _108324, 498, '&self', [empty], _989178)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] [empty]\==[empty]
   <span class="ansi1 ansi32"
>Call: </span>(266) [lists] lists:member(_991236-_991238, ['Empty'-_5658])
   <span class="ansi1 ansi32"
>Call: </span>(267) [lists] lists:member_([], _991236-_991238, 'Empty'-_5658)
   <span class="ansi1 ansi32"
>Exit: </span>(267) [lists] lists:member_([], 'Empty'-_5658, 'Empty'-_5658)
   <span class="ansi1 ansi32"
>Exit: </span>(266) [lists] lists:member('Empty'-_5658, ['Empty'-_5658])
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi31"
>Fail: </span>(264) [user] eval_20(=, _6910, 499, '&self', [case, ['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]], _7012)
   <span class="ansi1 ansi32"
>Call: </span>(264) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(264) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(264) [user] ignore((_7020==1->ignore(\+ \+ (flag(eval_num, _7058, _7058+1), (retval(fail)\=@=retval(fail), nonvar(_7012)->indentq(0, _7058, <--, [e, _7012]);indentq(0, _7058, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _7058, _7058+1), (retval(fail)\=@=retval(fail), nonvar(_7012)->indentq(0, _7058, <--, [e, _7012]);indentq(0, _7058, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] _7020==1
   <span class="ansi1 ansi31"
>Fail: </span>(266) [system] _7020==1
^  <span class="ansi1 ansi32"
>Call: </span>(267) [system] setup_call_cleanup('$notrace'(_1002432, _1002434), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _7058, _7058+1), (retval(fail)\=@=retval(fail), nonvar(_7012)->indentq(0, _7058, <--, [e, _7012]);indentq(0, _7058, <--, [e, retval(fail)])))))))), '$restore_trace'(_1002432, _1002434))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] sig_atomic(system:'$notrace'(_1002432, _1002434))
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _7058, _7058+1), (retval(fail)\=@=retval(fail), nonvar(_7012)->indentq(0, _7058, <--, [e, _7012]);indentq(0, _7058, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(264) [system] ignore(user:(_7020==1->ignore(\+ \+ (flag(eval_num, _7058, _7058+1), (retval(fail)\=@=retval(fail), nonvar(_7012)->indentq(0, _7058, <--, [e, _7012]);indentq(0, _7058, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _7058, _7058+1), (retval(fail)\=@=retval(fail), nonvar(_7012)->indentq(0, _7058, <--, [e, _7012]);indentq(0, _7058, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(262) [system] call_cleanup(user:((call(eval_20(=, _6910), 499, '&self', [case, ['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]], _7012)*->nb_setarg(1, retval(fail), _7012);fail, trace, call(eval_20(=, _6910), 499, '&self', [case, ['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]], _7012)), ignore(notrace((\+_7012\=_7028, nb_setarg(1, retval(fail), _7012))))), user:ignore((_7020==1->ignore(\+ \+ (flag(eval_num, _7058, _7058+1), (retval(fail)\=@=retval(fail), nonvar(_7012)->indentq(0, _7058, <--, [e, _7012]);indentq(0, _7058, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _7058, _7058+1), (retval(fail)\=@=retval(fail), nonvar(_7012)->indentq(0, _7058, <--, [e, _7012]);indentq(0, _7058, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(261) [user] trace_eval(eval_20(=, _6910), e, 499, '&self', [case, ['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]], _7012)
^  <span class="ansi1 ansi31"
>Fail: </span>(258) [user] eval_args(=, _6910, 500, '&self', [case, ['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]], _6362)
^  <span class="ansi1 ansi31"
>Fail: </span>(249) [system] call(user:once, user:if_or_else(eval(=, _6342, 498, '&self', [case, ['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]], _6362), call(eval, [case, ['if-unify-or-empty', _5640, _5640], [['Empty', _5658]]], _6362)))
^  <span class="ansi1 ansi32"
>Call: </span>(249) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(251) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(251) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(253) [system] setup_call_cleanup('$notrace'(_1013894, _1013896), once(rtrace:retract(t_l:tracer_reset(_1013884))), '$restore_trace'(_1013894, _1013896))
^  <span class="ansi1 ansi32"
>Call: </span>(254) [system] sig_atomic(system:'$notrace'(_1013894, _1013896))
^  <span class="ansi1 ansi32"
>Exit: </span>(253) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(253) [rtrace] tAt(false, 271, 271, false)

NDet Result(147): <span class="ansi33"
>Empty
</span>
NDet Result(148): <span class="ansi33"
>(iz if-unify-or-empty MinimalMeTTaHelper)
</span>
NDet Result(149): <span class="ansi33"
>(@doc if-unify-or-empty (@desc "Attempts to unify two atoms and returns a result. Returns Empty if they cannot be unified.") (@params ((@param "First atom") (@param "Second atom"))) (@return "Unification result or Empty"))
</span>
NDet Result(150): <span class="ansi33"
>(: if-unify-or-empty (-> Atom Atom Atom))
</span>
NDet Result(151): <span class="ansi33"
>(= (if-unify-or-empty $10000 $10000)  unified)
</span>
NDet Result(152): <span class="ansi33"
>(= (if-unify-or-empty $10000 $10001)  
  (empty))
</span>
NDet Result(153): <span class="ansi33"
>(iz cons-atom MinimalMeTTa)
</span>
NDet Result(154): <span class="ansi33"
>(@doc cons-atom (@desc "Constructs an expression using two arguments") (@params ((@param "Head of an expression") (@param "Tail of an expression"))) (@return "New expression consisting of the two input arguments"))
</span>
NDet Result(155): <span class="ansi33"
>(: cons-atom (-> Atom Expression Expression))
</span>
NDet Result(156): <span class="ansi33"
>(iz decons-atom MinimalMeTTa)
</span>
NDet Result(157): <span class="ansi33"
>(@doc decons-atom (@desc "Works as a reverse to cons-atom function. It gets Expression as an input and returns it split into head and tail, e.g. (decons-atom (Cons X Nil)) -> (Cons (X Nil))") (@params ((@param "Expression to be Deconsed"))) (@return "Deconsed expression"))
</span>
NDet Result(158): <span class="ansi33"
>(: decons-atom (-> Expression Expression))
</span>
NDet Result(159): <span class="ansi33"
>(iz min-atom MeTTa)
</span>
NDet Result(160): <span class="ansi33"
>(@doc min-atom (@desc "Returns atom with minimum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Minimum value in the expression. Error if expression contains non-numeric value or is empty."))
</span>
NDet Result(161): <span class="ansi33"
>(: min-atom (-> Expression Number))
</span>
NDet Result(162): <span class="ansi33"
>(= (min-atom $10000)  
  (call-fn! min_list $10000))
</span>
NDet Result(163): <span class="ansi33"
>(iz max-atom MeTTa)
</span>
NDet Result(164): <span class="ansi33"
>(@doc max-atom (@desc "Returns atom with maximum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Maximum value in the expression. Error if expression contains non-numeric value or is empty."))
</span>
NDet Result(165): <span class="ansi33"
>(: max-atom (-> Expression Number))
</span>
NDet Result(166): <span class="ansi33"
>(is-fn-1 max-atom max_list)
</span>
NDet Result(167): <span class="ansi33"
>(iz size-atom MeTTa)
</span>
NDet Result(168): <span class="ansi33"
>(@doc size-atom (@desc "Returns the size of an expression (first argument).") (@params ((@param "Expression to measure the size of"))) (@return "Size of the expression"))
</span>
NDet Result(169): <span class="ansi33"
>(: size-atom (-> Expression Integer))
</span>
NDet Result(170): <span class="ansi33"
>(is-fn-1 size-atom length)
</span>
NDet Result(171): <span class="ansi33"
>(iz index-atom MeTTa)
</span>
NDet Result(172): <span class="ansi33"
>(@doc index-atom (@desc "Returns atom from an expression (first argument) using index (second argument) or error if index is out of bounds.") (@params ((@param "Expression") (@param "Index"))) (@return "Atom at the specified index in the expression. Error if index is out of bounds."))
</span>
NDet Result(173): <span class="ansi33"
>(: index-atom (-> Expression Number Atom))
</span>
NDet Result(174): <span class="ansi33"
>(is-fn-21 index-atom nth0)
</span>
NDet Result(175): <span class="ansi33"
>(iz powi MeTTa)
</span>
NDet Result(176): <span class="ansi33"
>(@doc powi (@desc "Takes base (first argument) and power (second argument) and returns the result of raising the base to the power.") (@params ((@param "Base. Could be a float.") (@param "Power. Must be an integer."))) (@return "Result of base raised to the power"))
</span>
NDet Result(177): <span class="ansi33"
>(= (powi $10000 $10001)  
  (call-fn! pow $10000 $10001))
</span>
NDet Result(178): <span class="ansi33"
>(==> (is-op-1 $10000 $10001) (is-fn-1 $10000 $10001))
</span>```
```metta
*/

<span class="ansi38-013099040"
>!(assertEqual (match &self $1 $1) (get-atoms &self))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.13"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.13</h3>

#(failed #( : user once ) #( : user #(if_or_else #(eval = $10000 497 &self (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003) #(call eval (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003)) ))


#(on_mettalog_error #(failed #( : user once ) #( : user #(if_or_else #(eval = $10000 497 &self (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003) #(call eval (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003)) )))

^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] call(user:once, user:if_or_else(eval(=, _601240, 497, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498), call(eval, [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498)))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] once(user:if_or_else(eval(=, _601240, 497, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498), call(eval, [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498)))
   <span class="ansi1 ansi32"
>Call: </span>(285) [user] if_or_else(eval(=, _601240, 497, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498), call(eval, [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] eval(=, _601240, 497, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498)
^  <span class="ansi1 ansi32"
>Call: </span>(287) [user] catch_metta_return(eval_args(=, _601240, 497, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498), _604498)
^  <span class="ansi1 ansi32"
>Call: </span>(289) [user] eval_args(=, _601240, 497, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498)
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] var([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] setup_call_cleanup('$notrace'(_623364, _623366), once(user:self_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])), '$restore_trace'(_623364, _623366))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] sig_atomic(system:'$notrace'(_623364, _623366))
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] setup_call_cleanup('$notrace'(_625452, _625454), once(user:nonvar(_604498)), '$restore_trace'(_625452, _625454))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] sig_atomic(system:'$notrace'(_625452, _625454))
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] setup_call_cleanup('$notrace'(_627540, _627542), once(user:nonvar(_604498)), '$restore_trace'(_627540, _627542))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] sig_atomic(system:'$notrace'(_627540, _627542))
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] [['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(290) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] self_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] setup_call_cleanup('$notrace'(_634696, _634698), once(user:self_eval0([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])), '$restore_trace'(_634696, _634698))
^  <span class="ansi1 ansi32"
>Call: </span>(293) [system] sig_atomic(system:'$notrace'(_634696, _634698))
^  <span class="ansi1 ansi31"
>Fail: </span>(290) [user] self_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] eval_00(=, _601240, 497, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498)
^  <span class="ansi1 ansi32"
>Call: </span>(291) [user] self_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Call: </span>(293) [system] setup_call_cleanup('$notrace'(_639840, _639842), once(user:self_eval0([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])), '$restore_trace'(_639840, _639842))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] sig_atomic(system:'$notrace'(_639840, _639842))
^  <span class="ansi1 ansi31"
>Fail: </span>(291) [user] self_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Call: </span>(291) [user] eval_01(=, _601240, 497, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498)
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(292) [system] [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] if_t((497<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] 497<1
   <span class="ansi1 ansi31"
>Fail: </span>(294) [system] 497<1
^  <span class="ansi1 ansi32"
>Exit: </span>(292) [user] if_t((497<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(293) [system] setup_call_cleanup('$notrace'(_650114, _650116), once(user:(_650090 is 497-1, copy_term([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _650104))), '$restore_trace'(_650114, _650116))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] sig_atomic(system:'$notrace'(_650114, _650116))
^  <span class="ansi1 ansi32"
>Exit: </span>(293) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(496 is 497-1, copy_term([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], [case, ['if-unify-or-empty', _652212, _652212], [['Empty', _652242]]]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] trace_eval(eval_20(=, _601240), e, 496, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _653278)
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] must_det_ll((notrace((flag(eval_num, _654332, _654332+1), _654350 is _654332 mod 500, _654368 is 99-496 mod 100, _654392=_654394, option_else('trace-length', _654406, 500), option_else('trace-depth', _654414, 30))), quietly(if_t((nop(stop_rtrace), _654350>_654406), (set_debug(eval, false), _654470 is _654406+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_654470])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_654522)))))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] once(user:(notrace((flag(eval_num, _654332, _654332+1), _654350 is _654332 mod 500, _654368 is 99-496 mod 100, _654392=_654394, option_else('trace-length', _654406, 500), option_else('trace-depth', _654414, 30))), quietly(if_t((nop(stop_rtrace), _654350>_654406), (set_debug(eval, false), _654470 is _654406+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_654470])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_654522)))))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [system] setup_call_cleanup('$notrace'(_656568, _656570), once(user:(flag(eval_num, _654332, _654332+1), _654350 is _654332 mod 500, _654368 is 99-496 mod 100, _654392=_654394, option_else('trace-length', _654406, 500), option_else('trace-depth', _654414, 30))), '$restore_trace'(_656568, _656570))
^  <span class="ansi1 ansi32"
>Call: </span>(298) [system] sig_atomic(system:'$notrace'(_656568, _656570))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 1320, 1320+1), 320 is 1320 mod 500, 3 is 99-496 mod 100, _654392=_654392, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 320>500), (set_debug(eval, false), _654470 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_654470])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 320>500), (set_debug(eval, false), _654470 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_654470])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(296) [user] nop(notrace(no_repeats_var(_654522)))
   <span class="ansi1 ansi32"
>Exit: </span>(296) [user] nop(notrace(no_repeats_var(_654522)))
^  <span class="ansi1 ansi32"
>Exit: </span>(294) [system] once(user:(notrace((flag(eval_num, 1320, 1320+1), 320 is 1320 mod 500, 3 is 99-496 mod 100, _654392=_654392, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 320>500), (set_debug(eval, false), _654470 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_654470])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_654522)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(293) [user] must_det_ll(user:(notrace((flag(eval_num, 1320, 1320+1), 320 is 1320 mod 500, 3 is 99-496 mod 100, _654392=_654392, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 320>500), (set_debug(eval, false), _654470 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_654470])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_654522)))))
   <span class="ansi1 ansi32"
>Call: </span>(293) [occurs] occurs:sub_term(_666220, e)
   <span class="ansi1 ansi32"
>Exit: </span>(293) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(293) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(294) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(293) [occurs] occurs:sub_term(_666220, e)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] _673326=e
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] if_trace((eval;e), (_654392=1, indentq(3, 320, -->, [e, [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] setup_call_cleanup('$notrace'(_676466, _676468), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _654392=1, indentq(3, 320, -->, [e, [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]]))), _676424, fbug((_676424-->if_trace((eval;e), (_654392=1, indentq(3, 320, -->, [e, [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]])))))))), '$restore_trace'(_676466, _676468))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [system] sig_atomic(system:'$notrace'(_676466, _676468))
^  <span class="ansi1 ansi32"
>Exit: </span>(295) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _654392=1, indentq(3, 320, -->, [e, [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]]))), _676424, fbug((_676424-->if_trace((eval;e), (_654392=1, indentq(3, 320, -->, [e, [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(293) [user] if_trace((eval;e), (_654392=1, indentq(3, 320, -->, [e, [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]])))
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] _680662=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] _682700=(\+ \+ (flag(eval_num, _682720, _682720+1), (retval(fail)\=@=retval(fail), nonvar(_653278)->indentq(3, _682720, <--, [e, _653278]);indentq(3, _682720, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] (\+ \+ (flag(eval_num, _682720, _682720+1), (retval(fail)\=@=retval(fail), nonvar(_653278)->indentq(3, _682720, <--, [e, _653278]);indentq(3, _682720, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _682720, _682720+1), (retval(fail)\=@=retval(fail), nonvar(_653278)->indentq(3, _682720, <--, [e, _653278]);indentq(3, _682720, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] call_cleanup(((call(eval_20(=, _601240), 496, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _653278)*->nb_setarg(1, retval(fail), _653278);fail, trace, call(eval_20(=, _601240), 496, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _653278)), ignore(notrace((\+_653278\=_654522, nb_setarg(1, retval(fail), _653278))))), ignore((_654392==1->ignore(\+ \+ (flag(eval_num, _682720, _682720+1), (retval(fail)\=@=retval(fail), nonvar(_653278)->indentq(3, _682720, <--, [e, _653278]);indentq(3, _682720, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _682720, _682720+1), (retval(fail)\=@=retval(fail), nonvar(_653278)->indentq(3, _682720, <--, [e, _653278]);indentq(3, _682720, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] eval_20(=, _601240, 496, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _653278)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] atom([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] no_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] self_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_690108, _690110), once(user:self_eval0([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])), '$restore_trace'(_690108, _690110))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_690108, _690110))
^  <span class="ansi1 ansi31"
>Fail: </span>(297) [user] self_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] atomic(case)
   <span class="ansi1 ansi32"
>Exit: </span>(297) [system] atomic(case)
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] is_sl(case)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] number(case)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] [['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] callable(case)
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] callable(case)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] [['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] is_list([['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] is_list([['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] is_list(case)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] is_list([['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] is_list([['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] is_list([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] is_list([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] once(expand_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _712452))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] expand_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _712452)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] is_list([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
   <span class="ansi1 ansi32"
>Exit: </span>(298) [system] is_list([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] ground(case)
   <span class="ansi1 ansi32"
>Exit: </span>(298) [system] ground(case)
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] apply:maplist(expand_eval, [['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _718552)
   <span class="ansi1 ansi32"
>Call: </span>(299) [apply] apply:maplist_([['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _718552, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] expand_eval(['if-unify-or-empty', _591556, _591556], _720608)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] is_list(['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] is_list(['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] apply:maplist(expand_eval, [_591556, _591556], _725686)
   <span class="ansi1 ansi32"
>Call: </span>(302) [apply] apply:maplist_([_591556, _591556], _725686, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] expand_eval(_591556, _727742)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list(_591556)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _591556=_727742
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] _591556=_591556
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] expand_eval(_591556, _591556)
   <span class="ansi1 ansi32"
>Call: </span>(303) [apply] apply:maplist_([_591556], _727744, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] expand_eval(_591556, _733844)
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] is_list(_591556)
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] _591556=_733844
   <span class="ansi1 ansi32"
>Exit: </span>(305) [system] _591556=_591556
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] expand_eval(_591556, _591556)
   <span class="ansi1 ansi32"
>Call: </span>(304) [apply] apply:maplist_([], _733846, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [apply] apply:maplist_([_591556], [_591556], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [apply] apply:maplist_([_591556, _591556], [_591556, _591556], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [apply] apply:maplist(user:expand_eval, [_591556, _591556], [_591556, _591556])
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] expand_eval(['if-unify-or-empty', _591556, _591556], ['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Call: </span>(300) [apply] apply:maplist_([[['Empty', _591574]]], _720610, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] expand_eval([['Empty', _591574]], _746068)
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] is_list([['Empty', _591574]])
   <span class="ansi1 ansi32"
>Exit: </span>(302) [system] is_list([['Empty', _591574]])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] ground(['Empty', _591574])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] apply:maplist(expand_eval, [], _749116)
   <span class="ansi1 ansi32"
>Call: </span>(303) [apply] apply:maplist_([], _749116, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [apply] apply:maplist_([], [], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [apply] apply:maplist(user:expand_eval, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] expand_eval([['Empty', _591574]], [['Empty', _591574]])
   <span class="ansi1 ansi32"
>Call: </span>(301) [apply] apply:maplist_([], _746070, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [apply] apply:maplist_([[['Empty', _591574]]], [[['Empty', _591574]]], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [apply] apply:maplist_([['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], [['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [apply] apply:maplist(user:expand_eval, [['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], [['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] expand_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [system] once(user:expand_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]))
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]\==[case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] is_progn(case)
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] is_space_op(case)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] must_det_ll([]==[])
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] once(user:([]==[]))
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(298) [system] []==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [system] once(user:([]==[]))
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] must_det_ll(user:([]==[]))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] into_case_list([['Empty', _591574]], _774560)
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] is_list([['Empty', _591574]])
   <span class="ansi1 ansi32"
>Exit: </span>(297) [system] is_list([['Empty', _591574]])
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] into_case_list([['Empty', _591574]], [['Empty', _591574]])
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] into_case_keys(1, [['Empty', _591574]], _778618)
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] _779658 is 1+1
   <span class="ansi1 ansi32"
>Exit: </span>(297) [system] 2 is 1+1
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] is_case(_779648, ['Empty', _591574], _779650)
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] is_case('Empty', ['Empty', _591574], _591574)
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_591574)))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_784824, _784826), once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_591574))), _784782, fbug((_784782-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_591574)))))))), '$restore_trace'(_784824, _784826))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_784824, _784826))
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_591574))), _784782, fbug((_784782-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_591574)))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_591574)))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] into_case_keys(2, [], _779644)
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] into_case_keys(2, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] into_case_keys(1, [['Empty', _591574]], ['Empty'-_591574])
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] eval_case(=, _601240, 496, '&self', ['if-unify-or-empty', _591556, _591556], ['Empty'-_591574], _653278)
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _591556, _591556]))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_794192, _794194), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _591556, _591556]))), _794150, fbug((_794150-->if_trace(case, writeqln(case=['if-unify-or-empty', _591556, _591556]))))))), '$restore_trace'(_794192, _794194))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_794192, _794194))
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _591556, _591556]))), _794150, fbug((_794150-->if_trace(case, writeqln(case=['if-unify-or-empty', _591556, _591556]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _591556, _591556]))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] eval_args(=, _798514, 496, '&self', ['if-unify-or-empty', _591556, _591556], _798388)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] var(['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_800446, _800448), once(user:self_eval(['if-unify-or-empty', _591556, _591556])), '$restore_trace'(_800446, _800448))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_800446, _800448))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_802534, _802536), once(user:nonvar(_798388)), '$restore_trace'(_802534, _802536))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_802534, _802536))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_804622, _804624), once(user:nonvar(_798388)), '$restore_trace'(_804622, _804624))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_804622, _804624))
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] [_591556, _591556]==[]
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(298) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] self_eval(['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] setup_call_cleanup('$notrace'(_811778, _811780), once(user:self_eval0(['if-unify-or-empty', _591556, _591556])), '$restore_trace'(_811778, _811780))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] sig_atomic(system:'$notrace'(_811778, _811780))
^  <span class="ansi1 ansi31"
>Fail: </span>(298) [user] self_eval(['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] eval_00(=, _814866, 496, '&self', ['if-unify-or-empty', _591556, _591556], _798388)
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] self_eval(['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] setup_call_cleanup('$notrace'(_816924, _816926), once(user:self_eval0(['if-unify-or-empty', _591556, _591556])), '$restore_trace'(_816924, _816926))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] sig_atomic(system:'$notrace'(_816924, _816926))
^  <span class="ansi1 ansi31"
>Fail: </span>(299) [user] self_eval(['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] eval_01(=, _814866, 496, '&self', ['if-unify-or-empty', _591556, _591556], _798388)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] ['if-unify-or-empty', _591556, _591556]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] ['if-unify-or-empty', _591556, _591556]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] if_t((496<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] 496<1
   <span class="ansi1 ansi31"
>Fail: </span>(302) [system] 496<1
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] if_t((496<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] setup_call_cleanup('$notrace'(_827198, _827200), once(user:(_827174 is 496-1, copy_term(['if-unify-or-empty', _591556, _591556], _827188))), '$restore_trace'(_827198, _827200))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] sig_atomic(system:'$notrace'(_827198, _827200))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(495 is 496-1, copy_term(['if-unify-or-empty', _591556, _591556], ['if-unify-or-empty', _829284, _829284]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] trace_eval(eval_20(=, _814866), e, 495, '&self', ['if-unify-or-empty', _591556, _591556], _830326)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] must_det_ll((notrace((flag(eval_num, _831380, _831380+1), _831398 is _831380 mod 500, _831416 is 99-495 mod 100, _831440=_831442, option_else('trace-length', _831454, 500), option_else('trace-depth', _831462, 30))), quietly(if_t((nop(stop_rtrace), _831398>_831454), (set_debug(eval, false), _831518 is _831454+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_831518])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_831570)))))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] once(user:(notrace((flag(eval_num, _831380, _831380+1), _831398 is _831380 mod 500, _831416 is 99-495 mod 100, _831440=_831442, option_else('trace-length', _831454, 500), option_else('trace-depth', _831462, 30))), quietly(if_t((nop(stop_rtrace), _831398>_831454), (set_debug(eval, false), _831518 is _831454+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_831518])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_831570)))))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_833616, _833618), once(user:(flag(eval_num, _831380, _831380+1), _831398 is _831380 mod 500, _831416 is 99-495 mod 100, _831440=_831442, option_else('trace-length', _831454, 500), option_else('trace-depth', _831462, 30))), '$restore_trace'(_833616, _833618))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_833616, _833618))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 1321, 1321+1), 321 is 1321 mod 500, 4 is 99-495 mod 100, _831440=_831440, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 321>500), (set_debug(eval, false), _831518 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_831518])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 321>500), (set_debug(eval, false), _831518 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_831518])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(304) [user] nop(notrace(no_repeats_var(_831570)))
   <span class="ansi1 ansi32"
>Exit: </span>(304) [user] nop(notrace(no_repeats_var(_831570)))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] once(user:(notrace((flag(eval_num, 1321, 1321+1), 321 is 1321 mod 500, 4 is 99-495 mod 100, _831440=_831440, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 321>500), (set_debug(eval, false), _831518 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_831518])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_831570)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] must_det_ll(user:(notrace((flag(eval_num, 1321, 1321+1), 321 is 1321 mod 500, 4 is 99-495 mod 100, _831440=_831440, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 321>500), (set_debug(eval, false), _831518 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_831518])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_831570)))))
   <span class="ansi1 ansi32"
>Call: </span>(301) [occurs] occurs:sub_term(_843268, e)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(301) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(302) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(301) [occurs] occurs:sub_term(_843268, e)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] _850374=e
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] if_trace((eval;e), (_831440=1, indentq(4, 321, -->, [e, ['if-unify-or-empty', _591556, _591556]])))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] setup_call_cleanup('$notrace'(_853514, _853516), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _831440=1, indentq(4, 321, -->, [e, ['if-unify-or-empty', _591556, _591556]]))), _853472, fbug((_853472-->if_trace((eval;e), (_831440=1, indentq(4, 321, -->, [e, ['if-unify-or-empty', _591556, _591556]])))))))), '$restore_trace'(_853514, _853516))
^  <span class="ansi1 ansi32"
>Call: </span>(304) [system] sig_atomic(system:'$notrace'(_853514, _853516))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _831440=1, indentq(4, 321, -->, [e, ['if-unify-or-empty', _591556, _591556]]))), _853472, fbug((_853472-->if_trace((eval;e), (_831440=1, indentq(4, 321, -->, [e, ['if-unify-or-empty', _591556, _591556]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] if_trace((eval;e), (_831440=1, indentq(4, 321, -->, [e, ['if-unify-or-empty', _591556, _591556]])))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] _857710=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] _859748=(\+ \+ (flag(eval_num, _859768, _859768+1), (retval(fail)\=@=retval(fail), nonvar(_830326)->indentq(4, _859768, <--, [e, _830326]);indentq(4, _859768, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] (\+ \+ (flag(eval_num, _859768, _859768+1), (retval(fail)\=@=retval(fail), nonvar(_830326)->indentq(4, _859768, <--, [e, _830326]);indentq(4, _859768, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _859768, _859768+1), (retval(fail)\=@=retval(fail), nonvar(_830326)->indentq(4, _859768, <--, [e, _830326]);indentq(4, _859768, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] call_cleanup(((call(eval_20(=, _814866), 495, '&self', ['if-unify-or-empty', _591556, _591556], _830326)*->nb_setarg(1, retval(fail), _830326);fail, trace, call(eval_20(=, _814866), 495, '&self', ['if-unify-or-empty', _591556, _591556], _830326)), ignore(notrace((\+_830326\=_831570, nb_setarg(1, retval(fail), _830326))))), ignore((_831440==1->ignore(\+ \+ (flag(eval_num, _859768, _859768+1), (retval(fail)\=@=retval(fail), nonvar(_830326)->indentq(4, _859768, <--, [e, _830326]);indentq(4, _859768, <--, [e, retval(fail)]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _859768, _859768+1), (retval(fail)\=@=retval(fail), nonvar(_830326)->indentq(4, _859768, <--, [e, _830326]);indentq(4, _859768, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_20(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _830326)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] atom(['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] no_eval(['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] self_eval(['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] setup_call_cleanup('$notrace'(_867156, _867158), once(user:self_eval0(['if-unify-or-empty', _591556, _591556])), '$restore_trace'(_867156, _867158))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] sig_atomic(system:'$notrace'(_867156, _867158))
^  <span class="ansi1 ansi31"
>Fail: </span>(305) [user] self_eval(['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] atomic('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(305) [system] atomic('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] is_sl('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] number('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [_591556, _591556]==[]
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _878350==eval
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [_591556, _591556]==[]
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list([_591556, _591556])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list([_591556, _591556])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list([_591556, _591556])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list([_591556, _591556])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list(['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list(['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] once(expand_eval(['if-unify-or-empty', _591556, _591556], _890528))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] expand_eval(['if-unify-or-empty', _591556, _591556], _890528)
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] is_list(['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Exit: </span>(306) [system] is_list(['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(306) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] apply:maplist(expand_eval, [_591556, _591556], _896628)
   <span class="ansi1 ansi32"
>Call: </span>(307) [apply] apply:maplist_([_591556, _591556], _896628, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] expand_eval(_591556, _898684)
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] is_list(_591556)
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] _591556=_898684
   <span class="ansi1 ansi32"
>Exit: </span>(309) [system] _591556=_591556
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] expand_eval(_591556, _591556)
   <span class="ansi1 ansi32"
>Call: </span>(308) [apply] apply:maplist_([_591556], _898686, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] expand_eval(_591556, _904786)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list(_591556)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _591556=_904786
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] _591556=_591556
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] expand_eval(_591556, _591556)
   <span class="ansi1 ansi32"
>Call: </span>(309) [apply] apply:maplist_([], _904788, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(309) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(308) [apply] apply:maplist_([_591556], [_591556], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [apply] apply:maplist_([_591556, _591556], [_591556, _591556], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [apply] apply:maplist(user:expand_eval, [_591556, _591556], [_591556, _591556])
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [user] expand_eval(['if-unify-or-empty', _591556, _591556], ['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [system] once(user:expand_eval(['if-unify-or-empty', _591556, _591556], ['if-unify-or-empty', _591556, _591556]))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] ['if-unify-or-empty', _591556, _591556]\==['if-unify-or-empty', _591556, _591556]
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] is_progn('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] is_space_op('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] arg(_922208, v('catch!', 'throw!', 'number-of!', 'limit!', 'offset!', 'max-time!', 'findall!', 'setup-call-cleanup!', 'call-cleanup!', 'call-cleanup!', 'with-output-to!'), 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _923106='if-unify-or-empty'
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] 'if-unify-or-empty'='if-unify-or-empty'
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _925140)
^  <span class="ansi1 ansi31"
>Fail: </span>(304) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _925140)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list(['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list(['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] apply:maplist(self_eval, ['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Call: </span>(305) [apply] apply:maplist_(['if-unify-or-empty', _591556, _591556], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] self_eval('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_932274, _932276), once(user:self_eval0('if-unify-or-empty')), '$restore_trace'(_932274, _932276))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_932274, _932276))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0('if-unify-or-empty')), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] self_eval('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(306) [apply] apply:maplist_([_591556, _591556], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] self_eval(_591556)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_938428, _938430), once(user:self_eval0(_591556)), '$restore_trace'(_938428, _938430))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_938428, _938430))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_591556)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] self_eval(_591556)
   <span class="ansi1 ansi32"
>Call: </span>(307) [apply] apply:maplist_([_591556], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] self_eval(_591556)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_944582, _944584), once(user:self_eval0(_591556)), '$restore_trace'(_944582, _944584))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_944582, _944584))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_591556)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] self_eval(_591556)
   <span class="ansi1 ansi32"
>Call: </span>(308) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(308) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [apply] apply:maplist_([_591556], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(306) [apply] apply:maplist_([_591556, _591556], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(305) [apply] apply:maplist_(['if-unify-or-empty', _591556, _591556], user:self_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [apply] apply:maplist(user:self_eval, ['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] ['if-unify-or-empty', _591556, _591556]=[_954800|_954802]
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] ['if-unify-or-empty', _591556, _591556]=['if-unify-or-empty', _591556, _591556]
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _958860=do_more_defs(true)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] do_more_defs(true)=do_more_defs(true)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] clause(eval_21(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _830326), _960912)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] 'if-unify-or-empty'==(/)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] 'if-unify-or-empty'== ===
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] 'if-unify-or-empty'== ====
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] eval_40(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984)
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] eval_selfless(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_selfless_0(['if-unify-or-empty', _591556, _591556], _964984)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] is_assignment('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(308) [system] atom('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] eval_selfless_1(['if-unify-or-empty', _591556, _591556], _964984)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] allow_clp
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] false_flag
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(310) [system] fail
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] false_flag
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] eval_selfless_2(['if-unify-or-empty', _591556, _591556], _964984)
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] fake_notrace((ground(['if-unify-or-empty', _591556, _591556]), ['if-unify-or-empty', _591556, _591556]=[_980208, _980214, _980220], atom(_980208), catch_warn(current_op(_980246, yfx, _980208)), ['if-unify-or-empty', _591556, _591556]\=[_980266], s2ps(['if-unify-or-empty', _591556, _591556], _980274)))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] real_notrace(user:(ground(['if-unify-or-empty', _591556, _591556]), ['if-unify-or-empty', _591556, _591556]=[_980208, _980214, _980220], atom(_980208), catch_warn(current_op(_980246, yfx, _980208)), ['if-unify-or-empty', _591556, _591556]\=[_980266], s2ps(['if-unify-or-empty', _591556, _591556], _980274)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] setup_call_cleanup('$notrace'(_982308, _982310), once(user:(ground(['if-unify-or-empty', _591556, _591556]), ['if-unify-or-empty', _591556, _591556]=[_980208, _980214, _980220], atom(_980208), catch_warn(current_op(_980246, yfx, _980208)), ['if-unify-or-empty', _591556, _591556]\=[_980266], s2ps(['if-unify-or-empty', _591556, _591556], _980274))), '$restore_trace'(_982308, _982310))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(user:'$notrace'(_982308, _982310))
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] real_notrace(user:(ground(['if-unify-or-empty', _591556, _591556]), ['if-unify-or-empty', _591556, _591556]=[_980208, _980214, _980220], atom(_980208), catch_warn(current_op(_980246, yfx, _980208)), ['if-unify-or-empty', _591556, _591556]\=[_980266], s2ps(['if-unify-or-empty', _591556, _591556], _980274)))
^  <span class="ansi1 ansi31"
>Fail: </span>(308) [user] fake_notrace(user:(ground(['if-unify-or-empty', _591556, _591556]), ['if-unify-or-empty', _591556, _591556]=[_980208, _980214, _980220], atom(_980208), catch_warn(current_op(_980246, yfx, _980208)), ['if-unify-or-empty', _591556, _591556]\=[_980266], s2ps(['if-unify-or-empty', _591556, _591556], _980274)))
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] 'if-unify-or-empty'==(==)
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] 'if-unify-or-empty'==(==)
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] eval_41(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_adjust_args(=, _814866, _995496, _964984, 495, '&self', ['if-unify-or-empty', _591556, _591556], _995498)
   <span class="ansi1 ansi32"
>Call: </span>(307) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _814866, _995496, _964984, 495, '&self', ['if-unify-or-empty', _591556, _591556], _995498)), eval_adjust_args1(=, _814866, _995496, _964984, 495, '&self', ['if-unify-or-empty', _591556, _591556], _995498))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_adjust_args2(=, _814866, _995496, _964984, 495, '&self', ['if-unify-or-empty', _591556, _591556], _995498)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] apply:maplist(must_eval_args(=, _1002652, 495, '&self'), [_591556, _591556], _1002646)
   <span class="ansi1 ansi32"
>Call: </span>(311) [apply] apply:maplist_([_591556, _591556], _1002646, user:must_eval_args(=, _1002652, 495, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] must_eval_args(=, _1002652, 495, '&self', _591556, _1004712)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] was_option_value(nodebug, _1015876)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] current_prolog_flag(nodebug, _1016894)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] current_prolog_flag(nodebug, _1016894)
   <span class="ansi1 ansi32"
>Call: </span>(318) [$syspreds] prolog_load_context(nodebug, _1018928)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [$syspreds] prolog_load_context(nodebug, _1018928)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nb_current(nodebug, _1020962)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] nb_current(nodebug, _1020962)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] was_option_value(nodebug, _1015876)
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_1027074, _1027076), once(user:option_value0(nodebug, true)), '$restore_trace'(_1027074, _1027076))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_1027074, _1027076))
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(314) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1047414)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1047414, _1048558)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_1052524, _1052526, _1052528), defined)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(317) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1052524, _1052526, _1052528))
   <span class="ansi1 ansi32"
>Call: </span>(318) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1052524, _1052526, _1052528))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] callable(debugging_logicmoo_setting(_1052524, _1052526, _1052528))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] callable(debugging_logicmoo_setting(_1052524, _1052526, _1052528))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1052524, _1052526, _1052528))
   <span class="ansi1 ansi32"
>Exit: </span>(317) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1052524, _1052526, _1052528))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_1052524, _1052526, _1052528), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _1047414, _1064708)
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(314) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval_args(=, _1002652, 495, '&self', _591556, _1004712)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(_591556)
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] var(_591556)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] nonvar(_1004712)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_1075934, _1075936), once(user:self_eval(_591556)), '$restore_trace'(_1075934, _1075936))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_1075934, _1075936))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_591556)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] _1004712=_591556
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] _591556=_591556
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] eval_args(=, _1002652, 495, '&self', _591556, _591556)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] must_eval_args(=, _1002652, 495, '&self', _591556, _591556)
   <span class="ansi1 ansi32"
>Call: </span>(312) [apply] apply:maplist_([_591556], _1004714, user:must_eval_args(=, _1002652, 495, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] must_eval_args(=, _1002652, 495, '&self', _591556, _1084198)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] was_option_value(nodebug, _1095362)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] current_prolog_flag(nodebug, _1096380)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] current_prolog_flag(nodebug, _1096380)
   <span class="ansi1 ansi32"
>Call: </span>(319) [$syspreds] prolog_load_context(nodebug, _1098414)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [$syspreds] prolog_load_context(nodebug, _1098414)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] nb_current(nodebug, _1100448)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] nb_current(nodebug, _1100448)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] was_option_value(nodebug, _1095362)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_1106560, _1106562), once(user:option_value0(nodebug, true)), '$restore_trace'(_1106560, _1106562))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_1106560, _1106562))
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(315) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1126900)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1126900, _1128044)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_1132010, _1132012, _1132014), defined)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(318) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1132010, _1132012, _1132014))
   <span class="ansi1 ansi32"
>Call: </span>(319) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1132010, _1132012, _1132014))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] callable(debugging_logicmoo_setting(_1132010, _1132012, _1132014))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] callable(debugging_logicmoo_setting(_1132010, _1132012, _1132014))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1132010, _1132012, _1132014))
   <span class="ansi1 ansi32"
>Exit: </span>(318) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1132010, _1132012, _1132014))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_1132010, _1132012, _1132014), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _1126900, _1144194)
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(315) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] eval_args(=, _1002652, 495, '&self', _591556, _1084198)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] var(_591556)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] var(_591556)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nonvar(_1084198)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] setup_call_cleanup('$notrace'(_1155420, _1155422), once(user:self_eval(_591556)), '$restore_trace'(_1155420, _1155422))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] sig_atomic(system:'$notrace'(_1155420, _1155422))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_591556)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] _1084198=_591556
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] _591556=_591556
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] eval_args(=, _1002652, 495, '&self', _591556, _591556)
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] must_eval_args(=, _1002652, 495, '&self', _591556, _591556)
   <span class="ansi1 ansi32"
>Call: </span>(313) [apply] apply:maplist_([], _1084200, user:must_eval_args(=, _1002652, 495, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(313) [apply] apply:maplist_([], [], user:must_eval_args(=, _1002652, 495, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(312) [apply] apply:maplist_([_591556], [_591556], user:must_eval_args(=, _1002652, 495, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(311) [apply] apply:maplist_([_591556, _591556], [_591556, _591556], user:must_eval_args(=, _1002652, 495, '&self'))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [apply] apply:maplist(user:must_eval_args(=, _1002652, 495, '&self'), [_591556, _591556], [_591556, _591556])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _995496=_964984
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] _964984=_964984
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_adjust_args2(=, _814866, _964984, _964984, 495, '&self', ['if-unify-or-empty', _591556, _591556], ['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _814866, _964984, _964984, 495, '&self', ['if-unify-or-empty', _591556, _591556], ['if-unify-or-empty', _591556, _591556])), eval_adjust_args1(=, _814866, _964984, _964984, 495, '&self', ['if-unify-or-empty', _591556, _591556], ['if-unify-or-empty', _591556, _591556]))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_adjust_args(=, _814866, _964984, _964984, 495, '&self', ['if-unify-or-empty', _591556, _591556], ['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] if_trace((e;args), (['if-unify-or-empty', _591556, _591556]\==['if-unify-or-empty', _591556, _591556]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _591556, _591556]->['if-unify-or-empty', _591556, _591556])));nop(indentq2(495, same(['if-unify-or-empty', _591556, _591556])))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_1174006, _1174008), once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _591556, _591556]\==['if-unify-or-empty', _591556, _591556]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _591556, _591556]->['if-unify-or-empty', _591556, _591556])));nop(indentq2(495, same(['if-unify-or-empty', _591556, _591556])))))), _1173964, fbug((_1173964-->if_trace((e;args), (['if-unify-or-empty', _591556, _591556]\==['if-unify-or-empty', _591556, _591556]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _591556, _591556]->['if-unify-or-empty', _591556, _591556])));nop(indentq2(495, same(['if-unify-or-empty', _591556, _591556])))))))))), '$restore_trace'(_1174006, _1174008))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_1174006, _1174008))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _591556, _591556]\==['if-unify-or-empty', _591556, _591556]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _591556, _591556]->['if-unify-or-empty', _591556, _591556])));nop(indentq2(495, same(['if-unify-or-empty', _591556, _591556])))))), _1173964, fbug((_1173964-->if_trace((e;args), (['if-unify-or-empty', _591556, _591556]\==['if-unify-or-empty', _591556, _591556]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _591556, _591556]->['if-unify-or-empty', _591556, _591556])));nop(indentq2(495, same(['if-unify-or-empty', _591556, _591556])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] if_trace((e;args), (['if-unify-or-empty', _591556, _591556]\==['if-unify-or-empty', _591556, _591556]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _591556, _591556]->['if-unify-or-empty', _591556, _591556])));nop(indentq2(495, same(['if-unify-or-empty', _591556, _591556])))))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_70(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984)
   <span class="ansi1 ansi32"
>Call: </span>(307) [user] if_or_else(eval_maybe_python(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984), if_or_else(eval_maybe_host_predicate(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984), if_or_else(eval_maybe_host_function(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984), if_or_else(eval_maybe_defn(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984), eval_maybe_subst(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984)))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] eval_maybe_python(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984)
   <span class="ansi1 ansi32"
>Call: </span>(309) [user] metta_atom('&self', ['registered-python-function', _1181366, _1181372, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] typed_list('&self', _1182512, _1182386)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(310) [user] typed_list('&self', _1185556, _1182386)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] metta_atom_in_file('&self', ['registered-python-function', _1181366, _1181372, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] metta_atom_in_file('&self', ['registered-python-function', _1181366, _1181372, 'if-unify-or-empty'], _1188610, _1188612)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] loaded_into_kb('&self', _1189508)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] loaded_into_kb('&self', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] once(user:asserted_metta_pred(_1195468, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] asserted_metta_pred(_1195468, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(313) [user] asserted_metta_pred(_1195468, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] metta_atom_asserted('&self', ['registered-python-function', _1181366, _1181372, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] metta_atom_asserted_deduced('&self', ['registered-python-function', _1181366, _1181372, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] metta_atom('&corelib', ['registered-python-function', _1181366, _1181372, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] typed_list('&corelib', _1219510, _1219384)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(312) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(311) [user] typed_list('&corelib', _1222554, _1219384)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] metta_atom_in_file('&corelib', ['registered-python-function', _1181366, _1181372, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] metta_atom_in_file('&corelib', ['registered-python-function', _1181366, _1181372, 'if-unify-or-empty'], _1225608, _1225610)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] loaded_into_kb('&corelib', _1226506)
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] once(user:asserted_metta_pred(_1232450, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] asserted_metta_pred(_1232450, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] asserted_metta_pred(_1232450, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] once(user:asserted_metta_pred(_1252132, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] asserted_metta_pred(_1252132, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] asserted_metta_pred(_1252132, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(311) [user] metta_atom_asserted('&corelib', ['registered-python-function', _1181366, _1181372, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] metta_atom_asserted_deduced('&corelib', ['registered-python-function', _1181366, _1181372, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(308) [user] if_or_else(eval_maybe_host_predicate(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984), if_or_else(eval_maybe_host_function(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984), if_or_else(eval_maybe_defn(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984), eval_maybe_subst(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984))))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_maybe_host_predicate(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] once((is_system_pred('if-unify-or-empty'), length([_591556, _591556], _1277016), is_syspred('if-unify-or-empty', _1277016, _1277024)))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom_concat(_1281208, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom_concat(_1284252, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom_concat(_1287296, '-p', 'if-unify-or-empty')
^  <span class="ansi1 ansi31"
>Fail: </span>(312) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(309) [user] if_or_else(eval_maybe_host_function(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984), if_or_else(eval_maybe_defn(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984), eval_maybe_subst(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] eval_maybe_host_function(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom_concat(_1296408, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom_concat(_1299452, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom_concat(_1302496, '-p', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] if_or_else(eval_maybe_defn(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984), eval_maybe_subst(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] eval_maybe_defn(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] trace_eval(eval_defn_choose_candidates(=, _814866), defn, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] must_det_ll((notrace((flag(eval_num, _1312536, _1312536+1), _1312554 is _1312536 mod 500, _1312572 is 99-495 mod 100, _1312596=_1312598, option_else('trace-length', _1312610, 500), option_else('trace-depth', _1312618, 30))), quietly(if_t((nop(stop_rtrace), _1312554>_1312610), (set_debug(eval, false), _1312674 is _1312610+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1312674])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1312726)))))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] once(user:(notrace((flag(eval_num, _1312536, _1312536+1), _1312554 is _1312536 mod 500, _1312572 is 99-495 mod 100, _1312596=_1312598, option_else('trace-length', _1312610, 500), option_else('trace-depth', _1312618, 30))), quietly(if_t((nop(stop_rtrace), _1312554>_1312610), (set_debug(eval, false), _1312674 is _1312610+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1312674])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1312726)))))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_1314772, _1314774), once(user:(flag(eval_num, _1312536, _1312536+1), _1312554 is _1312536 mod 500, _1312572 is 99-495 mod 100, _1312596=_1312598, option_else('trace-length', _1312610, 500), option_else('trace-depth', _1312618, 30))), '$restore_trace'(_1314772, _1314774))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_1314772, _1314774))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 1322, 1322+1), 322 is 1322 mod 500, 4 is 99-495 mod 100, _1312596=_1312596, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 322>500), (set_debug(eval, false), _1312674 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1312674])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 322>500), (set_debug(eval, false), _1312674 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1312674])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(316) [user] nop(notrace(no_repeats_var(_1312726)))
   <span class="ansi1 ansi32"
>Exit: </span>(316) [user] nop(notrace(no_repeats_var(_1312726)))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [system] once(user:(notrace((flag(eval_num, 1322, 1322+1), 322 is 1322 mod 500, 4 is 99-495 mod 100, _1312596=_1312596, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 322>500), (set_debug(eval, false), _1312674 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1312674])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1312726)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] must_det_ll(user:(notrace((flag(eval_num, 1322, 1322+1), 322 is 1322 mod 500, 4 is 99-495 mod 100, _1312596=_1312596, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 322>500), (set_debug(eval, false), _1312674 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1312674])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1312726)))))
   <span class="ansi1 ansi32"
>Call: </span>(313) [occurs] occurs:sub_term(_1324424, defn)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [occurs] occurs:sub_term(defn, defn)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] defn\=defn
   <span class="ansi1 ansi31"
>Fail: </span>(313) [system] defn\=defn
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(313) [occurs] occurs:sub_term(_1324424, defn)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _1331530=defn
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] defn=defn
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] if_trace((eval;defn), (_1312596=1, indentq(4, 322, -->, [defn, ['if-unify-or-empty', _591556, _591556]])))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_1334670, _1334672), once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _1312596=1, indentq(4, 322, -->, [defn, ['if-unify-or-empty', _591556, _591556]]))), _1334628, fbug((_1334628-->if_trace((eval;defn), (_1312596=1, indentq(4, 322, -->, [defn, ['if-unify-or-empty', _591556, _591556]])))))))), '$restore_trace'(_1334670, _1334672))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_1334670, _1334672))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _1312596=1, indentq(4, 322, -->, [defn, ['if-unify-or-empty', _591556, _591556]]))), _1334628, fbug((_1334628-->if_trace((eval;defn), (_1312596=1, indentq(4, 322, -->, [defn, ['if-unify-or-empty', _591556, _591556]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] if_trace((eval;defn), (_1312596=1, indentq(4, 322, -->, [defn, ['if-unify-or-empty', _591556, _591556]])))
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _1338866=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _1340904=(\+ \+ (flag(eval_num, _1340924, _1340924+1), (retval(fail)\=@=retval(fail), nonvar(_964984)->indentq(4, _1340924, <--, [defn, _964984]);indentq(4, _1340924, <--, [defn, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] (\+ \+ (flag(eval_num, _1340924, _1340924+1), (retval(fail)\=@=retval(fail), nonvar(_964984)->indentq(4, _1340924, <--, [defn, _964984]);indentq(4, _1340924, <--, [defn, retval(fail)]))))=(\+ \+ (flag(eval_num, _1340924, _1340924+1), (retval(fail)\=@=retval(fail), nonvar(_964984)->indentq(4, _1340924, <--, [defn, _964984]);indentq(4, _1340924, <--, [defn, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] call_cleanup(((call(eval_defn_choose_candidates(=, _814866), 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984)*->nb_setarg(1, retval(fail), _964984);fail, trace, call(eval_defn_choose_candidates(=, _814866), 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984)), ignore(notrace((\+_964984\=_1312726, nb_setarg(1, retval(fail), _964984))))), ignore((_1312596==1->ignore(\+ \+ (flag(eval_num, _1340924, _1340924+1), (retval(fail)\=@=retval(fail), nonvar(_964984)->indentq(4, _1340924, <--, [defn, _964984]);indentq(4, _1340924, <--, [defn, retval(fail)]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1340924, _1340924+1), (retval(fail)\=@=retval(fail), nonvar(_964984)->indentq(4, _1340924, <--, [defn, _964984]);indentq(4, _1340924, <--, [defn, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_defn_choose_candidates(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] findall((_1345266->_1345268), get_defn_expansions(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _1345266, _1345268), _1345286)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [$bags] findall((_1345266->_1345268), user:get_defn_expansions(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _1345266, _1345268), _1345286, [])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [$bags] cleanup_bag(findall_loop((_1345266->_1345268), user:get_defn_expansions(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _1345266, _1345268), _1345286, []), '$destroy_findall_bag')
   <span class="ansi1 ansi32"
>Call: </span>(319) [$bags] findall_loop((_1345266->_1345268), user:get_defn_expansions(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _1345266, _1345268), _1345286, [])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] get_defn_expansions(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _1345266, _1345268)
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] same_len_copy([_591556, _591556], _1350458)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] length([_591556, _591556], _1351476)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(_1351476)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] var(_1351476)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] []==[]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _1351476=2
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] 2=2
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] length([_591556, _591556], 2)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] length(_1350458, 2)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(2)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] integer(2)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] integer(2)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _1350458==[]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(_1350458)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] var(_1350458)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] length([_1366700, _1366706], 2)
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [user] same_len_copy([_591556, _591556], [_1366700, _1366706])
   <span class="ansi1 ansi32"
>Call: </span>(321) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _1366700, _1366706], _1345268)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] ignore((=)=(=))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] (=)=(=)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] (=)=(=)
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] ignore(user:((=)=(=)))
   <span class="ansi1 ansi32"
>Call: </span>(322) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _1366700, _1366706], _1345268]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _1366700, _1366706], _1345268]))
   <span class="ansi1 ansi32"
>Call: </span>(323) [user] metta_atom('&self', [=, ['if-unify-or-empty', _1366700, _1366706], _1345268])
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] typed_list('&self', _1376022, _1375896)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(325) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(324) [user] typed_list('&self', _1379066, _1375896)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _1366700, _1366706], _1345268])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _1366700, _1366706], _1345268], _1382120, _1382122)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] loaded_into_kb('&self', _1383018)
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] loaded_into_kb('&self', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] once(user:asserted_metta_pred(_1388978, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] asserted_metta_pred(_1388978, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(327) [user] asserted_metta_pred(_1388978, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(324) [user] metta_atom_asserted('&self', [=, ['if-unify-or-empty', _1366700, _1366706], _1345268])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] metta_atom_asserted_deduced('&self', [=, ['if-unify-or-empty', _1366700, _1366706], _1345268])
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(324) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _1366700, _1366706], _1345268])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] typed_list('&corelib', _1413020, _1412894)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(326) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(325) [user] typed_list('&corelib', _1416064, _1412894)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _1366700, _1366706], _1345268])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _1366700, _1366706], _1345268], _1419118, _1419120)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] loaded_into_kb('&corelib', _1420016)
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] once(user:asserted_metta_pred(_1425960, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] asserted_metta_pred(_1425960, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(328) [user] asserted_metta_pred(_1425960, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] once(user:asserted_metta_pred(_1445642, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] asserted_metta_pred(_1445642, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(328) [user] asserted_metta_pred(_1445642, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(325) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _1366700, _1366706], _1345268])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] metta_atom_asserted_deduced('&corelib', [=, ['if-unify-or-empty', _1366700, _1366706], _1345268])
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] fail
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _1366700, _1366700], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(324) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _1366700, _1366700], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(323) [user] metta_atom('&self', [=, ['if-unify-or-empty', _1366700, _1366700], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _1366700, _1366700], unified]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _1366700, _1366700], unified]))
   <span class="ansi1 ansi32"
>Exit: </span>(321) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _1366700, _1366700], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] get_defn_expansions(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], ['if-unify-or-empty', _1366700, _1366700], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _1366700, _1366706], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(324) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _1366700, _1366706], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(323) [user] metta_atom('&self', [=, ['if-unify-or-empty', _1366700, _1366706], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _1366700, _1366706], [empty]]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _1366700, _1366706], [empty]]))
   <span class="ansi1 ansi32"
>Exit: </span>(321) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _1366700, _1366706], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] get_defn_expansions(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], ['if-unify-or-empty', _1366700, _1366706], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(319) [$bags] findall_loop((_1345266->_1345268), user:get_defn_expansions(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _1345266, _1345268), [(['if-unify-or-empty', _1478646, _1478646]->unified), (['if-unify-or-empty', _1478610, _1478616]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [$bags] cleanup_bag('$bags':findall_loop((_1345266->_1345268), user:get_defn_expansions(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _1345266, _1345268), [(['if-unify-or-empty', _1478646, _1478646]->unified), (['if-unify-or-empty', _1478610, _1478616]->[empty])], []), '$bags':'$destroy_findall_bag')
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [$bags] findall((_1345266->_1345268), user:get_defn_expansions(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _1345266, _1345268), [(['if-unify-or-empty', _1478646, _1478646]->unified), (['if-unify-or-empty', _1478610, _1478616]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [$bags] findall((_1345266->_1345268), user:get_defn_expansions(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _1345266, _1345268), [(['if-unify-or-empty', _1478646, _1478646]->unified), (['if-unify-or-empty', _1478610, _1478616]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_defn_bodies(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984, [(['if-unify-or-empty', _1478646, _1478646]->unified), (['if-unify-or-empty', _1478610, _1478616]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] if_trace(e, maplist(print_templates(495, '   '), [(['if-unify-or-empty', _1478646, _1478646]->unified), (['if-unify-or-empty', _1478610, _1478616]->[empty])]))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_1484878, _1484880), once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(495, '   '), [(['if-unify-or-empty', _1478646, _1478646]->unified), (['if-unify-or-empty', _1478610, _1478616]->[empty])]))), _1484836, fbug((_1484836-->if_trace(e, maplist(print_templates(495, '   '), [(['if-unify-or-empty', _1478646, _1478646]->unified), (['if-unify-or-empty', _1478610, _1478616]->[empty])]))))))), '$restore_trace'(_1484878, _1484880))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_1484878, _1484880))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(495, '   '), [(['if-unify-or-empty', _1478646, _1478646]->unified), (['if-unify-or-empty', _1478610, _1478616]->[empty])]))), _1484836, fbug((_1484836-->if_trace(e, maplist(print_templates(495, '   '), [(['if-unify-or-empty', _1478646, _1478646]->unified), (['if-unify-or-empty', _1478610, _1478616]->[empty])]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [user] if_trace(e, maplist(print_templates(495, '   '), [(['if-unify-or-empty', _1478646, _1478646]->unified), (['if-unify-or-empty', _1478610, _1478616]->[empty])]))
   <span class="ansi1 ansi32"
>Call: </span>(317) [user] if_or_else((member((_1489088->_1489090), [(['if-unify-or-empty', _1478646, _1478646]->unified), (['if-unify-or-empty', _1478610, _1478616]->[empty])]), copy_term((_1489088->_1489090), _1489102), eval_defn_success(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984, _1489088, _1489090, _1489102)), eval_defn_failure(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984))
   <span class="ansi1 ansi32"
>Call: </span>(319) [lists] lists:member((_1489088->_1489090), [(['if-unify-or-empty', _1478646, _1478646]->unified), (['if-unify-or-empty', _1478610, _1478616]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(320) [lists] lists:member_([(['if-unify-or-empty', _1478610, _1478616]->[empty])], (_1489088->_1489090), (['if-unify-or-empty', _1478646, _1478646]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [lists] lists:member_([(['if-unify-or-empty', _1478610, _1478616]->[empty])], (['if-unify-or-empty', _1478646, _1478646]->unified), (['if-unify-or-empty', _1478646, _1478646]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [lists] lists:member((['if-unify-or-empty', _1478646, _1478646]->unified), [(['if-unify-or-empty', _1478646, _1478646]->unified), (['if-unify-or-empty', _1478610, _1478616]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] copy_term((['if-unify-or-empty', _1478646, _1478646]->unified), _1489102)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] copy_term((['if-unify-or-empty', _1478646, _1478646]->unified), (['if-unify-or-empty', _1495252, _1495252]->unified))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_defn_success(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984, ['if-unify-or-empty', _1478646, _1478646], unified, (['if-unify-or-empty', _1495252, _1495252]->unified))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] ['if-unify-or-empty', _591556, _591556]=['if-unify-or-empty', _1478646, _1478646]
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] ['if-unify-or-empty', _591556, _591556]=['if-unify-or-empty', _591556, _591556]
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _964984=unified
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] unified=unified
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] ['if-unify-or-empty', _591556, _591556]\=@=unified
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] ['if-unify-or-empty', _591556, _591556]\=@=unified
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1495252, _1495252]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_1504500, _1504502), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1495252, _1495252]->unified)))))), _1504458, fbug((_1504458-->if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1495252, _1495252]->unified)))))))))), '$restore_trace'(_1504500, _1504502))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_1504500, _1504502))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1495252, _1495252]->unified)))))), _1504458, fbug((_1504458-->if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1495252, _1495252]->unified)))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1495252, _1495252]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] light_eval(=, _814866, 495, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] light_eval(=, _814866, 495, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] eval_defn_success(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified, ['if-unify-or-empty', _591556, _591556], unified, (['if-unify-or-empty', _1495252, _1495252]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(317) [user] if_or_else((member((['if-unify-or-empty', _591556, _591556]->unified), [(['if-unify-or-empty', _591556, _591556]->unified), (['if-unify-or-empty', _1478610, _1478616]->[empty])]), copy_term((['if-unify-or-empty', _591556, _591556]->unified), (['if-unify-or-empty', _1495252, _1495252]->unified)), eval_defn_success(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified, ['if-unify-or-empty', _591556, _591556], unified, (['if-unify-or-empty', _1495252, _1495252]->unified))), eval_defn_failure(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] eval_defn_bodies(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified, [(['if-unify-or-empty', _591556, _591556]->unified), (['if-unify-or-empty', _1478610, _1478616]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] eval_defn_choose_candidates(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] ignore(notrace((\+unified\=_1312726, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_1517948, _1517950), once(user:(\+unified\=_1312726, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_1517948, _1517950))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_1517948, _1517950))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_1312726, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] ignore(user:notrace((\+unified\=_1312726, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _814866), 495, '&self', ['if-unify-or-empty', _591556, _591556], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_defn_choose_candidates(=, _814866), 495, '&self', ['if-unify-or-empty', _591556, _591556], unified)), ignore(notrace((\+unified\=_1312726, nb_setarg(1, retval(unified), unified))))), user:ignore((_1312596==1->ignore(\+ \+ (flag(eval_num, _1340924, _1340924+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(4, _1340924, <--, [defn, unified]);indentq(4, _1340924, <--, [defn, retval(unified)]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1340924, _1340924+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(4, _1340924, <--, [defn, unified]);indentq(4, _1340924, <--, [defn, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] trace_eval(eval_defn_choose_candidates(=, _814866), defn, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] eval_maybe_defn(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else(eval_maybe_defn(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified), eval_maybe_subst(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified))
   <span class="ansi1 ansi32"
>Exit: </span>(309) [user] if_or_else(eval_maybe_host_function(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified), if_or_else(eval_maybe_defn(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified), eval_maybe_subst(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified)))
   <span class="ansi1 ansi32"
>Exit: </span>(308) [user] if_or_else(eval_maybe_host_predicate(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified), if_or_else(eval_maybe_host_function(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified), if_or_else(eval_maybe_defn(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified), eval_maybe_subst(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified))))
   <span class="ansi1 ansi32"
>Exit: </span>(307) [user] if_or_else(eval_maybe_python(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified), if_or_else(eval_maybe_host_predicate(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified), if_or_else(eval_maybe_host_function(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified), if_or_else(eval_maybe_defn(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified), eval_maybe_subst(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_70(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] check_returnval(=, _814866, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] check_returnval(=, _814866, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [user] eval_41(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] eval_40(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] unified=_830326
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] eval_20(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified)
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] ignore(notrace((\+unified\=_831570, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_1542478, _1542480), once(user:(\+unified\=_831570, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_1542478, _1542480))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_1542478, _1542480))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_831570, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [system] ignore(user:notrace((\+unified\=_831570, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] call_cleanup(user:((call(eval_20(=, _814866), 495, '&self', ['if-unify-or-empty', _591556, _591556], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_20(=, _814866), 495, '&self', ['if-unify-or-empty', _591556, _591556], unified)), ignore(notrace((\+unified\=_831570, nb_setarg(1, retval(unified), unified))))), user:ignore((_831440==1->ignore(\+ \+ (flag(eval_num, _859768, _859768+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(4, _859768, <--, [e, unified]);indentq(4, _859768, <--, [e, retval(unified)]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _859768, _859768+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(4, _859768, <--, [e, unified]);indentq(4, _859768, <--, [e, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] trace_eval(eval_20(=, _814866), e, 495, '&self', ['if-unify-or-empty', _591556, _591556], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] self_eval(unified)
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_1551712, _1551714), once(user:self_eval0(unified)), '$restore_trace'(_1551712, _1551714))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_1551712, _1551714))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(unified)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] self_eval(unified)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] _798388=unified
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] eval_01(=, _814866, 496, '&self', ['if-unify-or-empty', _591556, _591556], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [user] eval_00(=, _814866, 496, '&self', ['if-unify-or-empty', _591556, _591556], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] eval_args(=, _814866, 496, '&self', ['if-unify-or-empty', _591556, _591556], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_1562030, _1562032), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _1561988, fbug((_1561988-->if_trace(case, writeqln(switch=unified))))))), '$restore_trace'(_1562030, _1562032))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_1562030, _1562032))
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _1561988, fbug((_1561988-->if_trace(case, writeqln(switch=unified))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] select_case(496, '&self', unified, ['Empty'-_591574], _1566226)
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] best_key(unified, ['Empty'-_591574], _1566226)
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_1568278-_1566226, ['Empty'-_591574])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member_([], _1568278-_1566226, 'Empty'-_591574)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member_([], 'Empty'-_591574, 'Empty'-_591574)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [lists] lists:member('Empty'-_591574, ['Empty'-_591574])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] unified='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_1573372-_1566226, ['Empty'-_591574])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member_([], _1573372-_1566226, 'Empty'-_591574)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member_([], 'Empty'-_591574, 'Empty'-_591574)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [lists] lists:member('Empty'-_591574, ['Empty'-_591574])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] unified=='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_1578466-_1566226, ['Empty'-_591574])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member_([], _1578466-_1566226, 'Empty'-_591574)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member_([], 'Empty'-_591574, 'Empty'-_591574)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [lists] lists:member('Empty'-_591574, ['Empty'-_591574])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] unified=@='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_1583560-_1566226, ['Empty'-_591574])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member_([], _1583560-_1566226, 'Empty'-_591574)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member_([], 'Empty'-_591574, 'Empty'-_591574)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [lists] lists:member('Empty'-_591574, ['Empty'-_591574])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] unified='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] maybe_special_keys(496, '&self', ['Empty'-_591574], _1588652)
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] eval_args(496, '&self', 'Empty', _1589686)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] eval_args(=, _1590838, 496, '&self', 'Empty', _1589686)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] var('Empty')
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_1592770, _1592772), once(user:self_eval('Empty')), '$restore_trace'(_1592770, _1592772))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_1592770, _1592772))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval('Empty')), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] _1589686='Empty'
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] 'Empty'='Empty'
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] eval_args(=, _1598072, 496, '&self', 'Empty', 'Empty')
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] eval_args(496, '&self', 'Empty', 'Empty')
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] 'Empty'\=@='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] maybe_special_keys(496, '&self', [], _1588652)
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] maybe_special_keys(496, '&self', [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [user] maybe_special_keys(496, '&self', ['Empty'-_591574], [])
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] best_key(unified, [], _1566226)
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_1605114-_1566226, [])
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_1606136-_1566226, [])
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_1607158-_1566226, [])
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_1608180-_1566226, [])
   <span class="ansi1 ansi32"
>Call: </span>(298) [lists] lists:member(_1609202-_1566226, [])
   <span class="ansi1 ansi32"
>Call: </span>(297) [lists] lists:member(_1610224-_1610226, ['Empty'-_591574])
   <span class="ansi1 ansi32"
>Call: </span>(298) [lists] lists:member_([], _1610224-_1610226, 'Empty'-_591574)
   <span class="ansi1 ansi32"
>Exit: </span>(298) [lists] lists:member_([], 'Empty'-_591574, 'Empty'-_591574)
   <span class="ansi1 ansi32"
>Exit: </span>(297) [lists] lists:member('Empty'-_591574, ['Empty'-_591574])
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] 'Empty'=='%void%'
   <span class="ansi1 ansi32"
>Call: </span>(321) [lists] lists:member_([], (_1489088->_1489090), (['if-unify-or-empty', _1478610, _1478616]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(321) [lists] lists:member_([], (['if-unify-or-empty', _1478610, _1478616]->[empty]), (['if-unify-or-empty', _1478610, _1478616]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [lists] lists:member_([(['if-unify-or-empty', _1478610, _1478616]->[empty])], (['if-unify-or-empty', _1478610, _1478616]->[empty]), (['if-unify-or-empty', _1478646, _1478646]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [lists] lists:member((['if-unify-or-empty', _1478610, _1478616]->[empty]), [(['if-unify-or-empty', _1478646, _1478646]->unified), (['if-unify-or-empty', _1478610, _1478616]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] copy_term((['if-unify-or-empty', _1478610, _1478616]->[empty]), _1489102)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] copy_term((['if-unify-or-empty', _1478610, _1478616]->[empty]), (['if-unify-or-empty', _1620424, _1620430]->[empty]))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_defn_success(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], _964984, ['if-unify-or-empty', _1478610, _1478616], [empty], (['if-unify-or-empty', _1620424, _1620430]->[empty]))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] ['if-unify-or-empty', _591556, _591556]=['if-unify-or-empty', _1478610, _1478616]
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] ['if-unify-or-empty', _591556, _591556]=['if-unify-or-empty', _591556, _591556]
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _964984=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] [empty]=[empty]
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] ['if-unify-or-empty', _591556, _591556]\=@=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] ['if-unify-or-empty', _591556, _591556]\=@=[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1620424, _1620430]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_1629672, _1629674), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1620424, _1620430]->[empty])))))), _1629630, fbug((_1629630-->if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1620424, _1620430]->[empty])))))))))), '$restore_trace'(_1629672, _1629674))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_1629672, _1629674))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1620424, _1620430]->[empty])))))), _1629630, fbug((_1629630-->if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1620424, _1620430]->[empty])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1620424, _1620430]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] light_eval(=, _814866, 495, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] light_eval(=, _814866, 495, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] eval_defn_success(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty], ['if-unify-or-empty', _591556, _591556], [empty], (['if-unify-or-empty', _1620424, _1620430]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(317) [user] if_or_else((member((['if-unify-or-empty', _591556, _591556]->[empty]), [(['if-unify-or-empty', _1478646, _1478646]->unified), (['if-unify-or-empty', _591556, _591556]->[empty])]), copy_term((['if-unify-or-empty', _591556, _591556]->[empty]), (['if-unify-or-empty', _1620424, _1620430]->[empty])), eval_defn_success(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty], ['if-unify-or-empty', _591556, _591556], [empty], (['if-unify-or-empty', _1620424, _1620430]->[empty]))), eval_defn_failure(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty]))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] eval_defn_bodies(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty], [(['if-unify-or-empty', _1478646, _1478646]->unified), (['if-unify-or-empty', _591556, _591556]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] eval_defn_choose_candidates(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] ignore(notrace((\+[empty]\=_1312726, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_1643128, _1643130), once(user:(\+[empty]\=_1312726, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_1643128, _1643130))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_1643128, _1643130))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_1312726, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] ignore(user:notrace((\+[empty]\=_1312726, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] ignore((_1312596==1->ignore(\+ \+ (flag(eval_num, _1340924, _1340924+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1340924, <--, [defn, [empty]]);indentq(4, _1340924, <--, [defn, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1340924, _1340924+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1340924, <--, [defn, [empty]]);indentq(4, _1340924, <--, [defn, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] _1312596==1
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] _1312596==1
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_1650320, _1650322), once(user:ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1340924, _1340924+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1340924, <--, [defn, [empty]]);indentq(4, _1340924, <--, [defn, retval([empty])])))))))), '$restore_trace'(_1650320, _1650322))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_1650320, _1650322))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1340924, _1340924+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1340924, <--, [defn, [empty]]);indentq(4, _1340924, <--, [defn, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] ignore(user:(_1312596==1->ignore(\+ \+ (flag(eval_num, _1340924, _1340924+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1340924, <--, [defn, [empty]]);indentq(4, _1340924, <--, [defn, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1340924, _1340924+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1340924, <--, [defn, [empty]]);indentq(4, _1340924, <--, [defn, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _814866), 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_defn_choose_candidates(=, _814866), 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty])), ignore(notrace((\+[empty]\=_1312726, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_1312596==1->ignore(\+ \+ (flag(eval_num, _1340924, _1340924+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1340924, <--, [defn, [empty]]);indentq(4, _1340924, <--, [defn, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1340924, _1340924+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1340924, <--, [defn, [empty]]);indentq(4, _1340924, <--, [defn, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] trace_eval(eval_defn_choose_candidates(=, _814866), defn, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] eval_maybe_defn(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else(eval_maybe_defn(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty]), eval_maybe_subst(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(309) [user] if_or_else(eval_maybe_host_function(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty]), if_or_else(eval_maybe_defn(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty]), eval_maybe_subst(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty])))
   <span class="ansi1 ansi32"
>Exit: </span>(308) [user] if_or_else(eval_maybe_host_predicate(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty]), if_or_else(eval_maybe_host_function(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty]), if_or_else(eval_maybe_defn(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty]), eval_maybe_subst(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty]))))
   <span class="ansi1 ansi32"
>Exit: </span>(307) [user] if_or_else(eval_maybe_python(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty]), if_or_else(eval_maybe_host_predicate(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty]), if_or_else(eval_maybe_host_function(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty]), if_or_else(eval_maybe_defn(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty]), eval_maybe_subst(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty])))))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_70(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] check_returnval(=, _814866, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] check_returnval(=, _814866, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [user] eval_41(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] eval_40(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [empty]=_830326
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] [empty]=[empty]
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] eval_20(=, _814866, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] ignore(notrace((\+[empty]\=_831570, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_1675024, _1675026), once(user:(\+[empty]\=_831570, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_1675024, _1675026))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_1675024, _1675026))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_831570, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [system] ignore(user:notrace((\+[empty]\=_831570, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] ignore((_831440==1->ignore(\+ \+ (flag(eval_num, _859768, _859768+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _859768, <--, [e, [empty]]);indentq(4, _859768, <--, [e, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _859768, _859768+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _859768, <--, [e, [empty]]);indentq(4, _859768, <--, [e, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] _831440==1
   <span class="ansi1 ansi31"
>Fail: </span>(305) [system] _831440==1
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] setup_call_cleanup('$notrace'(_1682216, _1682218), once(user:ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _859768, _859768+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _859768, <--, [e, [empty]]);indentq(4, _859768, <--, [e, retval([empty])])))))))), '$restore_trace'(_1682216, _1682218))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] sig_atomic(system:'$notrace'(_1682216, _1682218))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _859768, _859768+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _859768, <--, [e, [empty]]);indentq(4, _859768, <--, [e, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [system] ignore(user:(_831440==1->ignore(\+ \+ (flag(eval_num, _859768, _859768+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _859768, <--, [e, [empty]]);indentq(4, _859768, <--, [e, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _859768, _859768+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _859768, <--, [e, [empty]]);indentq(4, _859768, <--, [e, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] call_cleanup(user:((call(eval_20(=, _814866), 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_20(=, _814866), 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty])), ignore(notrace((\+[empty]\=_831570, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_831440==1->ignore(\+ \+ (flag(eval_num, _859768, _859768+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _859768, <--, [e, [empty]]);indentq(4, _859768, <--, [e, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _859768, _859768+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _859768, <--, [e, [empty]]);indentq(4, _859768, <--, [e, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] trace_eval(eval_20(=, _814866), e, 495, '&self', ['if-unify-or-empty', _591556, _591556], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_1691616, _1691618), once(user:self_eval0([empty])), '$restore_trace'(_1691616, _1691618))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_1691616, _1691618))
^  <span class="ansi1 ansi31"
>Fail: </span>(300) [user] self_eval([empty])
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] [empty]=@=['if-unify-or-empty', _829284, _829284]
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] eval_01(=, _814866, 495, '&self', [empty], _1695720)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] [empty]\==[empty]
   <span class="ansi1 ansi32"
>Call: </span>(297) [lists] lists:member(_1697778-_1697780, ['Empty'-_591574])
   <span class="ansi1 ansi32"
>Call: </span>(298) [lists] lists:member_([], _1697778-_1697780, 'Empty'-_591574)
   <span class="ansi1 ansi32"
>Exit: </span>(298) [lists] lists:member_([], 'Empty'-_591574, 'Empty'-_591574)
   <span class="ansi1 ansi32"
>Exit: </span>(297) [lists] lists:member('Empty'-_591574, ['Empty'-_591574])
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi31"
>Fail: </span>(295) [user] eval_20(=, _601240, 496, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _653278)
   <span class="ansi1 ansi32"
>Call: </span>(295) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(295) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] ignore((_654392==1->ignore(\+ \+ (flag(eval_num, _682720, _682720+1), (retval(fail)\=@=retval(fail), nonvar(_653278)->indentq(3, _682720, <--, [e, _653278]);indentq(3, _682720, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _682720, _682720+1), (retval(fail)\=@=retval(fail), nonvar(_653278)->indentq(3, _682720, <--, [e, _653278]);indentq(3, _682720, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] _654392==1
   <span class="ansi1 ansi31"
>Fail: </span>(297) [system] _654392==1
^  <span class="ansi1 ansi32"
>Call: </span>(298) [system] setup_call_cleanup('$notrace'(_1708974, _1708976), once(user:ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _682720, _682720+1), (retval(fail)\=@=retval(fail), nonvar(_653278)->indentq(3, _682720, <--, [e, _653278]);indentq(3, _682720, <--, [e, retval(fail)])))))))), '$restore_trace'(_1708974, _1708976))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] sig_atomic(system:'$notrace'(_1708974, _1708976))
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _682720, _682720+1), (retval(fail)\=@=retval(fail), nonvar(_653278)->indentq(3, _682720, <--, [e, _653278]);indentq(3, _682720, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(295) [system] ignore(user:(_654392==1->ignore(\+ \+ (flag(eval_num, _682720, _682720+1), (retval(fail)\=@=retval(fail), nonvar(_653278)->indentq(3, _682720, <--, [e, _653278]);indentq(3, _682720, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _682720, _682720+1), (retval(fail)\=@=retval(fail), nonvar(_653278)->indentq(3, _682720, <--, [e, _653278]);indentq(3, _682720, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(293) [system] call_cleanup(user:((call(eval_20(=, _601240), 496, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _653278)*->nb_setarg(1, retval(fail), _653278);fail, trace, call(eval_20(=, _601240), 496, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _653278)), ignore(notrace((\+_653278\=_654522, nb_setarg(1, retval(fail), _653278))))), user:ignore((_654392==1->ignore(\+ \+ (flag(eval_num, _682720, _682720+1), (retval(fail)\=@=retval(fail), nonvar(_653278)->indentq(3, _682720, <--, [e, _653278]);indentq(3, _682720, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _682720, _682720+1), (retval(fail)\=@=retval(fail), nonvar(_653278)->indentq(3, _682720, <--, [e, _653278]);indentq(3, _682720, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(292) [user] trace_eval(eval_20(=, _601240), e, 496, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _653278)
^  <span class="ansi1 ansi31"
>Fail: </span>(289) [user] eval_args(=, _601240, 497, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498)
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] call(eval, [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498)
   <span class="ansi1 ansi32"
>Call: </span>(287) [user] eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498)
^  <span class="ansi1 ansi32"
>Call: </span>(288) [user] current_self(_1718382)
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] nb_current(self_space, _1718382)
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(288) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(288) [user] eval('&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498)
   <span class="ansi1 ansi32"
>Call: </span>(289) [user] eval_H(500, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498)
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] fast_option_value(compile, save)
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] atom(compile)
   <span class="ansi1 ansi32"
>Exit: </span>(291) [system] atom(compile)
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] current_prolog_flag(compile, save)
   <span class="ansi1 ansi31"
>Fail: </span>(291) [system] current_prolog_flag(compile, save)
^  <span class="ansi1 ansi31"
>Fail: </span>(290) [user] fast_option_value(compile, save)
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] catch_metta_return(eval_args(=, _1732584, 500, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498), _604498)
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] eval_args(=, _1732584, 500, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] var([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] setup_call_cleanup('$notrace'(_1735694, _1735696), once(user:self_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])), '$restore_trace'(_1735694, _1735696))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] sig_atomic(system:'$notrace'(_1735694, _1735696))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] setup_call_cleanup('$notrace'(_1737782, _1737784), once(user:nonvar(_604498)), '$restore_trace'(_1737782, _1737784))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] sig_atomic(system:'$notrace'(_1737782, _1737784))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] setup_call_cleanup('$notrace'(_1739870, _1739872), once(user:nonvar(_604498)), '$restore_trace'(_1739870, _1739872))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] sig_atomic(system:'$notrace'(_1739870, _1739872))
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] [['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] self_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] setup_call_cleanup('$notrace'(_1747026, _1747028), once(user:self_eval0([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])), '$restore_trace'(_1747026, _1747028))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [system] sig_atomic(system:'$notrace'(_1747026, _1747028))
^  <span class="ansi1 ansi31"
>Fail: </span>(293) [user] self_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] eval_00(=, _1732584, 500, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498)
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] self_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Call: </span>(296) [system] setup_call_cleanup('$notrace'(_1752170, _1752172), once(user:self_eval0([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])), '$restore_trace'(_1752170, _1752172))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [system] sig_atomic(system:'$notrace'(_1752170, _1752172))
^  <span class="ansi1 ansi31"
>Fail: </span>(294) [user] self_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] eval_01(=, _1732584, 500, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _604498)
   <span class="ansi1 ansi32"
>Call: </span>(295) [system] [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(295) [system] [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(297) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(295) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [system] setup_call_cleanup('$notrace'(_1762444, _1762446), once(user:(_1762420 is 500-1, copy_term([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _1762434))), '$restore_trace'(_1762444, _1762446))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [system] sig_atomic(system:'$notrace'(_1762444, _1762446))
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], [case, ['if-unify-or-empty', _1764542, _1764542], [['Empty', _1764572]]]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] trace_eval(eval_20(=, _1732584), e, 499, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _1765608)
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] must_det_ll((notrace((flag(eval_num, _1766662, _1766662+1), _1766680 is _1766662 mod 500, _1766698 is 99-499 mod 100, _1766722=_1766724, option_else('trace-length', _1766736, 500), option_else('trace-depth', _1766744, 30))), quietly(if_t((nop(stop_rtrace), _1766680>_1766736), (set_debug(eval, false), _1766800 is _1766736+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1766800])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1766852)))))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] once(user:(notrace((flag(eval_num, _1766662, _1766662+1), _1766680 is _1766662 mod 500, _1766698 is 99-499 mod 100, _1766722=_1766724, option_else('trace-length', _1766736, 500), option_else('trace-depth', _1766744, 30))), quietly(if_t((nop(stop_rtrace), _1766680>_1766736), (set_debug(eval, false), _1766800 is _1766736+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1766800])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1766852)))))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] setup_call_cleanup('$notrace'(_1768898, _1768900), once(user:(flag(eval_num, _1766662, _1766662+1), _1766680 is _1766662 mod 500, _1766698 is 99-499 mod 100, _1766722=_1766724, option_else('trace-length', _1766736, 500), option_else('trace-depth', _1766744, 30))), '$restore_trace'(_1768898, _1768900))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] sig_atomic(system:'$notrace'(_1768898, _1768900))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 1323, 1323+1), 323 is 1323 mod 500, 0 is 99-499 mod 100, _1766722=_1766722, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 323>500), (set_debug(eval, false), _1766800 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1766800])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 323>500), (set_debug(eval, false), _1766800 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1766800])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(299) [user] nop(notrace(no_repeats_var(_1766852)))
   <span class="ansi1 ansi32"
>Exit: </span>(299) [user] nop(notrace(no_repeats_var(_1766852)))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [system] once(user:(notrace((flag(eval_num, 1323, 1323+1), 323 is 1323 mod 500, 0 is 99-499 mod 100, _1766722=_1766722, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 323>500), (set_debug(eval, false), _1766800 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1766800])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1766852)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] must_det_ll(user:(notrace((flag(eval_num, 1323, 1323+1), 323 is 1323 mod 500, 0 is 99-499 mod 100, _1766722=_1766722, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 323>500), (set_debug(eval, false), _1766800 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1766800])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1766852)))))
   <span class="ansi1 ansi32"
>Call: </span>(296) [occurs] occurs:sub_term(_1778550, e)
   <span class="ansi1 ansi32"
>Exit: </span>(296) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(296) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(297) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(296) [occurs] occurs:sub_term(_1778550, e)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] _1785656=e
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] if_trace((eval;e), (_1766722=1, indentq(0, 323, -->, [e, [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(298) [system] setup_call_cleanup('$notrace'(_1788796, _1788798), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _1766722=1, indentq(0, 323, -->, [e, [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]]))), _1788754, fbug((_1788754-->if_trace((eval;e), (_1766722=1, indentq(0, 323, -->, [e, [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]])))))))), '$restore_trace'(_1788796, _1788798))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] sig_atomic(system:'$notrace'(_1788796, _1788798))
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _1766722=1, indentq(0, 323, -->, [e, [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]]))), _1788754, fbug((_1788754-->if_trace((eval;e), (_1766722=1, indentq(0, 323, -->, [e, [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] if_trace((eval;e), (_1766722=1, indentq(0, 323, -->, [e, [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]])))
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] _1792992=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] _1795030=(\+ \+ (flag(eval_num, _1795050, _1795050+1), (retval(fail)\=@=retval(fail), nonvar(_1765608)->indentq(0, _1795050, <--, [e, _1765608]);indentq(0, _1795050, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] (\+ \+ (flag(eval_num, _1795050, _1795050+1), (retval(fail)\=@=retval(fail), nonvar(_1765608)->indentq(0, _1795050, <--, [e, _1765608]);indentq(0, _1795050, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _1795050, _1795050+1), (retval(fail)\=@=retval(fail), nonvar(_1765608)->indentq(0, _1795050, <--, [e, _1765608]);indentq(0, _1795050, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] call_cleanup(((call(eval_20(=, _1732584), 499, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _1765608)*->nb_setarg(1, retval(fail), _1765608);fail, trace, call(eval_20(=, _1732584), 499, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _1765608)), ignore(notrace((\+_1765608\=_1766852, nb_setarg(1, retval(fail), _1765608))))), ignore((_1766722==1->ignore(\+ \+ (flag(eval_num, _1795050, _1795050+1), (retval(fail)\=@=retval(fail), nonvar(_1765608)->indentq(0, _1795050, <--, [e, _1765608]);indentq(0, _1795050, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1795050, _1795050+1), (retval(fail)\=@=retval(fail), nonvar(_1765608)->indentq(0, _1795050, <--, [e, _1765608]);indentq(0, _1795050, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] eval_20(=, _1732584, 499, '&self', [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _1765608)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] atom([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] no_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] self_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_1802438, _1802440), once(user:self_eval0([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])), '$restore_trace'(_1802438, _1802440))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_1802438, _1802440))
^  <span class="ansi1 ansi31"
>Fail: </span>(300) [user] self_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] atomic(case)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] atomic(case)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] is_sl(case)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] number(case)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] [['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] callable(case)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] callable(case)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] [['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] is_list([['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] is_list([['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] is_list(case)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] is_list([['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] is_list([['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] is_list([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] is_list([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] once(expand_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _1824782))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] expand_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _1824782)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] is_list([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] is_list([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] ground(case)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] ground(case)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] apply:maplist(expand_eval, [['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _1830882)
   <span class="ansi1 ansi32"
>Call: </span>(302) [apply] apply:maplist_([['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], _1830882, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] expand_eval(['if-unify-or-empty', _591556, _591556], _1832938)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list(['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list(['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] apply:maplist(expand_eval, [_591556, _591556], _1838016)
   <span class="ansi1 ansi32"
>Call: </span>(305) [apply] apply:maplist_([_591556, _591556], _1838016, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] expand_eval(_591556, _1840072)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list(_591556)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _591556=_1840072
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] _591556=_591556
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] expand_eval(_591556, _591556)
   <span class="ansi1 ansi32"
>Call: </span>(306) [apply] apply:maplist_([_591556], _1840074, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] expand_eval(_591556, _1846174)
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] is_list(_591556)
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] _591556=_1846174
   <span class="ansi1 ansi32"
>Exit: </span>(308) [system] _591556=_591556
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] expand_eval(_591556, _591556)
   <span class="ansi1 ansi32"
>Call: </span>(307) [apply] apply:maplist_([], _1846176, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(306) [apply] apply:maplist_([_591556], [_591556], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(305) [apply] apply:maplist_([_591556, _591556], [_591556, _591556], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [apply] apply:maplist(user:expand_eval, [_591556, _591556], [_591556, _591556])
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] expand_eval(['if-unify-or-empty', _591556, _591556], ['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Call: </span>(303) [apply] apply:maplist_([[['Empty', _591574]]], _1832940, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] expand_eval([['Empty', _591574]], _1858398)
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] is_list([['Empty', _591574]])
   <span class="ansi1 ansi32"
>Exit: </span>(305) [system] is_list([['Empty', _591574]])
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] ground(['Empty', _591574])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] apply:maplist(expand_eval, [], _1861446)
   <span class="ansi1 ansi32"
>Call: </span>(306) [apply] apply:maplist_([], _1861446, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(306) [apply] apply:maplist_([], [], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [apply] apply:maplist(user:expand_eval, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] expand_eval([['Empty', _591574]], [['Empty', _591574]])
   <span class="ansi1 ansi32"
>Call: </span>(304) [apply] apply:maplist_([], _1858400, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [apply] apply:maplist_([[['Empty', _591574]]], [[['Empty', _591574]]], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [apply] apply:maplist_([['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], [['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [apply] apply:maplist(user:expand_eval, [['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], [['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] expand_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [system] once(user:expand_eval([case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]], [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]))
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] [case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]\==[case, ['if-unify-or-empty', _591556, _591556], [['Empty', _591574]]]
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] is_progn(case)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] is_space_op(case)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] must_det_ll([]==[])
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] once(user:([]==[]))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] []==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [system] once(user:([]==[]))
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] must_det_ll(user:([]==[]))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] into_case_list([['Empty', _591574]], _1886890)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] is_list([['Empty', _591574]])
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] is_list([['Empty', _591574]])
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] into_case_list([['Empty', _591574]], [['Empty', _591574]])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] into_case_keys(1, [['Empty', _591574]], _1890948)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] _1891988 is 1+1
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] 2 is 1+1
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] is_case(_1891978, ['Empty', _591574], _1891980)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] is_case('Empty', ['Empty', _591574], _591574)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_591574)))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_1897154, _1897156), once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_591574))), _1897112, fbug((_1897112-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_591574)))))))), '$restore_trace'(_1897154, _1897156))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_1897154, _1897156))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_591574))), _1897112, fbug((_1897112-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_591574)))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_591574)))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] into_case_keys(2, [], _1891974)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] into_case_keys(2, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] into_case_keys(1, [['Empty', _591574]], ['Empty'-_591574])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] eval_case(=, _1732584, 499, '&self', ['if-unify-or-empty', _591556, _591556], ['Empty'-_591574], _1765608)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _591556, _591556]))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_1906522, _1906524), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _591556, _591556]))), _1906480, fbug((_1906480-->if_trace(case, writeqln(case=['if-unify-or-empty', _591556, _591556]))))))), '$restore_trace'(_1906522, _1906524))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_1906522, _1906524))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _591556, _591556]))), _1906480, fbug((_1906480-->if_trace(case, writeqln(case=['if-unify-or-empty', _591556, _591556]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _591556, _591556]))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] eval_args(=, _1910844, 499, '&self', ['if-unify-or-empty', _591556, _591556], _1910718)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] var(['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_1912776, _1912778), once(user:self_eval(['if-unify-or-empty', _591556, _591556])), '$restore_trace'(_1912776, _1912778))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_1912776, _1912778))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_1914864, _1914866), once(user:nonvar(_1910718)), '$restore_trace'(_1914864, _1914866))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_1914864, _1914866))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_1916952, _1916954), once(user:nonvar(_1910718)), '$restore_trace'(_1916952, _1916954))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_1916952, _1916954))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] [_591556, _591556]==[]
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] self_eval(['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] setup_call_cleanup('$notrace'(_1924108, _1924110), once(user:self_eval0(['if-unify-or-empty', _591556, _591556])), '$restore_trace'(_1924108, _1924110))
^  <span class="ansi1 ansi32"
>Call: </span>(304) [system] sig_atomic(system:'$notrace'(_1924108, _1924110))
^  <span class="ansi1 ansi31"
>Fail: </span>(301) [user] self_eval(['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] eval_00(=, _1927196, 499, '&self', ['if-unify-or-empty', _591556, _591556], _1910718)
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] self_eval(['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(304) [system] setup_call_cleanup('$notrace'(_1929254, _1929256), once(user:self_eval0(['if-unify-or-empty', _591556, _591556])), '$restore_trace'(_1929254, _1929256))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] sig_atomic(system:'$notrace'(_1929254, _1929256))
^  <span class="ansi1 ansi31"
>Fail: </span>(302) [user] self_eval(['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] eval_01(=, _1927196, 499, '&self', ['if-unify-or-empty', _591556, _591556], _1910718)
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] ['if-unify-or-empty', _591556, _591556]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] ['if-unify-or-empty', _591556, _591556]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] if_t((499<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] 499<1
   <span class="ansi1 ansi31"
>Fail: </span>(305) [system] 499<1
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] if_t((499<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(304) [system] setup_call_cleanup('$notrace'(_1939528, _1939530), once(user:(_1939504 is 499-1, copy_term(['if-unify-or-empty', _591556, _591556], _1939518))), '$restore_trace'(_1939528, _1939530))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] sig_atomic(system:'$notrace'(_1939528, _1939530))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(498 is 499-1, copy_term(['if-unify-or-empty', _591556, _591556], ['if-unify-or-empty', _1941614, _1941614]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] trace_eval(eval_20(=, _1927196), e, 498, '&self', ['if-unify-or-empty', _591556, _591556], _1942656)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] must_det_ll((notrace((flag(eval_num, _1943710, _1943710+1), _1943728 is _1943710 mod 500, _1943746 is 99-498 mod 100, _1943770=_1943772, option_else('trace-length', _1943784, 500), option_else('trace-depth', _1943792, 30))), quietly(if_t((nop(stop_rtrace), _1943728>_1943784), (set_debug(eval, false), _1943848 is _1943784+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1943848])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1943900)))))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] once(user:(notrace((flag(eval_num, _1943710, _1943710+1), _1943728 is _1943710 mod 500, _1943746 is 99-498 mod 100, _1943770=_1943772, option_else('trace-length', _1943784, 500), option_else('trace-depth', _1943792, 30))), quietly(if_t((nop(stop_rtrace), _1943728>_1943784), (set_debug(eval, false), _1943848 is _1943784+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1943848])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1943900)))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_1945946, _1945948), once(user:(flag(eval_num, _1943710, _1943710+1), _1943728 is _1943710 mod 500, _1943746 is 99-498 mod 100, _1943770=_1943772, option_else('trace-length', _1943784, 500), option_else('trace-depth', _1943792, 30))), '$restore_trace'(_1945946, _1945948))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_1945946, _1945948))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 1324, 1324+1), 324 is 1324 mod 500, 1 is 99-498 mod 100, _1943770=_1943770, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 324>500), (set_debug(eval, false), _1943848 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1943848])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 324>500), (set_debug(eval, false), _1943848 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1943848])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(307) [user] nop(notrace(no_repeats_var(_1943900)))
   <span class="ansi1 ansi32"
>Exit: </span>(307) [user] nop(notrace(no_repeats_var(_1943900)))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] once(user:(notrace((flag(eval_num, 1324, 1324+1), 324 is 1324 mod 500, 1 is 99-498 mod 100, _1943770=_1943770, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 324>500), (set_debug(eval, false), _1943848 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1943848])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1943900)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] must_det_ll(user:(notrace((flag(eval_num, 1324, 1324+1), 324 is 1324 mod 500, 1 is 99-498 mod 100, _1943770=_1943770, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 324>500), (set_debug(eval, false), _1943848 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1943848])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1943900)))))
   <span class="ansi1 ansi32"
>Call: </span>(304) [occurs] occurs:sub_term(_1955598, e)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(304) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(305) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(304) [occurs] occurs:sub_term(_1955598, e)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _1962704=e
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] if_trace((eval;e), (_1943770=1, indentq(1, 324, -->, [e, ['if-unify-or-empty', _591556, _591556]])))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] setup_call_cleanup('$notrace'(_1965844, _1965846), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _1943770=1, indentq(1, 324, -->, [e, ['if-unify-or-empty', _591556, _591556]]))), _1965802, fbug((_1965802-->if_trace((eval;e), (_1943770=1, indentq(1, 324, -->, [e, ['if-unify-or-empty', _591556, _591556]])))))))), '$restore_trace'(_1965844, _1965846))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] sig_atomic(system:'$notrace'(_1965844, _1965846))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _1943770=1, indentq(1, 324, -->, [e, ['if-unify-or-empty', _591556, _591556]]))), _1965802, fbug((_1965802-->if_trace((eval;e), (_1943770=1, indentq(1, 324, -->, [e, ['if-unify-or-empty', _591556, _591556]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] if_trace((eval;e), (_1943770=1, indentq(1, 324, -->, [e, ['if-unify-or-empty', _591556, _591556]])))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _1970040=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _1972078=(\+ \+ (flag(eval_num, _1972098, _1972098+1), (retval(fail)\=@=retval(fail), nonvar(_1942656)->indentq(1, _1972098, <--, [e, _1942656]);indentq(1, _1972098, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] (\+ \+ (flag(eval_num, _1972098, _1972098+1), (retval(fail)\=@=retval(fail), nonvar(_1942656)->indentq(1, _1972098, <--, [e, _1942656]);indentq(1, _1972098, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _1972098, _1972098+1), (retval(fail)\=@=retval(fail), nonvar(_1942656)->indentq(1, _1972098, <--, [e, _1942656]);indentq(1, _1972098, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] call_cleanup(((call(eval_20(=, _1927196), 498, '&self', ['if-unify-or-empty', _591556, _591556], _1942656)*->nb_setarg(1, retval(fail), _1942656);fail, trace, call(eval_20(=, _1927196), 498, '&self', ['if-unify-or-empty', _591556, _591556], _1942656)), ignore(notrace((\+_1942656\=_1943900, nb_setarg(1, retval(fail), _1942656))))), ignore((_1943770==1->ignore(\+ \+ (flag(eval_num, _1972098, _1972098+1), (retval(fail)\=@=retval(fail), nonvar(_1942656)->indentq(1, _1972098, <--, [e, _1942656]);indentq(1, _1972098, <--, [e, retval(fail)]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1972098, _1972098+1), (retval(fail)\=@=retval(fail), nonvar(_1942656)->indentq(1, _1972098, <--, [e, _1942656]);indentq(1, _1972098, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_20(=, _1927196, 498, '&self', ['if-unify-or-empty', _591556, _591556], _1942656)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] atom(['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] no_eval(['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] self_eval(['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_1979486, _1979488), once(user:self_eval0(['if-unify-or-empty', _591556, _591556])), '$restore_trace'(_1979486, _1979488))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_1979486, _1979488))
^  <span class="ansi1 ansi31"
>Fail: </span>(308) [user] self_eval(['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] atomic('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(308) [system] atomic('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] is_sl('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] number('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] [_591556, _591556]==[]
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _1990680==eval
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] [_591556, _591556]==[]
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list([_591556, _591556])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] is_list([_591556, _591556])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list([_591556, _591556])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] is_list([_591556, _591556])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list(['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] is_list(['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] once(expand_eval(['if-unify-or-empty', _591556, _591556], _2002858))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] expand_eval(['if-unify-or-empty', _591556, _591556], _2002858)
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] is_list(['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Exit: </span>(309) [system] is_list(['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(309) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] apply:maplist(expand_eval, [_591556, _591556], _2008958)
   <span class="ansi1 ansi32"
>Call: </span>(310) [apply] apply:maplist_([_591556, _591556], _2008958, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] expand_eval(_591556, _2011014)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] is_list(_591556)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] _591556=_2011014
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] _591556=_591556
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] expand_eval(_591556, _591556)
   <span class="ansi1 ansi32"
>Call: </span>(311) [apply] apply:maplist_([_591556], _2011016, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] expand_eval(_591556, _2017116)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list(_591556)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _591556=_2017116
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] _591556=_591556
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] expand_eval(_591556, _591556)
   <span class="ansi1 ansi32"
>Call: </span>(312) [apply] apply:maplist_([], _2017118, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(312) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(311) [apply] apply:maplist_([_591556], [_591556], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [apply] apply:maplist_([_591556, _591556], [_591556, _591556], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [apply] apply:maplist(user:expand_eval, [_591556, _591556], [_591556, _591556])
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] expand_eval(['if-unify-or-empty', _591556, _591556], ['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [system] once(user:expand_eval(['if-unify-or-empty', _591556, _591556], ['if-unify-or-empty', _591556, _591556]))
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] ['if-unify-or-empty', _591556, _591556]\==['if-unify-or-empty', _591556, _591556]
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] is_progn('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] is_space_op('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] arg(_2034538, v('catch!', 'throw!', 'number-of!', 'limit!', 'offset!', 'max-time!', 'findall!', 'setup-call-cleanup!', 'call-cleanup!', 'call-cleanup!', 'with-output-to!'), 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _2035436='if-unify-or-empty'
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] 'if-unify-or-empty'='if-unify-or-empty'
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _2037470)
^  <span class="ansi1 ansi31"
>Fail: </span>(307) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _2037470)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list(['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] is_list(['if-unify-or-empty', _591556, _591556])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] apply:maplist(self_eval, ['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Call: </span>(308) [apply] apply:maplist_(['if-unify-or-empty', _591556, _591556], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] self_eval('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] setup_call_cleanup('$notrace'(_2044604, _2044606), once(user:self_eval0('if-unify-or-empty')), '$restore_trace'(_2044604, _2044606))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] sig_atomic(system:'$notrace'(_2044604, _2044606))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0('if-unify-or-empty')), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] self_eval('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(309) [apply] apply:maplist_([_591556, _591556], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] self_eval(_591556)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_2050758, _2050760), once(user:self_eval0(_591556)), '$restore_trace'(_2050758, _2050760))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_2050758, _2050760))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_591556)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] self_eval(_591556)
   <span class="ansi1 ansi32"
>Call: </span>(310) [apply] apply:maplist_([_591556], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] self_eval(_591556)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] setup_call_cleanup('$notrace'(_2056912, _2056914), once(user:self_eval0(_591556)), '$restore_trace'(_2056912, _2056914))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(system:'$notrace'(_2056912, _2056914))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_591556)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] self_eval(_591556)
   <span class="ansi1 ansi32"
>Call: </span>(311) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(311) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [apply] apply:maplist_([_591556], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(309) [apply] apply:maplist_([_591556, _591556], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(308) [apply] apply:maplist_(['if-unify-or-empty', _591556, _591556], user:self_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [apply] apply:maplist(user:self_eval, ['if-unify-or-empty', _591556, _591556])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] ['if-unify-or-empty', _591556, _591556]=[_2067130|_2067132]
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] ['if-unify-or-empty', _591556, _591556]=['if-unify-or-empty', _591556, _591556]
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _2071190=do_more_defs(true)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] do_more_defs(true)=do_more_defs(true)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] clause(eval_21(=, _1927196, 498, '&self', ['if-unify-or-empty', _591556, _591556], _1942656), _2073242)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] 'if-unify-or-empty'==(/)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] 'if-unify-or-empty'== ===
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] 'if-unify-or-empty'== ====
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] eval_40(=, _1927196, 498, '&self', ['if-unify-or-empty', _591556, _591556], _2077314)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] eval_selfless(=, _1927196, 498, '&self', ['if-unify-or-empty', _591556, _591556], _2077314)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_selfless_0(['if-unify-or-empty', _591556, _591556], _2077314)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] is_assignment('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(311) [system] atom('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] eval_selfless_1(['if-unify-or-empty', _591556, _591556], _2077314)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] allow_clp
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] false_flag
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(313) [system] fail
^  <span class="ansi1 ansi31"
>Fail: </span>(312) [user] false_flag
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] eval_selfless_2(['if-unify-or-empty', _591556, _591556], _2077314)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] fake_notrace((ground(['if-unify-or-empty', _591556, _591556]), ['if-unify-or-empty', _591556, _591556]=[_2092538, _2092544, _2092550], atom(_2092538), catch_warn(current_op(_2092576, yfx, _2092538)), ['if-unify-or-empty', _591556, _591556]\=[_2092596], s2ps(['if-unify-or-empty', _591556, _591556], _2092604)))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] real_notrace(user:(ground(['if-unify-or-empty', _591556, _591556]), ['if-unify-or-empty', _591556, _591556]=[_2092538, _2092544, _2092550], atom(_2092538), catch_warn(current_op(_2092576, yfx, _2092538)), ['if-unify-or-empty', _591556, _591556]\=[_2092596], s2ps(['if-unify-or-empty', _591556, _591556], _2092604)))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] setup_call_cleanup('$notrace'(_2094638, _2094640), once(user:(ground(['if-unify-or-empty', _591556, _591556]), ['if-unify-or-empty', _591556, _591556]=[_2092538, _2092544, _2092550], atom(_2092538), catch_warn(current_op(_2092576, yfx, _2092538)), ['if-unify-or-empty', _591556, _591556]\=[_2092596], s2ps(['if-unify-or-empty', _591556, _591556], _2092604))), '$restore_trace'(_2094638, _2094640))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(user:'$notrace'(_2094638, _2094640))
^  <span class="ansi1 ansi31"
>Fail: </span>(312) [user] real_notrace(user:(ground(['if-unify-or-empty', _17304, _17304]), ['if-unify-or-empty', _17304, _17304]=[_19352, _19358, _19364], atom(_19352), catch_warn(current_op(_19390, yfx, _19352)), ['if-unify-or-empty', _17304, _17304]\=[_19410], s2ps(['if-unify-or-empty', _17304, _17304], _19418)))
^  <span class="ansi1 ansi31"
>Fail: </span>(311) [user] fake_notrace(user:(ground(['if-unify-or-empty', _17304, _17304]), ['if-unify-or-empty', _17304, _17304]=[_19352, _19358, _19364], atom(_19352), catch_warn(current_op(_19390, yfx, _19352)), ['if-unify-or-empty', _17304, _17304]\=[_19410], s2ps(['if-unify-or-empty', _17304, _17304], _19418)))
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] 'if-unify-or-empty'==(==)
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] 'if-unify-or-empty'==(==)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] eval_41(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_adjust_args(=, _18996, _30372, _19326, 498, '&self', ['if-unify-or-empty', _17304, _17304], _30374)
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _18996, _30372, _19326, 498, '&self', ['if-unify-or-empty', _17304, _17304], _30374)), eval_adjust_args1(=, _18996, _30372, _19326, 498, '&self', ['if-unify-or-empty', _17304, _17304], _30374))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval_adjust_args2(=, _18996, _30372, _19326, 498, '&self', ['if-unify-or-empty', _17304, _17304], _30374)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] apply:maplist(must_eval_args(=, _37528, 498, '&self'), [_17304, _17304], _37522)
   <span class="ansi1 ansi32"
>Call: </span>(314) [apply] apply:maplist_([_17304, _17304], _37522, user:must_eval_args(=, _37528, 498, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] must_eval_args(=, _37528, 498, '&self', _17304, _39588)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] was_option_value(nodebug, _50752)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] current_prolog_flag(nodebug, _51770)
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] current_prolog_flag(nodebug, _51770)
   <span class="ansi1 ansi32"
>Call: </span>(321) [$syspreds] prolog_load_context(nodebug, _53804)
   <span class="ansi1 ansi31"
>Fail: </span>(321) [$syspreds] prolog_load_context(nodebug, _53804)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] nb_current(nodebug, _55838)
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] nb_current(nodebug, _55838)
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [user] was_option_value(nodebug, _50752)
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_61950, _61952), once(user:option_value0(nodebug, true)), '$restore_trace'(_61950, _61952))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_61950, _61952))
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(317) [prolog_debug] prolog_debug:debugging(metta(eval_args), _82290)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [prolog_debug] prolog_debug:debugging(metta(eval_args), _82290, _83434)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_87400, _87402, _87404), defined)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(320) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_87400, _87402, _87404))
   <span class="ansi1 ansi32"
>Call: </span>(321) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_87400, _87402, _87404))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] callable(debugging_logicmoo_setting(_87400, _87402, _87404))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] callable(debugging_logicmoo_setting(_87400, _87402, _87404))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(321) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_87400, _87402, _87404))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_87400, _87402, _87404))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_87400, _87402, _87404), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _82290, _99584)
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(317) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_args(=, _37528, 498, '&self', _17304, _39588)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] var(_17304)
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] var(_17304)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] nonvar(_39588)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_110810, _110812), once(user:self_eval(_17304)), '$restore_trace'(_110810, _110812))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_110810, _110812))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_17304)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] _39588=_17304
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] _17304=_17304
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] eval_args(=, _37528, 498, '&self', _17304, _17304)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] must_eval_args(=, _37528, 498, '&self', _17304, _17304)
   <span class="ansi1 ansi32"
>Call: </span>(315) [apply] apply:maplist_([_17304], _39590, user:must_eval_args(=, _37528, 498, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] must_eval_args(=, _37528, 498, '&self', _17304, _119074)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] was_option_value(nodebug, _130238)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] current_prolog_flag(nodebug, _131256)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [system] current_prolog_flag(nodebug, _131256)
   <span class="ansi1 ansi32"
>Call: </span>(322) [$syspreds] prolog_load_context(nodebug, _133290)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [$syspreds] prolog_load_context(nodebug, _133290)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] nb_current(nodebug, _135324)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [system] nb_current(nodebug, _135324)
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] was_option_value(nodebug, _130238)
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_141436, _141438), once(user:option_value0(nodebug, true)), '$restore_trace'(_141436, _141438))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_141436, _141438))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(318) [prolog_debug] prolog_debug:debugging(metta(eval_args), _161776)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [prolog_debug] prolog_debug:debugging(metta(eval_args), _161776, _162920)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_166886, _166888, _166890), defined)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(321) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(321) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_166886, _166888, _166890))
   <span class="ansi1 ansi32"
>Call: </span>(322) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_166886, _166888, _166890))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] callable(debugging_logicmoo_setting(_166886, _166888, _166890))
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] callable(debugging_logicmoo_setting(_166886, _166888, _166890))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_166886, _166888, _166890))
   <span class="ansi1 ansi32"
>Exit: </span>(321) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_166886, _166888, _166890))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_166886, _166888, _166890), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _161776, _179070)
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(318) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] eval_args(=, _37528, 498, '&self', _17304, _119074)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] var(_17304)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] var(_17304)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nonvar(_119074)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_190296, _190298), once(user:self_eval(_17304)), '$restore_trace'(_190296, _190298))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_190296, _190298))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_17304)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] _119074=_17304
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] _17304=_17304
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [user] eval_args(=, _37528, 498, '&self', _17304, _17304)
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] must_eval_args(=, _37528, 498, '&self', _17304, _17304)
   <span class="ansi1 ansi32"
>Call: </span>(316) [apply] apply:maplist_([], _119076, user:must_eval_args(=, _37528, 498, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(316) [apply] apply:maplist_([], [], user:must_eval_args(=, _37528, 498, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(315) [apply] apply:maplist_([_17304], [_17304], user:must_eval_args(=, _37528, 498, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(314) [apply] apply:maplist_([_17304, _17304], [_17304, _17304], user:must_eval_args(=, _37528, 498, '&self'))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [apply] apply:maplist(user:must_eval_args(=, _37528, 498, '&self'), [_17304, _17304], [_17304, _17304])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _30372=_19326
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] _19326=_19326
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] eval_adjust_args2(=, _18996, _19326, _19326, 498, '&self', ['if-unify-or-empty', _17304, _17304], ['if-unify-or-empty', _17304, _17304])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _18996, _19326, _19326, 498, '&self', ['if-unify-or-empty', _17304, _17304], ['if-unify-or-empty', _17304, _17304])), eval_adjust_args1(=, _18996, _19326, _19326, 498, '&self', ['if-unify-or-empty', _17304, _17304], ['if-unify-or-empty', _17304, _17304]))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_adjust_args(=, _18996, _19326, _19326, 498, '&self', ['if-unify-or-empty', _17304, _17304], ['if-unify-or-empty', _17304, _17304])
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] if_trace((e;args), (['if-unify-or-empty', _17304, _17304]\==['if-unify-or-empty', _17304, _17304]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _17304, _17304]->['if-unify-or-empty', _17304, _17304])));nop(indentq2(498, same(['if-unify-or-empty', _17304, _17304])))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] setup_call_cleanup('$notrace'(_208882, _208884), once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _17304, _17304]\==['if-unify-or-empty', _17304, _17304]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _17304, _17304]->['if-unify-or-empty', _17304, _17304])));nop(indentq2(498, same(['if-unify-or-empty', _17304, _17304])))))), _208840, fbug((_208840-->if_trace((e;args), (['if-unify-or-empty', _17304, _17304]\==['if-unify-or-empty', _17304, _17304]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _17304, _17304]->['if-unify-or-empty', _17304, _17304])));nop(indentq2(498, same(['if-unify-or-empty', _17304, _17304])))))))))), '$restore_trace'(_208882, _208884))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] sig_atomic(system:'$notrace'(_208882, _208884))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _17304, _17304]\==['if-unify-or-empty', _17304, _17304]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _17304, _17304]->['if-unify-or-empty', _17304, _17304])));nop(indentq2(498, same(['if-unify-or-empty', _17304, _17304])))))), _208840, fbug((_208840-->if_trace((e;args), (['if-unify-or-empty', _17304, _17304]\==['if-unify-or-empty', _17304, _17304]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _17304, _17304]->['if-unify-or-empty', _17304, _17304])));nop(indentq2(498, same(['if-unify-or-empty', _17304, _17304])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] if_trace((e;args), (['if-unify-or-empty', _17304, _17304]\==['if-unify-or-empty', _17304, _17304]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _17304, _17304]->['if-unify-or-empty', _17304, _17304])));nop(indentq2(498, same(['if-unify-or-empty', _17304, _17304])))))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_70(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326)
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] if_or_else(eval_maybe_python(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326), if_or_else(eval_maybe_host_predicate(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326), if_or_else(eval_maybe_host_function(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326), if_or_else(eval_maybe_defn(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326), eval_maybe_subst(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326)))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] eval_maybe_python(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326)
   <span class="ansi1 ansi32"
>Call: </span>(312) [user] metta_atom('&self', ['registered-python-function', _216242, _216248, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] typed_list('&self', _217388, _217262)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(313) [user] typed_list('&self', _220432, _217262)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] metta_atom_in_file('&self', ['registered-python-function', _216242, _216248, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] metta_atom_in_file('&self', ['registered-python-function', _216242, _216248, 'if-unify-or-empty'], _223486, _223488)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] loaded_into_kb('&self', _224384)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] loaded_into_kb('&self', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] once(user:asserted_metta_pred(_230344, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] asserted_metta_pred(_230344, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] asserted_metta_pred(_230344, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] metta_atom_asserted('&self', ['registered-python-function', _216242, _216248, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] metta_atom_asserted_deduced('&self', ['registered-python-function', _216242, _216248, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] metta_atom('&corelib', ['registered-python-function', _216242, _216248, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] typed_list('&corelib', _254386, _254260)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] typed_list('&corelib', _257430, _254260)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] metta_atom_in_file('&corelib', ['registered-python-function', _216242, _216248, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] metta_atom_in_file('&corelib', ['registered-python-function', _216242, _216248, 'if-unify-or-empty'], _260484, _260486)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] loaded_into_kb('&corelib', _261382)
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] once(user:asserted_metta_pred(_267326, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] asserted_metta_pred(_267326, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] asserted_metta_pred(_267326, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] once(user:asserted_metta_pred(_287008, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] asserted_metta_pred(_287008, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] asserted_metta_pred(_287008, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(314) [user] metta_atom_asserted('&corelib', ['registered-python-function', _216242, _216248, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] metta_atom_asserted_deduced('&corelib', ['registered-python-function', _216242, _216248, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(311) [user] if_or_else(eval_maybe_host_predicate(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326), if_or_else(eval_maybe_host_function(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326), if_or_else(eval_maybe_defn(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326), eval_maybe_subst(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326))))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval_maybe_host_predicate(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] once((is_system_pred('if-unify-or-empty'), length([_17304, _17304], _311892), is_syspred('if-unify-or-empty', _311892, _311900)))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom_concat(_316084, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom_concat(_319128, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom_concat(_322172, '-p', 'if-unify-or-empty')
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [user] if_or_else(eval_maybe_host_function(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326), if_or_else(eval_maybe_defn(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326), eval_maybe_subst(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326)))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval_maybe_host_function(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom_concat(_331284, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom_concat(_334328, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom_concat(_337372, '-p', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] if_or_else(eval_maybe_defn(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326), eval_maybe_subst(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] eval_maybe_defn(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _17304, _17304])
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _17304, _17304])
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] trace_eval(eval_defn_choose_candidates(=, _18996), defn, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] must_det_ll((notrace((flag(eval_num, _347412, _347412+1), _347430 is _347412 mod 500, _347448 is 99-498 mod 100, _347472=_347474, option_else('trace-length', _347486, 500), option_else('trace-depth', _347494, 30))), quietly(if_t((nop(stop_rtrace), _347430>_347486), (set_debug(eval, false), _347550 is _347486+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_347550])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_347602)))))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] once(user:(notrace((flag(eval_num, _347412, _347412+1), _347430 is _347412 mod 500, _347448 is 99-498 mod 100, _347472=_347474, option_else('trace-length', _347486, 500), option_else('trace-depth', _347494, 30))), quietly(if_t((nop(stop_rtrace), _347430>_347486), (set_debug(eval, false), _347550 is _347486+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_347550])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_347602)))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_349648, _349650), once(user:(flag(eval_num, _347412, _347412+1), _347430 is _347412 mod 500, _347448 is 99-498 mod 100, _347472=_347474, option_else('trace-length', _347486, 500), option_else('trace-depth', _347494, 30))), '$restore_trace'(_349648, _349650))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_349648, _349650))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 1325, 1325+1), 325 is 1325 mod 500, 1 is 99-498 mod 100, _347472=_347472, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 325>500), (set_debug(eval, false), _347550 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_347550])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 325>500), (set_debug(eval, false), _347550 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_347550])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(319) [user] nop(notrace(no_repeats_var(_347602)))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [user] nop(notrace(no_repeats_var(_347602)))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [system] once(user:(notrace((flag(eval_num, 1325, 1325+1), 325 is 1325 mod 500, 1 is 99-498 mod 100, _347472=_347472, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 325>500), (set_debug(eval, false), _347550 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_347550])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_347602)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] must_det_ll(user:(notrace((flag(eval_num, 1325, 1325+1), 325 is 1325 mod 500, 1 is 99-498 mod 100, _347472=_347472, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 325>500), (set_debug(eval, false), _347550 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_347550])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_347602)))))
   <span class="ansi1 ansi32"
>Call: </span>(316) [occurs] occurs:sub_term(_359300, defn)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [occurs] occurs:sub_term(defn, defn)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] defn\=defn
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] defn\=defn
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(316) [occurs] occurs:sub_term(_359300, defn)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] _366406=defn
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] defn=defn
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] if_trace((eval;defn), (_347472=1, indentq(1, 325, -->, [defn, ['if-unify-or-empty', _17304, _17304]])))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_369546, _369548), once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _347472=1, indentq(1, 325, -->, [defn, ['if-unify-or-empty', _17304, _17304]]))), _369504, fbug((_369504-->if_trace((eval;defn), (_347472=1, indentq(1, 325, -->, [defn, ['if-unify-or-empty', _17304, _17304]])))))))), '$restore_trace'(_369546, _369548))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_369546, _369548))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _347472=1, indentq(1, 325, -->, [defn, ['if-unify-or-empty', _17304, _17304]]))), _369504, fbug((_369504-->if_trace((eval;defn), (_347472=1, indentq(1, 325, -->, [defn, ['if-unify-or-empty', _17304, _17304]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] if_trace((eval;defn), (_347472=1, indentq(1, 325, -->, [defn, ['if-unify-or-empty', _17304, _17304]])))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] _373742=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] _375780=(\+ \+ (flag(eval_num, _375800, _375800+1), (retval(fail)\=@=retval(fail), nonvar(_19326)->indentq(1, _375800, <--, [defn, _19326]);indentq(1, _375800, <--, [defn, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] (\+ \+ (flag(eval_num, _375800, _375800+1), (retval(fail)\=@=retval(fail), nonvar(_19326)->indentq(1, _375800, <--, [defn, _19326]);indentq(1, _375800, <--, [defn, retval(fail)]))))=(\+ \+ (flag(eval_num, _375800, _375800+1), (retval(fail)\=@=retval(fail), nonvar(_19326)->indentq(1, _375800, <--, [defn, _19326]);indentq(1, _375800, <--, [defn, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] call_cleanup(((call(eval_defn_choose_candidates(=, _18996), 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326)*->nb_setarg(1, retval(fail), _19326);fail, trace, call(eval_defn_choose_candidates(=, _18996), 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326)), ignore(notrace((\+_19326\=_347602, nb_setarg(1, retval(fail), _19326))))), ignore((_347472==1->ignore(\+ \+ (flag(eval_num, _375800, _375800+1), (retval(fail)\=@=retval(fail), nonvar(_19326)->indentq(1, _375800, <--, [defn, _19326]);indentq(1, _375800, <--, [defn, retval(fail)]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _375800, _375800+1), (retval(fail)\=@=retval(fail), nonvar(_19326)->indentq(1, _375800, <--, [defn, _19326]);indentq(1, _375800, <--, [defn, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] eval_defn_choose_candidates(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] findall((_380142->_380144), get_defn_expansions(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _380142, _380144), _380162)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [$bags] findall((_380142->_380144), user:get_defn_expansions(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _380142, _380144), _380162, [])
^  <span class="ansi1 ansi32"
>Call: </span>(321) [$bags] cleanup_bag(findall_loop((_380142->_380144), user:get_defn_expansions(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _380142, _380144), _380162, []), '$destroy_findall_bag')
   <span class="ansi1 ansi32"
>Call: </span>(322) [$bags] findall_loop((_380142->_380144), user:get_defn_expansions(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _380142, _380144), _380162, [])
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] get_defn_expansions(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _380142, _380144)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] same_len_copy([_17304, _17304], _385334)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] length([_17304, _17304], _386352)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(_386352)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] var(_386352)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] []==[]
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _386352=2
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] 2=2
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] length([_17304, _17304], 2)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] length(_385334, 2)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(2)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] integer(2)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] integer(2)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _385334==[]
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(_385334)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] var(_385334)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] length([_401576, _401582], 2)
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [user] same_len_copy([_17304, _17304], [_401576, _401582])
   <span class="ansi1 ansi32"
>Call: </span>(324) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _401576, _401582], _380144)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] ignore((=)=(=))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] (=)=(=)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] (=)=(=)
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] ignore(user:((=)=(=)))
   <span class="ansi1 ansi32"
>Call: </span>(325) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _401576, _401582], _380144]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _401576, _401582], _380144]))
   <span class="ansi1 ansi32"
>Call: </span>(326) [user] metta_atom('&self', [=, ['if-unify-or-empty', _401576, _401582], _380144])
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] typed_list('&self', _410898, _410772)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(328) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(327) [user] typed_list('&self', _413942, _410772)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _401576, _401582], _380144])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _401576, _401582], _380144], _416996, _416998)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] loaded_into_kb('&self', _417894)
^  <span class="ansi1 ansi32"
>Exit: </span>(329) [user] loaded_into_kb('&self', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] once(user:asserted_metta_pred(_423854, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] asserted_metta_pred(_423854, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(330) [user] asserted_metta_pred(_423854, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(327) [user] metta_atom_asserted('&self', [=, ['if-unify-or-empty', _401576, _401582], _380144])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] metta_atom_asserted_deduced('&self', [=, ['if-unify-or-empty', _401576, _401582], _380144])
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(327) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _401576, _401582], _380144])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] typed_list('&corelib', _447896, _447770)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(329) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(328) [user] typed_list('&corelib', _450940, _447770)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _401576, _401582], _380144])
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _401576, _401582], _380144], _453994, _453996)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] loaded_into_kb('&corelib', _454892)
^  <span class="ansi1 ansi32"
>Exit: </span>(330) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] once(user:asserted_metta_pred(_460836, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] asserted_metta_pred(_460836, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(331) [user] asserted_metta_pred(_460836, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Exit: </span>(330) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] once(user:asserted_metta_pred(_480518, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] asserted_metta_pred(_480518, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(331) [user] asserted_metta_pred(_480518, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(328) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _401576, _401582], _380144])
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] metta_atom_asserted_deduced('&corelib', [=, ['if-unify-or-empty', _401576, _401582], _380144])
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] fail
   <span class="ansi1 ansi32"
>Exit: </span>(328) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _401576, _401576], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(327) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _401576, _401576], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(326) [user] metta_atom('&self', [=, ['if-unify-or-empty', _401576, _401576], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _401576, _401576], unified]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _401576, _401576], unified]))
   <span class="ansi1 ansi32"
>Exit: </span>(324) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _401576, _401576], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] get_defn_expansions(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], ['if-unify-or-empty', _401576, _401576], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _401576, _401582], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(327) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _401576, _401582], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(326) [user] metta_atom('&self', [=, ['if-unify-or-empty', _401576, _401582], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _401576, _401582], [empty]]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _401576, _401582], [empty]]))
   <span class="ansi1 ansi32"
>Exit: </span>(324) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _401576, _401582], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] get_defn_expansions(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], ['if-unify-or-empty', _401576, _401582], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(322) [$bags] findall_loop((_380142->_380144), user:get_defn_expansions(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _380142, _380144), [(['if-unify-or-empty', _513522, _513522]->unified), (['if-unify-or-empty', _513486, _513492]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [$bags] cleanup_bag('$bags':findall_loop((_380142->_380144), user:get_defn_expansions(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _380142, _380144), [(['if-unify-or-empty', _513522, _513522]->unified), (['if-unify-or-empty', _513486, _513492]->[empty])], []), '$bags':'$destroy_findall_bag')
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [$bags] findall((_380142->_380144), user:get_defn_expansions(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _380142, _380144), [(['if-unify-or-empty', _513522, _513522]->unified), (['if-unify-or-empty', _513486, _513492]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [$bags] findall((_380142->_380144), user:get_defn_expansions(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _380142, _380144), [(['if-unify-or-empty', _513522, _513522]->unified), (['if-unify-or-empty', _513486, _513492]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_defn_bodies(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326, [(['if-unify-or-empty', _513522, _513522]->unified), (['if-unify-or-empty', _513486, _513492]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _513522, _513522]->unified), (['if-unify-or-empty', _513486, _513492]->[empty])]))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_519754, _519756), once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(498, '   '), [(['if-unify-or-empty', _513522, _513522]->unified), (['if-unify-or-empty', _513486, _513492]->[empty])]))), _519712, fbug((_519712-->if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _513522, _513522]->unified), (['if-unify-or-empty', _513486, _513492]->[empty])]))))))), '$restore_trace'(_519754, _519756))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_519754, _519756))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(498, '   '), [(['if-unify-or-empty', _513522, _513522]->unified), (['if-unify-or-empty', _513486, _513492]->[empty])]))), _519712, fbug((_519712-->if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _513522, _513522]->unified), (['if-unify-or-empty', _513486, _513492]->[empty])]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _513522, _513522]->unified), (['if-unify-or-empty', _513486, _513492]->[empty])]))
   <span class="ansi1 ansi32"
>Call: </span>(320) [user] if_or_else((member((_523964->_523966), [(['if-unify-or-empty', _513522, _513522]->unified), (['if-unify-or-empty', _513486, _513492]->[empty])]), copy_term((_523964->_523966), _523978), eval_defn_success(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326, _523964, _523966, _523978)), eval_defn_failure(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326))
   <span class="ansi1 ansi32"
>Call: </span>(322) [lists] lists:member((_523964->_523966), [(['if-unify-or-empty', _513522, _513522]->unified), (['if-unify-or-empty', _513486, _513492]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(323) [lists] lists:member_([(['if-unify-or-empty', _513486, _513492]->[empty])], (_523964->_523966), (['if-unify-or-empty', _513522, _513522]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(323) [lists] lists:member_([(['if-unify-or-empty', _513486, _513492]->[empty])], (['if-unify-or-empty', _513522, _513522]->unified), (['if-unify-or-empty', _513522, _513522]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [lists] lists:member((['if-unify-or-empty', _513522, _513522]->unified), [(['if-unify-or-empty', _513522, _513522]->unified), (['if-unify-or-empty', _513486, _513492]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] copy_term((['if-unify-or-empty', _513522, _513522]->unified), _523978)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] copy_term((['if-unify-or-empty', _513522, _513522]->unified), (['if-unify-or-empty', _530128, _530128]->unified))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] eval_defn_success(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326, ['if-unify-or-empty', _513522, _513522], unified, (['if-unify-or-empty', _530128, _530128]->unified))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] ['if-unify-or-empty', _17304, _17304]=['if-unify-or-empty', _513522, _513522]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] ['if-unify-or-empty', _17304, _17304]=['if-unify-or-empty', _17304, _17304]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _19326=unified
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] unified=unified
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] ['if-unify-or-empty', _17304, _17304]\=@=unified
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] ['if-unify-or-empty', _17304, _17304]\=@=unified
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _530128, _530128]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_539376, _539378), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _530128, _530128]->unified)))))), _539334, fbug((_539334-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _530128, _530128]->unified)))))))))), '$restore_trace'(_539376, _539378))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_539376, _539378))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _530128, _530128]->unified)))))), _539334, fbug((_539334-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _530128, _530128]->unified)))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _530128, _530128]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] light_eval(=, _18996, 498, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] light_eval(=, _18996, 498, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] eval_defn_success(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified, ['if-unify-or-empty', _17304, _17304], unified, (['if-unify-or-empty', _530128, _530128]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_or_else((member((['if-unify-or-empty', _17304, _17304]->unified), [(['if-unify-or-empty', _17304, _17304]->unified), (['if-unify-or-empty', _513486, _513492]->[empty])]), copy_term((['if-unify-or-empty', _17304, _17304]->unified), (['if-unify-or-empty', _530128, _530128]->unified)), eval_defn_success(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified, ['if-unify-or-empty', _17304, _17304], unified, (['if-unify-or-empty', _530128, _530128]->unified))), eval_defn_failure(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] eval_defn_bodies(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified, [(['if-unify-or-empty', _17304, _17304]->unified), (['if-unify-or-empty', _513486, _513492]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] eval_defn_choose_candidates(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] ignore(notrace((\+unified\=_347602, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_552824, _552826), once(user:(\+unified\=_347602, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_552824, _552826))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_552824, _552826))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_347602, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] ignore(user:notrace((\+unified\=_347602, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _18996), 498, '&self', ['if-unify-or-empty', _17304, _17304], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_defn_choose_candidates(=, _18996), 498, '&self', ['if-unify-or-empty', _17304, _17304], unified)), ignore(notrace((\+unified\=_347602, nb_setarg(1, retval(unified), unified))))), user:ignore((_347472==1->ignore(\+ \+ (flag(eval_num, _375800, _375800+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _375800, <--, [defn, unified]);indentq(1, _375800, <--, [defn, retval(unified)]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _375800, _375800+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _375800, <--, [defn, unified]);indentq(1, _375800, <--, [defn, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] trace_eval(eval_defn_choose_candidates(=, _18996), defn, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] eval_maybe_defn(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [user] if_or_else(eval_maybe_defn(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified), eval_maybe_subst(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified))
   <span class="ansi1 ansi32"
>Exit: </span>(312) [user] if_or_else(eval_maybe_host_function(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified), if_or_else(eval_maybe_defn(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified), eval_maybe_subst(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified)))
   <span class="ansi1 ansi32"
>Exit: </span>(311) [user] if_or_else(eval_maybe_host_predicate(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified), if_or_else(eval_maybe_host_function(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified), if_or_else(eval_maybe_defn(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified), eval_maybe_subst(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified))))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else(eval_maybe_python(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified), if_or_else(eval_maybe_host_predicate(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified), if_or_else(eval_maybe_host_function(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified), if_or_else(eval_maybe_defn(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified), eval_maybe_subst(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_70(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] check_returnval(=, _18996, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] check_returnval(=, _18996, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] eval_41(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] eval_40(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] unified=_19026
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_20(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified)
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(306) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] ignore(notrace((\+unified\=_19042, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_577354, _577356), once(user:(\+unified\=_19042, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_577354, _577356))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_577354, _577356))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_19042, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] ignore(user:notrace((\+unified\=_19042, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [system] call_cleanup(user:((call(eval_20(=, _18996), 498, '&self', ['if-unify-or-empty', _17304, _17304], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_20(=, _18996), 498, '&self', ['if-unify-or-empty', _17304, _17304], unified)), ignore(notrace((\+unified\=_19042, nb_setarg(1, retval(unified), unified))))), user:ignore((_19034==1->ignore(\+ \+ (flag(eval_num, _19072, _19072+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _19072, <--, [e, unified]);indentq(1, _19072, <--, [e, retval(unified)]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _19072, _19072+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _19072, <--, [e, unified]);indentq(1, _19072, <--, [e, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] trace_eval(eval_20(=, _18996), e, 498, '&self', ['if-unify-or-empty', _17304, _17304], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] self_eval(unified)
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_586588, _586590), once(user:self_eval0(unified)), '$restore_trace'(_586588, _586590))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_586588, _586590))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(unified)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] self_eval(unified)
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] _18994=unified
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [user] eval_01(=, _18996, 499, '&self', ['if-unify-or-empty', _17304, _17304], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] eval_00(=, _18996, 499, '&self', ['if-unify-or-empty', _17304, _17304], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] eval_args(=, _18996, 499, '&self', ['if-unify-or-empty', _17304, _17304], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_596906, _596908), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _596864, fbug((_596864-->if_trace(case, writeqln(switch=unified))))))), '$restore_trace'(_596906, _596908))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_596906, _596908))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _596864, fbug((_596864-->if_trace(case, writeqln(switch=unified))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] select_case(499, '&self', unified, ['Empty'-_17322], _601102)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] best_key(unified, ['Empty'-_17322], _601102)
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_603154-_601102, ['Empty'-_17322])
   <span class="ansi1 ansi32"
>Call: </span>(303) [lists] lists:member_([], _603154-_601102, 'Empty'-_17322)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [lists] lists:member_([], 'Empty'-_17322, 'Empty'-_17322)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [lists] lists:member('Empty'-_17322, ['Empty'-_17322])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] unified='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_608248-_601102, ['Empty'-_17322])
   <span class="ansi1 ansi32"
>Call: </span>(303) [lists] lists:member_([], _608248-_601102, 'Empty'-_17322)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [lists] lists:member_([], 'Empty'-_17322, 'Empty'-_17322)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [lists] lists:member('Empty'-_17322, ['Empty'-_17322])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] unified=='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_613342-_601102, ['Empty'-_17322])
   <span class="ansi1 ansi32"
>Call: </span>(303) [lists] lists:member_([], _613342-_601102, 'Empty'-_17322)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [lists] lists:member_([], 'Empty'-_17322, 'Empty'-_17322)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [lists] lists:member('Empty'-_17322, ['Empty'-_17322])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] unified=@='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_618436-_601102, ['Empty'-_17322])
   <span class="ansi1 ansi32"
>Call: </span>(303) [lists] lists:member_([], _618436-_601102, 'Empty'-_17322)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [lists] lists:member_([], 'Empty'-_17322, 'Empty'-_17322)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [lists] lists:member('Empty'-_17322, ['Empty'-_17322])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] unified='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] maybe_special_keys(499, '&self', ['Empty'-_17322], _623528)
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] eval_args(499, '&self', 'Empty', _624562)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_args(=, _625714, 499, '&self', 'Empty', _624562)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] var('Empty')
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_627646, _627648), once(user:self_eval('Empty')), '$restore_trace'(_627646, _627648))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_627646, _627648))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval('Empty')), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _624562='Empty'
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] 'Empty'='Empty'
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] eval_args(=, _632948, 499, '&self', 'Empty', 'Empty')
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [user] eval_args(499, '&self', 'Empty', 'Empty')
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] 'Empty'\=@='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] maybe_special_keys(499, '&self', [], _623528)
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [user] maybe_special_keys(499, '&self', [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] maybe_special_keys(499, '&self', ['Empty'-_17322], [])
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] best_key(unified, [], _601102)
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_639990-_601102, [])
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_641012-_601102, [])
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_642034-_601102, [])
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_643056-_601102, [])
   <span class="ansi1 ansi32"
>Call: </span>(301) [lists] lists:member(_644078-_601102, [])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member(_645100-_645102, ['Empty'-_17322])
   <span class="ansi1 ansi32"
>Call: </span>(301) [lists] lists:member_([], _645100-_645102, 'Empty'-_17322)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [lists] lists:member_([], 'Empty'-_17322, 'Empty'-_17322)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member('Empty'-_17322, ['Empty'-_17322])
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] 'Empty'=='%void%'
   <span class="ansi1 ansi32"
>Call: </span>(324) [lists] lists:member_([], (_523964->_523966), (['if-unify-or-empty', _513486, _513492]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(324) [lists] lists:member_([], (['if-unify-or-empty', _513486, _513492]->[empty]), (['if-unify-or-empty', _513486, _513492]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(323) [lists] lists:member_([(['if-unify-or-empty', _513486, _513492]->[empty])], (['if-unify-or-empty', _513486, _513492]->[empty]), (['if-unify-or-empty', _513522, _513522]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [lists] lists:member((['if-unify-or-empty', _513486, _513492]->[empty]), [(['if-unify-or-empty', _513522, _513522]->unified), (['if-unify-or-empty', _513486, _513492]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] copy_term((['if-unify-or-empty', _513486, _513492]->[empty]), _523978)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] copy_term((['if-unify-or-empty', _513486, _513492]->[empty]), (['if-unify-or-empty', _655300, _655306]->[empty]))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] eval_defn_success(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], _19326, ['if-unify-or-empty', _513486, _513492], [empty], (['if-unify-or-empty', _655300, _655306]->[empty]))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] ['if-unify-or-empty', _17304, _17304]=['if-unify-or-empty', _513486, _513492]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] ['if-unify-or-empty', _17304, _17304]=['if-unify-or-empty', _17304, _17304]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _19326=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] [empty]=[empty]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] ['if-unify-or-empty', _17304, _17304]\=@=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] ['if-unify-or-empty', _17304, _17304]\=@=[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _655300, _655306]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_664548, _664550), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _655300, _655306]->[empty])))))), _664506, fbug((_664506-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _655300, _655306]->[empty])))))))))), '$restore_trace'(_664548, _664550))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_664548, _664550))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _655300, _655306]->[empty])))))), _664506, fbug((_664506-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _655300, _655306]->[empty])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _655300, _655306]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] light_eval(=, _18996, 498, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] light_eval(=, _18996, 498, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] eval_defn_success(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty], ['if-unify-or-empty', _17304, _17304], [empty], (['if-unify-or-empty', _655300, _655306]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_or_else((member((['if-unify-or-empty', _17304, _17304]->[empty]), [(['if-unify-or-empty', _513522, _513522]->unified), (['if-unify-or-empty', _17304, _17304]->[empty])]), copy_term((['if-unify-or-empty', _17304, _17304]->[empty]), (['if-unify-or-empty', _655300, _655306]->[empty])), eval_defn_success(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty], ['if-unify-or-empty', _17304, _17304], [empty], (['if-unify-or-empty', _655300, _655306]->[empty]))), eval_defn_failure(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty]))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] eval_defn_bodies(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty], [(['if-unify-or-empty', _513522, _513522]->unified), (['if-unify-or-empty', _17304, _17304]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] eval_defn_choose_candidates(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] ignore(notrace((\+[empty]\=_347602, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_678004, _678006), once(user:(\+[empty]\=_347602, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_678004, _678006))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_678004, _678006))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_347602, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] ignore(user:notrace((\+[empty]\=_347602, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] ignore((_347472==1->ignore(\+ \+ (flag(eval_num, _375800, _375800+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _375800, <--, [defn, [empty]]);indentq(1, _375800, <--, [defn, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _375800, _375800+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _375800, <--, [defn, [empty]]);indentq(1, _375800, <--, [defn, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _347472==1
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] _347472==1
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_685196, _685198), once(user:ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _375800, _375800+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _375800, <--, [defn, [empty]]);indentq(1, _375800, <--, [defn, retval([empty])])))))))), '$restore_trace'(_685196, _685198))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_685196, _685198))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _375800, _375800+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _375800, <--, [defn, [empty]]);indentq(1, _375800, <--, [defn, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] ignore(user:(_347472==1->ignore(\+ \+ (flag(eval_num, _375800, _375800+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _375800, <--, [defn, [empty]]);indentq(1, _375800, <--, [defn, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _375800, _375800+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _375800, <--, [defn, [empty]]);indentq(1, _375800, <--, [defn, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _18996), 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_defn_choose_candidates(=, _18996), 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty])), ignore(notrace((\+[empty]\=_347602, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_347472==1->ignore(\+ \+ (flag(eval_num, _375800, _375800+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _375800, <--, [defn, [empty]]);indentq(1, _375800, <--, [defn, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _375800, _375800+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _375800, <--, [defn, [empty]]);indentq(1, _375800, <--, [defn, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] trace_eval(eval_defn_choose_candidates(=, _18996), defn, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] eval_maybe_defn(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [user] if_or_else(eval_maybe_defn(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty]), eval_maybe_subst(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(312) [user] if_or_else(eval_maybe_host_function(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty]), if_or_else(eval_maybe_defn(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty]), eval_maybe_subst(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty])))
   <span class="ansi1 ansi32"
>Exit: </span>(311) [user] if_or_else(eval_maybe_host_predicate(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty]), if_or_else(eval_maybe_host_function(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty]), if_or_else(eval_maybe_defn(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty]), eval_maybe_subst(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty]))))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else(eval_maybe_python(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty]), if_or_else(eval_maybe_host_predicate(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty]), if_or_else(eval_maybe_host_function(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty]), if_or_else(eval_maybe_defn(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty]), eval_maybe_subst(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty])))))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_70(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] check_returnval(=, _18996, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] check_returnval(=, _18996, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] eval_41(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] eval_40(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] [empty]=_19026
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] [empty]=[empty]
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_20(=, _18996, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(306) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] ignore(notrace((\+[empty]\=_19042, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_709900, _709902), once(user:(\+[empty]\=_19042, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_709900, _709902))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_709900, _709902))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_19042, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] ignore(user:notrace((\+[empty]\=_19042, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] ignore((_19034==1->ignore(\+ \+ (flag(eval_num, _19072, _19072+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _19072, <--, [e, [empty]]);indentq(1, _19072, <--, [e, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _19072, _19072+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _19072, <--, [e, [empty]]);indentq(1, _19072, <--, [e, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] _19034==1
   <span class="ansi1 ansi31"
>Fail: </span>(308) [system] _19034==1
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_717092, _717094), once(user:ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _19072, _19072+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _19072, <--, [e, [empty]]);indentq(1, _19072, <--, [e, retval([empty])])))))))), '$restore_trace'(_717092, _717094))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_717092, _717094))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _19072, _19072+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _19072, <--, [e, [empty]]);indentq(1, _19072, <--, [e, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] ignore(user:(_19034==1->ignore(\+ \+ (flag(eval_num, _19072, _19072+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _19072, <--, [e, [empty]]);indentq(1, _19072, <--, [e, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _19072, _19072+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _19072, <--, [e, [empty]]);indentq(1, _19072, <--, [e, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [system] call_cleanup(user:((call(eval_20(=, _18996), 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_20(=, _18996), 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty])), ignore(notrace((\+[empty]\=_19042, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_19034==1->ignore(\+ \+ (flag(eval_num, _19072, _19072+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _19072, <--, [e, [empty]]);indentq(1, _19072, <--, [e, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _19072, _19072+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _19072, <--, [e, [empty]]);indentq(1, _19072, <--, [e, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] trace_eval(eval_20(=, _18996), e, 498, '&self', ['if-unify-or-empty', _17304, _17304], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_726492, _726494), once(user:self_eval0([empty])), '$restore_trace'(_726492, _726494))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_726492, _726494))
^  <span class="ansi1 ansi31"
>Fail: </span>(303) [user] self_eval([empty])
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] [empty]=@=['if-unify-or-empty', _19010, _19010]
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_01(=, _18996, 498, '&self', [empty], _730596)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [empty]\==[empty]
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member(_732654-_732656, ['Empty'-_17322])
   <span class="ansi1 ansi32"
>Call: </span>(301) [lists] lists:member_([], _732654-_732656, 'Empty'-_17322)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [lists] lists:member_([], 'Empty'-_17322, 'Empty'-_17322)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member('Empty'-_17322, ['Empty'-_17322])
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi31"
>Fail: </span>(298) [user] eval_20(=, _18574, 499, '&self', [case, ['if-unify-or-empty', _17304, _17304], [['Empty', _17322]]], _18676)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(298) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] ignore((_18684==1->ignore(\+ \+ (flag(eval_num, _18722, _18722+1), (retval(fail)\=@=retval(fail), nonvar(_18676)->indentq(0, _18722, <--, [e, _18676]);indentq(0, _18722, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _18722, _18722+1), (retval(fail)\=@=retval(fail), nonvar(_18676)->indentq(0, _18722, <--, [e, _18676]);indentq(0, _18722, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] _18684==1
   <span class="ansi1 ansi31"
>Fail: </span>(300) [system] _18684==1
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] setup_call_cleanup('$notrace'(_743850, _743852), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _18722, _18722+1), (retval(fail)\=@=retval(fail), nonvar(_18676)->indentq(0, _18722, <--, [e, _18676]);indentq(0, _18722, <--, [e, retval(fail)])))))))), '$restore_trace'(_743850, _743852))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] sig_atomic(system:'$notrace'(_743850, _743852))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _18722, _18722+1), (retval(fail)\=@=retval(fail), nonvar(_18676)->indentq(0, _18722, <--, [e, _18676]);indentq(0, _18722, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [system] ignore(user:(_18684==1->ignore(\+ \+ (flag(eval_num, _18722, _18722+1), (retval(fail)\=@=retval(fail), nonvar(_18676)->indentq(0, _18722, <--, [e, _18676]);indentq(0, _18722, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _18722, _18722+1), (retval(fail)\=@=retval(fail), nonvar(_18676)->indentq(0, _18722, <--, [e, _18676]);indentq(0, _18722, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(296) [system] call_cleanup(user:((call(eval_20(=, _18574), 499, '&self', [case, ['if-unify-or-empty', _17304, _17304], [['Empty', _17322]]], _18676)*->nb_setarg(1, retval(fail), _18676);fail, trace, call(eval_20(=, _18574), 499, '&self', [case, ['if-unify-or-empty', _17304, _17304], [['Empty', _17322]]], _18676)), ignore(notrace((\+_18676\=_18692, nb_setarg(1, retval(fail), _18676))))), user:ignore((_18684==1->ignore(\+ \+ (flag(eval_num, _18722, _18722+1), (retval(fail)\=@=retval(fail), nonvar(_18676)->indentq(0, _18722, <--, [e, _18676]);indentq(0, _18722, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _18722, _18722+1), (retval(fail)\=@=retval(fail), nonvar(_18676)->indentq(0, _18722, <--, [e, _18676]);indentq(0, _18722, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(295) [user] trace_eval(eval_20(=, _18574), e, 499, '&self', [case, ['if-unify-or-empty', _17304, _17304], [['Empty', _17322]]], _18676)
^  <span class="ansi1 ansi31"
>Fail: </span>(292) [user] eval_args(=, _18574, 500, '&self', [case, ['if-unify-or-empty', _17304, _17304], [['Empty', _17322]]], _18026)
^  <span class="ansi1 ansi31"
>Fail: </span>(283) [system] call(user:once, user:if_or_else(eval(=, _18006, 497, '&self', [case, ['if-unify-or-empty', _17304, _17304], [['Empty', _17322]]], _18026), call(eval, [case, ['if-unify-or-empty', _17304, _17304], [['Empty', _17322]]], _18026)))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(285) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(287) [system] setup_call_cleanup('$notrace'(_755312, _755314), once(rtrace:retract(t_l:tracer_reset(_755302))), '$restore_trace'(_755312, _755314))
^  <span class="ansi1 ansi32"
>Call: </span>(288) [system] sig_atomic(system:'$notrace'(_755312, _755314))
^  <span class="ansi1 ansi32"
>Exit: </span>(287) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(287) [rtrace] tAt(false, 271, 271, false)
; 
; EVAL TEST
; took 0.678 secs. (677.80 milliseconds) 

!(assertEqual (match &self $1 $1) (get-atoms &self))

<span class="ansi1 ansi90"
>Info: Processing progress: 100% </span><span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta progress.
</span>
Script done on 2024-12-01 11:00:53+00:00 [COMMAND_EXIT_CODE="143"]

</pre>
</body>

</html>
\033[1;33mCompleted (EXITCODE=143) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat/' --timeout=40 --html --repl=false  --test "tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta" --halt=true\033[0m
