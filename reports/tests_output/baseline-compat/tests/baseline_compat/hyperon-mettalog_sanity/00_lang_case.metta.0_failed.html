<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi36 { color: #00aaaa; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2025-02-03 19:01:14+00:00 [COMMAND="timeout --preserve-status --foreground 40 swipl  /home/runner/work/metta-testsuite/metta-testsuite/prolog/metta_lang/metta_interp.pl -- --python=enable -- --timeout=40 --output=/home/runner/work/metta-testsuite/metta-testsuite/reports/tests_output/baseline-compat --html --test tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta --halt=true  --stdin=tty --stdout=tty --stderr=tty" TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
^@P;HTML|
;         [set_debug transpiler false]

P;HTML|
;          [set_debug overtime 4.0]

P;HTML|
;          [set_debug overflow 1000]

P;HTML|
;          [set_debug eval false]

P;HTML|
;          [set_debug load silent]

P;HTML|
;          [set_debug trace-on-load false]

P;HTML|
;          [set_debug exec false]

P;HTML|
;          [set_debug error non-type]

P;HTML|
;          [set_debug fail false]

P;HTML|
;          [set_debug test true]

P;HTML|
;         [set_debug test false]

P;HTML|
;         [set_debug fail false]

P;HTML|
;         [set_debug load false]

; [ : user [load_metta_file &self tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta] ]
;;; cases are processed sequentially
<span class="ansi38-013099040"
>!(assertEqual (+ 1 (superpose (1 2 3))) (+ 1 (superpose (1 2 3))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.01"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.01</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.12 milliseconds) 

!(assertEqual (+ 1 (superpose (1 2 3))) (+ 1 (superpose (1 2 3))))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (2 3 4) 
      (2 3 4)]]
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqual (+ 1 (superpose (1 2 3))) (+ 1 (superpose (1 (superpose (2 3))))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.02"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.02</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.92 milliseconds) 

!(assertEqual (+ 1 (superpose (1 2 3))) (+ 1 (superpose (1 (superpose (2 3))))))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (2 3 4) 
      (2 3 4)]]
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqual ((superpose (1 2 3))) ((superpose (1 (superpose ((+ 1 1) 3))))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.03"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.03</h3>
; 
; EVAL TEST
; took 0.003 secs. (2.70 milliseconds) 

!(assertEqual ((superpose (1 2 3))) ((superpose (1 (superpose ((+ 1 1) 3))))))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (1) 
        (2) 
        (3)) 
      ( (1) 
        (2) 
        (3))]]
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; cases are processed sequentially
<span class="ansi38-013099040"
>!(assertEqual (case (+ 1 5) ((5 Error) (6 OK) (6 Error))) OK)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.04"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.04</h3>
; 
; EVAL TEST
; took 0.000771 secs. (770.91 microseconds) 

!(assertEqual (case (+ 1 5) ((5 Error) (6 OK) (6 Error))) OK)

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (OK) 
      (OK)]]
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; we can use variables as cases
<span class="ansi38-013099040"
>!(assertEqual (case (+ 1 5) (($x (+ 1 $x)))) 7)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.05"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.05</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.13 milliseconds) 

!(assertEqual (case (+ 1 5) (($x (+ 1 $x)))) 7)

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (7) 
      (7)]]
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; cases are not necessarily exhaustive,
;;; and the result can be empty
<span class="ansi38-013099040"
>!(assertEqual (case 5 ((6 OK))) (superpose ()))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.06"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.06</h3>
; 
; EVAL TEST
; took 0.000276 secs. (276.17 microseconds) 

!(assertEqual (case 5 ((6 OK))) (superpose ()))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn () ()]]
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; it is non-deterministic: each value is matched against all cases
<span class="ansi38-013099040"
>!(assertEqual (case (+ 1 (superpose (1 2 3))) ((3 OK-3) (4 OK-4))) (superpose (OK-3 OK-4)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.07"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.07</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.32 milliseconds) 

!(assertEqual (case (+ 1 (superpose (1 2 3))) ((3 OK-3) (4 OK-4))) (superpose (OK-3 OK-4)))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (OK-3 OK-4) 
      (OK-3 OK-4)]]
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; one case can produce multiple results
<span class="ansi38-013099040"
>!(assertEqual (case (+ 1 (superpose (1 2 3))) (($x (+ 1 $x)))) (superpose (3 4 5)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.08"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.08</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.41 milliseconds) 

!(assertEqual (case (+ 1 (superpose (1 2 3))) (($x (+ 1 $x)))) (superpose (3 4 5)))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (3 4 5) 
      (3 4 5)]]
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqualToResult (superpose ()) ())

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.09"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.09</h3>
; 
; EVAL TEST
; took 0.000126 secs. (125.53 microseconds) 

!(assertEqualToResult (superpose ()) ())

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn () ()]]
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqualToResult (collapse (superpose ())) (()))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.10"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.10</h3>
; 
; EVAL TEST
; took 0.000270 secs. (269.73 microseconds) 

!(assertEqualToResult (collapse (superpose ())) (()))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (()) 
      (())]]
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqualToResult (superpose ((nop 1))) ())

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.11"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.11</h3>
; 
; EVAL TEST
; took 0.000233 secs. (232.98 microseconds) 

!(assertEqualToResult (superpose ((nop 1))) ())

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (()) ()]]
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqualToResult (collapse (superpose ((nop 1)))) (()))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.12"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.12</h3>
; 
; EVAL TEST
; took 0.000431 secs. (431.30 microseconds) 

!(assertEqualToResult (collapse (superpose ((nop 1)))) (()))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (())) 
      (())]]
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-255165000"
> (= (Rel-P P P P)  10)
</span><span class="ansi38-255165000"
> (Rel-P A B)
</span><span class="ansi38-255165000"
> (Rel-Q A C)
</span><span class="ansi38-013099040"
>!(match &self $1 $1)

</span>
N(1): <span class="ansi33"
>(= (Rel-P P P P)  10)
</span>
N(2): <span class="ansi33"
>(Rel-P A B)
</span>
N(3): <span class="ansi33"
>(Rel-Q A C)
</span>
N(4): <span class="ansi33"
>&corelib
</span>
N(5): <span class="ansi33"
>&stdlib
</span>
N(6): <span class="ansi33"
>(@doc Any (@desc "The universal type; any value belongs to this type."))
</span>
N(7): <span class="ansi33"
>(: Any Type)
</span>
N(8): <span class="ansi33"
>(@doc Atom (@desc "Type representing any atom."))
</span>
N(9): <span class="ansi33"
>(: Atom Type)
</span>
N(10): <span class="ansi33"
>(@doc LazyEvaluatable (@desc "A type of Atom/Value that hyperon does not implicitly evaluate"))
</span>
N(11): <span class="ansi33"
>(: LazyEvaluatable Type)
</span>
N(12): <span class="ansi33"
>(:> Atom LazyEvaluatable)
</span>
N(13): <span class="ansi33"
>(@doc Bool (@desc "Boolean type of True or False."))
</span>
N(14): <span class="ansi33"
>(: Bool Type)
</span>
N(15): <span class="ansi33"
>(@doc LazyBool (@desc "A LazyEvaluatable that when evaluated returns True or False."))
</span>
N(16): <span class="ansi33"
>(: LazyBool Type)
</span>
N(17): <span class="ansi33"
>(:> LazyBool LazyEvaluatable)
</span>
N(18): <span class="ansi33"
>(@doc Expression (@desc "Type representing an S-Expression, which is a combination of atoms."))
</span>
N(19): <span class="ansi33"
>(: Expression Type)
</span>
N(20): <span class="ansi33"
>(:> Expression LazyEvaluatable)
</span>
N(21): <span class="ansi33"
>(@doc Number (@desc "Numeric type, including integers and floating-point numbers."))
</span>
N(22): <span class="ansi33"
>(: Number Type)
</span>
N(23): <span class="ansi33"
>(@doc hyperon::space::DynSpace (@desc "Dynamic space type, representing an Atomspace."))
</span>
N(24): <span class="ansi33"
>(: hyperon::space::DynSpace Type)
</span>
N(25): <span class="ansi33"
>(@doc ReturnType (@desc "Type representing a function's return value."))
</span>
N(26): <span class="ansi33"
>(: ReturnType Type)
</span>
N(27): <span class="ansi33"
>(@doc Symbol (@desc "Type representing a symbol or identifier."))
</span>
N(28): <span class="ansi33"
>(: Symbol Type)
</span>
N(29): <span class="ansi33"
>(@doc StateMonad (@desc "Type representing a state monad, used for encapsulating stateful computations."))
</span>
N(30): <span class="ansi33"
>(: StateMonad Type)
</span>
N(31): <span class="ansi33"
>(@doc Type (@desc "Type representing a type."))
</span>
N(32): <span class="ansi33"
>(: Type Type)
</span>
N(33): <span class="ansi33"
>(@doc True (@desc "Boolean value representing truth."))
</span>
N(34): <span class="ansi33"
>(: True Bool)
</span>
N(35): <span class="ansi33"
>(@doc False (@desc "Boolean value representing falsehood."))
</span>
N(36): <span class="ansi33"
>(: False Bool)
</span>
N(37): <span class="ansi33"
>(@doc %Undefined% (@desc "Special type representing an undefined value or type."))
</span>
N(38): <span class="ansi33"
>(: %Undefined% Type)
</span>
N(39): <span class="ansi33"
>(@doc Variable (@desc "Type representing a variable in the language."))
</span>
N(40): <span class="ansi33"
>(: Variable Type)
</span>
N(41): <span class="ansi33"
>(@doc : (@desc "Type declarion operator"))
</span>
N(42): <span class="ansi33"
>(@doc <: (@desc "Super Type declarion operator"))
</span>
N(43): <span class="ansi33"
>(: : %Undefined%)
</span>
N(44): <span class="ansi33"
>(: if-empty (-> Atom Atom Atom Atom))
</span>
N(45): <span class="ansi33"
>(: if-non-empty-expression (-> Atom Atom Atom Atom))
</span>
N(46): <span class="ansi33"
>(: if-not-reducible (-> Atom Atom Atom Atom))
</span>
N(47): <span class="ansi33"
>(: return (-> Atom ReturnType))
</span>
N(48): <span class="ansi33"
>(: switch (-> %Undefined% Expression Atom))
</span>
N(49): <span class="ansi33"
>(: unify (-> Atom Atom Atom Atom %Undefined%))
</span>
N(50): <span class="ansi33"
>(: get-vtype (-> Atom Atom))
</span>
N(51): <span class="ansi33"
>(: get-vtype (-> Atom hyperon::space::DynSpace Atom))
</span>
N(52): <span class="ansi33"
>(: get-types (-> Atom Atom))
</span>
N(53): <span class="ansi33"
>(: get-types (-> Atom hyperon::space::DynSpace Atom))
</span>
N(54): <span class="ansi33"
>(: get-dtype (-> Atom Atom))
</span>
N(55): <span class="ansi33"
>(: get-dtype (-> Atom hyperon::space::DynSpace Atom))
</span>
N(56): <span class="ansi33"
>(: get-ftype (-> Atom Atom))
</span>
N(57): <span class="ansi33"
>(: get-ftype (-> Atom hyperon::space::DynSpace Atom))
</span>
N(58): <span class="ansi33"
>(: pragma! (-> Atom Atom (->)))
</span>
N(59): <span class="ansi33"
>(: match (-> hyperon::space::DynSpace Atom Atom %Undefined%))
</span>
N(60): <span class="ansi33"
>(: combine (-> $t $t $t))
</span>
N(61): <span class="ansi33"
>(: import! (-> hyperon::space::DynSpace Atom (->)))
</span>
N(62): <span class="ansi33"
>(@doc type-check (@desc "The value of type-check determines MeTTa's type-checking behavior. Set via pragma!. When set to auto (i.e. !(pragma! type-check auto)), types are checked immediately on adding an expression to the space. By default, when unset (or set to anything other than auto), types are checked only on evaluation. For example !(+ 1 \"2\") would trigger a type violation, but (= (foo $x) (+ $x \"2\")) would not, unless type-check is set to auto, in which case both would trigger type violations."))
</span>
N(63): <span class="ansi33"
>(: type-check Symbol)
</span>
N(64): <span class="ansi33"
>(iz predicate-arity MeTTaLog)
</span>
N(65): <span class="ansi33"
>(@doc predicate-arity (@desc "Specifies the arity (number of arguments) for a given predicate, allowing it to be queriable in the system's match framework. This is particularly useful for enabling built-in functions, such as `size-atom`, to be used as predicates in declarative contexts and run in reverse to compute inputs based on outputs.\n\n\nFor example:\n  ; Enable the built-in function `size-atom` that takes an atom and returns the size\n    as a predicate with arity 2\n  (predicate-arity size-atom 2)\n\n\n  ; Now `size-atom` can be used as a predicate in pattern matching\n  !(match &dyn-space '(size-atom (a b c) $size) \n         (The abc tuple was len $size))\n  ; This pattern will resolve `Size = 3` and execute the action.\n\n\nAdditionally, by running `size-atom` in reverse, you can compute a new atom based on a desired size:\n  !(match &dyn-space '(size-atom $new-atom 4) \n         (The new atom is $new-atom))\n  ; This resolves `$new-atom` to a tuple of size 4, such as ($1 $2 $3 $4).\n\n\nThis reverse functionality is made possible because predicates can describe relationships, allowing you to infer inputs from outputs.") (@params ((@param "Predicate symbol" "The name of the predicate whose arity is being defined."))) (@return "The number of arguments required for the predicate."))
</span>
N(66): <span class="ansi33"
>(: predicate-arity (-> Symbol Number))
</span>
N(67): <span class="ansi33"
>(predicate-arity predicate-arity 2)
</span>
N(68): <span class="ansi33"
>(function-arity predicate-arity 1)
</span>
N(69): <span class="ansi33"
>(@doc function-arity (@desc "Defines the arity of a function, allowing predicates or built-in facts to also behave as callable functions. This enables procedural-style execution where the last argument of the predicate becomes the function's return value, and the system internally resolves the function using a `match` query. \n\n\nFor example:\n  ; Declare the built-in predicate `max` with arity 3\n  (predicate-arity max 3)\n\n  ; Enable `max` as a function\n  (function-arity max 2)\n\n\n  ; Define the rules for `max`\n  (= (max $X $Y $Y) (<= $X $Y))\n  (= (max $X $Y $X) (> $X $Y))\n\n\n  ; Using `max` declaratively as a predicate\n  !(match &self (max (5 10) $max)\n         (The maximum is $max))\n  [(The maximum is 10)]\n\n\n  ; Using `max` procedurally as a function\n  !(max 5 10)\n  [10]\n  \n\n\n  ; Reverse execution with `max`\n  !(let True (== (max $a $b) 10) ($a $b)) ; as a function\n  [(#(exists $a (=< $a 10)) 10), (10 #(exists $b (=< 10 $b )))]\n  !(match &self (max $a $b 10) ($a $b)) ; or as a predicate\n  [(#(exists $a (=< $a 10)) 10), (10 #(exists $b (=< 10 $b )))]\n\n\n  This dual behavior allows predicates to act as functions, bridging procedural and declarative paradigms. By defining `function-arity`, the function automatically resolves using the logic of the associated predicate.") (@params ((@param "Function symbol" "The name of the function or predicate to enable as a callable function."))) (@return "The number of arguments expected by the function."))
</span>
N(70): <span class="ansi33"
>(: function-arity (-> Symbol Number))
</span>
N(71): <span class="ansi33"
>(predicate-arity function-arity 2)
</span>
N(72): <span class="ansi33"
>(function-arity function-arity 1)
</span>
N(73): <span class="ansi33"
>(iz MettaMorph-If MeTTaMorph)
</span>
N(74): <span class="ansi33"
>(@doc MettaMorph-If (@desc "Conditional function that evaluates and returns one of the provided atoms based on a boolean condition.") (@params ((@param "Boolean condition") (@param "Atom to return if condition is True") (@param "Atom to return if condition is False (optional)"))) (@return "Either the second or third argument depending on the condition"))
</span>
N(75): <span class="ansi33"
>(: MettaMorph-If (-> Bool Atom Atom Atom))
</span>
N(76): <span class="ansi33"
>(: MettaMorph-If (-> Bool Atom Atom))
</span>
N(77): <span class="ansi33"
>(= (MettaMorph-If True $then)  $then)
</span>
N(78): <span class="ansi33"
>(= (MettaMorph-If False $then)  
  (let $n 0 
    (let $n 1 $n)))
</span>
N(79): <span class="ansi33"
>(= (MettaMorph-If $cond $then $else)  
  (if $cond $then $else))
</span>
N(80): <span class="ansi33"
>(iz SrcPredicate MeTTa)
</span>
N(81): <span class="ansi33"
>(@doc SrcPredicate (@desc "Type representing a source predicate."))
</span>
N(82): <span class="ansi33"
>(: SrcPredicate Type)
</span>
N(83): <span class="ansi33"
>(iz SrcFunction MeTTa)
</span>
N(84): <span class="ansi33"
>(@doc SrcFunction (@desc "Type representing a source function."))
</span>
N(85): <span class="ansi33"
>(: SrcFunction Type)
</span>
N(86): <span class="ansi33"
>(iz MeTTaResult MeTTa)
</span>
N(87): <span class="ansi33"
>(@doc MeTTaResult (@desc "Type representing the result of a MeTTa evaluation."))
</span>
N(88): <span class="ansi33"
>(: MeTTaResult Type)
</span>[error metta_NotReducible [file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta] (match &self $1 $1)]
<span class="ansi38-013099040"
>!(get-atoms &self)

</span>
N(1): <span class="ansi33"
>(= (Rel-P P P P)  10)
</span>
N(2): <span class="ansi33"
>(Rel-P A B)
</span>
N(3): <span class="ansi33"
>(Rel-Q A C)
</span>
N(4): <span class="ansi33"
>&corelib
</span>
N(5): <span class="ansi33"
>&stdlib
</span>
N(6): <span class="ansi33"
>(@doc Any (@desc "The universal type; any value belongs to this type."))
</span>
N(7): <span class="ansi33"
>(: Any Type)
</span>
N(8): <span class="ansi33"
>(@doc Atom (@desc "Type representing any atom."))
</span>
N(9): <span class="ansi33"
>(: Atom Type)
</span>
N(10): <span class="ansi33"
>(@doc LazyEvaluatable (@desc "A type of Atom/Value that hyperon does not implicitly evaluate"))
</span>
N(11): <span class="ansi33"
>(: LazyEvaluatable Type)
</span>
N(12): <span class="ansi33"
>(:> Atom LazyEvaluatable)
</span>
N(13): <span class="ansi33"
>(@doc Bool (@desc "Boolean type of True or False."))
</span>
N(14): <span class="ansi33"
>(: Bool Type)
</span>
N(15): <span class="ansi33"
>(@doc LazyBool (@desc "A LazyEvaluatable that when evaluated returns True or False."))
</span>
N(16): <span class="ansi33"
>(: LazyBool Type)
</span>
N(17): <span class="ansi33"
>(:> LazyBool LazyEvaluatable)
</span>
N(18): <span class="ansi33"
>(@doc Expression (@desc "Type representing an S-Expression, which is a combination of atoms."))
</span>
N(19): <span class="ansi33"
>(: Expression Type)
</span>
N(20): <span class="ansi33"
>(:> Expression LazyEvaluatable)
</span>
N(21): <span class="ansi33"
>(@doc Number (@desc "Numeric type, including integers and floating-point numbers."))
</span>
N(22): <span class="ansi33"
>(: Number Type)
</span>
N(23): <span class="ansi33"
>(@doc hyperon::space::DynSpace (@desc "Dynamic space type, representing an Atomspace."))
</span>
N(24): <span class="ansi33"
>(: hyperon::space::DynSpace Type)
</span>
N(25): <span class="ansi33"
>(@doc ReturnType (@desc "Type representing a function's return value."))
</span>
N(26): <span class="ansi33"
>(: ReturnType Type)
</span>
N(27): <span class="ansi33"
>(@doc Symbol (@desc "Type representing a symbol or identifier."))
</span>
N(28): <span class="ansi33"
>(: Symbol Type)
</span>
N(29): <span class="ansi33"
>(@doc StateMonad (@desc "Type representing a state monad, used for encapsulating stateful computations."))
</span>
N(30): <span class="ansi33"
>(: StateMonad Type)
</span>
N(31): <span class="ansi33"
>(@doc Type (@desc "Type representing a type."))
</span>
N(32): <span class="ansi33"
>(: Type Type)
</span>
N(33): <span class="ansi33"
>(@doc True (@desc "Boolean value representing truth."))
</span>
N(34): <span class="ansi33"
>(: True Bool)
</span>
N(35): <span class="ansi33"
>(@doc False (@desc "Boolean value representing falsehood."))
</span>
N(36): <span class="ansi33"
>(: False Bool)
</span>
N(37): <span class="ansi33"
>(@doc %Undefined% (@desc "Special type representing an undefined value or type."))
</span>
N(38): <span class="ansi33"
>(: %Undefined% Type)
</span>
N(39): <span class="ansi33"
>(@doc Variable (@desc "Type representing a variable in the language."))
</span>
N(40): <span class="ansi33"
>(: Variable Type)
</span>
N(41): <span class="ansi33"
>(@doc : (@desc "Type declarion operator"))
</span>
N(42): <span class="ansi33"
>(@doc <: (@desc "Super Type declarion operator"))
</span>
N(43): <span class="ansi33"
>(: : %Undefined%)
</span>
N(44): <span class="ansi33"
>(: if-empty (-> Atom Atom Atom Atom))
</span>
N(45): <span class="ansi33"
>(: if-non-empty-expression (-> Atom Atom Atom Atom))
</span>
N(46): <span class="ansi33"
>(: if-not-reducible (-> Atom Atom Atom Atom))
</span>
N(47): <span class="ansi33"
>(: return (-> Atom ReturnType))
</span>
N(48): <span class="ansi33"
>(: switch (-> %Undefined% Expression Atom))
</span>
N(49): <span class="ansi33"
>(: unify (-> Atom Atom Atom Atom %Undefined%))
</span>
N(50): <span class="ansi33"
>(: get-vtype (-> Atom Atom))
</span>
N(51): <span class="ansi33"
>(: get-vtype (-> Atom hyperon::space::DynSpace Atom))
</span>
N(52): <span class="ansi33"
>(: get-types (-> Atom Atom))
</span>
N(53): <span class="ansi33"
>(: get-types (-> Atom hyperon::space::DynSpace Atom))
</span>
N(54): <span class="ansi33"
>(: get-dtype (-> Atom Atom))
</span>
N(55): <span class="ansi33"
>(: get-dtype (-> Atom hyperon::space::DynSpace Atom))
</span>
N(56): <span class="ansi33"
>(: get-ftype (-> Atom Atom))
</span>
N(57): <span class="ansi33"
>(: get-ftype (-> Atom hyperon::space::DynSpace Atom))
</span>
N(58): <span class="ansi33"
>(: pragma! (-> Atom Atom (->)))
</span>
N(59): <span class="ansi33"
>(: match (-> hyperon::space::DynSpace Atom Atom %Undefined%))
</span>
N(60): <span class="ansi33"
>(: combine (-> $t $t $t))
</span>
N(61): <span class="ansi33"
>(: import! (-> hyperon::space::DynSpace Atom (->)))
</span>
N(62): <span class="ansi33"
>(@doc type-check (@desc "The value of type-check determines MeTTa's type-checking behavior. Set via pragma!. When set to auto (i.e. !(pragma! type-check auto)), types are checked immediately on adding an expression to the space. By default, when unset (or set to anything other than auto), types are checked only on evaluation. For example !(+ 1 \"2\") would trigger a type violation, but (= (foo $x) (+ $x \"2\")) would not, unless type-check is set to auto, in which case both would trigger type violations."))
</span>
N(63): <span class="ansi33"
>(: type-check Symbol)
</span>
N(64): <span class="ansi33"
>(iz predicate-arity MeTTaLog)
</span>
N(65): <span class="ansi33"
>(@doc predicate-arity (@desc "Specifies the arity (number of arguments) for a given predicate, allowing it to be queriable in the system's match framework. This is particularly useful for enabling built-in functions, such as `size-atom`, to be used as predicates in declarative contexts and run in reverse to compute inputs based on outputs.\n\n\nFor example:\n  ; Enable the built-in function `size-atom` that takes an atom and returns the size\n    as a predicate with arity 2\n  (predicate-arity size-atom 2)\n\n\n  ; Now `size-atom` can be used as a predicate in pattern matching\n  !(match &dyn-space '(size-atom (a b c) $size) \n         (The abc tuple was len $size))\n  ; This pattern will resolve `Size = 3` and execute the action.\n\n\nAdditionally, by running `size-atom` in reverse, you can compute a new atom based on a desired size:\n  !(match &dyn-space '(size-atom $new-atom 4) \n         (The new atom is $new-atom))\n  ; This resolves `$new-atom` to a tuple of size 4, such as ($1 $2 $3 $4).\n\n\nThis reverse functionality is made possible because predicates can describe relationships, allowing you to infer inputs from outputs.") (@params ((@param "Predicate symbol" "The name of the predicate whose arity is being defined."))) (@return "The number of arguments required for the predicate."))
</span>
N(66): <span class="ansi33"
>(: predicate-arity (-> Symbol Number))
</span>
N(67): <span class="ansi33"
>(predicate-arity predicate-arity 2)
</span>
N(68): <span class="ansi33"
>(function-arity predicate-arity 1)
</span>
N(69): <span class="ansi33"
>(@doc function-arity (@desc "Defines the arity of a function, allowing predicates or built-in facts to also behave as callable functions. This enables procedural-style execution where the last argument of the predicate becomes the function's return value, and the system internally resolves the function using a `match` query. \n\n\nFor example:\n  ; Declare the built-in predicate `max` with arity 3\n  (predicate-arity max 3)\n\n  ; Enable `max` as a function\n  (function-arity max 2)\n\n\n  ; Define the rules for `max`\n  (= (max $X $Y $Y) (<= $X $Y))\n  (= (max $X $Y $X) (> $X $Y))\n\n\n  ; Using `max` declaratively as a predicate\n  !(match &self (max (5 10) $max)\n         (The maximum is $max))\n  [(The maximum is 10)]\n\n\n  ; Using `max` procedurally as a function\n  !(max 5 10)\n  [10]\n  \n\n\n  ; Reverse execution with `max`\n  !(let True (== (max $a $b) 10) ($a $b)) ; as a function\n  [(#(exists $a (=< $a 10)) 10), (10 #(exists $b (=< 10 $b )))]\n  !(match &self (max $a $b 10) ($a $b)) ; or as a predicate\n  [(#(exists $a (=< $a 10)) 10), (10 #(exists $b (=< 10 $b )))]\n\n\n  This dual behavior allows predicates to act as functions, bridging procedural and declarative paradigms. By defining `function-arity`, the function automatically resolves using the logic of the associated predicate.") (@params ((@param "Function symbol" "The name of the function or predicate to enable as a callable function."))) (@return "The number of arguments expected by the function."))
</span>
N(70): <span class="ansi33"
>(: function-arity (-> Symbol Number))
</span>
N(71): <span class="ansi33"
>(predicate-arity function-arity 2)
</span>
N(72): <span class="ansi33"
>(function-arity function-arity 1)
</span>
N(73): <span class="ansi33"
>(iz MettaMorph-If MeTTaMorph)
</span>
N(74): <span class="ansi33"
>(@doc MettaMorph-If (@desc "Conditional function that evaluates and returns one of the provided atoms based on a boolean condition.") (@params ((@param "Boolean condition") (@param "Atom to return if condition is True") (@param "Atom to return if condition is False (optional)"))) (@return "Either the second or third argument depending on the condition"))
</span>
N(75): <span class="ansi33"
>(: MettaMorph-If (-> Bool Atom Atom Atom))
</span>
N(76): <span class="ansi33"
>(: MettaMorph-If (-> Bool Atom Atom))
</span>
N(77): <span class="ansi33"
>(= (MettaMorph-If True $then)  $then)
</span>
N(78): <span class="ansi33"
>(= (MettaMorph-If False $then)  
  (let $n 0 
    (let $n 1 $n)))
</span>
N(79): <span class="ansi33"
>(= (MettaMorph-If $cond $then $else)  
  (if $cond $then $else))
</span>
N(80): <span class="ansi33"
>(iz SrcPredicate MeTTa)
</span>
N(81): <span class="ansi33"
>(@doc SrcPredicate (@desc "Type representing a source predicate."))
</span>
N(82): <span class="ansi33"
>(: SrcPredicate Type)
</span>
N(83): <span class="ansi33"
>(iz SrcFunction MeTTa)
</span>
N(84): <span class="ansi33"
>(@doc SrcFunction (@desc "Type representing a source function."))
</span>
N(85): <span class="ansi33"
>(: SrcFunction Type)
</span>
N(86): <span class="ansi33"
>(iz MeTTaResult MeTTa)
</span>
N(87): <span class="ansi33"
>(@doc MeTTaResult (@desc "Type representing the result of a MeTTa evaluation."))
</span>
N(88): <span class="ansi33"
>(: MeTTaResult Type)
</span>[error metta_NotReducible [file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta] (get-atoms &self)]
<span class="ansi38-013099040"
>!(assertEqual (match &self $1 $1) (get-atoms &self))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.13"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.13</h3>

[error metta_NotReducible [file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta] (assertEqual (match &self $1 $1) (get-atoms &self))];;;;l !(repl!)
<span class="ansi38-013099040"
>!(assertEqualToResult (match &self ($Rel A $X) ($Rel A $X)) ((Rel-P A B) (Rel-Q A C)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.14"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.14</h3>
; 
; EVAL TEST
; took 0.003 secs. (2.86 milliseconds) 

!(assertEqualToResult (match &self ($Rel A $X) ($Rel A $X)) ((Rel-P A B) (Rel-Q A C)))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (Rel-P A B) (Rel-Q A C)) 
      ( (Rel-P A B) (Rel-Q A C))]]
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqualToResult (superpose ((Rel-P B) (Rel-Q C))) ((Rel-P B) (Rel-Q C)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.15"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.15</h3>
; 
; EVAL TEST
; took 0.004 secs. (3.66 milliseconds) 

!(assertEqualToResult (superpose ((Rel-P B) (Rel-Q C))) ((Rel-P B) (Rel-Q C)))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (Rel-P B) (Rel-Q C)) 
      ( (Rel-P B) (Rel-Q C))]]
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Basic Match
<span class="ansi38-013099040"
>!(assertEqual (match &self ($rel A $x) ($rel $x)) (superpose ((Rel-P B) (Rel-Q C))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.16"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.16</h3>
; 
; EVAL TEST
; took 0.006 secs. (5.55 milliseconds) 

!(assertEqual (match &self ($rel A $x) ($rel $x)) (superpose ((Rel-P B) (Rel-Q C))))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (Rel-P B) (Rel-Q C)) 
      ( (Rel-P B) (Rel-Q C))]]
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; cases can be used for deconstruction
<span class="ansi38-013099040"
>!(assertEqual (superpose ((P B) (Q C))) (case (match &self ($rel A $x) ($rel $x)) (((Rel-P $y) (P $y)) ((Rel-Q $y) (Q $y)))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.17"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.17</h3>
; 
; EVAL TEST
; took 0.009 secs. (9.22 milliseconds) 

!(assertEqual (superpose ((P B) (Q C))) (case (match &self ($rel A $x) ($rel $x)) (((Rel-P $y) (P $y)) ((Rel-Q $y) (Q $y)))))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (P B) (Q C)) 
      ( (P B) (Q C))]]
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; %void% can be used to capture empty results
<span class="ansi38-013099040"
>!(assertEqual (case (match &self ($rel B $x) ($rel $x)) (((Rel-P $y) (P $y)) ((Rel-Q $y) (Q $y)) (%void% no-match))) no-match)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.18"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.18</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.06 milliseconds) 

!(assertEqual (case (match &self ($rel B $x) ($rel $x)) (((Rel-P $y) (P $y)) ((Rel-Q $y) (Q $y)) (%void% no-match))) no-match)

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (no-match) 
      (no-match)]]
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 17
</span><span class="ansi31"
>Failures: 1
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[(= (Rel-P P P P)  10), (Rel-P A B), (Rel-Q A C), &corelib, &stdlib, (@doc Any (@desc "The universal type; any value belongs to this type.")), (: Any Type), (@doc Atom (@desc "Type representing any atom.")), (: Atom Type), (@doc LazyEvaluatable (@desc "A type of Atom/Value that hyperon does not implicitly evaluate")), (: LazyEvaluatable Type), (:> Atom LazyEvaluatable), (@doc Bool (@desc "Boolean type of True or False.")), (: Bool Type), (@doc LazyBool (@desc "A LazyEvaluatable that when evaluated returns True or False.")), (: LazyBool Type), (:> LazyBool LazyEvaluatable), (@doc Expression (@desc "Type representing an S-Expression, which is a combination of atoms.")), (: Expression Type), (:> Expression LazyEvaluatable), (@doc Number (@desc "Numeric type, including integers and floating-point numbers.")), (: Number Type), (@doc hyperon::space::DynSpace (@desc "Dynamic space type, representing an Atomspace.")), (: hyperon::space::DynSpace Type), (@doc ReturnType (@desc "Type representing a function's return value.")), (: ReturnType Type), (@doc Symbol (@desc "Type representing a symbol or identifier.")), (: Symbol Type), (@doc StateMonad (@desc "Type representing a state monad, used for encapsulating stateful computations.")), (: StateMonad Type), (@doc Type (@desc "Type representing a type.")), (: Type Type), (@doc True (@desc "Boolean value representing truth.")), (: True Bool), (@doc False (@desc "Boolean value representing falsehood.")), (: False Bool), (@doc %Undefined% (@desc "Special type representing an undefined value or type.")), (: %Undefined% Type), (@doc Variable (@desc "Type representing a variable in the language.")), (: Variable Type), (@doc : (@desc "Type declarion operator")), (@doc <: (@desc "Super Type declarion operator")), (: : %Undefined%), (: if-empty (-> Atom Atom Atom Atom)), (: if-non-empty-expression (-> Atom Atom Atom Atom)), (: if-not-reducible (-> Atom Atom Atom Atom)), (: return (-> Atom ReturnType)), (: switch (-> %Undefined% Expression Atom)), (: unify (-> Atom Atom Atom Atom %Undefined%)), (: get-vtype (-> Atom Atom)), (: get-vtype (-> Atom hyperon::space::DynSpace Atom)), (: get-types (-> Atom Atom)), (: get-types (-> Atom hyperon::space::DynSpace Atom)), (: get-dtype (-> Atom Atom)), (: get-dtype (-> Atom hyperon::space::DynSpace Atom)), (: get-ftype (-> Atom Atom)), (: get-ftype (-> Atom hyperon::space::DynSpace Atom)), (: pragma! (-> Atom Atom (->))), (: match (-> hyperon::space::DynSpace Atom Atom %Undefined%)), (: combine (-> $t $t $t)), (: import! (-> hyperon::space::DynSpace Atom (->))), (@doc type-check (@desc "The value of type-check determines MeTTa's type-checking behavior. Set via pragma!. When set to auto (i.e. !(pragma! type-check auto)), types are checked immediately on adding an expression to the space. By default, when unset (or set to anything other than auto), types are checked only on evaluation. For example !(+ 1 \"2\") would trigger a type violation, but (= (foo $x) (+ $x \"2\")) would not, unless type-check is set to auto, in which case both would trigger type violations.")), (: type-check Symbol), (iz predicate-arity MeTTaLog), (@doc predicate-arity (@desc "Specifies the arity (number of arguments) for a given predicate, allowing it to be queriable in the system's match framework. This is particularly useful for enabling built-in functions, such as `size-atom`, to be used as predicates in declarative contexts and run in reverse to compute inputs based on outputs.\n\n\nFor example:\n  ; Enable the built-in function `size-atom` that takes an atom and returns the size\n    as a predicate with arity 2\n  (predicate-arity size-atom 2)\n\n\n  ; Now `size-atom` can be used as a predicate in pattern matching\n  !(match &dyn-space '(size-atom (a b c) $size) \n         (The abc tuple was len $size))\n  ; This pattern will resolve `Size = 3` and execute the action.\n\n\nAdditionally, by running `size-atom` in reverse, you can compute a new atom based on a desired size:\n  !(match &dyn-space '(size-atom $new-atom 4) \n         (The new atom is $new-atom))\n  ; This resolves `$new-atom` to a tuple of size 4, such as ($1 $2 $3 $4).\n\n\nThis reverse functionality is made possible because predicates can describe relationships, allowing you to infer inputs from outputs.") (@params ((@param "Predicate symbol" "The name of the predicate whose arity is being defined."))) (@return "The number of arguments required for the predicate.")), (: predicate-arity (-> Symbol Number)), (predicate-arity predicate-arity 2), (function-arity predicate-arity 1), (@doc function-arity (@desc "Defines the arity of a function, allowing predicates or built-in facts to also behave as callable functions. This enables procedural-style execution where the last argument of the predicate becomes the function's return value, and the system internally resolves the function using a `match` query. \n\n\nFor example:\n  ; Declare the built-in predicate `max` with arity 3\n  (predicate-arity max 3)\n\n  ; Enable `max` as a function\n  (function-arity max 2)\n\n\n  ; Define the rules for `max`\n  (= (max $X $Y $Y) (<= $X $Y))\n  (= (max $X $Y $X) (> $X $Y))\n\n\n  ; Using `max` declaratively as a predicate\n  !(match &self (max (5 10) $max)\n         (The maximum is $max))\n  [(The maximum is 10)]\n\n\n  ; Using `max` procedurally as a function\n  !(max 5 10)\n  [10]\n  \n\n\n  ; Reverse execution with `max`\n  !(let True (== (max $a $b) 10) ($a $b)) ; as a function\n  [(#(exists $a (=< $a 10)) 10), (10 #(exists $b (=< 10 $b )))]\n  !(match &self (max $a $b 10) ($a $b)) ; or as a predicate\n  [(#(exists $a (=< $a 10)) 10), (10 #(exists $b (=< 10 $b )))]\n\n\n  This dual behavior allows predicates to act as functions, bridging procedural and declarative paradigms. By defining `function-arity`, the function automatically resolves using the logic of the associated predicate.") (@params ((@param "Function symbol" "The name of the function or predicate to enable as a callable function."))) (@return "The number of arguments expected by the function.")), (: function-arity (-> Symbol Number)), (predicate-arity function-arity 2), (function-arity function-arity 1), (iz MettaMorph-If MeTTaMorph), (@doc MettaMorph-If (@desc "Conditional function that evaluates and returns one of the provided atoms based on a boolean condition.") (@params ((@param "Boolean condition") (@param "Atom to return if condition is True") (@param "Atom to return if condition is False (optional)"))) (@return "Either the second or third argument depending on the condition")), (: MettaMorph-If (-> Bool Atom Atom Atom)), (: MettaMorph-If (-> Bool Atom Atom)), (= (MettaMorph-If True $then)  $then), (= (MettaMorph-If False $then)  
  (let $n 0 
    (let $n 1 $n))), (= (MettaMorph-If $cond $then $else)  
  (if $cond $then $else)), (iz SrcPredicate MeTTa), (@doc SrcPredicate (@desc "Type representing a source predicate.")), (: SrcPredicate Type), (iz SrcFunction MeTTa), (@doc SrcFunction (@desc "Type representing a source function.")), (: SrcFunction Type), (iz MeTTaResult MeTTa), (@doc MeTTaResult (@desc "Type representing the result of a MeTTa evaluation.")), (: MeTTaResult Type)[(= (Rel-P P P P)  10), (Rel-P A B), (Rel-Q A C), &corelib, &stdlib, (@doc Any (@desc "The universal type; any value belongs to this type.")), (: Any Type), (@doc Atom (@desc "Type representing any atom.")), (: Atom Type), (@doc LazyEvaluatable (@desc "A type of Atom/Value that hyperon does not implicitly evaluate")), (: LazyEvaluatable Type), (:> Atom LazyEvaluatable), (@doc Bool (@desc "Boolean type of True or False.")), (: Bool Type), (@doc LazyBool (@desc "A LazyEvaluatable that when evaluated returns True or False.")), (: LazyBool Type), (:> LazyBool LazyEvaluatable), (@doc Expression (@desc "Type representing an S-Expression, which is a combination of atoms.")), (: Expression Type), (:> Expression LazyEvaluatable), (@doc Number (@desc "Numeric type, including integers and floating-point numbers.")), (: Number Type), (@doc hyperon::space::DynSpace (@desc "Dynamic space type, representing an Atomspace.")), (: hyperon::space::DynSpace Type), (@doc ReturnType (@desc "Type representing a function's return value.")), (: ReturnType Type), (@doc Symbol (@desc "Type representing a symbol or identifier.")), (: Symbol Type), (@doc StateMonad (@desc "Type representing a state monad, used for encapsulating stateful computations.")), (: StateMonad Type), (@doc Type (@desc "Type representing a type.")), (: Type Type), (@doc True (@desc "Boolean value representing truth.")), (: True Bool), (@doc False (@desc "Boolean value representing falsehood.")), (: False Bool), (@doc %Undefined% (@desc "Special type representing an undefined value or type.")), (: %Undefined% Type), (@doc Variable (@desc "Type representing a variable in the language.")), (: Variable Type), (@doc : (@desc "Type declarion operator")), (@doc <: (@desc "Super Type declarion operator")), (: : %Undefined%), (: if-empty (-> Atom Atom Atom Atom)), (: if-non-empty-expression (-> Atom Atom Atom Atom)), (: if-not-reducible (-> Atom Atom Atom Atom)), (: return (-> Atom ReturnType)), (: switch (-> %Undefined% Expression Atom)), (: unify (-> Atom Atom Atom Atom %Undefined%)), (: get-vtype (-> Atom Atom)), (: get-vtype (-> Atom hyperon::space::DynSpace Atom)), (: get-types (-> Atom Atom)), (: get-types (-> Atom hyperon::space::DynSpace Atom)), (: get-dtype (-> Atom Atom)), (: get-dtype (-> Atom hyperon::space::DynSpace Atom)), (: get-ftype (-> Atom Atom)), (: get-ftype (-> Atom hyperon::space::DynSpace Atom)), (: pragma! (-> Atom Atom (->))), (: match (-> hyperon::space::DynSpace Atom Atom %Undefined%)), (: combine (-> $t $t $t)), (: import! (-> hyperon::space::DynSpace Atom (->))), (@doc type-check (@desc "The value of type-check determines MeTTa's type-checking behavior. Set via pragma!. When set to auto (i.e. !(pragma! type-check auto)), types are checked immediately on adding an expression to the space. By default, when unset (or set to anything other than auto), types are checked only on evaluation. For example !(+ 1 \"2\") would trigger a type violation, but (= (foo $x) (+ $x \"2\")) would not, unless type-check is set to auto, in which case both would trigger type violations.")), (: type-check Symbol), (iz predicate-arity MeTTaLog), (@doc predicate-arity (@desc "Specifies the arity (number of arguments) for a given predicate, allowing it to be queriable in the system's match framework. This is particularly useful for enabling built-in functions, such as `size-atom`, to be used as predicates in declarative contexts and run in reverse to compute inputs based on outputs.\n\n\nFor example:\n  ; Enable the built-in function `size-atom` that takes an atom and returns the size\n    as a predicate with arity 2\n  (predicate-arity size-atom 2)\n\n\n  ; Now `size-atom` can be used as a predicate in pattern matching\n  !(match &dyn-space '(size-atom (a b c) $size) \n         (The abc tuple was len $size))\n  ; This pattern will resolve `Size = 3` and execute the action.\n\n\nAdditionally, by running `size-atom` in reverse, you can compute a new atom based on a desired size:\n  !(match &dyn-space '(size-atom $new-atom 4) \n         (The new atom is $new-atom))\n  ; This resolves `$new-atom` to a tuple of size 4, such as ($1 $2 $3 $4).\n\n\nThis reverse functionality is made possible because predicates can describe relationships, allowing you to infer inputs from outputs.") (@params ((@param "Predicate symbol" "The name of the predicate whose arity is being defined."))) (@return "The number of arguments required for the predicate.")), (: predicate-arity (-> Symbol Number)), (predicate-arity predicate-arity 2), (function-arity predicate-arity 1), (@doc function-arity (@desc "Defines the arity of a function, allowing predicates or built-in facts to also behave as callable functions. This enables procedural-style execution where the last argument of the predicate becomes the function's return value, and the system internally resolves the function using a `match` query. \n\n\nFor example:\n  ; Declare the built-in predicate `max` with arity 3\n  (predicate-arity max 3)\n\n  ; Enable `max` as a function\n  (function-arity max 2)\n\n\n  ; Define the rules for `max`\n  (= (max $X $Y $Y) (<= $X $Y))\n  (= (max $X $Y $X) (> $X $Y))\n\n\n  ; Using `max` declaratively as a predicate\n  !(match &self (max (5 10) $max)\n         (The maximum is $max))\n  [(The maximum is 10)]\n\n\n  ; Using `max` procedurally as a function\n  !(max 5 10)\n  [10]\n  \n\n\n  ; Reverse execution with `max`\n  !(let True (== (max $a $b) 10) ($a $b)) ; as a function\n  [(#(exists $a (=< $a 10)) 10), (10 #(exists $b (=< 10 $b )))]\n  !(match &self (max $a $b 10) ($a $b)) ; or as a predicate\n  [(#(exists $a (=< $a 10)) 10), (10 #(exists $b (=< 10 $b )))]\n\n\n  This dual behavior allows predicates to act as functions, bridging procedural and declarative paradigms. By defining `function-arity`, the function automatically resolves using the logic of the associated predicate.") (@params ((@param "Function symbol" "The name of the function or predicate to enable as a callable function."))) (@return "The number of arguments expected by the function.")), (: function-arity (-> Symbol Number)), (predicate-arity function-arity 2), (function-arity function-arity 1), (iz MettaMorph-If MeTTaMorph), (@doc MettaMorph-If (@desc "Conditional function that evaluates and returns one of the provided atoms based on a boolean condition.") (@params ((@param "Boolean condition") (@param "Atom to return if condition is True") (@param "Atom to return if condition is False (optional)"))) (@return "Either the second or third argument depending on the condition")), (: MettaMorph-If (-> Bool Atom Atom Atom)), (: MettaMorph-If (-> Bool Atom Atom)), (= (MettaMorph-If True $then)  $then), (= (MettaMorph-If False $then)  
  (let $n 0 
    (let $n 1 $n))), (= (MettaMorph-If $cond $then $else)  
  (if $cond $then $else)), (iz SrcPredicate MeTTa), (@doc SrcPredicate (@desc "Type representing a source predicate.")), (: SrcPredicate Type), (iz SrcFunction MeTTa), (@doc SrcFunction (@desc "Type representing a source function.")), (: SrcFunction Type), (iz MeTTaResult MeTTa), (@doc MeTTaResult (@desc "Type representing the result of a MeTTa evaluation.")), (: MeTTaResult Type)[[()]
[()]
[()]
[()]
[()]

Script done on 2025-02-03 19:01:24+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: /home/runner/work/metta-testsuite/metta-testsuite/mettalog '--output=/home/runner/work/metta-testsuite/metta-testsuite/reports/tests_output/baseline-compat' --timeout=40 --html --repl=false  --test "tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta" --halt=true\033[0m
