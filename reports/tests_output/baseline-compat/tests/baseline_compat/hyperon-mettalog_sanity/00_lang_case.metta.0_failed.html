<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi36 { color: #00aaaa; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-12-11 17:09:25-08:00 [COMMAND="timeout --preserve-status --foreground --signal=SIGTERM --kill-after=5s 40 swipl  /home/deb12user/metta-wam/prolog/metta_lang/metta_interp.pl -- --python=enable -- --timeout=40 --output=./reports/tests_output/baseline-compat/ --html --test tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta --halt=true  --stdin=tty --stdout=tty --stderr=tty" TERM="xterm" TTY="/dev/pts/2" COLUMNS="214" LINES="54"]
;           #(set_option_value compat false)
;           #(set_option_value compatio false)
;           #(set_option_value src_indents false)
;         #(set_option_value devel false)
;         #(set_option_value stack-max 500)
;         #(set_option_value limit inf)
;         #(set_option_value initial-result-count 10)
;         #(set_option_value answer-format show)
;         #(set_option_value repeats true)
;         #(set_option_value time true)
;         #(set_option_value synth-unit-tests false)
;         #(set_option_value optimize true)
;         #(set_option_value transpiler silent)
;          #(set_debug transpiler false)
;         #(set_option_value compile false)
;         #(set_option_value tabling auto)
;         #(set_option_value log false)
;         #(set_option_value output ./)
;         #(set_option_value exeout ./Sav.gitlab.MeTTaLog)
;         #(set_option_value halt false)
;         #(set_option_value trace-length 500)
;         #(set_option_value trace-on-overtime 4.0)
;          #(set_debug overtime 4.0)
;         #(set_option_value trace-on-overflow 1000)
;          #(set_debug overflow 1000)
;         #(set_option_value trace-on-eval false)
;          #(set_debug eval false)
;         #(set_option_value trace-on-load silent)
;          #(set_debug load silent)
;          #(set_debug trace-on-load false)
;         #(set_option_value trace-on-exec false)
;          #(set_debug exec false)
;         #(set_option_value trace-on-error non-type)
;          #(set_debug error non-type)
;         #(set_option_value trace-on-fail false)
;          #(set_debug fail false)
;         #(set_option_value trace-on-test true)
;          #(set_debug test true)
;         #(set_option_value repl-on-error true)
;         #(set_option_value repl-on-fail false)
;         #(set_option_value exit-on-fail false)
;         #(set_option_value repl auto)
;         #(set_option_value prolog false)
;         #(set_option_value exec noskip)
;         #(set_option_value maximum-result-count inf)
;         #(set_option_value html false)
;         #(set_option_value python true)
;         #(set_option_value trace-on-test false)
;         #(set_debug test false)
;         #(set_option_value trace-on-fail false)
;         #(set_debug fail false)
;         #(set_option_value load show)
;         #(set_option_value test false)
;          #(is_cmd_option prescan halt --halt=true true)
;          #(set_option_value halt true)
;          #(is_cmd_option prescan stdin --stdin=tty tty)
;           #(set_option_value stdin tty)
;          #(is_cmd_option prescan stdout --stdout=tty tty)
;           #(set_option_value stdout tty)
;          #(is_cmd_option prescan stderr --stderr=tty tty)
;           #(set_option_value stderr tty)
;          #(set_option_value compat false)
;          #(set_option_value compatio false)
;          #(set_option_value src_indents false)
;          #(set_option_value devel false)
;          #(set_option_value stack-max 500)
;          #(set_option_value limit inf)
;          #(set_option_value initial-result-count 10)
;          #(set_option_value answer-format show)
;          #(set_option_value repeats true)
;          #(set_option_value time true)
;          #(set_option_value synth-unit-tests false)
;          #(set_option_value optimize true)
;          #(set_option_value transpiler silent)
;          #(set_debug transpiler false)
;          #(set_option_value compile false)
;          #(set_option_value tabling auto)
;          #(set_option_value log false)
;          #(set_option_value output ./)
;          #(set_option_value exeout ./Sav.gitlab.MeTTaLog)
;          #(set_option_value halt false)
;          #(set_option_value trace-length 500)
;          #(set_option_value trace-on-overtime 4.0)
;          #(set_debug overtime 4.0)
;          #(set_option_value trace-on-overflow 1000)
;          #(set_debug overflow 1000)
;          #(set_option_value trace-on-eval false)
;          #(set_debug eval false)
;          #(set_option_value trace-on-load silent)
;          #(set_debug load silent)
;          #(set_debug trace-on-load false)
;          #(set_option_value trace-on-exec false)
;          #(set_debug exec false)
;          #(set_option_value trace-on-error non-type)
;          #(set_debug error non-type)
;          #(set_option_value trace-on-fail false)
;          #(set_debug fail false)
;          #(set_option_value trace-on-test true)
;          #(set_debug test true)
;          #(set_option_value repl-on-error true)
;          #(set_option_value repl-on-fail false)
;          #(set_option_value exit-on-fail false)
;          #(set_option_value repl auto)
;          #(set_option_value prolog false)
;          #(set_option_value exec noskip)
;          #(set_option_value maximum-result-count inf)
;          #(set_option_value html false)
;          #(set_option_value python true)
;         #(set_option_value trace-on-test false)
;          #(set_debug test false)
;         #(set_option_value trace-on-fail false)
;          #(set_debug fail false)
;         #(set_option_value load show)
;         #(set_option_value test true)
;        #(is_cmd_option execute python --python=enable enable)
;         #(set_option_value python enable)
;        #(is_cmd_option execute timeout --timeout=40 40)
;         #(set_option_value timeout 40)
;         #(is_cmd_option execute output --output=./reports/tests_output/baseline-compat/ ./reports/tests_output/baseline-compat/)
;         #(set_option_value output ./reports/tests_output/baseline-compat/)
;         #(is_cmd_option execute html --html true)
;          #(set_option_value html true)
;         #(is_cmd_option execute test --test true)
;          #(set_option_value test true)

; #( : user #(load_metta_file &self tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta) )
;                       #(track_load_into_file /home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta)
;                                        #(load_answer_file /home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta.answers /home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta)
;                                         #( = 1 "[()]" )
;                                         #( = 2 "[()]" )
;                                         #( = 3 "[()]" )
;                                         #( = 4 "[()]" )
;                                         #( = 5 "[()]" )
;                                         #( = 6 "[()]" )
;                                         #( = 7 "[()]" )
;                                         #( = 8 "[()]" )
;                                         #( = 9 "[()]" )
;                                         #( = 10 "[()]" )
;                                         #( = 11 "[(Error (assertEqualToResult (superpose ((nop 1))) ()) " )
;                                         #( = 11 "Expected: []" )
;                                         #( = 11 "Got: [()]" )
;                                         #( = 12 "Excessive result: ())]" )
;                                         #( = 12 "0.02user 0.00system 0:00.04elapsed 80%CPU (0avgtext+0avgdata 26224maxresident)k" )
;                                         #( = 12 "0inputs+0outputs (0major+3323minor)pagefaults 0swaps" )
;                                        #(load_answer_file /home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta.answers /home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta)
;;; cases are processed sequentially
<span class="ansi38-013099040"
>!(assertEqual (+ 1 (superpose (1 2 3))) (+ 1 (superpose (1 2 3))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.01"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.01</h3>
; 
; EVAL TEST
; took 0.000305 secs. (304.80 microseconds) 

!(assertEqual (+ 1 (superpose (1 2 3))) (+ 1 (superpose (1 2 3))))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      (2 3 4) 
      (2 3 4)))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqual (+ 1 (superpose (1 2 3))) (+ 1 (superpose (1 (superpose (2 3))))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.02"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.02</h3>
; 
; EVAL TEST
; took 0.000362 secs. (361.80 microseconds) 

!(assertEqual (+ 1 (superpose (1 2 3))) (+ 1 (superpose (1 (superpose (2 3))))))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      (2 3 4) 
      (2 3 4)))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqual ((superpose (1 2 3))) ((superpose (1 (superpose ((+ 1 1) 3))))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.03"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.03</h3>
; 
; EVAL TEST
; took 0.000473 secs. (472.90 microseconds) 

!(assertEqual ((superpose (1 2 3))) ((superpose (1 (superpose ((+ 1 1) 3))))))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (1) 
        (2) 
        (3)) 
      ( (1) 
        (2) 
        (3))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; cases are processed sequentially
<span class="ansi38-013099040"
>!(assertEqual (case (+ 1 5) ((5 Error) (6 OK) (6 Error))) OK)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.04"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.04</h3>
; 
; EVAL TEST
; took 0.000142 secs. (142.10 microseconds) 

!(assertEqual (case (+ 1 5) ((5 Error) (6 OK) (6 Error))) OK)

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      (OK) 
      (OK)))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; we can use variables as cases
<span class="ansi38-013099040"
>!(assertEqual (case (+ 1 5) (($x (+ 1 $x)))) 7)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.05"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.05</h3>
; 
; EVAL TEST
; took 0.000187 secs. (186.80 microseconds) 

!(assertEqual (case (+ 1 5) (($x (+ 1 $x)))) 7)

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      (7) 
      (7)))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; cases are not necessarily exhaustive,
;;; and the result can be empty
<span class="ansi38-013099040"
>!(assertEqual (case 5 ((6 OK))) (superpose ()))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.06"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.06</h3>
; 
; EVAL TEST
; took 0.000104 secs. (103.60 microseconds) 

!(assertEqual (case 5 ((6 OK))) (superpose ()))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test () ()))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; it is non-deterministic: each value is matched against all cases
<span class="ansi38-013099040"
>!(assertEqual (case (+ 1 (superpose (1 2 3))) ((3 OK-3) (4 OK-4))) (superpose (OK-3 OK-4)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.07"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.07</h3>
; 
; EVAL TEST
; took 0.000344 secs. (344.20 microseconds) 

!(assertEqual (case (+ 1 (superpose (1 2 3))) ((3 OK-3) (4 OK-4))) (superpose (OK-3 OK-4)))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      (OK-3 OK-4) 
      (OK-3 OK-4)))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; one case can produce multiple results
<span class="ansi38-013099040"
>!(assertEqual (case (+ 1 (superpose (1 2 3))) (($x (+ 1 $x)))) (superpose (3 4 5)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.08"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.08</h3>
; 
; EVAL TEST
; took 0.000371 secs. (371.10 microseconds) 

!(assertEqual (case (+ 1 (superpose (1 2 3))) (($x (+ 1 $x)))) (superpose (3 4 5)))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      (3 4 5) 
      (3 4 5)))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqualToResult (superpose ()) ())

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.09"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.09</h3>
; 
; EVAL TEST
; took 0.000049 secs. (48.50 microseconds) 

!(assertEqualToResult (superpose ()) ())

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test () ()))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqualToResult (collapse (superpose ())) (()))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.10"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.10</h3>
; 
; EVAL TEST
; took 0.000087 secs. (87.20 microseconds) 

!(assertEqualToResult (collapse (superpose ())) (()))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      (()) 
      (())))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqualToResult (superpose ((nop 1))) ())

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.11"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.11</h3>
; 
; EVAL TEST
; took 0.000088 secs. (87.60 microseconds) 

!(assertEqualToResult (superpose ((nop 1))) ())

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      (()) ()))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqualToResult (collapse (superpose ((nop 1)))) (()))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.12"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.12</h3>
; 
; EVAL TEST
; took 0.000166 secs. (166.00 microseconds) 

!(assertEqualToResult (collapse (superpose ((nop 1)))) (()))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (())) 
      (())))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-255165000"
> (= (Rel-P P P P)  10)
</span><span class="ansi38-255165000"
> (Rel-P A B)
</span><span class="ansi38-255165000"
> (Rel-Q A C)
</span><span class="ansi38-013099040"
>!(match &self $1 $1)

</span>
NDet Result(1): <span class="ansi33"
>&corelib
</span>$1 = &corelib

NDet Result(2): <span class="ansi33"
>&stdlib
</span>$1 = &stdlib

NDet Result(3): <span class="ansi33"
>(= (Rel-P P P P)  10)
</span>$1 = (= (Rel-P P P P)  10)

NDet Result(4): <span class="ansi33"
>(Rel-P A B)
</span>$1 = (Rel-P A B)

NDet Result(5): <span class="ansi33"
>(Rel-Q A C)
</span>$1 = (Rel-Q A C)

NDet Result(6): <span class="ansi33"
>(@doc Any (@desc "The universal type; any value belongs to this type."))
</span>$1 = (@doc Any (@desc "The universal type; any value belongs to this type."))

NDet Result(7): <span class="ansi33"
>(: Any Type)
</span>$1 = (: Any Type)

NDet Result(8): <span class="ansi33"
>(@doc Atom (@desc "Type representing any atom."))
</span>$1 = (@doc Atom (@desc "Type representing any atom."))

NDet Result(9): <span class="ansi33"
>(: Atom Type)
</span>$1 = (: Atom Type)

NDet Result(10): <span class="ansi33"
>(@doc LazyEvaluatable (@desc "A type of Atom/Value that hyperon does not implicitly evaluate"))
</span>$1 = (@doc LazyEvaluatable (@desc "A type of Atom/Value that hyperon does not implicitly evaluate"))

NDet Result(11): <span class="ansi33"
>(: LazyEvaluatable Type)
</span>$1 = (: LazyEvaluatable Type)

NDet Result(12): <span class="ansi33"
>(:> Atom LazyEvaluatable)
</span>$1 = (:> Atom LazyEvaluatable)

NDet Result(13): <span class="ansi33"
>(@doc Bool (@desc "Boolean type of True or False."))
</span>$1 = (@doc Bool (@desc "Boolean type of True or False."))

NDet Result(14): <span class="ansi33"
>(: Bool Type)
</span>$1 = (: Bool Type)

NDet Result(15): <span class="ansi33"
>(@doc LazyBool (@desc "A LazyEvaluatable that when evaluated returns True or False."))
</span>$1 = (@doc LazyBool (@desc "A LazyEvaluatable that when evaluated returns True or False."))

NDet Result(16): <span class="ansi33"
>(: LazyBool Type)
</span>$1 = (: LazyBool Type)

NDet Result(17): <span class="ansi33"
>(:> LazyBool LazyEvaluatable)
</span>$1 = (:> LazyBool LazyEvaluatable)

NDet Result(18): <span class="ansi33"
>(@doc Expression (@desc "Type representing an S-Expression, which is a combination of atoms."))
</span>$1 = (@doc Expression (@desc "Type representing an S-Expression, which is a combination of atoms."))

NDet Result(19): <span class="ansi33"
>(: Expression Type)
</span>$1 = (: Expression Type)

NDet Result(20): <span class="ansi33"
>(:> Expression LazyEvaluatable)
</span>$1 = (:> Expression LazyEvaluatable)

NDet Result(21): <span class="ansi33"
>(@doc Number (@desc "Numeric type, including integers and floating-point numbers."))
</span>$1 = (@doc Number (@desc "Numeric type, including integers and floating-point numbers."))

NDet Result(22): <span class="ansi33"
>(: Number Type)
</span>$1 = (: Number Type)

NDet Result(23): <span class="ansi33"
>(@doc hyperon::space::DynSpace (@desc "Dynamic space type, representing an Atomspace."))
</span>$1 = (@doc hyperon::space::DynSpace (@desc "Dynamic space type, representing an Atomspace."))

NDet Result(24): <span class="ansi33"
>(: hyperon::space::DynSpace Type)
</span>$1 = (: hyperon::space::DynSpace Type)

NDet Result(25): <span class="ansi33"
>(@doc ReturnType (@desc "Type representing a function's return value."))
</span>$1 = (@doc ReturnType (@desc "Type representing a function's return value."))

NDet Result(26): <span class="ansi33"
>(: ReturnType Type)
</span>$1 = (: ReturnType Type)

NDet Result(27): <span class="ansi33"
>(@doc Symbol (@desc "Type representing a symbol or identifier."))
</span>$1 = (@doc Symbol (@desc "Type representing a symbol or identifier."))

NDet Result(28): <span class="ansi33"
>(: Symbol Type)
</span>$1 = (: Symbol Type)

NDet Result(29): <span class="ansi33"
>(@doc StateMonad (@desc "Type representing a state monad, used for encapsulating stateful computations."))
</span>$1 = (@doc StateMonad (@desc "Type representing a state monad, used for encapsulating stateful computations."))

NDet Result(30): <span class="ansi33"
>(: StateMonad Type)
</span>$1 = (: StateMonad Type)

NDet Result(31): <span class="ansi33"
>(@doc Type (@desc "Type representing a type."))
</span>$1 = (@doc Type (@desc "Type representing a type."))

NDet Result(32): <span class="ansi33"
>(: Type Type)
</span>$1 = (: Type Type)

NDet Result(33): <span class="ansi33"
>(@doc True (@desc "Boolean value representing truth."))
</span>$1 = (@doc True (@desc "Boolean value representing truth."))

NDet Result(34): <span class="ansi33"
>(: True Bool)
</span>$1 = (: True Bool)

NDet Result(35): <span class="ansi33"
>(@doc False (@desc "Boolean value representing falsehood."))
</span>$1 = (@doc False (@desc "Boolean value representing falsehood."))

NDet Result(36): <span class="ansi33"
>(: False Bool)
</span>$1 = (: False Bool)

NDet Result(37): <span class="ansi33"
>(@doc %Undefined% (@desc "Special type representing an undefined value or type."))
</span>$1 = (@doc %Undefined% (@desc "Special type representing an undefined value or type."))

NDet Result(38): <span class="ansi33"
>(: %Undefined% Type)
</span>$1 = (: %Undefined% Type)

NDet Result(39): <span class="ansi33"
>(@doc Variable (@desc "Type representing a variable in the language."))
</span>$1 = (@doc Variable (@desc "Type representing a variable in the language."))

NDet Result(40): <span class="ansi33"
>(: Variable Type)
</span>$1 = (: Variable Type)

NDet Result(41): <span class="ansi33"
>(@doc : (@desc "Type declarion operator"))
</span>$1 = (@doc : (@desc "Type declarion operator"))

NDet Result(42): <span class="ansi33"
>(@doc <: (@desc "Super Type declarion operator"))
</span>$1 = (@doc <: (@desc "Super Type declarion operator"))

NDet Result(43): <span class="ansi33"
>(: : %Undefined%)
</span>$1 = (: : %Undefined%)

NDet Result(44): <span class="ansi33"
>(: if-empty (-> Atom Atom Atom Atom))
</span>$1 = (: if-empty (-> Atom Atom Atom Atom))

NDet Result(45): <span class="ansi33"
>(: if-non-empty-expression (-> Atom Atom Atom Atom))
</span>$1 = (: if-non-empty-expression (-> Atom Atom Atom Atom))

NDet Result(46): <span class="ansi33"
>(: if-not-reducible (-> Atom Atom Atom Atom))
</span>$1 = (: if-not-reducible (-> Atom Atom Atom Atom))

NDet Result(47): <span class="ansi33"
>(: return (-> Atom ReturnType))
</span>$1 = (: return (-> Atom ReturnType))

NDet Result(48): <span class="ansi33"
>(: switch (-> %Undefined% Expression Atom))
</span>$1 = (: switch (-> %Undefined% Expression Atom))

NDet Result(49): <span class="ansi33"
>(: unify (-> Atom Atom Atom Atom %Undefined%))
</span>$1 = (: unify (-> Atom Atom Atom Atom %Undefined%))

NDet Result(50): <span class="ansi33"
>(: get-type (-> Atom Type))
</span>$1 = (: get-type (-> Atom Type))

NDet Result(51): <span class="ansi33"
>(: get-type0 (-> Atom Atom))
</span>$1 = (: get-type0 (-> Atom Atom))

NDet Result(52): <span class="ansi33"
>(: get-ftype (-> Atom Atom))
</span>$1 = (: get-ftype (-> Atom Atom))

NDet Result(53): <span class="ansi33"
>(: pragma! (-> Atom Atom (->)))
</span>$1 = (: pragma! (-> Atom Atom (->)))

NDet Result(54): <span class="ansi33"
>(: = (-> Atom Atom %Undefined%))
</span>$1 = (: = (-> Atom Atom %Undefined%))

NDet Result(55): <span class="ansi33"
>(: match (-> hyperon::space::DynSpace Atom Atom %Undefined%))
</span>$1 = (: match (-> hyperon::space::DynSpace Atom Atom %Undefined%))

NDet Result(56): <span class="ansi33"
>(: case (-> Expression Atom Atom))
</span>$1 = (: case (-> Expression Atom Atom))

NDet Result(57): <span class="ansi33"
>(: combine (-> $10000 $10000 $10000))
</span>$1 = (: combine (-> $10000 $10000 $10000))

NDet Result(58): <span class="ansi33"
>(: import! (-> hyperon::space::DynSpace Atom (->)))
</span>$1 = (: import! (-> hyperon::space::DynSpace Atom (->)))

NDet Result(59): <span class="ansi33"
>(: If (-> Bool Atom Atom Atom))
</span>$1 = (: If (-> Bool Atom Atom Atom))

NDet Result(60): <span class="ansi33"
>(: If (-> Bool Atom Atom))
</span>$1 = (: If (-> Bool Atom Atom))

NDet Result(61): <span class="ansi33"
>(= (If True $10000)  $10000)
</span>$1 = (= (If True $10000)  $10000)

NDet Result(62): <span class="ansi33"
>(= (If False $10000)  
  (let $10001 0 
    (let $10001 1 $10001)))
</span>$1 = (= (If False $10000)  
  (let $10001 0 
    (let $10001 1 $10001)))

NDet Result(63): <span class="ansi33"
>(= (If $10000 $10001 $10002)  
  (if $10000 $10001 $10002))
</span>$1 = (= (If $10000 $10001 $10002)  
  (if $10000 $10001 $10002))

NDet Result(64): <span class="ansi33"
>(iz predicate-arity MeTTaLog)
</span>$1 = (iz predicate-arity MeTTaLog)

NDet Result(65): <span class="ansi33"
>(@doc predicate-arity (@desc "Specifies the arity (number of arguments) for a given predicate, allowing it to be queriable in the system's match framework. This is particularly useful for enabling built-in functions, such as `size-atom`, to be used as predicates in declarative contexts and run in reverse to compute inputs based on outputs.\n\n\nFor example:\n  ; Enable the built-in function `size-atom` that takes an atom and returns the size\n    as a predicate with arity 2\n  (predicate-arity size-atom 2)\n\n\n  ; Now `size-atom` can be used as a predicate in pattern matching\n  !(match &dyn-space '(size-atom (a b c) $size) \n         (The abc tuple was len $size))\n  ; This pattern will resolve `Size = 3` and execute the action.\n\n\nAdditionally, by running `size-atom` in reverse, you can compute a new atom based on a desired size:\n  !(match &dyn-space '(size-atom $new-atom 4) \n         (The new atom is $new-atom))\n  ; This resolves `$new-atom` to a tuple of size 4, such as ($1 $2 $3 $4).\n\n\nThis reverse functionality is made possible because predicates can describe relationships, allowing you to infer inputs from outputs.") (@params ((@param "Predicate symbol" "The name of the predicate whose arity is being defined."))) (@return "The number of arguments required for the predicate."))
</span>$1 = (@doc predicate-arity (@desc "Specifies the arity (number of arguments) for a given predicate, allowing it to be queriable in the system's match framework. This is particularly useful for enabling built-in functions, such as `size-atom`, to be used as predicates in declarative contexts and run in reverse to compute inputs based on outputs.\n\n\nFor example:\n  ; Enable the built-in function `size-atom` that takes an atom and returns the size\n    as a predicate with arity 2\n  (predicate-arity size-atom 2)\n\n\n  ; Now `size-atom` can be used as a predicate in pattern matching\n  !(match &dyn-space '(size-atom (a b c) $size) \n         (The abc tuple was len $size))\n  ; This pattern will resolve `Size = 3` and execute the action.\n\n\nAdditionally, by running `size-atom` in reverse, you can compute a new atom based on a desired size:\n  !(match &dyn-space '(size-atom $new-atom 4) \n         (The new atom is $new-atom))\n  ; This resolves `$new-atom` to a tuple of size 4, such as ($1 $2 $3 $4).\n\n\nThis reverse functionality is made possible because predicates can describe relationships, allowing you to infer inputs from outputs.") (@params ((@param "Predicate symbol" "The name of the predicate whose arity is being defined."))) (@return "The number of arguments required for the predicate."))

NDet Result(66): <span class="ansi33"
>(: predicate-arity (-> Symbol Number))
</span>$1 = (: predicate-arity (-> Symbol Number))

NDet Result(67): <span class="ansi33"
>(predicate-arity predicate-arity 2)
</span>$1 = (predicate-arity predicate-arity 2)

NDet Result(68): <span class="ansi33"
>(function-arity predicate-arity 1)
</span>$1 = (function-arity predicate-arity 1)

NDet Result(69): <span class="ansi33"
>(@doc function-arity (@desc "Defines the arity of a function, allowing predicates or built-in facts to also behave as callable functions. This enables procedural-style execution where the last argument of the predicate becomes the function's return value, and the system internally resolves the function using a `match` query. \n\n\nFor example:\n  ; Declare the built-in predicate `max` with arity 3\n  (predicate-arity max 3)\n\n  ; Enable `max` as a function\n  (function-arity max 2)\n\n\n  ; Define the rules for `max`\n  (= (max $X $Y $Y) (<= $X $Y))\n  (= (max $X $Y $X) (> $X $Y))\n\n\n  ; Using `max` declaratively as a predicate\n  !(match &self (max (5 10) $max)\n         (The maximum is $max))\n  [(The maximum is 10)]\n\n\n  ; Using `max` procedurally as a function\n  !(max 5 10)\n  [10]\n  \n\n\n  ; Reverse execution with `max`\n  !(let True (== (max $a $b) 10) ($a $b)) ; as a function\n  [(#(exists $a (=< $a 10)) 10), (10 #(exists $b (=< 10 $b )))]\n  !(match &self (max $a $b 10) ($a $b)) ; or as a predicate\n  [(#(exists $a (=< $a 10)) 10), (10 #(exists $b (=< 10 $b )))]\n\n\n  This dual behavior allows predicates to act as functions, bridging procedural and declarative paradigms. By defining `function-arity`, the function automatically resolves using the logic of the associated predicate.") (@params ((@param "Function symbol" "The name of the function or predicate to enable as a callable function."))) (@return "The number of arguments expected by the function."))
</span>$1 = (@doc function-arity (@desc "Defines the arity of a function, allowing predicates or built-in facts to also behave as callable functions. This enables procedural-style execution where the last argument of the predicate becomes the function's return value, and the system internally resolves the function using a `match` query. \n\n\nFor example:\n  ; Declare the built-in predicate `max` with arity 3\n  (predicate-arity max 3)\n\n  ; Enable `max` as a function\n  (function-arity max 2)\n\n\n  ; Define the rules for `max`\n  (= (max $X $Y $Y) (<= $X $Y))\n  (= (max $X $Y $X) (> $X $Y))\n\n\n  ; Using `max` declaratively as a predicate\n  !(match &self (max (5 10) $max)\n         (The maximum is $max))\n  [(The maximum is 10)]\n\n\n  ; Using `max` procedurally as a function\n  !(max 5 10)\n  [10]\n  \n\n\n  ; Reverse execution with `max`\n  !(let True (== (max $a $b) 10) ($a $b)) ; as a function\n  [(#(exists $a (=< $a 10)) 10), (10 #(exists $b (=< 10 $b )))]\n  !(match &self (max $a $b 10) ($a $b)) ; or as a predicate\n  [(#(exists $a (=< $a 10)) 10), (10 #(exists $b (=< 10 $b )))]\n\n\n  This dual behavior allows predicates to act as functions, bridging procedural and declarative paradigms. By defining `function-arity`, the function automatically resolves using the logic of the associated predicate.") (@params ((@param "Function symbol" "The name of the function or predicate to enable as a callable function."))) (@return "The number of arguments expected by the function."))

NDet Result(70): <span class="ansi33"
>(: function-arity (-> Symbol Number))
</span>$1 = (: function-arity (-> Symbol Number))

NDet Result(71): <span class="ansi33"
>(predicate-arity function-arity 2)
</span>$1 = (predicate-arity function-arity 2)

NDet Result(72): <span class="ansi33"
>(function-arity function-arity 1)
</span>$1 = (function-arity function-arity 1)

NDet Result(73): <span class="ansi33"
>(iz If MeTTa)
</span>$1 = (iz If MeTTa)

NDet Result(74): <span class="ansi33"
>(@doc If (@desc "Conditional function that evaluates and returns one of the provided atoms based on a boolean condition.") (@params ((@param "Boolean condition") (@param "Atom to return if condition is True") (@param "Atom to return if condition is False (optional)"))) (@return "Either the second or third argument depending on the condition"))
</span>$1 = (@doc If (@desc "Conditional function that evaluates and returns one of the provided atoms based on a boolean condition.") (@params ((@param "Boolean condition") (@param "Atom to return if condition is True") (@param "Atom to return if condition is False (optional)"))) (@return "Either the second or third argument depending on the condition"))

NDet Result(75): <span class="ansi33"
>(predicate-arity : 2)
</span>$1 = (predicate-arity : 2)

NDet Result(76): <span class="ansi33"
>(= (: $10000 P1)  
  (predicate-arity $10000 1))
</span>$1 = (= (: $10000 P1)  
  (predicate-arity $10000 1))

NDet Result(77): <span class="ansi33"
>(iz SrcPredicate MeTTa)
</span>$1 = (iz SrcPredicate MeTTa)

NDet Result(78): <span class="ansi33"
>(@doc SrcPredicate (@desc "Type representing a source predicate."))
</span>$1 = (@doc SrcPredicate (@desc "Type representing a source predicate."))

NDet Result(79): <span class="ansi33"
>(: SrcPredicate Type)
</span>$1 = (: SrcPredicate Type)

NDet Result(80): <span class="ansi33"
>(iz SrcFunction MeTTa)
</span>$1 = (iz SrcFunction MeTTa)

NDet Result(81): <span class="ansi33"
>(@doc SrcFunction (@desc "Type representing a source function."))
</span>$1 = (@doc SrcFunction (@desc "Type representing a source function."))

NDet Result(82): <span class="ansi33"
>(: SrcFunction Type)
</span>$1 = (: SrcFunction Type)

NDet Result(83): <span class="ansi33"
>(iz MeTTaResult MeTTa)
</span>$1 = (iz MeTTaResult MeTTa)

NDet Result(84): <span class="ansi33"
>(@doc MeTTaResult (@desc "Type representing the result of a MeTTa evaluation."))
</span>$1 = (@doc MeTTaResult (@desc "Type representing the result of a MeTTa evaluation."))

NDet Result(85): <span class="ansi33"
>(: MeTTaResult Type)
</span>$1 = (: MeTTaResult Type)

NDet Result(86): <span class="ansi33"
>(iz NotReducible MeTTaResult)
</span>$1 = (iz NotReducible MeTTaResult)

NDet Result(87): <span class="ansi33"
>(@doc NotReducible (@desc "Result indicating that an atom cannot be reduced further."))
</span>$1 = (@doc NotReducible (@desc "Result indicating that an atom cannot be reduced further."))

NDet Result(88): <span class="ansi33"
>(: NotReducible MeTTaResult)
</span>$1 = (: NotReducible MeTTaResult)

NDet Result(89): <span class="ansi33"
>Empty
</span>$1 = (iz  MeTTaResult)

NDet Result(90): <span class="ansi33"
>Empty
</span>$1 = (@doc  (@desc "Result indicating an empty evaluation result."))

NDet Result(91): <span class="ansi33"
>Empty
</span>$1 = (:  MeTTaResult)

NDet Result(92): <span class="ansi33"
>(iz ValueAtom MeTTa)
</span>$1 = (iz ValueAtom MeTTa)

NDet Result(93): <span class="ansi33"
>(@doc ValueAtom (@desc "Type representing a value atom."))
</span>$1 = (@doc ValueAtom (@desc "Type representing a value atom."))

NDet Result(94): <span class="ansi33"
>(:> ValueAtom Atom)
</span>$1 = (:> ValueAtom Atom)

NDet Result(95): <span class="ansi33"
>(iz ForeignObject MeTTa)
</span>$1 = (iz ForeignObject MeTTa)

NDet Result(96): <span class="ansi33"
>(@doc ForeignObject (@desc "Type representing a foreign object, such as a Python object."))
</span>$1 = (@doc ForeignObject (@desc "Type representing a foreign object, such as a Python object."))

NDet Result(97): <span class="ansi33"
>(: ForeignObject Type)
</span>$1 = (: ForeignObject Type)

NDet Result(98): <span class="ansi33"
>(:> ValueAtom Grounded)
</span>$1 = (:> ValueAtom Grounded)

NDet Result(99): <span class="ansi33"
>(:> ForeignObject ValueAtom)
</span>$1 = (:> ForeignObject ValueAtom)

NDet Result(100): <span class="ansi33"
>(iz PyObject MeTTa)
</span>$1 = (iz PyObject MeTTa)

NDet Result(101): <span class="ansi33"
>(@doc PyObject (@desc "Type representing a Python object."))
</span>$1 = (@doc PyObject (@desc "Type representing a Python object."))

NDet Result(102): <span class="ansi33"
>(:> PyObject ForeignObject)
</span>$1 = (:> PyObject ForeignObject)

NDet Result(103): <span class="ansi33"
>(:> hyperon::space::DynSpace Grounded)
</span>$1 = (:> hyperon::space::DynSpace Grounded)

NDet Result(104): <span class="ansi33"
>(iz py-list MeTTa)
</span>$1 = (iz py-list MeTTa)

NDet Result(105): <span class="ansi33"
>(@doc py-list (@desc "Converts a MeTTa Expression into a Python list and returns it as a PyObject.") (@params ((@param (@desc "A MeTTa List that will be converted into a Python list")))) (@return (@desc "A Python list object that represents the given MeTTa Expression as a PyObject")))
</span>$1 = (@doc py-list (@desc "Converts a MeTTa Expression into a Python list and returns it as a PyObject.") (@params ((@param (@desc "A MeTTa List that will be converted into a Python list")))) (@return (@desc "A Python list object that represents the given MeTTa Expression as a PyObject")))

NDet Result(106): <span class="ansi33"
>(: py-list (-> Expression PyObject))
</span>$1 = (: py-list (-> Expression PyObject))

NDet Result(107): <span class="ansi33"
>(iz py-chain MeTTa)
</span>$1 = (iz py-chain MeTTa)

NDet Result(108): <span class="ansi33"
>(@doc py-chain (@desc "Chains together a list of Python objects contained in a MeTTa Expression, applying the Python vertical bar | OR operation jointly to all elements.") (@params ((@param (@desc "A MeTTa list of atoms, each embedding a Python object.")))) (@return (@desc "A MeTTa atom which embeds the result of applying the Python OR | operator to all elements of the list.")))
</span>$1 = (@doc py-chain (@desc "Chains together a list of Python objects contained in a MeTTa Expression, applying the Python vertical bar | OR operation jointly to all elements.") (@params ((@param (@desc "A MeTTa list of atoms, each embedding a Python object.")))) (@return (@desc "A MeTTa atom which embeds the result of applying the Python OR | operator to all elements of the list.")))

NDet Result(109): <span class="ansi33"
>(: py-chain (-> Expression PyObject))
</span>$1 = (: py-chain (-> Expression PyObject))

NDet Result(110): <span class="ansi33"
>(iz py-eval MeTTaLog)
</span>$1 = (iz py-eval MeTTaLog)

NDet Result(111): <span class="ansi33"
>(@doc py-eval (@desc "Evaluates a Python expression from a string and returns the result as a PyObject.") (@params ((@param (@desc "A string representing a Python expression that will be evaluated")))) (@return (@desc "The result of evaluating the Python expression as a PyObject")))
</span>$1 = (@doc py-eval (@desc "Evaluates a Python expression from a string and returns the result as a PyObject.") (@params ((@param (@desc "A string representing a Python expression that will be evaluated")))) (@return (@desc "The result of evaluating the Python expression as a PyObject")))

NDet Result(112): <span class="ansi33"
>(: py-eval (-> String PyObject))
</span>$1 = (: py-eval (-> String PyObject))

NDet Result(113): <span class="ansi33"
>(iz py-exec! MeTTaLog)
</span>$1 = (iz py-exec! MeTTaLog)

NDet Result(114): <span class="ansi33"
>(@doc py-exec! (@desc "Executes some Python sourcecode from a string !(py-exec! \"import torch\") -> True.  !(py-exec! \"import torche\") -> False. ") (@params ((@param (@type String) (@desc "A string representing a Python sourcecode that will be executed")))) (@return (@desc "The True|False results of executing the Python expression")))
</span>$1 = (@doc py-exec! (@desc "Executes some Python sourcecode from a string !(py-exec! \"import torch\") -> True.  !(py-exec! \"import torche\") -> False. ") (@params ((@param (@type String) (@desc "A string representing a Python sourcecode that will be executed")))) (@return (@desc "The True|False results of executing the Python expression")))

NDet Result(115): <span class="ansi33"
>(: py-exec! (-> String Bool))
</span>$1 = (: py-exec! (-> String Bool))

NDet Result(116): <span class="ansi33"
>(iz = MeTTa)
</span>$1 = (iz = MeTTa)

NDet Result(117): <span class="ansi33"
>(@doc = (@desc "A symbol used to define reduction rules for expressions.") (@params ((@param "Pattern to be matched against expression to be reduced") (@param "Result of reduction or transformation of the first pattern"))) (@return "Not reduced itself unless custom equalities over equalities are added"))
</span>$1 = (@doc = (@desc "A symbol used to define reduction rules for expressions.") (@params ((@param "Pattern to be matched against expression to be reduced") (@param "Result of reduction or transformation of the first pattern"))) (@return "Not reduced itself unless custom equalities over equalities are added"))

NDet Result(118): <span class="ansi33"
>(: = (-> $10000 $10000 Atom))
</span>$1 = (: = (-> $10000 $10000 Atom))

NDet Result(119): <span class="ansi33"
>(: = (-> Atom Atom Atom))
</span>$1 = (: = (-> Atom Atom Atom))

NDet Result(120): <span class="ansi33"
>(iz ErrorType MeTTa)
</span>$1 = (iz ErrorType MeTTa)

NDet Result(121): <span class="ansi33"
>(@doc ErrorType (@desc "Type of the atom which contains error"))
</span>$1 = (@doc ErrorType (@desc "Type of the atom which contains error"))

NDet Result(122): <span class="ansi33"
>(: ErrorType Type)
</span>$1 = (: ErrorType Type)

NDet Result(123): <span class="ansi33"
>(iz Error MeTTa)
</span>$1 = (iz Error MeTTa)

NDet Result(124): <span class="ansi33"
>(@doc Error (@desc "Error constructor") (@params ((@param "Atom which contains error") (@param "Error message, can be one of the reserved symbols: BadType, IncorrectNumberOfArguments"))) (@return "Instance of the error atom"))
</span>$1 = (@doc Error (@desc "Error constructor") (@params ((@param "Atom which contains error") (@param "Error message, can be one of the reserved symbols: BadType, IncorrectNumberOfArguments"))) (@return "Instance of the error atom"))

NDet Result(125): <span class="ansi33"
>(: Error (-> Atom Atom ErrorType))
</span>$1 = (: Error (-> Atom Atom ErrorType))

NDet Result(126): <span class="ansi33"
>(iz return MinimalMeTTa)
</span>$1 = (iz return MinimalMeTTa)

NDet Result(127): <span class="ansi33"
>(@doc return (@desc "Returns value from the (function ...) expression") (@params ((@param "Value to be returned"))) (@return "Passed argument"))
</span>$1 = (@doc return (@desc "Returns value from the (function ...) expression") (@params ((@param "Value to be returned"))) (@return "Passed argument"))

NDet Result(128): <span class="ansi33"
>(: return (-> $10000 $10000))
</span>$1 = (: return (-> $10000 $10000))

NDet Result(129): <span class="ansi33"
>(iz function MinimalMeTTa)
</span>$1 = (iz function MinimalMeTTa)

NDet Result(130): <span class="ansi33"
>(@doc function (@desc "Evaluates the argument until it becomes (return <result>). Then (function (return <result>)) is reduced to the <result>.") (@params ((@param "Atom to be evaluated"))) (@return "Result of atom's evaluation"))
</span>$1 = (@doc function (@desc "Evaluates the argument until it becomes (return <result>). Then (function (return <result>)) is reduced to the <result>.") (@params ((@param "Atom to be evaluated"))) (@return "Result of atom's evaluation"))

NDet Result(131): <span class="ansi33"
>(: function (-> Atom Atom))
</span>$1 = (: function (-> Atom Atom))

NDet Result(132): <span class="ansi33"
>(iz eval MinimalMeTTa)
</span>$1 = (iz eval MinimalMeTTa)

NDet Result(133): <span class="ansi33"
>(@doc eval (@desc "Evaluates input Atom, performs one step of the evaluation. Empty results (Empty, ()) are removed from the result set. If no results are produced for a non-grounded function, eval returns NotReducible.") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function"))) (@return "Result of evaluation"))
</span>$1 = (@doc eval (@desc "Evaluates input Atom, performs one step of the evaluation. Empty results (Empty, ()) are removed from the result set. If no results are produced for a non-grounded function, eval returns NotReducible.") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function"))) (@return "Result of evaluation"))

NDet Result(134): <span class="ansi33"
>(: eval (-> Atom Atom))
</span>$1 = (: eval (-> Atom Atom))

NDet Result(135): <span class="ansi33"
>(@doc evalc (@desc "Evaluates input atom, makes one step of the evaluation") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function") (@param "Space to evaluate atom in its context"))) (@return "Result of evaluation"))
</span>$1 = (@doc evalc (@desc "Evaluates input atom, makes one step of the evaluation") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function") (@param "Space to evaluate atom in its context"))) (@return "Result of evaluation"))

NDet Result(136): <span class="ansi33"
>(: evalc (-> Atom Grounded Atom))
</span>$1 = (: evalc (-> Atom Grounded Atom))

NDet Result(137): <span class="ansi33"
>(iz chain MinimalMeTTa)
</span>$1 = (iz chain MinimalMeTTa)

NDet Result(138): <span class="ansi33"
>(@doc chain (@desc "Evaluates first argument Atom, binds it to the Variable (second argument) and then evaluates third argument Template with Variable substituted in. When evaluation of the first Atom brings more than a single result, chain returns one instance of the Template expression for each result. The first argument Atom is only evaluated if it is part of the Minimal MeTTa specification; evaluation of non-Minimal MeTTa atoms can be controlled by wrapping in a call to eval (for one evaluation step) or metta (for full evaluation).") (@params ((@param "Atom to be evaluated") (@param "Variable") (@param "Template which will be evaluated at the end with Variable substituted"))) (@return "Result of evaluating third input argument"))
</span>$1 = (@doc chain (@desc "Evaluates first argument Atom, binds it to the Variable (second argument) and then evaluates third argument Template with Variable substituted in. When evaluation of the first Atom brings more than a single result, chain returns one instance of the Template expression for each result. The first argument Atom is only evaluated if it is part of the Minimal MeTTa specification; evaluation of non-Minimal MeTTa atoms can be controlled by wrapping in a call to eval (for one evaluation step) or metta (for full evaluation).") (@params ((@param "Atom to be evaluated") (@param "Variable") (@param "Template which will be evaluated at the end with Variable substituted"))) (@return "Result of evaluating third input argument"))

NDet Result(139): <span class="ansi33"
>(: chain (-> Atom Variable Atom Atom))
</span>$1 = (: chain (-> Atom Variable Atom Atom))

NDet Result(140): <span class="ansi33"
>(iz unify MeTTa)
</span>$1 = (iz unify MeTTa)

NDet Result(141): <span class="ansi33"
>(@doc unify (@desc "Like Match but allows any sort of container for the first argument. (Match only allows MeTTa spaces.)") (@params ((@param "The collection or space to match") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when found or fourth one otherwise"))
</span>$1 = (@doc unify (@desc "Like Match but allows any sort of container for the first argument. (Match only allows MeTTa spaces.)") (@params ((@param "The collection or space to match") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when found or fourth one otherwise"))

NDet Result(142): <span class="ansi33"
>(: unify (-> Atom Atom Atom Atom Atom))
</span>$1 = (: unify (-> Atom Atom Atom Atom Atom))

NDet Result(143): <span class="ansi33"
>(iz if-unify MinimalMeTTaHelper)
</span>$1 = (iz if-unify MinimalMeTTaHelper)

NDet Result(144): <span class="ansi33"
>(@doc if-unify (@desc "Matches two first terms and returns third argument if they are matched and fourth argument otherwise") (@params ((@param "First term to unify with") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when first two atoms are unifiable or fourth one otherwise"))
</span>$1 = (@doc if-unify (@desc "Matches two first terms and returns third argument if they are matched and fourth argument otherwise") (@params ((@param "First term to unify with") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when first two atoms are unifiable or fourth one otherwise"))

NDet Result(145): <span class="ansi33"
>(: if-unify (-> Atom Atom Atom Atom %Undefined%))
</span>$1 = (: if-unify (-> Atom Atom Atom Atom %Undefined%))

NDet Result(146): <span class="ansi33"
>(ALT= $10000 $10000)
</span>$1 = (ALT= (if-unify $10000 $10000 $10001 $10002) $10001)

NDet Result(147): <span class="ansi33"
>Empty
</span>$1 = (ALT= (if-unify $10000 $10000 $10001 $10002) (case (if-unify-or-empty $10000 $10000) (( $10002))))

NDet Result(148): <span class="ansi33"
>(iz if-unify-or-empty MinimalMeTTaHelper)
</span>$1 = (iz if-unify-or-empty MinimalMeTTaHelper)

NDet Result(149): <span class="ansi33"
>(@doc if-unify-or-empty (@desc "Attempts to unify two atoms and returns a result. Returns Empty if they cannot be unified.") (@params ((@param "First atom") (@param "Second atom"))) (@return "Unification result or Empty"))
</span>$1 = (@doc if-unify-or-empty (@desc "Attempts to unify two atoms and returns a result. Returns Empty if they cannot be unified.") (@params ((@param "First atom") (@param "Second atom"))) (@return "Unification result or Empty"))

NDet Result(150): <span class="ansi33"
>(: if-unify-or-empty (-> Atom Atom Atom))
</span>$1 = (: if-unify-or-empty (-> Atom Atom Atom))

NDet Result(151): <span class="ansi33"
>(= (if-unify-or-empty $10000 $10000)  unified)
</span>$1 = (= (if-unify-or-empty $10000 $10000)  unified)

NDet Result(152): <span class="ansi33"
>(= (if-unify-or-empty $10000 $10001)  
  (empty))
</span>$1 = (= (if-unify-or-empty $10000 $10001)  
  (empty))

NDet Result(153): <span class="ansi33"
>(iz cons-atom MinimalMeTTa)
</span>$1 = (iz cons-atom MinimalMeTTa)

NDet Result(154): <span class="ansi33"
>(@doc cons-atom (@desc "Constructs an expression using two arguments") (@params ((@param "Head of an expression") (@param "Tail of an expression"))) (@return "New expression consisting of the two input arguments"))
</span>$1 = (@doc cons-atom (@desc "Constructs an expression using two arguments") (@params ((@param "Head of an expression") (@param "Tail of an expression"))) (@return "New expression consisting of the two input arguments"))

NDet Result(155): <span class="ansi33"
>(: cons-atom (-> Atom Expression Expression))
</span>$1 = (: cons-atom (-> Atom Expression Expression))

NDet Result(156): <span class="ansi33"
>(iz decons-atom MinimalMeTTa)
</span>$1 = (iz decons-atom MinimalMeTTa)

NDet Result(157): <span class="ansi33"
>(@doc decons-atom (@desc "Works as a reverse to cons-atom function. It gets Expression as an input and returns it split into head and tail, e.g. (decons-atom (Cons X Nil)) -> (Cons (X Nil))") (@params ((@param "Expression to be Deconsed"))) (@return "Deconsed expression"))
</span>$1 = (@doc decons-atom (@desc "Works as a reverse to cons-atom function. It gets Expression as an input and returns it split into head and tail, e.g. (decons-atom (Cons X Nil)) -> (Cons (X Nil))") (@params ((@param "Expression to be Deconsed"))) (@return "Deconsed expression"))

NDet Result(158): <span class="ansi33"
>(: decons-atom (-> Expression Expression))
</span>$1 = (: decons-atom (-> Expression Expression))

NDet Result(159): <span class="ansi33"
>(iz min-atom MeTTa)
</span>$1 = (iz min-atom MeTTa)

NDet Result(160): <span class="ansi33"
>(@doc min-atom (@desc "Returns atom with minimum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Minimum value in the expression. Error if expression contains non-numeric value or is empty."))
</span>$1 = (@doc min-atom (@desc "Returns atom with minimum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Minimum value in the expression. Error if expression contains non-numeric value or is empty."))

NDet Result(161): <span class="ansi33"
>(: min-atom (-> Expression Number))
</span>$1 = (: min-atom (-> Expression Number))

NDet Result(162): <span class="ansi33"
>(= (min-atom $10000)  
  (call-fn! min_list $10000))
</span>$1 = (= (min-atom $10000)  
  (call-fn! min_list $10000))

NDet Result(163): <span class="ansi33"
>(iz max-atom MeTTa)
</span>$1 = (iz max-atom MeTTa)

NDet Result(164): <span class="ansi33"
>(@doc max-atom (@desc "Returns atom with maximum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Maximum value in the expression. Error if expression contains non-numeric value or is empty."))
</span>$1 = (@doc max-atom (@desc "Returns atom with maximum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Maximum value in the expression. Error if expression contains non-numeric value or is empty."))

NDet Result(165): <span class="ansi33"
>(: max-atom (-> Expression Number))
</span>$1 = (: max-atom (-> Expression Number))

NDet Result(166): <span class="ansi33"
>(is-fn-1 max-atom max_list)
</span>$1 = (is-fn-1 max-atom max_list)

NDet Result(167): <span class="ansi33"
>(iz size-atom MeTTa)
</span>$1 = (iz size-atom MeTTa)

NDet Result(168): <span class="ansi33"
>(@doc size-atom (@desc "Returns the size of an expression (first argument).") (@params ((@param "Expression to measure the size of"))) (@return "Size of the expression"))
</span>$1 = (@doc size-atom (@desc "Returns the size of an expression (first argument).") (@params ((@param "Expression to measure the size of"))) (@return "Size of the expression"))

NDet Result(169): <span class="ansi33"
>(: size-atom (-> Expression Integer))
</span>$1 = (: size-atom (-> Expression Integer))

NDet Result(170): <span class="ansi33"
>(is-fn-1 size-atom length)
</span>$1 = (is-fn-1 size-atom length)

NDet Result(171): <span class="ansi33"
>(iz index-atom MeTTa)
</span>$1 = (iz index-atom MeTTa)

NDet Result(172): <span class="ansi33"
>(@doc index-atom (@desc "Returns atom from an expression (first argument) using index (second argument) or error if index is out of bounds.") (@params ((@param "Expression") (@param "Index"))) (@return "Atom at the specified index in the expression. Error if index is out of bounds."))
</span>$1 = (@doc index-atom (@desc "Returns atom from an expression (first argument) using index (second argument) or error if index is out of bounds.") (@params ((@param "Expression") (@param "Index"))) (@return "Atom at the specified index in the expression. Error if index is out of bounds."))

NDet Result(173): <span class="ansi33"
>(: index-atom (-> Expression Number Atom))
</span>$1 = (: index-atom (-> Expression Number Atom))

NDet Result(174): <span class="ansi33"
>(is-fn-21 index-atom nth0)
</span>$1 = (is-fn-21 index-atom nth0)

NDet Result(175): <span class="ansi33"
>(iz powi MeTTa)
</span>$1 = (iz powi MeTTa)

NDet Result(176): <span class="ansi33"
>(@doc powi (@desc "Takes base (first argument) and power (second argument) and returns the result of raising the base to the power.") (@params ((@param "Base. Could be a float.") (@param "Power. Must be an integer."))) (@return "Result of base raised to the power"))
</span>$1 = (@doc powi (@desc "Takes base (first argument) and power (second argument) and returns the result of raising the base to the power.") (@params ((@param "Base. Could be a float.") (@param "Power. Must be an integer."))) (@return "Result of base raised to the power"))

NDet Result(177): <span class="ansi33"
>(= (powi $10000 $10001)  
  (call-fn! pow $10000 $10001))
</span>$1 = (= (powi $10000 $10001)  
  (call-fn! pow $10000 $10001))

NDet Result(178): <span class="ansi33"
>(==> (is-op-1 $10000 $10001) (is-fn-1 $10000 $10001))
</span>$1 = (==> (is-op-1 $10000 $10001) (is-fn-1 $10000 $10001))

NDet Result(179): <span class="ansi33"
>(==> (is-op-1 $10000 $10001) (: $10000 (-> Number Number)))
</span>$1 = (==> (is-op-1 $10000 $10001) (: $10000 (-> Number Number)))

NDet Result(180): <span class="ansi33"
>(==> (is-op-2 $10000 $10001) (is-fn-2 $10000 $10001))
</span>$1 = (==> (is-op-2 $10000 $10001) (is-fn-2 $10000 $10001))

NDet Result(181): <span class="ansi33"
>(==> (is-op-2 $10000 $10001) (: $10000 (-> Number Number Number)))
</span>$1 = (==> (is-op-2 $10000 $10001) (: $10000 (-> Number Number Number)))

NDet Result(182): <span class="ansi33"
>(==> (is-pred $10000 $10001) (is-pred-1 $10000 $10001))
</span>$1 = (==> (is-pred $10000 $10001) (is-pred-1 $10000 $10001))

NDet Result(183): <span class="ansi33"
>(==> (is-pred $10000 $10001) (: $10000 (-> Number Bool)))
</span>$1 = (==> (is-pred $10000 $10001) (: $10000 (-> Number Bool)))

NDet Result(184): <span class="ansi33"
>(==> (is-fn-1 $10000 $10001) (= ($10000 $10002)  
  (call-fn! $10001 $10002)))
</span>$1 = (==> (is-fn-1 $10000 $10001) (= ($10000 $10002)  
  (call-fn! $10001 $10002)))

NDet Result(185): <span class="ansi33"
>(==> (is-fn-r $10000 $10001) (= ($10000 $10002)  
  (call-fn-r! $10001 $10002)))
</span>$1 = (==> (is-fn-r $10000 $10001) (= ($10000 $10002)  
  (call-fn-r! $10001 $10002)))

NDet Result(186): <span class="ansi33"
>(==> (is-fn-2 $10000 $10001) (= ($10000 $10002 $10003)  
  (call-fn! $10001 $10002 $10003)))
</span>$1 = (==> (is-fn-2 $10000 $10001) (= ($10000 $10002 $10003)  
  (call-fn! $10001 $10002 $10003)))

NDet Result(187): <span class="ansi33"
>(==> (is-fn-21 $10000 $10001) (= ($10000 $10002 $10003)  
  (call-fn! $10001 $10003 $10002)))
</span>$1 = (==> (is-fn-21 $10000 $10001) (= ($10000 $10002 $10003)  
  (call-fn! $10001 $10003 $10002)))

NDet Result(188): <span class="ansi33"
>(==> (is-pred-1 $10000 $10001) (= ($10000 $10002)  
  (call-p! $10001 $10002)))
</span>$1 = (==> (is-pred-1 $10000 $10001) (= ($10000 $10002)  
  (call-p! $10001 $10002)))

NDet Result(189): <span class="ansi33"
>(==> (is-pred-2 $10000 $10001) (= ($10000 $10002 $10003)  
  (call-p! $10001 $10002 $10003)))
</span>$1 = (==> (is-pred-2 $10000 $10001) (= ($10000 $10002 $10003)  
  (call-p! $10001 $10002 $10003)))

NDet Result(190): <span class="ansi33"
>(is-fn-1 py-list py_list)
</span>$1 = (is-fn-1 py-list py_list)

NDet Result(191): <span class="ansi33"
>(iz powf MeTTa)
</span>$1 = (iz powf MeTTa)

NDet Result(192): <span class="ansi33"
>(@doc powf (@desc "Takes base (first argument) and power (second argument) and returns the result of raising the base to the power.") (@params ((@param "Base. Could be afloat.") (@param "Power. Could be afloat."))) (@return "Result of base raisedtothepower "))
</span>$1 = (@doc powf (@desc "Takes base (first argument) and power (second argument) and returns the result of raising the base to the power.") (@params ((@param "Base. Could be afloat.") (@param "Power. Could be afloat."))) (@return "Result of base raisedtothepower "))

NDet Result(193): <span class="ansi33"
>(is-op-2 powf pow)
</span>$1 = (is-op-2 powf pow)

NDet Result(194): <span class="ansi33"
>(is-op-2 pow pow)
</span>$1 = (is-op-2 pow pow)

NDet Result(195): <span class="ansi33"
>(iz sqrt MeTTa)
</span>$1 = (iz sqrt MeTTa)

NDet Result(196): <span class="ansi33"
>(@doc sqrt (@desc "Returns square root for input number (first argument) which should be >= 0") (@params ((@param "Input number"))) (@return "Result of a square root function"))
</span>$1 = (@doc sqrt (@desc "Returns square root for input number (first argument) which should be >= 0") (@params ((@param "Input number"))) (@return "Result of a square root function"))

NDet Result(197): <span class="ansi33"
>(is-op-1 sqrt sqrt)
</span>$1 = (is-op-1 sqrt sqrt)

NDet Result(198): <span class="ansi33"
>(iz abs MeTTa)
</span>$1 = (iz abs MeTTa)

NDet Result(199): <span class="ansi33"
>(@doc abs (@desc "Returns absolute value of input number (first argument)") (@params ((@param "Input number"))) (@return "Absolute value"))
</span>$1 = (@doc abs (@desc "Returns absolute value of input number (first argument)") (@params ((@param "Input number"))) (@return "Absolute value"))

NDet Result(200): <span class="ansi33"
>(is-op-1 abs abs)
</span>$1 = (is-op-1 abs abs)

NDet Result(201): <span class="ansi33"
>(iz log MeTTa)
</span>$1 = (iz log MeTTa)

NDet Result(202): <span class="ansi33"
>(@doc log (@desc "Returns result of a logarithm function given base (first argument) and input number (second argument)") (@params ((@param "Base") (@param "Input number"))) (@return "Result of log function"))
</span>$1 = (@doc log (@desc "Returns result of a logarithm function given base (first argument) and input number (second argument)") (@params ((@param "Base") (@param "Input number"))) (@return "Result of log function"))

NDet Result(203): <span class="ansi33"
>(is-op-2 log log2)
</span>$1 = (is-op-2 log log2)

NDet Result(204): <span class="ansi33"
>(iz trunc MeTTa)
</span>$1 = (iz trunc MeTTa)

NDet Result(205): <span class="ansi33"
>(@doc trunc (@desc "Returns integer part of the input value (first argument)") (@params ((@param "Float value"))) (@return "Integer part of float"))
</span>$1 = (@doc trunc (@desc "Returns integer part of the input value (first argument)") (@params ((@param "Float value"))) (@return "Integer part of float"))

NDet Result(206): <span class="ansi33"
>(is-op-1 trunc trunc)
</span>$1 = (is-op-1 trunc trunc)

NDet Result(207): <span class="ansi33"
>(iz ceil MeTTa)
</span>$1 = (iz ceil MeTTa)

NDet Result(208): <span class="ansi33"
>(@doc ceil (@desc "Returns the smallest integer greater than or equal to the input value (first argument)") (@params ((@param "Float value"))) (@return "Integer value greater than or equal to the input"))
</span>$1 = (@doc ceil (@desc "Returns the smallest integer greater than or equal to the input value (first argument)") (@params ((@param "Float value"))) (@return "Integer value greater than or equal to the input"))

NDet Result(209): <span class="ansi33"
>(is-op-1 ceil ceil)
</span>$1 = (is-op-1 ceil ceil)

NDet Result(210): <span class="ansi33"
>(iz floor MeTTa)
</span>$1 = (iz floor MeTTa)

NDet Result(211): <span class="ansi33"
>(@doc floor (@desc "Returns the smallest integer less than or equal to the input value (first argument)") (@params ((@param "Float value"))) (@return "Integer value less than or equal to the input"))
</span>$1 = (@doc floor (@desc "Returns the smallest integer less than or equal to the input value (first argument)") (@params ((@param "Float value"))) (@return "Integer value less than or equal to the input"))

NDet Result(212): <span class="ansi33"
>(is-op-1 floor floor)
</span>$1 = (is-op-1 floor floor)

NDet Result(213): <span class="ansi33"
>(iz round MeTTa)
</span>$1 = (iz round MeTTa)

NDet Result(214): <span class="ansi33"
>(@doc round (@desc "Returns the nearest integer to the input float value (first argument)") (@params ((@param "Float value"))) (@return "Nearest integer to the input"))
</span>$1 = (@doc round (@desc "Returns the nearest integer to the input float value (first argument)") (@params ((@param "Float value"))) (@return "Nearest integer to the input"))

NDet Result(215): <span class="ansi33"
>(is-op-1 round round)
</span>$1 = (is-op-1 round round)

NDet Result(216): <span class="ansi33"
>(iz sin MeTTa)
</span>$1 = (iz sin MeTTa)

NDet Result(217): <span class="ansi33"
>(@doc sin (@desc "Returns result of the sine function for an input value in radians (first argument)") (@params ((@param "Angle in radians"))) (@return "Result of the sine function"))
</span>$1 = (@doc sin (@desc "Returns result of the sine function for an input value in radians (first argument)") (@params ((@param "Angle in radians"))) (@return "Result of the sine function"))

NDet Result(218): <span class="ansi33"
>(is-op-1 sin sin)
</span>$1 = (is-op-1 sin sin)

NDet Result(219): <span class="ansi33"
>(iz asin MeTTa)
</span>$1 = (iz asin MeTTa)

NDet Result(220): <span class="ansi33"
>(@doc asin (@desc "Returns result of the arcsine function for an input value (first argument)") (@params ((@param "Float number"))) (@return "Result of the arcsine function"))
</span>$1 = (@doc asin (@desc "Returns result of the arcsine function for an input value (first argument)") (@params ((@param "Float number"))) (@return "Result of the arcsine function"))

NDet Result(221): <span class="ansi33"
>(is-op-1 asin asin)
</span>$1 = (is-op-1 asin asin)

NDet Result(222): <span class="ansi33"
>(iz cos MeTTa)
</span>$1 = (iz cos MeTTa)

NDet Result(223): <span class="ansi33"
>(@doc cos (@desc "Returns result of the cosine function for an input value in radians (first argument)") (@params ((@param "Angle in radians"))) (@return "Result of the cosine function"))
</span>$1 = (@doc cos (@desc "Returns result of the cosine function for an input value in radians (first argument)") (@params ((@param "Angle in radians"))) (@return "Result of the cosine function"))

NDet Result(224): <span class="ansi33"
>(is-op-1 cos cos)
</span>$1 = (is-op-1 cos cos)

NDet Result(225): <span class="ansi33"
>(iz acos MeTTa)
</span>$1 = (iz acos MeTTa)

NDet Result(226): <span class="ansi33"
>(@doc acos (@desc "Returns result of the arccosine function for an input value (first argument)") (@params ((@param "Float number"))) (@return "Result of the arccosine function"))
</span>$1 = (@doc acos (@desc "Returns result of the arccosine function for an input value (first argument)") (@params ((@param "Float number"))) (@return "Result of the arccosine function"))

NDet Result(227): <span class="ansi33"
>(is-op-1 acos acos)
</span>$1 = (is-op-1 acos acos)

NDet Result(228): <span class="ansi33"
>(iz tan MeTTa)
</span>$1 = (iz tan MeTTa)

NDet Result(229): <span class="ansi33"
>(@doc tan (@desc "Returns result of the tangent function for an input value in radians (first argument)") (@params ((@param "Angle in radians"))) (@return "Result of the tangent function"))
</span>$1 = (@doc tan (@desc "Returns result of the tangent function for an input value in radians (first argument)") (@params ((@param "Angle in radians"))) (@return "Result of the tangent function"))

NDet Result(230): <span class="ansi33"
>(is-op-1 tan tan)
</span>$1 = (is-op-1 tan tan)

NDet Result(231): <span class="ansi33"
>(iz atan MeTTa)
</span>$1 = (iz atan MeTTa)

NDet Result(232): <span class="ansi33"
>(@doc atan (@desc "Returns result of the arctangent function for an input value (first argument)") (@params ((@param "Float number"))) (@return "Result of the tangent function"))
</span>$1 = (@doc atan (@desc "Returns result of the arctangent function for an input value (first argument)") (@params ((@param "Float number"))) (@return "Result of the tangent function"))

NDet Result(233): <span class="ansi33"
>(is-op-1 atan atan)
</span>$1 = (is-op-1 atan atan)

NDet Result(234): <span class="ansi33"
>(iz isnan MeTTa)
</span>$1 = (iz isnan MeTTa)

NDet Result(235): <span class="ansi33"
>(@doc isnan (@desc "Returns True if input value is NaN. False - otherwise") (@params ((@param "Number"))) (@return "True/False"))
</span>$1 = (@doc isnan (@desc "Returns True if input value is NaN. False - otherwise") (@params ((@param "Number"))) (@return "True/False"))

NDet Result(236): <span class="ansi33"
>(is-pred isnan is_NaN)
</span>$1 = (is-pred isnan is_NaN)

NDet Result(237): <span class="ansi33"
>(iz isinf MeTTa)
</span>$1 = (iz isinf MeTTa)

NDet Result(238): <span class="ansi33"
>(@doc isinf (@desc "Returns True if input value is positive or negative infinity. False - otherwise") (@params ((@param "Number"))) (@return "True/False"))
</span>$1 = (@doc isinf (@desc "Returns True if input value is positive or negative infinity. False - otherwise") (@params ((@param "Number"))) (@return "True/False"))

NDet Result(239): <span class="ansi33"
>(is-pred isinf is_Inf)
</span>$1 = (is-pred isinf is_Inf)

NDet Result(240): <span class="ansi33"
>(iz random-int MeTTa)
</span>$1 = (iz random-int MeTTa)

NDet Result(241): <span class="ansi33"
>(@doc random-int (@desc "Returns random int number from range defined by two numbers (first and second argument)") (@params ((@param "Range start") (@param "Range end"))) (@return "Random int number from defined range"))
</span>$1 = (@doc random-int (@desc "Returns random int number from range defined by two numbers (first and second argument)") (@params ((@param "Range start") (@param "Range end"))) (@return "Random int number from defined range"))

NDet Result(242): <span class="ansi33"
>(is-op-2 random-int random)
</span>$1 = (is-op-2 random-int random)

NDet Result(243): <span class="ansi33"
>(iz random-float MeTTa)
</span>$1 = (iz random-float MeTTa)

NDet Result(244): <span class="ansi33"
>(@doc random-float (@desc "Returns random float number from range defined by two numbers (first and second argument)") (@params ((@param "Range start") (@param "Range end"))) (@return "Random float number from defined range"))
</span>$1 = (@doc random-float (@desc "Returns random float number from range defined by two numbers (first and second argument)") (@params ((@param "Range start") (@param "Range end"))) (@return "Random float number from defined range"))

NDet Result(245): <span class="ansi33"
>(iz collapse-bind MeTTa)
</span>$1 = (iz collapse-bind MeTTa)

NDet Result(246): <span class="ansi33"
>(@doc collapse-bind (@desc "Evaluates the Atom (first argument) and returns an expression which contains all alternative evaluations in a form (Atom Bindings). Bindings are represented in a form of a grounded atom { <var> <- <binding>, ... }. See also the complement superpose-bind. Note that, like chain, collapse-bind only evaluates Minimal Metta expressions. Evaluation of non-Minimal MeTTa atoms can be controlled by wrapping in a call to eval (for one evaluation step) or metta (for full evaluation).") (@params ((@param "Atom to be evaluated"))) (@return "All alternative evaluations"))
</span>$1 = (@doc collapse-bind (@desc "Evaluates the Atom (first argument) and returns an expression which contains all alternative evaluations in a form (Atom Bindings). Bindings are represented in a form of a grounded atom { <var> <- <binding>, ... }. See also the complement superpose-bind. Note that, like chain, collapse-bind only evaluates Minimal Metta expressions. Evaluation of non-Minimal MeTTa atoms can be controlled by wrapping in a call to eval (for one evaluation step) or metta (for full evaluation).") (@params ((@param "Atom to be evaluated"))) (@return "All alternative evaluations"))

NDet Result(247): <span class="ansi33"
>(: collapse-bind (-> Atom Expression))
</span>$1 = (: collapse-bind (-> Atom Expression))

NDet Result(248): <span class="ansi33"
>(iz superpose-bind MeTTa)
</span>$1 = (iz superpose-bind MeTTa)

NDet Result(249): <span class="ansi33"
>(@doc superpose-bind (@desc "Complement to the collapse-bind. It takes result of collapse-bind (first argument) and returns only result atoms without bindings. Primarily used with some filtering step on the collapse-bind results, i.e. collapse-bind -> <filter> -> superpose-bind.") (@params ((@param "Expression in form (Atom Binding)"))) (@return "Non-deterministic list of Atoms"))
</span>$1 = (@doc superpose-bind (@desc "Complement to the collapse-bind. It takes result of collapse-bind (first argument) and returns only result atoms without bindings. Primarily used with some filtering step on the collapse-bind results, i.e. collapse-bind -> <filter> -> superpose-bind.") (@params ((@param "Expression in form (Atom Binding)"))) (@return "Non-deterministic list of Atoms"))

NDet Result(250): <span class="ansi33"
>(: superpose-bind (-> Expression Atom))
</span>$1 = (: superpose-bind (-> Expression Atom))

NDet Result(251): <span class="ansi33"
>(@doc metta (@desc "Run MeTTa interpreter on atom.") (@params ((@param "Atom to be interpreted") (@param "Type of input atom") (@param "Atomspace where intepretation should take place"))) (@return "Result of interpretation"))
</span>$1 = (@doc metta (@desc "Run MeTTa interpreter on atom.") (@params ((@param "Atom to be interpreted") (@param "Type of input atom") (@param "Atomspace where intepretation should take place"))) (@return "Result of interpretation"))

NDet Result(252): <span class="ansi33"
>(: metta (-> Atom Type Grounded Atom))
</span>$1 = (: metta (-> Atom Type Grounded Atom))

NDet Result(253): <span class="ansi33"
>(iz id MinimalMeTTa)
</span>$1 = (iz id MinimalMeTTa)

NDet Result(254): <span class="ansi33"
>(@doc id (@desc "Returns its argument") (@params ((@param "Input argument"))) (@return "Input argument"))
</span>$1 = (@doc id (@desc "Returns its argument") (@params ((@param "Input argument"))) (@return "Input argument"))

NDet Result(255): <span class="ansi33"
>(: id (-> Atom Atom))
</span>$1 = (: id (-> Atom Atom))

NDet Result(256): <span class="ansi33"
>(= (id $10000)  $10000)
</span>$1 = (= (id $10000)  $10000)

NDet Result(257): <span class="ansi33"
>(iz atom-subst MinimalMeTTa)
</span>$1 = (iz atom-subst MinimalMeTTa)

NDet Result(258): <span class="ansi33"
>(@doc atom-subst (@desc "Substitutes variable passed as a second argument in the third argument by the first argument") (@params ((@param "Value to use for replacement") (@param "Variable to replace") (@param "Template to replace variable by the value"))) (@return "Template with substituted variable"))
</span>$1 = (@doc atom-subst (@desc "Substitutes variable passed as a second argument in the third argument by the first argument") (@params ((@param "Value to use for replacement") (@param "Variable to replace") (@param "Template to replace variable by the value"))) (@return "Template with substituted variable"))

NDet Result(259): <span class="ansi33"
>(: atom-subst (-> Atom Variable Atom Atom))
</span>$1 = (: atom-subst (-> Atom Variable Atom Atom))

NDet Result(260): <span class="ansi33"
>(= (atom-subst $10000 $10001 $10002)  
  (function (chain (eval (id $10000)) $10001 (return $10002))))
</span>$1 = (= (atom-subst $10000 $10001 $10002)  
  (function (chain (eval (id $10000)) $10001 (return $10002))))

NDet Result(261): <span class="ansi33"
>(iz if-decons-expr MinimalMeTTaHelper)
</span>$1 = (iz if-decons-expr MinimalMeTTaHelper)

NDet Result(262): <span class="ansi33"
>(@doc if-decons-expr (@desc "Checks if first argument is non empty expression. If so gets tail and head from the first argument and returns forth argument using head and tail values. Returns fifth argument otherwise.") (@params ((@param "Expression to be deconstructed") (@param "Head variable") (@param "Tail variable") (@param "Template to return if first argument is a non-empty expression") (@param "Default value to return otherwise"))) (@return "Either template with head and tail replaced by values or default value"))
</span>$1 = (@doc if-decons-expr (@desc "Checks if first argument is non empty expression. If so gets tail and head from the first argument and returns forth argument using head and tail values. Returns fifth argument otherwise.") (@params ((@param "Expression to be deconstructed") (@param "Head variable") (@param "Tail variable") (@param "Template to return if first argument is a non-empty expression") (@param "Default value to return otherwise"))) (@return "Either template with head and tail replaced by values or default value"))

NDet Result(263): <span class="ansi33"
>(: if-decons-expr (-> Expression Variable Variable Atom Atom Atom))
</span>$1 = (: if-decons-expr (-> Expression Variable Variable Atom Atom Atom))

NDet Result(264): <span class="ansi33"
>(= (if-decons-expr $10000 $10001 $10002 $10003 $10004)  
  (if-decons $10000 $10001 $10002 $10003 $10004))
</span>$1 = (= (if-decons-expr $10000 $10001 $10002 $10003 $10004)  
  (if-decons $10000 $10001 $10002 $10003 $10004))

NDet Result(265): <span class="ansi33"
>(: if-decons (-> Expression Variable Variable Atom Atom Atom))
</span>$1 = (: if-decons (-> Expression Variable Variable Atom Atom Atom))

NDet Result(266): <span class="ansi33"
>(ALT= $10000 $10001)
</span>$1 = (ALT= (if-decons-expr ($10000 

NDet Result(267): <span class="ansi33"
>(iz if-error MinimalMeTTaHelper)
</span>$1 = (iz if-error MinimalMeTTaHelper)

NDet Result(268): <span class="ansi33"
>(@doc if-error (@desc "Checks if first argument is an error atom. Returns second argument if so or third argument otherwise.") (@params ((@param "Atom to be checked for the error") (@param "Value to return if first argument is an error") (@param "Value to return otherwise"))) (@return "Second or third argument"))
</span>$1 = (@doc if-error (@desc "Checks if first argument is an error atom. Returns second argument if so or third argument otherwise.") (@params ((@param "Atom to be checked for the error") (@param "Value to return if first argument is an error") (@param "Value to return otherwise"))) (@return "Second or third argument"))

NDet Result(269): <span class="ansi33"
>(: if-error (-> Atom Atom Atom Atom))
</span>$1 = (: if-error (-> Atom Atom Atom Atom))

NDet Result(270): <span class="ansi33"
>(= (if-error $10000 $10001 $10002)  
  (function (chain (eval (get-metatype $10000)) $10003 (eval (if-equal $10003 Expression (eval (if-equal $10000 () (return $10002) (chain (decons-atom $10000) $10004 (if-unify $10004 ($10005 $10006) (eval (if-equal $10005 Error (return $10001) (return $10002))) (return $10002))))) (return $10002))))))
</span>$1 = (= (if-error $10000 $10001 $10002)  
  (function (chain (eval (get-metatype $10000)) $10003 (eval (if-equal $10003 Expression (eval (if-equal $10000 () (return $10002) (chain (decons-atom $10000) $10004 (if-unify $10004 ($10005 $10006) (eval (if-equal $10005 Error (return $10001) (return $10002))) (return $10002))))) (return $10002))))))

NDet Result(271): <span class="ansi33"
>(iz return-on-error MinimalMeTTaHelper)
</span>$1 = (iz return-on-error MinimalMeTTaHelper)

NDet Result(272): <span class="ansi33"
>(@doc return-on-error (@desc "Returns first argument if it is Empty or an error. Returns second argument otherwise.") (@params ((@param "Previous evaluation result") (@param "Atom for further evaluation"))) (@return "Return previous result if it is an error or Empty or continue evaluation"))
</span>$1 = (@doc return-on-error (@desc "Returns first argument if it is Empty or an error. Returns second argument otherwise.") (@params ((@param "Previous evaluation result") (@param "Atom for further evaluation"))) (@return "Return previous result if it is an error or Empty or continue evaluation"))

NDet Result(273): <span class="ansi33"
>(: return-on-error (-> Atom Atom Atom))
</span>$1 = (: return-on-error (-> Atom Atom Atom))

NDet Result(274): <span class="ansi33"
>Empty
</span>$1 = (= (return-on-error $10000 $10001)  
  (function (eval (if-equal $10000  (return (return )) (eval (if-error $10000 (return (return $10000)) (return $10001)))))))

NDet Result(275): <span class="ansi33"
>(iz switch MinimalMeTTaHelper)
</span>$1 = (iz switch MinimalMeTTaHelper)

NDet Result(276): <span class="ansi33"
>(@doc switch (@desc "Subsequently tests multiple pattern-matching conditions (second argument) for the given value (first argument)") (@params ((@param "Atom to be matched with patterns") (@param "Tuple of pairs mapping condition patterns to results"))) (@return "Result which corresponds to the pattern which is matched with the passed atom first"))
</span>$1 = (@doc switch (@desc "Subsequently tests multiple pattern-matching conditions (second argument) for the given value (first argument)") (@params ((@param "Atom to be matched with patterns") (@param "Tuple of pairs mapping condition patterns to results"))) (@return "Result which corresponds to the pattern which is matched with the passed atom first"))

NDet Result(277): <span class="ansi33"
>(: switch (-> Atom Atom Atom))
</span>$1 = (: switch (-> Atom Atom Atom))

NDet Result(278): <span class="ansi33"
>(= (switch $10000 $10001)  
  (case 
    (eval $10000) $10001))
</span>$1 = (= (switch $10000 $10001)  
  (case 
    (eval $10000) $10001))

NDet Result(279): <span class="ansi33"
>Empty
</span>$1 = (: ((: switch (-> %Undefined% Expression Atom)) (= (switch $10000 $10001)  
  (function (chain (decons-atom $10001) $10002 (chain (eval (switch-internal $10000 $10002)) $10003 (chain (eval (if-equal $10003 NotReducible  $10003)) $10004 (return $10004)))))) (iz switch-internal HelperMM) (@doc switch-internal (@desc "This function is being called inside switch function to test one of the cases and it calls switch once again if current condition is not met") (@params ((@param "Atom (it will be evaluated)") (@param "Deconsed tuple of pairs mapping condition patterns to results"))) (@return "Result of evaluating of Atom bound to met condition")) (= (switch-internal $10000 (($10005 $10006) $10007))  
  (function (if-unify $10000 $10005 (return $10006) (chain (eval (switch $10000 $10007)) $10008 (return $10008)))))) Comment)

NDet Result(280): <span class="ansi33"
>(iz is-function MinimalMeTTaHelper)
</span>$1 = (iz is-function MinimalMeTTaHelper)

NDet Result(281): <span class="ansi33"
>(@doc is-function (@desc "Function checks if input type is a function type") (@params ((@param "Type atom"))) (@return "True if type is a function type, False - otherwise"))
</span>$1 = (@doc is-function (@desc "Function checks if input type is a function type") (@params ((@param "Type atom"))) (@return "True if type is a function type, False - otherwise"))

NDet Result(282): <span class="ansi33"
>(: is-function (-> Type Bool))
</span>$1 = (: is-function (-> Type Bool))

NDet Result(283): <span class="ansi33"
>(= (is-function $10000)  
  (function (chain (eval (get-metatype $10000)) $10001 (eval (switch ($10000 $10001) ((($10000 Expression) (eval (if-decons-expr $10000 $10002 $10003 (if-unify $10002 -> (return True) (return False)) (return (Error (is-function $10000) "is-function non-empty expression as an argument"))))) (($10000 $10001) (return False))))))))
</span>$1 = (= (is-function $10000)  
  (function (chain (eval (get-metatype $10000)) $10001 (eval (switch ($10000 $10001) ((($10000 Expression) (eval (if-decons-expr $10000 $10002 $10003 (if-unify $10002 -> (return True) (return False)) (return (Error (is-function $10000) "is-function non-empty expression as an argument"))))) (($10000 $10001) (return False))))))))

NDet Result(284): <span class="ansi33"
>(iz type-cast MeTTa)
</span>$1 = (iz type-cast MeTTa)

NDet Result(285): <span class="ansi33"
>(@doc type-cast (@desc "Casts atom passed as a first argument to the type passed as a second argument using space as a context") (@params ((@param "Atom to be casted") (@param "Type to cast atom to") (@param "Context atomspace"))) (@return "Atom if casting is successful, (Error ... BadType) otherwise"))
</span>$1 = (@doc type-cast (@desc "Casts atom passed as a first argument to the type passed as a second argument using space as a context") (@params ((@param "Atom to be casted") (@param "Type to cast atom to") (@param "Context atomspace"))) (@return "Atom if casting is successful, (Error ... BadType) otherwise"))

NDet Result(286): <span class="ansi33"
>(: type-cast (-> Atom Atom Atom Atom))
</span>$1 = (: type-cast (-> Atom Atom Atom Atom))

NDet Result(287): <span class="ansi33"
>(ALT= $10000 $10001)
</span>$1 = (ALT= (type-cast $10000 $10001 &self) (function (chain (eval (get-metatype $10000)) $10002 (eval (if-equal $10001 $10002 (return $10000) (chain (eval (collapse-bind (eval (get-type $10000 &self)))) $10003 (chain (eval (map-atom $10003 $10004 (eval (first-from-pair $10004)))) $10005 (chain (eval (foldl-atom $10005 False $10006 $10007 (eval (match-type-or $10006 $10007 $10001)))) $10008 (eval (if $10008 (return $10000) (return (Error $10000 BadType))))))))))))

NDet Result(288): <span class="ansi33"
>(iz match-types MeTTa)
</span>$1 = (iz match-types MeTTa)

NDet Result(289): <span class="ansi33"
>(@doc match-types (@desc "Checks if two types can be unified and returns third argument if so, fourth - otherwise") (@params ((@param "First type") (@param "Second type") (@param "Atom to be returned if types can be unified") (@param "Atom to be returned if types cannot be unified"))) (@return "Third or fourth argument"))
</span>$1 = (@doc match-types (@desc "Checks if two types can be unified and returns third argument if so, fourth - otherwise") (@params ((@param "First type") (@param "Second type") (@param "Atom to be returned if types can be unified") (@param "Atom to be returned if types cannot be unified"))) (@return "Third or fourth argument"))

NDet Result(290): <span class="ansi33"
>(: match-types (-> Atom Atom Atom Atom Atom))
</span>$1 = (: match-types (-> Atom Atom Atom Atom Atom))

NDet Result(291): <span class="ansi33"
>(= (match-types $10000 $10001 $10002 $10003)  
  (function (eval (if-equal $10000 %Undefined% (return $10002) (eval (if-equal $10001 %Undefined% (return $10002) (eval (if-equal $10000 Atom (return $10002) (eval (if-equal $10001 Atom (return $10002) (if-unify $10000 $10001 (return $10002) (return $10003))))))))))))
</span>$1 = (= (match-types $10000 $10001 $10002 $10003)  
  (function (eval (if-equal $10000 %Undefined% (return $10002) (eval (if-equal $10001 %Undefined% (return $10002) (eval (if-equal $10000 Atom (return $10002) (eval (if-equal $10001 Atom (return $10002) (if-unify $10000 $10001 (return $10002) (return $10003))))))))))))

NDet Result(292): <span class="ansi33"
>(iz first-from-pair MinimalMeTTaHelper)
</span>$1 = (iz first-from-pair MinimalMeTTaHelper)

NDet Result(293): <span class="ansi33"
>(@doc first-from-pair (@desc "Gets a pair as a first argument and returns first atom from pair") (@params ((@param "Pair"))) (@return "First atom from a pair"))
</span>$1 = (@doc first-from-pair (@desc "Gets a pair as a first argument and returns first atom from pair") (@params ((@param "Pair"))) (@return "First atom from a pair"))

NDet Result(294): <span class="ansi33"
>(= (first-from-pair $10000)  
  (function (if-unify $10000 ($10001 $10002) (return $10001) (return (Error (first-from-pair $10000) "incorrect pair format")))))
</span>$1 = (= (first-from-pair $10000)  
  (function (if-unify $10000 ($10001 $10002) (return $10001) (return (Error (first-from-pair $10000) "incorrect pair format")))))

NDet Result(295): <span class="ansi33"
>(iz match-type-or HelperMM)
</span>$1 = (iz match-type-or HelperMM)

NDet Result(296): <span class="ansi33"
>(@doc match-type-or (@desc "Checks if two types (second and third arguments) can be unified and returns result of OR operation between first argument and type checking result") (@params ((@param "Boolean value") (@param "First type") (@param "Second type"))) (@return "True or False"))
</span>$1 = (@doc match-type-or (@desc "Checks if two types (second and third arguments) can be unified and returns result of OR operation between first argument and type checking result") (@params ((@param "Boolean value") (@param "First type") (@param "Second type"))) (@return "True or False"))

NDet Result(297): <span class="ansi33"
>(= (match-type-or $10000 $10001 $10002)  
  (function (chain (eval (match-types $10001 $10002 True False)) $10003 (chain (eval (or $10000 $10003)) $10004 (return $10004)))))
</span>$1 = (= (match-type-or $10000 $10001 $10002)  
  (function (chain (eval (match-types $10001 $10002 True False)) $10003 (chain (eval (or $10000 $10003)) $10004 (return $10004)))))

NDet Result(298): <span class="ansi33"
>(iz filter-atom MeTTa)
</span>$1 = (iz filter-atom MeTTa)

NDet Result(299): <span class="ansi33"
>(@doc filter-atom (@desc "Function takes list of atoms (first argument), variable (second argument) and filter predicate (third argument) and returns list with items which passed filter. E.g. (filter-atom (1 2 3 4) $v (eval (> $v 2))) will give (3 4)") (@params ((@param "List of atoms") (@param "Variable") (@param "Filter predicate"))) (@return "Filtered list"))
</span>$1 = (@doc filter-atom (@desc "Function takes list of atoms (first argument), variable (second argument) and filter predicate (third argument) and returns list with items which passed filter. E.g. (filter-atom (1 2 3 4) $v (eval (> $v 2))) will give (3 4)") (@params ((@param "List of atoms") (@param "Variable") (@param "Filter predicate"))) (@return "Filtered list"))

NDet Result(300): <span class="ansi33"
>(: filter-atom (-> Expression Variable Atom Expression))
</span>$1 = (: filter-atom (-> Expression Variable Atom Expression))

NDet Result(301): <span class="ansi33"
>(= (filter-atom $10000 $10001 $10002)  
  (function (eval (if-decons-expr $10000 $10003 $10004 (chain (eval (filter-atom $10004 $10001 $10002)) $10005 (chain (eval (atom-subst $10003 $10001 $10002)) $10006 (chain $10006 $10007 (eval (if $10007 (chain (cons-atom $10003 $10005) $10008 (return $10008)) (return $10005)))))) (return ())))))
</span>$1 = (= (filter-atom $10000 $10001 $10002)  
  (function (eval (if-decons-expr $10000 $10003 $10004 (chain (eval (filter-atom $10004 $10001 $10002)) $10005 (chain (eval (atom-subst $10003 $10001 $10002)) $10006 (chain $10006 $10007 (eval (if $10007 (chain (cons-atom $10003 $10005) $10008 (return $10008)) (return $10005)))))) (return ())))))

NDet Result(302): <span class="ansi33"
>(iz map-atom MeTTa)
</span>$1 = (iz map-atom MeTTa)

NDet Result(303): <span class="ansi33"
>(@doc map-atom (@desc "Function takes list of atoms (first argument), variable to be used inside (second variable) and an expression which will be evaluated for each atom in list (third argument). Expression should contain variable. So e.g. (map-atom (1 2 3 4) $v (eval (+ $v 1))) will give (2 3 4 5)") (@params ((@param "List of atoms") (@param "Variable name") (@param "Template using variable"))) (@return "Result of evaluating template for each atom in a list"))
</span>$1 = (@doc map-atom (@desc "Function takes list of atoms (first argument), variable to be used inside (second variable) and an expression which will be evaluated for each atom in list (third argument). Expression should contain variable. So e.g. (map-atom (1 2 3 4) $v (eval (+ $v 1))) will give (2 3 4 5)") (@params ((@param "List of atoms") (@param "Variable name") (@param "Template using variable"))) (@return "Result of evaluating template for each atom in a list"))

NDet Result(304): <span class="ansi33"
>(: map-atom (-> Expression Variable Atom Expression))
</span>$1 = (: map-atom (-> Expression Variable Atom Expression))

NDet Result(305): <span class="ansi33"
>(= (map-atom $10000 $10001 $10002)  
  (function (eval (if-decons-expr $10000 $10003 $10004 (chain (eval (map-atom $10004 $10001 $10002)) $10005 (chain (eval (atom-subst $10003 $10001 $10002)) $10006 (chain $10006 $10007 (chain (cons-atom $10007 $10005) $10008 (return $10008))))) (return ())))))
</span>$1 = (= (map-atom $10000 $10001 $10002)  
  (function (eval (if-decons-expr $10000 $10003 $10004 (chain (eval (map-atom $10004 $10001 $10002)) $10005 (chain (eval (atom-subst $10003 $10001 $10002)) $10006 (chain $10006 $10007 (chain (cons-atom $10007 $10005) $10008 (return $10008))))) (return ())))))

NDet Result(306): <span class="ansi33"
>(iz foldl-atom MeTTa)
</span>$1 = (iz foldl-atom MeTTa)

NDet Result(307): <span class="ansi33"
>(@doc foldl-atom (@desc "Function takes list of values (first argument), initial value (second argument) and operation (fifth argument) and applies it consequently to the list of values, using init value as a start. It also takes two variables (third and fourth argument) to use them inside") (@params ((@param "List of values") (@param "Init value") (@param "Variable") (@param "Variable") (@param "Operation"))) (@return "Result of applying operation to the list of values"))
</span>$1 = (@doc foldl-atom (@desc "Function takes list of values (first argument), initial value (second argument) and operation (fifth argument) and applies it consequently to the list of values, using init value as a start. It also takes two variables (third and fourth argument) to use them inside") (@params ((@param "List of values") (@param "Init value") (@param "Variable") (@param "Variable") (@param "Operation"))) (@return "Result of applying operation to the list of values"))

NDet Result(308): <span class="ansi33"
>(: foldl-atom (-> Expression Atom Variable Variable Atom Atom))
</span>$1 = (: foldl-atom (-> Expression Atom Variable Variable Atom Atom))

NDet Result(309): <span class="ansi33"
>(= (foldl-atom $10000 $10001 $10002 $10003 $10004)  
  (function (eval (if-decons-expr $10000 $10005 $10006 (chain (eval (atom-subst $10001 $10002 $10004)) $10007 (chain (eval (atom-subst $10005 $10003 $10007)) $10008 (chain $10008 $10009 (chain (eval (foldl-atom $10006 $10009 $10002 $10003 $10004)) $10010 (return $10010))))) (return $10001)))))
</span>$1 = (= (foldl-atom $10000 $10001 $10002 $10003 $10004)  
  (function (eval (if-decons-expr $10000 $10005 $10006 (chain (eval (atom-subst $10001 $10002 $10004)) $10007 (chain (eval (atom-subst $10005 $10003 $10007)) $10008 (chain $10008 $10009 (chain (eval (foldl-atom $10006 $10009 $10002 $10003 $10004)) $10010 (return $10010))))) (return $10001)))))

NDet Result(310): <span class="ansi33"
>(iz separate-errors MinimalMeTTaHelper)
</span>$1 = (iz separate-errors MinimalMeTTaHelper)

NDet Result(311): <span class="ansi33"
>(: separate-errors (-> Expression Expression Expression))
</span>$1 = (: separate-errors (-> Expression Expression Expression))

NDet Result(312): <span class="ansi33"
>(= (separate-errors $10000 $10001)  
  (function (if-unify $10000 ($10002 $10003) (if-unify $10001 ($10004 $10005) (eval (if-error $10004 (chain (cons-atom $10001 $10003) $10006 (return ($10002 $10006))) (chain (cons-atom $10001 $10002) $10007 (return ($10007 $10003))))) (return $10000)) (return $10000))))
</span>$1 = (= (separate-errors $10000 $10001)  
  (function (if-unify $10000 ($10002 $10003) (if-unify $10001 ($10004 $10005) (eval (if-error $10004 (chain (cons-atom $10001 $10003) $10006 (return ($10002 $10006))) (chain (cons-atom $10001 $10002) $10007 (return ($10007 $10003))))) (return $10000)) (return $10000))))

NDet Result(313): <span class="ansi33"
>(iz check-alternatives MinimalMeTTaHelper)
</span>$1 = (iz check-alternatives MinimalMeTTaHelper)

NDet Result(314): <span class="ansi33"
>(= (check-alternatives $10000)  
  (function (chain (collapse-bind $10000) $10001 (chain (eval (foldl-atom $10001 (() ()) $10002 $10003 (eval (separate-errors $10002 $10003)))) $10004 (if-unify $10004 ($10005 $10006) (chain (eval (if-equal $10005 () $10006 $10005)) $10007 (chain (superpose-bind $10007) $10008 (return $10008))) (return (Error (check-alternatives $10000) "list of results was not filtered correctly")))))))
</span>$1 = (= (check-alternatives $10000)  
  (function (chain (collapse-bind $10000) $10001 (chain (eval (foldl-atom $10001 (() ()) $10002 $10003 (eval (separate-errors $10002 $10003)))) $10004 (if-unify $10004 ($10005 $10006) (chain (eval (if-equal $10005 () $10006 $10005)) $10007 (chain (superpose-bind $10007) $10008 (return $10008))) (return (Error (check-alternatives $10000) "list of results was not filtered correctly")))))))

NDet Result(315): <span class="ansi33"
>(iz interpret MeTTa)
</span>$1 = (iz interpret MeTTa)

NDet Result(316): <span class="ansi33"
>(= (interpret $10000 $10001 $10002)  
  (function (chain (eval (get-metatype $10000)) $10003 (eval (if-equal $10001 Atom (return $10000) (eval (if-equal $10001 $10003 (return $10000) (eval (switch ($10001 $10003) ((($10001 Variable) (return $10000)) (($10001 Symbol) (chain (eval (type-cast $10000 $10001 $10002)) $10004 (return $10004))) (($10001 Grounded) (chain (eval (type-cast $10000 $10001 $10002)) $10004 (return $10004))) (($10001 Expression) (chain (eval (check-alternatives (eval (interpret-expression $10000 $10001 $10002)))) $10004 (return $10004)))))))))))))
</span>$1 = (= (interpret $10000 $10001 $10002)  
  (function (chain (eval (get-metatype $10000)) $10003 (eval (if-equal $10001 Atom (return $10000) (eval (if-equal $10001 $10003 (return $10000) (eval (switch ($10001 $10003) ((($10001 Variable) (return $10000)) (($10001 Symbol) (chain (eval (type-cast $10000 $10001 $10002)) $10004 (return $10004))) (($10001 Grounded) (chain (eval (type-cast $10000 $10001 $10002)) $10004 (return $10004))) (($10001 Expression) (chain (eval (check-alternatives (eval (interpret-expression $10000 $10001 $10002)))) $10004 (return $10004)))))))))))))

NDet Result(317): <span class="ansi33"
>(iz interpret-expression MinimalMeTTaHelper)
</span>$1 = (iz interpret-expression MinimalMeTTaHelper)

NDet Result(318): <span class="ansi33"
>(= (interpret-expression $10000 $10001 $10002)  
  (function (eval (if-decons $10000 $10003 $10004 (chain (eval (get-type $10003 $10002)) $10005 (chain (eval (is-function $10005)) $10006 (if-unify $10006 True (chain (eval (interpret-func $10000 $10005 $10001 $10002)) $10007 (chain (eval (metta-call $10007 $10001 $10002)) $10008 (return $10008))) (chain (eval (interpret-tuple $10000 $10002)) $10007 (chain (eval (metta-call $10007 $10001 $10002)) $10008 (return $10008)))))) (chain (eval (type-cast $10000 $10001 $10002)) $10008 (return $10008))))))
</span>$1 = (= (interpret-expression $10000 $10001 $10002)  
  (function (eval (if-decons $10000 $10003 $10004 (chain (eval (get-type $10003 $10002)) $10005 (chain (eval (is-function $10005)) $10006 (if-unify $10006 True (chain (eval (interpret-func $10000 $10005 $10001 $10002)) $10007 (chain (eval (metta-call $10007 $10001 $10002)) $10008 (return $10008))) (chain (eval (interpret-tuple $10000 $10002)) $10007 (chain (eval (metta-call $10007 $10001 $10002)) $10008 (return $10008)))))) (chain (eval (type-cast $10000 $10001 $10002)) $10008 (return $10008))))))

NDet Result(319): <span class="ansi33"
>(iz interpret-func MinimalMeTTaHelper)
</span>$1 = (iz interpret-func MinimalMeTTaHelper)

NDet Result(320): <span class="ansi33"
>(= (interpret-func $10000 $10001 $10002 $10003)  
  (function (eval (if-decons $10000 $10004 $10005 (chain (eval (interpret $10004 $10001 $10003)) $10006 (eval (return-on-error $10006 (eval (if-decons $10001 $10007 $10008 (chain (eval (interpret-args $10000 $10005 $10008 $10002 $10003)) $10009 (eval (return-on-error $10009 (chain (cons-atom $10006 $10009) $10010 (return $10010))))) (return (Error $10001 "Function type expected"))))))) (return (Error $10000 "Non-empty expression atom is expected"))))))
</span>$1 = (= (interpret-func $10000 $10001 $10002 $10003)  
  (function (eval (if-decons $10000 $10004 $10005 (chain (eval (interpret $10004 $10001 $10003)) $10006 (eval (return-on-error $10006 (eval (if-decons $10001 $10007 $10008 (chain (eval (interpret-args $10000 $10005 $10008 $10002 $10003)) $10009 (eval (return-on-error $10009 (chain (cons-atom $10006 $10009) $10010 (return $10010))))) (return (Error $10001 "Function type expected"))))))) (return (Error $10000 "Non-empty expression atom is expected"))))))

NDet Result(321): <span class="ansi33"
>(iz interpret-args MinimalMeTTaHelper)
</span>$1 = (iz interpret-args MinimalMeTTaHelper)

NDet Result(322): <span class="ansi33"
>(= (interpret-args $10000 $10001 $10002 $10003 $10004)  
  (function (if-unify $10001 () (eval (if-decons $10002 $10005 $10006 (chain (eval (== () $10006)) $10007 (eval (if $10007 (eval (match-types $10005 $10003 (return ()) (return (Error $10000 BadType)))) (return (Error $10000 BadType))))) (return (Error $10000 "Too many arguments")))) (eval (if-decons $10001 $10008 $10009 (eval (if-decons $10002 $10010 $10011 (chain (eval (interpret $10008 $10010 $10004)) $10012 (eval (if-equal $10012 $10008 (chain (eval (interpret-args-tail $10000 $10012 $10009 $10011 $10003 $10004)) $10013 (return $10013)) (eval (return-on-error $10012 (chain (eval (interpret-args-tail $10000 $10012 $10009 $10011 $10003 $10004)) $10013 (return $10013))))))) (return (Error $10000 BadType)))) (return (Error (interpret-atom $10000 $10001 $10002 $10004) "Non-empty expression atom is expected")))))))
</span>$1 = (= (interpret-args $10000 $10001 $10002 $10003 $10004)  
  (function (if-unify $10001 () (eval (if-decons $10002 $10005 $10006 (chain (eval (== () $10006)) $10007 (eval (if $10007 (eval (match-types $10005 $10003 (return ()) (return (Error $10000 BadType)))) (return (Error $10000 BadType))))) (return (Error $10000 "Too many arguments")))) (eval (if-decons $10001 $10008 $10009 (eval (if-decons $10002 $10010 $10011 (chain (eval (interpret $10008 $10010 $10004)) $10012 (eval (if-equal $10012 $10008 (chain (eval (interpret-args-tail $10000 $10012 $10009 $10011 $10003 $10004)) $10013 (return $10013)) (eval (return-on-error $10012 (chain (eval (interpret-args-tail $10000 $10012 $10009 $10011 $10003 $10004)) $10013 (return $10013))))))) (return (Error $10000 BadType)))) (return (Error (interpret-atom $10000 $10001 $10002 $10004) "Non-empty expression atom is expected")))))))

NDet Result(323): <span class="ansi33"
>(iz interpret-args-tail MinimalMeTTaHelper)
</span>$1 = (iz interpret-args-tail MinimalMeTTaHelper)

NDet Result(324): <span class="ansi33"
>(= (interpret-args-tail $10000 $10001 $10002 $10003 $10004 $10005)  
  (function (chain (eval (interpret-args $10000 $10002 $10003 $10004 $10005)) $10006 (eval (return-on-error $10006 (chain (cons-atom $10001 $10006) $10007 (return $10007)))))))
</span>$1 = (= (interpret-args-tail $10000 $10001 $10002 $10003 $10004 $10005)  
  (function (chain (eval (interpret-args $10000 $10002 $10003 $10004 $10005)) $10006 (eval (return-on-error $10006 (chain (cons-atom $10001 $10006) $10007 (return $10007)))))))

NDet Result(325): <span class="ansi33"
>(iz interpret-tuple MinimalMeTTaHelper)
</span>$1 = (iz interpret-tuple MinimalMeTTaHelper)

NDet Result(326): <span class="ansi33"
>Empty
</span>$1 = (= (interpret-tuple $10000 $10001)  
  (function (if-unify $10000 () (return $10000) (eval (if-decons $10000 $10002 $10003 (chain (eval (interpret $10002 %Undefined% $10001)) $10004 (eval (if-equal $10004  (return ) (chain (eval (interpret-tuple $10003 $10001)) $10005 (eval (if-equal $10005  (return ) (chain (cons-atom $10004 $10005) $10006 (return $10006)))))))) (return (Error (interpret-tuple $10000 $10001) "Non-empty expression atom is expected as an argument")))))))

NDet Result(327): <span class="ansi33"
>(iz metta-call MinimalMeTTaHelper)
</span>$1 = (iz metta-call MinimalMeTTaHelper)

NDet Result(328): <span class="ansi33"
>Empty
</span>$1 = (= (metta-call $10000 $10001 $10002)  
  (function (eval (if-error $10000 (return $10000) (chain (eval $10000) $10003 (eval (if-equal $10003 NotReducible (return $10000) (eval (if-equal $10003  (return ) (eval (if-error $10003 (return $10003) (chain (eval (interpret $10003 $10001 $10002)) $10004 (return $10004)))))))))))))

NDet Result(329): <span class="ansi33"
>(iz is-function-type MeTTa)
</span>$1 = (iz is-function-type MeTTa)

NDet Result(330): <span class="ansi33"
>(@doc is-function-type (@desc "Function checks if input type is a function type") (@params ((@param "Type notation"))) (@return "True if input type notation is a function type, False - otherwise"))
</span>$1 = (@doc is-function-type (@desc "Function checks if input type is a function type") (@params ((@param "Type notation"))) (@return "True if input type notation is a function type, False - otherwise"))

NDet Result(331): <span class="ansi33"
>(: is-function-type (-> Type Bool))
</span>$1 = (: is-function-type (-> Type Bool))

NDet Result(332): <span class="ansi33"
>(= (is-function-type $10000)  
  (let $10001 
    (get-metatype $10000) 
    (case $10001 
      ( (Expression (let $10002 (car-atom $10000) (if (== $10002 ->) True False))) ($10003 False)))))
</span>$1 = (= (is-function-type $10000)  
  (let $10001 
    (get-metatype $10000) 
    (case $10001 
      ( (Expression (let $10002 (car-atom $10000) (if (== $10002 ->) True False))) ($10003 False)))))

NDet Result(333): <span class="ansi33"
>(iz if MeTTa)
</span>$1 = (iz if MeTTa)

NDet Result(334): <span class="ansi33"
>(@doc if (@desc "Replace itself by one of the arguments depending on condition.") (@params ((@param "Boolean condition") (@param "Result when condition is True") (@param "Result when condition is False"))) (@return "Second or third argument"))
</span>$1 = (@doc if (@desc "Replace itself by one of the arguments depending on condition.") (@params ((@param "Boolean condition") (@param "Result when condition is True") (@param "Result when condition is False"))) (@return "Second or third argument"))

NDet Result(335): <span class="ansi33"
>(: if (-> Bool Atom Atom $10000))
</span>$1 = (: if (-> Bool Atom Atom $10000))

NDet Result(336): <span class="ansi33"
>(ALT= $10000 $10000)
</span>$1 = (ALT= (if True $10000 $10001) $10000)

NDet Result(337): <span class="ansi33"
>(ALT= $10000 $10000)
</span>$1 = (ALT= (if False $10000 $10001) $10001)

NDet Result(338): <span class="ansi33"
>(iz or MeTTa)
</span>$1 = (iz or MeTTa)

NDet Result(339): <span class="ansi33"
>(@doc or (@desc "Logical disjunction of two arguments") (@params ((@param "First argument") (@param "Second argument"))) (@return "True if any of input arguments is True, False - otherwise"))
</span>$1 = (@doc or (@desc "Logical disjunction of two arguments") (@params ((@param "First argument") (@param "Second argument"))) (@return "True if any of input arguments is True, False - otherwise"))

NDet Result(340): <span class="ansi33"
>(: or (-> Bool LazyBool Bool))
</span>$1 = (: or (-> Bool LazyBool Bool))

NDet Result(341): <span class="ansi33"
>(ALT= False False)
</span>$1 = (ALT= (or False False) False)

NDet Result(342): <span class="ansi33"
>(ALT= True True)
</span>$1 = (ALT= (or False True) True)

NDet Result(343): <span class="ansi33"
>(ALT= True True)
</span>$1 = (ALT= (or True False) True)

NDet Result(344): <span class="ansi33"
>(ALT= True True)
</span>$1 = (ALT= (or True True) True)

NDet Result(345): <span class="ansi33"
>(ALT= True True)
</span>$1 = (ALT= (or True True) True)

NDet Result(346): <span class="ansi33"
>(iz and MeTTa)
</span>$1 = (iz and MeTTa)

NDet Result(347): <span class="ansi33"
>(@doc and (@desc "Logical conjunction of two arguments") (@params ((@param "First argument") (@param "Second argument"))) (@return "Returns True if both arguments are True, False - otherwise"))
</span>$1 = (@doc and (@desc "Logical conjunction of two arguments") (@params ((@param "First argument") (@param "Second argument"))) (@return "Returns True if both arguments are True, False - otherwise"))

NDet Result(348): <span class="ansi33"
>(: and (-> Bool LazyBool Bool))
</span>$1 = (: and (-> Bool LazyBool Bool))

NDet Result(349): <span class="ansi33"
>(ALT= False False)
</span>$1 = (ALT= (and False False) False)

NDet Result(350): <span class="ansi33"
>(ALT= False False)
</span>$1 = (ALT= (and False True) False)

NDet Result(351): <span class="ansi33"
>(ALT= False False)
</span>$1 = (ALT= (and True False) False)

NDet Result(352): <span class="ansi33"
>(ALT= True True)
</span>$1 = (ALT= (and True True) True)

NDet Result(353): <span class="ansi33"
>(iz not MeTTa)
</span>$1 = (iz not MeTTa)

NDet Result(354): <span class="ansi33"
>(@doc not (@desc "Logical negation") (@params ((@param "Argument"))) (@return "Negates boolean input argument (False -> True, True -> False)"))
</span>$1 = (@doc not (@desc "Logical negation") (@params ((@param "Argument"))) (@return "Negates boolean input argument (False -> True, True -> False)"))

NDet Result(355): <span class="ansi33"
>(: not (-> Bool Bool))
</span>$1 = (: not (-> Bool Bool))

NDet Result(356): <span class="ansi33"
>(ALT= False False)
</span>$1 = (ALT= (not True) False)

NDet Result(357): <span class="ansi33"
>(ALT= True True)
</span>$1 = (ALT= (not False) True)

NDet Result(358): <span class="ansi33"
>(iz let MeTTa)
</span>$1 = (iz let MeTTa)

NDet Result(359): <span class="ansi33"
>(@doc let (@desc "Let function is utilized to establish temporary variable bindings within an expression. It allows introducing variables (first argument), assign values to them (second argument), and then use these values within the scope of the let block") (@params ((@param "Variable name (or several variables inside brackets ())") (@param "Expression to be bound to variable (it is being reduced before bind)") (@param "Expression which will be reduced and in which variable (first argument) could be used"))) (@return "Result of third argument's evaluation"))
</span>$1 = (@doc let (@desc "Let function is utilized to establish temporary variable bindings within an expression. It allows introducing variables (first argument), assign values to them (second argument), and then use these values within the scope of the let block") (@params ((@param "Variable name (or several variables inside brackets ())") (@param "Expression to be bound to variable (it is being reduced before bind)") (@param "Expression which will be reduced and in which variable (first argument) could be used"))) (@return "Result of third argument's evaluation"))

NDet Result(360): <span class="ansi33"
>(: let (-> Atom %Undefined% Atom Atom))
</span>$1 = (: let (-> Atom %Undefined% Atom Atom))

NDet Result(361): <span class="ansi33"
>(ALT= $10000 $10000)
</span>$1 = (ALT= (let $10000 $10000 $10001) (if-unify $10000 $10000 $10001 ))

NDet Result(362): <span class="ansi33"
>(iz let* MeTTa)
</span>$1 = (iz let* MeTTa)

NDet Result(363): <span class="ansi33"
>(@doc let* (@desc "Same as let, but first argument is a tuple containing tuples of variables and their bindings, e.g. (($v (+ 1 2)) ($v2 (* 5 6)))") (@params ((@param "Tuple of tuples with variables and their bindings") (@param "Expression which will be evaluated if each pair can be unified"))) (@return "Second argument or Empty"))
</span>$1 = (@doc let* (@desc "Same as let, but first argument is a tuple containing tuples of variables and their bindings, e.g. (($v (+ 1 2)) ($v2 (* 5 6)))") (@params ((@param "Tuple of tuples with variables and their bindings") (@param "Expression which will be evaluated if each pair can be unified"))) (@return "Second argument or Empty"))

NDet Result(364): <span class="ansi33"
>(: let* (-> Expression Atom %Undefined%))
</span>$1 = (: let* (-> Expression Atom %Undefined%))

NDet Result(365): 

#(failed #( : user once ) #( : user #( \+ #( \+ #( , #(maybe_name_vars (#( = _1 (ALT= (let* (($10000 $10000) 
^  <span class="ansi1 ansi32"
>Call: </span>(246) [user] call(user:once, user:(\+ \+ (maybe_name_vars(['_1'=['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], [eval, ['if-decons-expr', [[_789052, _789052]|_789064], [_789052, _789052], _789064, [let, _789052, _789052, ['let*', _789064, _789010]], _789010]]]]), old_not_compatio(write_bsrc(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]])), true)))
^  <span class="ansi1 ansi32"
>Call: </span>(247) [user] once(user:(\+ \+ (maybe_name_vars(['_1'=['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], [eval, ['if-decons-expr', [[_789052, _789052]|_789064], [_789052, _789052], _789064, [let, _789052, _789052, ['let*', _789064, _789010]], _789010]]]]), old_not_compatio(write_bsrc(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]])), true)))
^  <span class="ansi1 ansi32"
>Call: </span>(249) [user] maybe_name_vars(['_1'=['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], [eval, ['if-decons-expr', [[_789052, _789052]|_789064], [_789052, _789052], _789064, [let, _789052, _789052, ['let*', _789064, _789010]], _789010]]]])
   <span class="ansi1 ansi32"
>Call: </span>(250) [system] is_list(['_1'=['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], [eval, ['if-decons-expr', [[_789052, _789052]|_789064], [_789052, _789052], _789064, [let, _789052, _789052, ['let*', _789064, _789010]], _789010]]]])
   <span class="ansi1 ansi32"
>Exit: </span>(250) [system] is_list(['_1'=['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], [eval, ['if-decons-expr', [[_789052, _789052]|_789064], [_789052, _789052], _789064, [let, _789052, _789052, ['let*', _789064, _789010]], _789010]]]])
^  <span class="ansi1 ansi32"
>Call: </span>(250) [user] must_det_ll(n_to_vn('_1', _833272))
^  <span class="ansi1 ansi32"
>Call: </span>(251) [user] once(user:n_to_vn('_1', _833272))
^  <span class="ansi1 ansi32"
>Call: </span>(252) [user] n_to_vn('_1', _833272)
^  <span class="ansi1 ansi32"
>Call: </span>(253) [user] n_to_vn0('_1', _836062)
   <span class="ansi1 ansi32"
>Call: </span>(254) [system] var('_1')
   <span class="ansi1 ansi32"
>Call: </span>(254) [system] integer('_1')
   <span class="ansi1 ansi32"
>Call: </span>(254) [system] number('_1')
   <span class="ansi1 ansi32"
>Call: </span>(254) [system] string('_1')
   <span class="ansi1 ansi32"
>Call: </span>(254) [system] atom('_1')
   <span class="ansi1 ansi32"
>Exit: </span>(254) [system] atom('_1')
   <span class="ansi1 ansi32"
>Call: </span>(254) [system] atom_concat($, _842536, '_1')
   <span class="ansi1 ansi32"
>Call: </span>(254) [system] atom_concat('_', _843470, '_1')
   <span class="ansi1 ansi32"
>Exit: </span>(254) [system] atom_concat('_', '1', '_1')
^  <span class="ansi1 ansi32"
>Call: </span>(254) [user] backward_compatibility:sformat(_836062, '_~w', ['1'])
^  <span class="ansi1 ansi32"
>Call: </span>(255) [user] format(string(_836062), '_~w', ['1'])
^  <span class="ansi1 ansi32"
>Exit: </span>(255) [user] format(string("_1"), '_~w', ['1'])
^  <span class="ansi1 ansi32"
>Exit: </span>(254) [user] backward_compatibility:sformat("_1", '_~w', ['1'])
^  <span class="ansi1 ansi32"
>Exit: </span>(253) [user] n_to_vn0('_1', "_1")
   <span class="ansi1 ansi32"
>Call: </span>(253) [system] name(_833272, "_1")
   <span class="ansi1 ansi32"
>Exit: </span>(253) [system] name('_1', "_1")
^  <span class="ansi1 ansi32"
>Exit: </span>(252) [user] n_to_vn('_1', '_1')
^  <span class="ansi1 ansi32"
>Exit: </span>(251) [system] once(user:n_to_vn('_1', '_1'))
^  <span class="ansi1 ansi32"
>Exit: </span>(250) [user] must_det_ll(user:n_to_vn('_1', '_1'))
^  <span class="ansi1 ansi32"
>Call: </span>(250) [user] must_det_ll(ignore(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], [eval, ['if-decons-expr', [[_789052, _789052]|_789064], [_789052, _789052], _789064, [let, _789052, _789052, ['let*', _789064, _789010]], _789010]]]=_1))
^  <span class="ansi1 ansi32"
>Call: </span>(251) [user] once(user:ignore(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], [eval, ['if-decons-expr', [[_789052, _789052]|_789064], [_789052, _789052], _789064, [let, _789052, _789052, ['let*', _789064, _789010]], _789010]]]=_1))
^  <span class="ansi1 ansi32"
>Call: </span>(252) [user] ignore(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], [eval, ['if-decons-expr', [[_789052, _789052]|_789064], [_789052, _789052], _789064, [let, _789052, _789052, ['let*', _789064, _789010]], _789010]]]=_1)
   <span class="ansi1 ansi32"
>Call: </span>(253) [system] ['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], [eval, ['if-decons-expr', [[_789052, _789052]|_789064], [_789052, _789052], _789064, [let, _789052, _789052, ['let*', _789064, _789010]], _789010]]]=_1
^  <span class="ansi1 ansi32"
>Exit: </span>(252) [system] ignore(user:(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], [eval, ['if-decons-expr', [[_789052, _789052]|_789064], [_789052, _789052], _789064, [let, _789052, _789052, ['let*', _789064, _789010]], _789010]]]=_1))
^  <span class="ansi1 ansi32"
>Exit: </span>(251) [system] once(user:ignore(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], [eval, ['if-decons-expr', [[_789052, _789052]|_789064], [_789052, _789052], _789064, [let, _789052, _789052, ['let*', _789064, _789010]], _789010]]]=_1))
^  <span class="ansi1 ansi32"
>Exit: </span>(250) [user] must_det_ll(user:ignore(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], [eval, ['if-decons-expr', [[_789052, _789052]|_789064], [_789052, _789052], _789064, [let, _789052, _789052, ['let*', _789064, _789010]], _789010]]]=_1))
^  <span class="ansi1 ansi32"
>Call: </span>(250) [user] maybe_name_vars([])
   <span class="ansi1 ansi32"
>Call: </span>(251) [system] is_list([])
   <span class="ansi1 ansi32"
>Exit: </span>(251) [system] is_list([])
^  <span class="ansi1 ansi32"
>Exit: </span>(250) [user] maybe_name_vars([])
^  <span class="ansi1 ansi32"
>Exit: </span>(249) [user] maybe_name_vars(['_1'=['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], [eval, ['if-decons-expr', [[_789052, _789052]|_789064], [_789052, _789052], _789064, [let, _789052, _789052, ['let*', _789064, _789010]], _789010]]]])
   <span class="ansi1 ansi32"
>Call: </span>(249) [user] old_not_compatio(write_bsrc(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]]))
   <span class="ansi1 ansi32"
>Call: </span>(250) [user] write_bsrc(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]])
   <span class="ansi1 ansi32"
>Call: </span>(251) [system] ['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]]=='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(251) [system] ground(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]])
   <span class="ansi1 ansi32"
>Call: </span>(251) [$attvar] copy_term(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]], _869488, _869490)
   <span class="ansi1 ansi32"
>Call: </span>(252) [system] term_attvars(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]], _870424)
   <span class="ansi1 ansi32"
>Exit: </span>(252) [system] term_attvars(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]], [])
   <span class="ansi1 ansi32"
>Call: </span>(252) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(252) [system] []==[]
   <span class="ansi1 ansi32"
>Call: </span>(252) [system] _869490=[]
   <span class="ansi1 ansi32"
>Exit: </span>(252) [system] []=[]
   <span class="ansi1 ansi32"
>Call: </span>(252) [system] copy_term(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]], _869488)
   <span class="ansi1 ansi32"
>Exit: </span>(252) [system] copy_term(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]], ['ALT=', ['let*', [[_876956, _876956]|_876952], _876968], ['let*', _876952, _876968]])
   <span class="ansi1 ansi32"
>Exit: </span>(251) [$attvar] copy_term(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]], ['ALT=', ['let*', [[_876956, _876956]|_876952], _876968], ['let*', _876952, _876968]], [])
   <span class="ansi1 ansi32"
>Call: </span>(251) [system] ['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]]=['ALT=', ['let*', [[_876956, _876956]|_876952], _876968], ['let*', _876952, _876968]]
   <span class="ansi1 ansi32"
>Exit: </span>(251) [system] ['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]]=['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]]
   <span class="ansi1 ansi32"
>Call: </span>(251) [user] write_bsrc_goal(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]], [])
^  <span class="ansi1 ansi32"
>Call: </span>(252) [user] write_src(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]])
^  <span class="ansi1 ansi32"
>Call: </span>(254) [system] setup_call_cleanup('$notrace'(_882576, _882578), once(user:(src_vars(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]], _882562), pp_sex(_882562))), '$restore_trace'(_882576, _882578))
^  <span class="ansi1 ansi32"
>Call: </span>(255) [system] sig_atomic(system:'$notrace'(_882576, _882578))
^  <span class="ansi1 ansi31"
>Fail: </span>(252) [user] write_src(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]])
   <span class="ansi1 ansi31"
>Fail: </span>(249) [user] old_not_compatio(write_bsrc(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(246) [system] call(user:once, user:(\+ \+ (maybe_name_vars(['_1'=['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], [eval, ['if-decons-expr', [[_789052, _789052]|_789064], [_789052, _789052], _789064, [let, _789052, _789052, ['let*', _789064, _789010]], _789010]]]]), old_not_compatio(write_bsrc(['ALT=', ['let*', [[_789052, _789052]|_789064], _789010], ['let*', _789064, _789010]])), true)))
^  <span class="ansi1 ansi32"
>Call: </span>(246) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(248) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(248) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(250) [system] setup_call_cleanup('$notrace'(_890050, _890052), once(rtrace:retract(t_l:tracer_reset(_890040))), '$restore_trace'(_890050, _890052))
^  <span class="ansi1 ansi32"
>Call: </span>(251) [system] sig_atomic(system:'$notrace'(_890050, _890052))
^  <span class="ansi1 ansi32"
>Exit: </span>(250) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(250) [rtrace] tAt(false, 271, 271, false)

NDet Result(366): <span class="ansi33"
>(iz add-reduct MeTTa)
</span>$1 = (iz add-reduct MeTTa)

NDet Result(367): <span class="ansi33"
>(@doc add-reduct (@desc "Prevents atom from being reduced") (@params ((@param "Atom"))) (@return "Quoted atom"))
</span>$1 = (@doc add-reduct (@desc "Prevents atom from being reduced") (@params ((@param "Atom"))) (@return "Quoted atom"))

NDet Result(368): <span class="ansi33"
>(@doc add-reduct-rust1 (@desc "Adds atom into the atomspace reducing it first") (@params ((@param "Atomspace to add atom into") (@param "Atom to add"))) (@return "Unit atom"))
</span>$1 = (@doc add-reduct-rust1 (@desc "Adds atom into the atomspace reducing it first") (@params ((@param "Atomspace to add atom into") (@param "Atom to add"))) (@return "Unit atom"))

NDet Result(369): <span class="ansi33"
>(: add-reduct-rust1 (-> hyperon::space::DynSpace %Undefined% (->)))
</span>$1 = (: add-reduct-rust1 (-> hyperon::space::DynSpace %Undefined% (->)))

NDet Result(370): <span class="ansi33"
>(= (add-reduct-minimal $10000 $10001)  
  (add-atom $10000 $10001))
</span>$1 = (= (add-reduct-minimal $10000 $10001)  
  (add-atom $10000 $10001))

NDet Result(371): <span class="ansi33"
>(: add-reduct (-> Grounded %Undefined% (->)))
</span>$1 = (: add-reduct (-> Grounded %Undefined% (->)))

NDet Result(372): <span class="ansi33"
>(= (add-reduct $10000 $10001)  
  (add-atom $10000 $10001))
</span>$1 = (= (add-reduct $10000 $10001)  
  (add-atom $10000 $10001))

NDet Result(373): <span class="ansi33"
>(iz stringToChars MeTTa)
</span>$1 = (iz stringToChars MeTTa)

NDet Result(374): <span class="ansi33"
>(@doc stringToChars (@desc "Converts a string into a list expression of characters.") (@params ((@param "String to be converted."))) (@return "Expression representing the list of characters."))
</span>$1 = (@doc stringToChars (@desc "Converts a string into a list expression of characters.") (@params ((@param "String to be converted."))) (@return "Expression representing the list of characters."))

NDet Result(375): <span class="ansi33"
>(: stringToChars (-> String Expression))
</span>$1 = (: stringToChars (-> String Expression))

NDet Result(376): <span class="ansi33"
>(iz charsToString MeTTa)
</span>$1 = (iz charsToString MeTTa)

NDet Result(377): <span class="ansi33"
>(@doc charsToString (@desc "Converts a list expression of characters into a string.") (@params ((@param "Expression representing the list of characters."))) (@return "Converted string."))
</span>$1 = (@doc charsToString (@desc "Converts a list expression of characters into a string.") (@params ((@param "Expression representing the list of characters."))) (@return "Converted string."))

NDet Result(378): <span class="ansi33"
>(: charsToString (-> Expression String))
</span>$1 = (: charsToString (-> Expression String))

NDet Result(379): <span class="ansi33"
>(iz parse MeTTa)
</span>$1 = (iz parse MeTTa)

NDet Result(380): <span class="ansi33"
>(@doc parse (@desc "Parses MeTTa code from a string and returns the corresponding atom.") (@params ((@param "String containing MeTTa code."))) (@return "Parsed atom."))
</span>$1 = (@doc parse (@desc "Parses MeTTa code from a string and returns the corresponding atom.") (@params ((@param "String containing MeTTa code."))) (@return "Parsed atom."))

NDet Result(381): <span class="ansi33"
>(: parse (-> String Atom))
</span>$1 = (: parse (-> String Atom))

NDet Result(382): <span class="ansi33"
>(iz repr MeTTa)
</span>$1 = (iz repr MeTTa)

NDet Result(383): <span class="ansi33"
>(@doc repr (@desc "Creates a string representation of an atom.") (@params ((@param "Atom to be represented as a string."))) (@return "String representation of the atom."))
</span>$1 = (@doc repr (@desc "Creates a string representation of an atom.") (@params ((@param "Atom to be represented as a string."))) (@return "String representation of the atom."))

NDet Result(384): <span class="ansi33"
>(: repr (-> Atom String))
</span>$1 = (: repr (-> Atom String))

NDet Result(385): <span class="ansi33"
>(iz car-atom MeTTa)
</span>$1 = (iz car-atom MeTTa)

NDet Result(386): <span class="ansi33"
>(@doc car-atom (@desc "Extracts the first atom of an expression as a tuple") (@params ((@param "Expression"))) (@return "First atom of an expression"))
</span>$1 = (@doc car-atom (@desc "Extracts the first atom of an expression as a tuple") (@params ((@param "Expression"))) (@return "First atom of an expression"))

NDet Result(387): <span class="ansi33"
>(: car-atom (-> Expression Atom))
</span>$1 = (: car-atom (-> Expression Atom))

NDet Result(388): <span class="ansi33"
>(ALT= $10000 $10000)
</span>$1 = (ALT= (car-atom ($10000 

NDet Result(389): <span class="ansi33"
>(iz cdr-atom MeTTa)
</span>$1 = (iz cdr-atom MeTTa)

NDet Result(390): <span class="ansi33"
>(@doc cdr-atom (@desc "Extracts the tail of an expression (all except first atom)") (@params ((@param "Expression"))) (@return "Tail of an expression"))
</span>$1 = (@doc cdr-atom (@desc "Extracts the tail of an expression (all except first atom)") (@params ((@param "Expression"))) (@return "Tail of an expression"))

NDet Result(391): <span class="ansi33"
>(: cdr-atom (-> Expression Expression))
</span>$1 = (: cdr-atom (-> Expression Expression))

NDet Result(392): <span class="ansi33"
>(= (cdr-atom $10000)  
  (eval (if-decons-expr $10000 $10001 $10002 $10002 (Error (cdr-atom $10000) "cdr-atom expects a non-empty expression as an argument"))))
</span>$1 = (= (cdr-atom $10000)  
  (eval (if-decons-expr $10000 $10001 $10002 $10002 (Error (cdr-atom $10000) "cdr-atom expects a non-empty expression as an argument"))))

NDet Result(393): <span class="ansi33"
>(iz quote MeTTa)
</span>$1 = (iz quote MeTTa)

NDet Result(394): <span class="ansi33"
>(@doc quote (@desc "Prevents atom from being reduced") (@params ((@param "Atom"))) (@return "Quoted atom"))
</span>$1 = (@doc quote (@desc "Prevents atom from being reduced") (@params ((@param "Atom"))) (@return "Quoted atom"))

NDet Result(395): <span class="ansi33"
>(: quote (-> Atom Atom))
</span>$1 = (: quote (-> Atom Atom))

NDet Result(396): <span class="ansi33"
>(= (quote $10000)  NotReducible)
</span>$1 = (= (quote $10000)  NotReducible)

NDet Result(397): <span class="ansi33"
>(iz unquote MeTTa)
</span>$1 = (iz unquote MeTTa)

NDet Result(398): <span class="ansi33"
>(@doc unquote (@desc "Unquotes quoted atom, e.g. (unquote (quote $x)) returns $x") (@params ((@param "Quoted atom"))) (@return "Unquoted atom"))
</span>$1 = (@doc unquote (@desc "Unquotes quoted atom, e.g. (unquote (quote $x)) returns $x") (@params ((@param "Quoted atom"))) (@return "Unquoted atom"))

NDet Result(399): <span class="ansi33"
>(: unquote (-> %Undefined% %Undefined%))
</span>$1 = (: unquote (-> %Undefined% %Undefined%))

NDet Result(400): <span class="ansi33"
>(= (unquote (quote $10000))  $10000)
</span>$1 = (= (unquote (quote $10000))  $10000)

NDet Result(401): <span class="ansi33"
>(iz nop MeTTa)
</span>$1 = (iz nop MeTTa)

NDet Result(402): <span class="ansi33"
>(@doc nop (@desc "Outputs unit atom") (@params ()) (@return "Unit atom"))
</span>$1 = (@doc nop (@desc "Outputs unit atom") (@params ()) (@return "Unit atom"))

NDet Result(403): <span class="ansi33"
>(: nop (-> EmptyType))
</span>$1 = (: nop (-> EmptyType))

NDet Result(404): <span class="ansi33"
>(ALT= () ())
</span>$1 = (ALT= (nop) ())

NDet Result(405): <span class="ansi33"
>(@doc nop (@desc "Outputs unit atom for any input") (@params ((@param "Anything"))) (@return "Unit atom"))
</span>$1 = (@doc nop (@desc "Outputs unit atom for any input") (@params ((@param "Anything"))) (@return "Unit atom"))

NDet Result(406): <span class="ansi33"
>(: nop (-> Atom (->)))
</span>$1 = (: nop (-> Atom (->)))

NDet Result(407): <span class="ansi33"
>(ALT= () ())
</span>$1 = (ALT= (nop $10000) ())

NDet Result(408): <span class="ansi33"
>(iz empty MeTTa)
</span>$1 = (iz empty MeTTa)

NDet Result(409): <span class="ansi33"
>(@doc empty (@desc "Cuts evaluation of the non-deterministic branch and removes it from the result") (@params ()) (@return "Nothing"))
</span>$1 = (@doc empty (@desc "Cuts evaluation of the non-deterministic branch and removes it from the result") (@params ()) (@return "Nothing"))

NDet Result(410): <span class="ansi33"
>(: empty (-> %Undefined%))
</span>$1 = (: empty (-> %Undefined%))

NDet Result(411): <span class="ansi33"
>(ALT= (empty) (let a b never-happens))
</span>$1 = (ALT= (empty) (let a b never-happens))

NDet Result(412): <span class="ansi33"
>(iz unique MeTTa)
</span>$1 = (iz unique MeTTa)

NDet Result(413): <span class="ansi33"
>(@doc unique (@desc "Function takes non-deterministic input (first argument) and returns only unique entities. E.g. (unique (superpose (a b c d d))) -> [a, b, c, d]") (@params ((@param "Non-deterministic set of values"))) (@return "Unique non-deterministic values from input set"))
</span>$1 = (@doc unique (@desc "Function takes non-deterministic input (first argument) and returns only unique entities. E.g. (unique (superpose (a b c d d))) -> [a, b, c, d]") (@params ((@param "Non-deterministic set of values"))) (@return "Unique non-deterministic values from input set"))

NDet Result(414): <span class="ansi33"
>(: unique (-> Atom Atom))
</span>$1 = (: unique (-> Atom Atom))

NDet Result(415): <span class="ansi33"
>(iz union MeTTa)
</span>$1 = (iz union MeTTa)

NDet Result(416): <span class="ansi33"
>(@doc union (@desc "Function takes two non-deterministic inputs (first and second argument) and returns their union. E.g. (union (superpose (a b b c)) (superpose (b c c d))) -> [a, b, b, c, b, c, c, d]") (@params ((@param "Non-deterministic set of values") (@param "Another non-deterministic set of values"))) (@return "Non-deterministic Union of sets"))
</span>$1 = (@doc union (@desc "Function takes two non-deterministic inputs (first and second argument) and returns their union. E.g. (union (superpose (a b b c)) (superpose (b c c d))) -> [a, b, b, c, b, c, c, d]") (@params ((@param "Non-deterministic set of values") (@param "Another non-deterministic set of values"))) (@return "Non-deterministic Union of sets"))

NDet Result(417): <span class="ansi33"
>(: union (-> Atom Atom Atom))
</span>$1 = (: union (-> Atom Atom Atom))

NDet Result(418): <span class="ansi33"
>(iz intersection MeTTa)
</span>$1 = (iz intersection MeTTa)

NDet Result(419): <span class="ansi33"
>(@doc intersection (@desc "Function takes two non-deterministic inputs (first and second argument) and returns their intersection. E.g. (intersection (superpose (a b c c)) (superpose (b c c c d))) -> [b, c, c]") (@params ((@param "Non-deterministic set of values") (@param "Another non-deterministic set of values"))) (@return "Non-deterministic Intersection of sets"))
</span>$1 = (@doc intersection (@desc "Function takes two non-deterministic inputs (first and second argument) and returns their intersection. E.g. (intersection (superpose (a b c c)) (superpose (b c c c d))) -> [b, c, c]") (@params ((@param "Non-deterministic set of values") (@param "Another non-deterministic set of values"))) (@return "Non-deterministic Intersection of sets"))

NDet Result(420): <span class="ansi33"
>(: intersection (-> Atom Atom Atom))
</span>$1 = (: intersection (-> Atom Atom Atom))

NDet Result(421): <span class="ansi33"
>(iz subtraction MeTTa)
</span>$1 = (iz subtraction MeTTa)

NDet Result(422): <span class="ansi33"
>(@doc subtraction (@desc "Function takes two non-deterministic inputs (first and second argument) and returns their subtraction. E.g. !(subtraction (superpose (a b b c)) (superpose (b c c d))) -> [a, b]") (@params ((@param "Non-deterministic set of values") (@param "Another non-deterministic set of values"))) (@return "Non-deterministic Subtraction of sets"))
</span>$1 = (@doc subtraction (@desc "Function takes two non-deterministic inputs (first and second argument) and returns their subtraction. E.g. !(subtraction (superpose (a b b c)) (superpose (b c c d))) -> [a, b]") (@params ((@param "Non-deterministic set of values") (@param "Another non-deterministic set of values"))) (@return "Non-deterministic Subtraction of sets"))

NDet Result(423): <span class="ansi33"
>(: subtraction (-> Atom Atom Atom))
</span>$1 = (: subtraction (-> Atom Atom Atom))

NDet Result(424): <span class="ansi33"
>(iz @doc MeTTa)
</span>$1 = (iz @doc MeTTa)

NDet Result(425): <span class="ansi33"
>(@doc @doc (@desc "Used for documentation purposes. Function documentation starts with @doc") (@params ((@param "Function name") (@param "Function description. Starts with @desc") (@param "(Optional) parameters description starting with @params which should contain one or more @param symbols") (@param "(Optional) description of what function will return. Starts with @return"))) (@return "Function documentation using @doc-formal"))
</span>$1 = (@doc @doc (@desc "Used for documentation purposes. Function documentation starts with @doc") (@params ((@param "Function name") (@param "Function description. Starts with @desc") (@param "(Optional) parameters description starting with @params which should contain one or more @param symbols") (@param "(Optional) description of what function will return. Starts with @return"))) (@return "Function documentation using @doc-formal"))

NDet Result(426): <span class="ansi33"
>(: @doc (-> Atom DocDescription DocInformal))
</span>$1 = (: @doc (-> Atom DocDescription DocInformal))

NDet Result(427): <span class="ansi33"
>(: @doc (-> Atom DocDescription DocParameters DocReturnInformal DocInformal))
</span>$1 = (: @doc (-> Atom DocDescription DocParameters DocReturnInformal DocInformal))

NDet Result(428): <span class="ansi33"
>(iz @doc DataFunctor)
</span>$1 = (iz @doc DataFunctor)

NDet Result(429): <span class="ansi33"
>(iz @desc MeTTa)
</span>$1 = (iz @desc MeTTa)

NDet Result(430): <span class="ansi33"
>(@doc @desc (@desc "Used for documentation purposes. Description of function starts with @desc as a part of @doc") (@params ((@param "String containing function description"))) (@return "Function description"))
</span>$1 = (@doc @desc (@desc "Used for documentation purposes. Description of function starts with @desc as a part of @doc") (@params ((@param "String containing function description"))) (@return "Function description"))

NDet Result(431): <span class="ansi33"
>(: @desc (-> String DocDescription))
</span>$1 = (: @desc (-> String DocDescription))

NDet Result(432): <span class="ansi33"
>(iz @desc DataFunctor)
</span>$1 = (iz @desc DataFunctor)

NDet Result(433): <span class="ansi33"
>(iz @param MeTTa)
</span>$1 = (iz @param MeTTa)

NDet Result(434): <span class="ansi33"
>(@doc @param (@desc "Used for documentation purposes. Description of function parameter starts with @param as a part of @params which is a part of @doc") (@params ((@param "String containing parameter description"))) (@return "Parameter description"))
</span>$1 = (@doc @param (@desc "Used for documentation purposes. Description of function parameter starts with @param as a part of @params which is a part of @doc") (@params ((@param "String containing parameter description"))) (@return "Parameter description"))

NDet Result(435): <span class="ansi33"
>(: @param (-> String DocParameterInformal))
</span>$1 = (: @param (-> String DocParameterInformal))

NDet Result(436): <span class="ansi33"
>(: @param (-> DocType DocDescription DocParameter))
</span>$1 = (: @param (-> DocType DocDescription DocParameter))

NDet Result(437): <span class="ansi33"
>(iz @param DataFunctor)
</span>$1 = (iz @param DataFunctor)

NDet Result(438): <span class="ansi33"
>(iz @return MeTTa)
</span>$1 = (iz @return MeTTa)

NDet Result(439): <span class="ansi33"
>(@doc @return (@desc "Used for documentation purposes. Description of function return value starts with @return as a part of @doc") (@params ((@param "String containing return value description"))) (@return "Return value description"))
</span>$1 = (@doc @return (@desc "Used for documentation purposes. Description of function return value starts with @return as a part of @doc") (@params ((@param "String containing return value description"))) (@return "Return value description"))

NDet Result(440): <span class="ansi33"
>(: @return (-> String DocReturnInformal))
</span>$1 = (: @return (-> String DocReturnInformal))

NDet Result(441): <span class="ansi33"
>(: @return (-> DocType DocDescription DocReturn))
</span>$1 = (: @return (-> DocType DocDescription DocReturn))

NDet Result(442): <span class="ansi33"
>(iz @return DataFunctor)
</span>$1 = (iz @return DataFunctor)

NDet Result(443): <span class="ansi33"
>(iz @doc-formal MeTTa)
</span>$1 = (iz @doc-formal MeTTa)

NDet Result(444): <span class="ansi33"
>(@doc @doc-formal (@desc "Used for documentation purposes. get-doc returns documentation starting with @doc-formal symbol. @doc-formal contains 6 or 4 parameters depending on the entity being described (functions being described using 6 parameters, atoms - 4 parameters)") (@params ((@param "Function/Atom name for which documentation is to be displayed. Format (@item name)") (@param "Contains (@kind function) or (@kind atom) depends on entity which documentation is displayed") (@param "Contains type notation of function/atom") (@param "Function/atom description") (@param "(Functions only). Description of function parameters") (@param "(Functions only). Description of function's return value"))) (@return "Expression containing full documentation on function"))
</span>$1 = (@doc @doc-formal (@desc "Used for documentation purposes. get-doc returns documentation starting with @doc-formal symbol. @doc-formal contains 6 or 4 parameters depending on the entity being described (functions being described using 6 parameters, atoms - 4 parameters)") (@params ((@param "Function/Atom name for which documentation is to be displayed. Format (@item name)") (@param "Contains (@kind function) or (@kind atom) depends on entity which documentation is displayed") (@param "Contains type notation of function/atom") (@param "Function/atom description") (@param "(Functions only). Description of function parameters") (@param "(Functions only). Description of function's return value"))) (@return "Expression containing full documentation on function"))

NDet Result(445): <span class="ansi33"
>(: @doc-formal (-> DocItem DocKindFunction DocType DocDescription DocParameters DocReturn DocFormal))
</span>$1 = (: @doc-formal (-> DocItem DocKindFunction DocType DocDescription DocParameters DocReturn DocFormal))

NDet Result(446): <span class="ansi33"
>(: @doc-formal (-> DocItem DocKindAtom DocType DocDescription DocFormal))
</span>$1 = (: @doc-formal (-> DocItem DocKindAtom DocType DocDescription DocFormal))

NDet Result(447): <span class="ansi33"
>(iz @doc-formal DataFunctor)
</span>$1 = (iz @doc-formal DataFunctor)

NDet Result(448): <span class="ansi33"
>(iz @item MeTTa)
</span>$1 = (iz @item MeTTa)

NDet Result(449): <span class="ansi33"
>(@doc @item (@desc "Used for documentation purposes. Converts atom/function's name to DocItem") (@params ((@param "Atom/Function name to be documented"))) (@return "(@item Atom) entity"))
</span>$1 = (@doc @item (@desc "Used for documentation purposes. Converts atom/function's name to DocItem") (@params ((@param "Atom/Function name to be documented"))) (@return "(@item Atom) entity"))

NDet Result(450): <span class="ansi33"
>(: @item (-> Atom DocItem))
</span>$1 = (: @item (-> Atom DocItem))

NDet Result(451): <span class="ansi33"
>(iz @item DataFunctor)
</span>$1 = (iz @item DataFunctor)

NDet Result(452): <span class="ansi33"
>(iz (@kind function) MeTTa)
</span>$1 = (iz (@kind function) MeTTa)

NDet Result(453): <span class="ansi33"
>(@doc (@kind function) (@desc "Used for documentation purposes. Shows type of entity to be documented. (@kind function) in this case"))
</span>$1 = (@doc (@kind function) (@desc "Used for documentation purposes. Shows type of entity to be documented. (@kind function) in this case"))

NDet Result(454): <span class="ansi33"
>(: (@kind function) DocKindFunction)
</span>$1 = (: (@kind function) DocKindFunction)

NDet Result(455): <span class="ansi33"
>(iz (@kind function) DataFunctor)
</span>$1 = (iz (@kind function) DataFunctor)

NDet Result(456): <span class="ansi33"
>(iz (@kind atom) MeTTa)
</span>$1 = (iz (@kind atom) MeTTa)

NDet Result(457): <span class="ansi33"
>(@doc (@kind atom) (@desc "Used for documentation purposes. Shows type of entity to be documented. (@kind atom) in this case"))
</span>$1 = (@doc (@kind atom) (@desc "Used for documentation purposes. Shows type of entity to be documented. (@kind atom) in this case"))

NDet Result(458): <span class="ansi33"
>(: (@kind atom) DocKindAtom)
</span>$1 = (: (@kind atom) DocKindAtom)

NDet Result(459): <span class="ansi33"
>(iz (@kind atom) DataFunctor)
</span>$1 = (iz (@kind atom) DataFunctor)

NDet Result(460): <span class="ansi33"
>(iz @type MeTTa)
</span>$1 = (iz @type MeTTa)

NDet Result(461): <span class="ansi33"
>(@doc @type (@desc "Used for documentation purposes. Converts atom/function's type to DocType") (@params ((@param "Atom/Function type to be documented"))) (@return "(@type Type) entity"))
</span>$1 = (@doc @type (@desc "Used for documentation purposes. Converts atom/function's type to DocType") (@params ((@param "Atom/Function type to be documented"))) (@return "(@type Type) entity"))

NDet Result(462): <span class="ansi33"
>(: @type (-> Type DocType))
</span>$1 = (: @type (-> Type DocType))

NDet Result(463): <span class="ansi33"
>(iz @type DataFunctor)
</span>$1 = (iz @type DataFunctor)

NDet Result(464): <span class="ansi33"
>(iz @params MeTTa)
</span>$1 = (iz @params MeTTa)

NDet Result(465): <span class="ansi33"
>(@doc @params (@desc "Used for function documentation purposes. Contains several @param entities with description of each @param") (@params ((@param "Several (@param ...) entities"))) (@return "DocParameters containing description of all parameters of function in form of (@params ((@param ...) (@param ...) ...))"))
</span>$1 = (@doc @params (@desc "Used for function documentation purposes. Contains several @param entities with description of each @param") (@params ((@param "Several (@param ...) entities"))) (@return "DocParameters containing description of all parameters of function in form of (@params ((@param ...) (@param ...) ...))"))

NDet Result(466): <span class="ansi33"
>(: @params (-> Expression DocParameters))
</span>$1 = (: @params (-> Expression DocParameters))

NDet Result(467): <span class="ansi33"
>(iz @params DataFunctor)
</span>$1 = (iz @params DataFunctor)

NDet Result(468): <span class="ansi33"
>(iz get-doc MeTTa)
</span>$1 = (iz get-doc MeTTa)

NDet Result(469): <span class="ansi33"
>(@doc get-doc (@desc "Returns documentation for the given Atom/Function") (@params ((@param "Atom/Function name for which documentation is needed"))) (@return "Documentation for the given atom/function"))
</span>$1 = (@doc get-doc (@desc "Returns documentation for the given Atom/Function") (@params ((@param "Atom/Function name for which documentation is needed"))) (@return "Documentation for the given atom/function"))

NDet Result(470): <span class="ansi33"
>(: get-doc (-> Atom Atom))
</span>$1 = (: get-doc (-> Atom Atom))

NDet Result(471): <span class="ansi33"
>(: metta-get-doc (-> Atom Atom))
</span>$1 = (: metta-get-doc (-> Atom Atom))

NDet Result(472): <span class="ansi33"
>(= (metta-get-doc $10000)  
  (let $10001 
    (get-metatype $10000) 
    (case $10001 
      ( (Expression (get-doc-atom $10000)) ($10002 (get-doc-single-atom $10000))))))
</span>$1 = (= (metta-get-doc $10000)  
  (let $10001 
    (get-metatype $10000) 
    (case $10001 
      ( (Expression (get-doc-atom $10000)) ($10002 (get-doc-single-atom $10000))))))

NDet Result(473): <span class="ansi33"
>(iz get-doc-single-atom PrivateRelation)
</span>$1 = (iz get-doc-single-atom PrivateRelation)

NDet Result(474): <span class="ansi33"
>(@doc get-doc-single-atom (@desc "Function used by get-doc to get documentation on either function or atom. It checks if input name is the name of function or atom and calls correspondent function") (@params ((@param "Atom/Function name for which documentation is needed"))) (@return "Documentation for the given atom/function"))
</span>$1 = (@doc get-doc-single-atom (@desc "Function used by get-doc to get documentation on either function or atom. It checks if input name is the name of function or atom and calls correspondent function") (@params ((@param "Atom/Function name for which documentation is needed"))) (@return "Documentation for the given atom/function"))

NDet Result(475): <span class="ansi33"
>(: get-doc-single-atom (-> Atom Atom))
</span>$1 = (: get-doc-single-atom (-> Atom Atom))

NDet Result(476): <span class="ansi33"
>(= (get-doc-single-atom $10000)  
  (let $10001 
    (mod-space! top) 
    (let $10002 
      (get-type-space $10001 $10000) 
      (if 
        (is-function-type $10002) 
        (get-doc-function $10000 $10002) 
        (get-doc-atom $10000)))))
</span>$1 = (= (get-doc-single-atom $10000)  
  (let $10001 
    (mod-space! top) 
    (let $10002 
      (get-type-space $10001 $10000) 
      (if 
        (is-function-type $10002) 
        (get-doc-function $10000 $10002) 
        (get-doc-atom $10000)))))

NDet Result(477): <span class="ansi33"
>(iz get-doc-function PrivateRelation)
</span>$1 = (iz get-doc-function PrivateRelation)

NDet Result(478): <span class="ansi33"
>(@doc get-doc-function (@desc "Function used by get-doc-single-atom to get documentation on a function. It returns documentation on a function if it exists or default documentation with no description otherwise") (@params ((@param "Function name for which documentation is needed") (@param "Type notation for this function"))) (@return "Documentation for the given function"))
</span>$1 = (@doc get-doc-function (@desc "Function used by get-doc-single-atom to get documentation on a function. It returns documentation on a function if it exists or default documentation with no description otherwise") (@params ((@param "Function name for which documentation is needed") (@param "Type notation for this function"))) (@return "Documentation for the given function"))

NDet Result(479): <span class="ansi33"
>(: get-doc-function (-> Atom Type Atom))
</span>$1 = (: get-doc-function (-> Atom Type Atom))

NDet Result(480): <span class="ansi33"
>(= (get-doc-function $10000 $10001)  
  (let $10002 
    (mod-space! top) 
    (unify $10002 
      (@doc $10000 $10003 
        (@params $10004) $10005) 
      (let $10006 
        (if 
          (== $10001 %Undefined%) 
          (undefined-doc-function-type $10004) 
          (cdr-atom $10001)) 
        (let 
          ($10007 $10008) 
          (get-doc-params $10004 $10005 $10006) 
          (@doc-formal 
            (@item $10000) 
            (@kind function) 
            (@type $10001) $10003 
            (@params $10007) $10008))) 
      (@doc-formal 
        (@item $10000) 
        (@kind function) 
        (@type $10001) 
        (@desc "No documentation")))))
</span>$1 = (= (get-doc-function $10000 $10001)  
  (let $10002 
    (mod-space! top) 
    (unify $10002 
      (@doc $10000 $10003 
        (@params $10004) $10005) 
      (let $10006 
        (if 
          (== $10001 %Undefined%) 
          (undefined-doc-function-type $10004) 
          (cdr-atom $10001)) 
        (let 
          ($10007 $10008) 
          (get-doc-params $10004 $10005 $10006) 
          (@doc-formal 
            (@item $10000) 
            (@kind function) 
            (@type $10001) $10003 
            (@params $10007) $10008))) 
      (@doc-formal 
        (@item $10000) 
        (@kind function) 
        (@type $10001) 
        (@desc "No documentation")))))

NDet Result(481): <span class="ansi33"
>(iz undefined-doc-function-type PrivateRelation)
</span>$1 = (iz undefined-doc-function-type PrivateRelation)

NDet Result(482): <span class="ansi33"
>(@doc undefined-doc-function-type (@desc "Function used by get-doc-single-atom in case of absence of function's type notation") (@params ((@param "List of parameters for the function we want to get documentation for"))) (@return "List of %Undefined% number of which depends on input list size. So for two parameters function will return (%Undefined% %Undefined% %Undefined%)"))
</span>$1 = (@doc undefined-doc-function-type (@desc "Function used by get-doc-single-atom in case of absence of function's type notation") (@params ((@param "List of parameters for the function we want to get documentation for"))) (@return "List of %Undefined% number of which depends on input list size. So for two parameters function will return (%Undefined% %Undefined% %Undefined%)"))

NDet Result(483): <span class="ansi33"
>(: undefined-doc-function-type (-> Expression Type))
</span>$1 = (: undefined-doc-function-type (-> Expression Type))

NDet Result(484): <span class="ansi33"
>(= (undefined-doc-function-type $10000)  
  (if 
    (== () $10000) 
    (%Undefined%) 
    (let $10001 
      (cdr-atom $10000) 
      (let $10002 
        (undefined-doc-function-type $10001) 
        (cons-atom %Undefined% $10002)))))
</span>$1 = (= (undefined-doc-function-type $10000)  
  (if 
    (== () $10000) 
    (%Undefined%) 
    (let $10001 
      (cdr-atom $10000) 
      (let $10002 
        (undefined-doc-function-type $10001) 
        (cons-atom %Undefined% $10002)))))

NDet Result(485): <span class="ansi33"
>(iz get-doc-params PrivateRelation)
</span>$1 = (iz get-doc-params PrivateRelation)

NDet Result(486): <span class="ansi33"
>(@doc get-doc-params (@desc "Function used by get-doc-function to get function's parameters documentation (including return value)") (@params ((@param "List of parameters in form of ((@param Description) (@param Description)...)") (@param "Return value's description in form of (@return Description)") (@param "Type notation without -> starting symbol e.g. (Atom Atom Atom)"))) (@return "United list of params and return value each augmented with its type. E.g. (((@param (@type Atom) (@desc Description)) (@param (@type Atom) (@desc Description2))) (@return (@type Atom) (@desc Description)))"))
</span>$1 = (@doc get-doc-params (@desc "Function used by get-doc-function to get function's parameters documentation (including return value)") (@params ((@param "List of parameters in form of ((@param Description) (@param Description)...)") (@param "Return value's description in form of (@return Description)") (@param "Type notation without -> starting symbol e.g. (Atom Atom Atom)"))) (@return "United list of params and return value each augmented with its type. E.g. (((@param (@type Atom) (@desc Description)) (@param (@type Atom) (@desc Description2))) (@return (@type Atom) (@desc Description)))"))

NDet Result(487): <span class="ansi33"
>(: get-doc-params (-> Expression Atom Expression (Expression Atom)))
</span>$1 = (: get-doc-params (-> Expression Atom Expression (Expression Atom)))

NDet Result(488): <span class="ansi33"
>(= (get-doc-params $10000 $10001 $10002)  
  (let $10003 
    (car-atom $10002) 
    (let $10004 
      (cdr-atom $10002) 
      (if 
        (== () $10000) 
        (let 
          (@return $10005) $10001 
          (() (@return (@type $10003) (@desc $10005)))) 
        (let 
          (@param $10006) 
          (car-atom $10000) 
          (let $10007 
            (cdr-atom $10000) 
            (let 
              ($10008 $10009) 
              (get-doc-params $10007 $10001 $10004) 
              (let $10010 
                (cons-atom 
                  (@param 
                    (@type $10003) 
                    (@desc $10006)) $10008) 
                ($10010 $10009)))))))))
</span>$1 = (= (get-doc-params $10000 $10001 $10002)  
  (let $10003 
    (car-atom $10002) 
    (let $10004 
      (cdr-atom $10002) 
      (if 
        (== () $10000) 
        (let 
          (@return $10005) $10001 
          (() (@return (@type $10003) (@desc $10005)))) 
        (let 
          (@param $10006) 
          (car-atom $10000) 
          (let $10007 
            (cdr-atom $10000) 
            (let 
              ($10008 $10009) 
              (get-doc-params $10007 $10001 $10004) 
              (let $10010 
                (cons-atom 
                  (@param 
                    (@type $10003) 
                    (@desc $10006)) $10008) 
                ($10010 $10009)))))))))

NDet Result(489): <span class="ansi33"
>(iz get-doc-atom PrivateRelation)
</span>$1 = (iz get-doc-atom PrivateRelation)

NDet Result(490): <span class="ansi33"
>(@doc get-doc-atom (@desc "Function used by get-doc (in case of input type Expression) and get-doc-single-atom (in case input value is not a function) to get documentation on input value") (@params ((@param "Atom's name to get documentation for"))) (@return "Documentation on input Atom"))
</span>$1 = (@doc get-doc-atom (@desc "Function used by get-doc (in case of input type Expression) and get-doc-single-atom (in case input value is not a function) to get documentation on input value") (@params ((@param "Atom's name to get documentation for"))) (@return "Documentation on input Atom"))

NDet Result(491): <span class="ansi33"
>(: get-doc-atom (-> Atom Atom))
</span>$1 = (: get-doc-atom (-> Atom Atom))

NDet Result(492): <span class="ansi33"
>(= (get-doc-atom $10000)  
  (let $10001 
    (mod-space! top) 
    (let $10002 
      (get-type-space $10001 $10000) 
      (unify $10001 
        (@doc $10000 $10003) 
        (@doc-formal 
          (@item $10000) 
          (@kind atom) 
          (@type $10002) $10003) 
        (unify $10001 
          (@doc $10000 $10004 
            (@params $10005) $10006) 
          (get-doc-function $10000 %Undefined%) 
          (@doc-formal 
            (@item $10000) 
            (@kind atom) 
            (@type $10002) 
            (@desc "No documentation")))))))
</span>$1 = (= (get-doc-atom $10000)  
  (let $10001 
    (mod-space! top) 
    (let $10002 
      (get-type-space $10001 $10000) 
      (unify $10001 
        (@doc $10000 $10003) 
        (@doc-formal 
          (@item $10000) 
          (@kind atom) 
          (@type $10002) $10003) 
        (unify $10001 
          (@doc $10000 $10004 
            (@params $10005) $10006) 
          (get-doc-function $10000 %Undefined%) 
          (@doc-formal 
            (@item $10000) 
            (@kind atom) 
            (@type $10002) 
            (@desc "No documentation")))))))

NDet Result(493): <span class="ansi33"
>(iz help! MeTTa)
</span>$1 = (iz help! MeTTa)

NDet Result(494): <span class="ansi33"
>(@doc help! (@desc "Function prints documentation for the input atom.") (@params ((@param "Input to get documentation for"))) (@return "Unit atom"))
</span>$1 = (@doc help! (@desc "Function prints documentation for the input atom.") (@params ((@param "Input to get documentation for"))) (@return "Unit atom"))

NDet Result(495): <span class="ansi33"
>(: help! (-> Atom (->)))
</span>$1 = (: help! (-> Atom (->)))

NDet Result(496): <span class="ansi33"
>(: metta-help! (-> Atom (->)))
</span>$1 = (: metta-help! (-> Atom (->)))

NDet Result(497): <span class="ansi33"
>(= (metta-help! $10000)  
  (case 
    (get-doc $10000) 
    ( ( (@doc-formal 
          (@item $10001) 
          (@kind function) 
          (@type $10002) 
          (@desc $10003) 
          (@params $10004) 
          (@return 
            (@type $10005) 
            (@desc $10006))) (let () (println! (format-args "Function {}: {} {}" ($10001 $10002 $10003))) (let () (println! (format-args "Parameters:" ())) (let () (for-each-in-atom $10004 help-param!) (let () (println! (format-args "Return: (type {}) {}" ($10005 $10006))) ()))))) 
      ( (@doc-formal 
          (@item $10001) 
          (@kind function) 
          (@type $10002) 
          (@desc $10003)) (let () (println! (format-args "Function {} (type {}) {}" ($10001 $10002 $10003))) ())) 
      ( (@doc-formal 
          (@item $10001) 
          (@kind atom) 
          (@type $10002) 
          (@desc $10003)) (let () (println! (format-args "Atom {}: {} {}" ($10001 $10002 $10003))) ())) 
      ($10007 (Error $10007 "Cannot match @doc-formal structure")))))
</span>$1 = (= (metta-help! $10000)  
  (case 
    (get-doc $10000) 
    ( ( (@doc-formal 
          (@item $10001) 
          (@kind function) 
          (@type $10002) 
          (@desc $10003) 
          (@params $10004) 
          (@return 
            (@type $10005) 
            (@desc $10006))) (let () (println! (format-args "Function {}: {} {}" ($10001 $10002 $10003))) (let () (println! (format-args "Parameters:" ())) (let () (for-each-in-atom $10004 help-param!) (let () (println! (format-args "Return: (type {}) {}" ($10005 $10006))) ()))))) 
      ( (@doc-formal 
          (@item $10001) 
          (@kind function) 
          (@type $10002) 
          (@desc $10003)) (let () (println! (format-args "Function {} (type {}) {}" ($10001 $10002 $10003))) ())) 
      ( (@doc-formal 
          (@item $10001) 
          (@kind atom) 
          (@type $10002) 
          (@desc $10003)) (let () (println! (format-args "Atom {}: {} {}" ($10001 $10002 $10003))) ())) 
      ($10007 (Error $10007 "Cannot match @doc-formal structure")))))

NDet Result(498): <span class="ansi33"
>(iz help-param! PrivateRelation)
</span>$1 = (iz help-param! PrivateRelation)

NDet Result(499): <span class="ansi33"
>(@doc help-param! (@desc "Function used by function help! to output parameters using println!") (@params ((@param "Parameters list"))) (@return "Unit atom"))
</span>$1 = (@doc help-param! (@desc "Function used by function help! to output parameters using println!") (@params ((@param "Parameters list"))) (@return "Unit atom"))

NDet Result(500): <span class="ansi33"
>(: help-param! (-> Atom (->)))
</span>$1 = (: help-param! (-> Atom (->)))

NDet Result(501): <span class="ansi33"
>(= (help-param! $10000)  
  (let 
    (@param 
      (@type $10001) 
      (@desc $10002)) $10000 
    (println! (format-args "  {} {}" ((type $10001) $10002)))))
</span>$1 = (= (help-param! $10000)  
  (let 
    (@param 
      (@type $10001) 
      (@desc $10002)) $10000 
    (println! (format-args "  {} {}" ((type $10001) $10002)))))

NDet Result(502): <span class="ansi33"
>(iz for-each-in-atom PrivateRelation)
</span>$1 = (iz for-each-in-atom PrivateRelation)

NDet Result(503): <span class="ansi33"
>(@doc for-each-in-atom (@desc "Applies function passed as a second argument to each atom inside first argument") (@params ((@param "Expression to each atom in which function will be applied") (@param "Function to apply"))) (@return "Unit atom"))
</span>$1 = (@doc for-each-in-atom (@desc "Applies function passed as a second argument to each atom inside first argument") (@params ((@param "Expression to each atom in which function will be applied") (@param "Function to apply"))) (@return "Unit atom"))

NDet Result(504): <span class="ansi33"
>(: for-each-in-atom (-> Expression Atom (->)))
</span>$1 = (: for-each-in-atom (-> Expression Atom (->)))

NDet Result(505): <span class="ansi33"
>(= (for-each-in-atom $10000 $10001)  
  (if 
    (noreduce-eq $10000 ()) () 
    (let $10002 
      (car-atom $10000) 
      (let $10003 
        (cdr-atom $10000) 
        (let $10004 
          ($10001 $10002) 
          (for-each-in-atom $10003 $10001))))))
</span>$1 = (= (for-each-in-atom $10000 $10001)  
  (if 
    (noreduce-eq $10000 ()) () 
    (let $10002 
      (car-atom $10000) 
      (let $10003 
        (cdr-atom $10000) 
        (let $10004 
          ($10001 $10002) 
          (for-each-in-atom $10003 $10001))))))

NDet Result(506): <span class="ansi33"
>(iz noreduce-eq PrivateRelation)
</span>$1 = (iz noreduce-eq PrivateRelation)

NDet Result(507): <span class="ansi33"
>(@doc noreduce-eq (@desc "Checks equality of two atoms without reducing them") (@params ((@param "First atom") (@param "Second atom"))) (@return "True if not reduced atoms are equal, False - otherwise"))
</span>$1 = (@doc noreduce-eq (@desc "Checks equality of two atoms without reducing them") (@params ((@param "First atom") (@param "Second atom"))) (@return "True if not reduced atoms are equal, False - otherwise"))

NDet Result(508): <span class="ansi33"
>(: noreduce-eq (-> Atom Atom Bool))
</span>$1 = (: noreduce-eq (-> Atom Atom Bool))

NDet Result(509): <span class="ansi33"
>(= (noreduce-eq $10000 $10001)  
  (== 
    (quote $10000) 
    (quote $10001)))
</span>$1 = (= (noreduce-eq $10000 $10001)  
  (== 
    (quote $10000) 
    (quote $10001)))

NDet Result(510): <span class="ansi33"
>(iz add-atom MeTTa)
</span>$1 = (iz add-atom MeTTa)

NDet Result(511): <span class="ansi33"
>(@doc add-atom (@desc "Adds atom into the atomspace without reducing it") (@params ((@param "Atomspace to add atom into") (@param "Atom to add"))) (@return "Unit atom"))
</span>$1 = (@doc add-atom (@desc "Adds atom into the atomspace without reducing it") (@params ((@param "Atomspace to add atom into") (@param "Atom to add"))) (@return "Unit atom"))

NDet Result(512): <span class="ansi33"
>(: add-atom (-> hyperon::space::DynSpace Atom (->)))
</span>$1 = (: add-atom (-> hyperon::space::DynSpace Atom (->)))

NDet Result(513): <span class="ansi33"
>(iz get-type MeTTa)
</span>$1 = (iz get-type MeTTa)

NDet Result(514): <span class="ansi33"
>(@doc get-type (@desc "Returns type notation of input atom") (@params ((@param "Atom to get type for"))) (@return "Type notation or %Undefined% if there is no type for input Atom"))
</span>$1 = (@doc get-type (@desc "Returns type notation of input atom") (@params ((@param "Atom to get type for"))) (@return "Type notation or %Undefined% if there is no type for input Atom"))

NDet Result(515): <span class="ansi33"
>(: get-type (-> Atom Atom))
</span>$1 = (: get-type (-> Atom Atom))

NDet Result(516): <span class="ansi33"
>(: get-type (-> Atom Atom Atom))
</span>$1 = (: get-type (-> Atom Atom Atom))

NDet Result(517): <span class="ansi33"
>(iz get-type-space MeTTa)
</span>$1 = (iz get-type-space MeTTa)

NDet Result(518): <span class="ansi33"
>(@doc get-type-space (@desc "Returns type notation of input Atom (second argument) relative to a specified atomspace (first argument)") (@params ((@param "Atomspace where type notation for input atom will be searched") (@param "Atom to get type for"))) (@return "Type notation or %Undefined% if there is no type for input Atom in provided atomspace"))
</span>$1 = (@doc get-type-space (@desc "Returns type notation of input Atom (second argument) relative to a specified atomspace (first argument)") (@params ((@param "Atomspace where type notation for input atom will be searched") (@param "Atom to get type for"))) (@return "Type notation or %Undefined% if there is no type for input Atom in provided atomspace"))

NDet Result(519): <span class="ansi33"
>(: get-type-space (-> Atom Atom Atom))
</span>$1 = (: get-type-space (-> Atom Atom Atom))

NDet Result(520): <span class="ansi33"
>(= (get-type-space $10000 $10001)  
  (get-type $10001 $10000))
</span>$1 = (= (get-type-space $10000 $10001)  
  (get-type $10001 $10000))

NDet Result(521): <span class="ansi33"
>(iz get-metatype MeTTa)
</span>$1 = (iz get-metatype MeTTa)

NDet Result(522): <span class="ansi33"
>(@doc get-metatype (@desc "Returns metatype of the input atom") (@params ((@param "Atom to get metatype for"))) (@return "Metatype of input atom"))
</span>$1 = (@doc get-metatype (@desc "Returns metatype of the input atom") (@params ((@param "Atom to get metatype for"))) (@return "Metatype of input atom"))

NDet Result(523): <span class="ansi33"
>(: get-metatype (-> Atom Atom))
</span>$1 = (: get-metatype (-> Atom Atom))

NDet Result(524): <span class="ansi33"
>(iz if-equal MinimalMeTTa)
</span>$1 = (iz if-equal MinimalMeTTa)

NDet Result(525): <span class="ansi33"
>(@doc if-equal (@desc "Checks if first two arguments are equal and evaluates third argument if equal, fourth argument - otherwise") (@params ((@param "First argument") (@param "Second argument") (@param "Atom to be evaluated if arguments are equal") (@param "Atom to be evaluated if arguments are not equal"))) (@return "Evaluated third or fourth argument"))
</span>$1 = (@doc if-equal (@desc "Checks if first two arguments are equal and evaluates third argument if equal, fourth argument - otherwise") (@params ((@param "First argument") (@param "Second argument") (@param "Atom to be evaluated if arguments are equal") (@param "Atom to be evaluated if arguments are not equal"))) (@return "Evaluated third or fourth argument"))

NDet Result(526): <span class="ansi33"
>(iz new-space MeTTa)
</span>$1 = (iz new-space MeTTa)

NDet Result(527): <span class="ansi33"
>(@doc new-space (@desc "Creates new Atomspace which could be used further in the program as a separate from &self Atomspace") (@params ()) (@return "Reference to a new space"))
</span>$1 = (@doc new-space (@desc "Creates new Atomspace which could be used further in the program as a separate from &self Atomspace") (@params ()) (@return "Reference to a new space"))

NDet Result(528): <span class="ansi33"
>(: new-space (-> hyperon::space::DynSpace))
</span>$1 = (: new-space (-> hyperon::space::DynSpace))

NDet Result(529): <span class="ansi33"
>(iz remove-atom MeTTa)
</span>$1 = (iz remove-atom MeTTa)

NDet Result(530): <span class="ansi33"
>(@doc remove-atom (@desc "Removes atom from the input Atomspace") (@params ((@param "Reference to the space from which the Atom needs to be removed") (@param "Atom to be removed"))) (@return "Unit atom"))
</span>$1 = (@doc remove-atom (@desc "Removes atom from the input Atomspace") (@params ((@param "Reference to the space from which the Atom needs to be removed") (@param "Atom to be removed"))) (@return "Unit atom"))

NDet Result(531): <span class="ansi33"
>(: remove-atom (-> hyperon::space::DynSpace Atom (->)))
</span>$1 = (: remove-atom (-> hyperon::space::DynSpace Atom (->)))

NDet Result(532): <span class="ansi33"
>(iz get-atoms MeTTa)
</span>$1 = (iz get-atoms MeTTa)

NDet Result(533): <span class="ansi33"
>(@doc get-atoms (@desc "Shows all atoms in the input Atomspace") (@params ((@param "Reference to the space"))) (@return "List of all atoms in the input space"))
</span>$1 = (@doc get-atoms (@desc "Shows all atoms in the input Atomspace") (@params ((@param "Reference to the space"))) (@return "List of all atoms in the input space"))

NDet Result(534): <span class="ansi33"
>(: get-atoms (-> hyperon::space::DynSpace Atom))
</span>$1 = (: get-atoms (-> hyperon::space::DynSpace Atom))

NDet Result(535): <span class="ansi33"
>(iz new-state MeTTa)
</span>$1 = (iz new-state MeTTa)

NDet Result(536): <span class="ansi33"
>(@doc new-state (@desc "Creates a new state atom wrapping its argument") (@params ((@param "Atom to be wrapped"))) (@return "Returns (State $value) where $value is an argument to a new-state"))
</span>$1 = (@doc new-state (@desc "Creates a new state atom wrapping its argument") (@params ((@param "Atom to be wrapped"))) (@return "Returns (State $value) where $value is an argument to a new-state"))

NDet Result(537): <span class="ansi33"
>(: new-state (-> $10000 (StateMonad $10000)))
</span>$1 = (: new-state (-> $10000 (StateMonad $10000)))

NDet Result(538): <span class="ansi33"
>(iz change-state! MeTTa)
</span>$1 = (iz change-state! MeTTa)

NDet Result(539): <span class="ansi33"
>(@doc change-state! (@desc "Changes input state's wrapped atom to another value (second argument). E.g. (change-state! (State 5) 6) -> (State 6)") (@params ((@param "State created by new-state function") (@param "Atom which will replace wrapped atom in the input state"))) (@return "State with replaced wrapped atom"))
</span>$1 = (@doc change-state! (@desc "Changes input state's wrapped atom to another value (second argument). E.g. (change-state! (State 5) 6) -> (State 6)") (@params ((@param "State created by new-state function") (@param "Atom which will replace wrapped atom in the input state"))) (@return "State with replaced wrapped atom"))

NDet Result(540): <span class="ansi33"
>(: change-state! (-> (StateMonad $10000) $10000 (StateMonad $10000)))
</span>$1 = (: change-state! (-> (StateMonad $10000) $10000 (StateMonad $10000)))

NDet Result(541): <span class="ansi33"
>(iz get-state MeTTa)
</span>$1 = (iz get-state MeTTa)

NDet Result(542): <span class="ansi33"
>(@doc get-state (@desc "Gets a state as an argument and returns its wrapped atom. E.g. (get-state (State 5)) -> 5") (@params ((@param "State"))) (@return "Atom wrapped by state"))
</span>$1 = (@doc get-state (@desc "Gets a state as an argument and returns its wrapped atom. E.g. (get-state (State 5)) -> 5") (@params ((@param "State"))) (@return "Atom wrapped by state"))

NDet Result(543): <span class="ansi33"
>(: get-state (-> (StateMonad $10000) $10000))
</span>$1 = (: get-state (-> (StateMonad $10000) $10000))

NDet Result(544): <span class="ansi33"
>(iz match MeTTa)
</span>$1 = (iz match MeTTa)

NDet Result(545): <span class="ansi33"
>(@doc match (@desc "Searches for all declared atoms corresponding to the given pattern (second argument) and produces the output pattern (third argument)") (@params ((@param "A grounded atom referencing a Space") (@param "Pattern atom to be searched") (@param "Output template typically containing variables from the input pattern"))) (@return "If match was successful it outputs template (third argument) with filled variables (if any were present in pattern) using matched pattern (second argument). Empty - otherwise"))
</span>$1 = (@doc match (@desc "Searches for all declared atoms corresponding to the given pattern (second argument) and produces the output pattern (third argument)") (@params ((@param "A grounded atom referencing a Space") (@param "Pattern atom to be searched") (@param "Output template typically containing variables from the input pattern"))) (@return "If match was successful it outputs template (third argument) with filled variables (if any were present in pattern) using matched pattern (second argument). Empty - otherwise"))

NDet Result(546): <span class="ansi33"
>(: match (-> Atom Atom Atom %Undefined%))
</span>$1 = (: match (-> Atom Atom Atom %Undefined%))

NDet Result(547): <span class="ansi33"
>(iz register-module! MeTTa)
</span>$1 = (iz register-module! MeTTa)

NDet Result(548): <span class="ansi33"
>(@doc register-module! (@desc "Takes a file system path (first argument) and loads the module into the runner") (@params ((@param "File system path"))) (@return "Unit atom"))
</span>$1 = (@doc register-module! (@desc "Takes a file system path (first argument) and loads the module into the runner") (@params ((@param "File system path"))) (@return "Unit atom"))

NDet Result(549): <span class="ansi33"
>(: register-module! (-> Atom (->)))
</span>$1 = (: register-module! (-> Atom (->)))

NDet Result(550): <span class="ansi33"
>(iz mod-space! MeTTa)
</span>$1 = (iz mod-space! MeTTa)

NDet Result(551): <span class="ansi33"
>(@doc mod-space! (@desc "Returns the space of the module (first argument) and tries to load the module if it is not loaded into the module system") (@params ((@param "Module name"))) (@return "Space name"))
</span>$1 = (@doc mod-space! (@desc "Returns the space of the module (first argument) and tries to load the module if it is not loaded into the module system") (@params ((@param "Module name"))) (@return "Space name"))

NDet Result(552): <span class="ansi33"
>(: mod-space! (-> Atom hyperon::space::DynSpace))
</span>$1 = (: mod-space! (-> Atom hyperon::space::DynSpace))

NDet Result(553): <span class="ansi33"
>(= (mod-space! self)  &self)
</span>$1 = (= (mod-space! self)  &self)

NDet Result(554): <span class="ansi33"
>(= (mod-space! top)  &self)
</span>$1 = (= (mod-space! top)  &self)

NDet Result(555): <span class="ansi33"
>(= (mod-space! corelib)  &corelib)
</span>$1 = (= (mod-space! corelib)  &corelib)

NDet Result(556): <span class="ansi33"
>(= (mod-space! stdlib)  &stdlib)
</span>$1 = (= (mod-space! stdlib)  &stdlib)

NDet Result(557): <span class="ansi33"
>(= (mod-space! catalog)  &catalog)
</span>$1 = (= (mod-space! catalog)  &catalog)

NDet Result(558): <span class="ansi33"
>(iz print-mods! MeTTa)
</span>$1 = (iz print-mods! MeTTa)

NDet Result(559): <span class="ansi33"
>(@doc print-mods! (@desc "Prints all modules with their correspondent spaces") (@params ()) (@return "Unit atom"))
</span>$1 = (@doc print-mods! (@desc "Prints all modules with their correspondent spaces") (@params ()) (@return "Unit atom"))

NDet Result(560): <span class="ansi33"
>(: print-mods! (-> (->)))
</span>$1 = (: print-mods! (-> (->)))

NDet Result(561): <span class="ansi33"
>(iz assertEqual MeTTa)
</span>$1 = (iz assertEqual MeTTa)

NDet Result(562): <span class="ansi33"
>(@doc assertEqual (@desc "Compares (sets of) results of evaluation of two expressions") (@params ((@param "First expression") (@param "Second expression"))) (@return "Unit atom if both expression after evaluation is equal, error - otherwise"))
</span>$1 = (@doc assertEqual (@desc "Compares (sets of) results of evaluation of two expressions") (@params ((@param "First expression") (@param "Second expression"))) (@return "Unit atom if both expression after evaluation is equal, error - otherwise"))

NDet Result(563): <span class="ansi33"
>(: assertEqual (-> Atom Atom Atom))
</span>$1 = (: assertEqual (-> Atom Atom Atom))

NDet Result(564): <span class="ansi33"
>(iz assertNotEqual MeTTaLog)
</span>$1 = (iz assertNotEqual MeTTaLog)

NDet Result(565): <span class="ansi33"
>(@doc assertNotEqual (@desc "Compares (sets of) results of evaluation of two expressions") (@params ((@param "First expression") (@param "Second expression"))) (@return "Unit atom if both expressions after evaluation are not equal, error - otherwise"))
</span>$1 = (@doc assertNotEqual (@desc "Compares (sets of) results of evaluation of two expressions") (@params ((@param "First expression") (@param "Second expression"))) (@return "Unit atom if both expressions after evaluation are not equal, error - otherwise"))

NDet Result(566): <span class="ansi33"
>(: assertNotEqual (-> Atom Atom Atom))
</span>$1 = (: assertNotEqual (-> Atom Atom Atom))

NDet Result(567): <span class="ansi33"
>(iz assertEqualToResult MeTTa)
</span>$1 = (iz assertEqualToResult MeTTa)

NDet Result(568): <span class="ansi33"
>(@doc assertEqualToResult (@desc "Same as assertEqual but it doesn't evaluate second argument. Second argument is considered as a set of values of the first argument's evaluation") (@params ((@param "First expression (it will be evaluated)") (@param "Second expression (it won't be evaluated)"))) (@return "Unit atom if both expression after evaluation is equal, error - otherwise"))
</span>$1 = (@doc assertEqualToResult (@desc "Same as assertEqual but it doesn't evaluate second argument. Second argument is considered as a set of values of the first argument's evaluation") (@params ((@param "First expression (it will be evaluated)") (@param "Second expression (it won't be evaluated)"))) (@return "Unit atom if both expression after evaluation is equal, error - otherwise"))

NDet Result(569): <span class="ansi33"
>(: assertEqualToResult (-> Atom Atom Atom))
</span>$1 = (: assertEqualToResult (-> Atom Atom Atom))

NDet Result(570): <span class="ansi33"
>(iz assertNotEqualToResult MeTTaLog)
</span>$1 = (iz assertNotEqualToResult MeTTaLog)

NDet Result(571): <span class="ansi33"
>(@doc assertNotEqualToResult (@desc "Same as assertNotEqual but it doesn't evaluate second argument. Second argument is considered as a set of values of the first argument's evaluation") (@params ((@param "First expression (it will be evaluated)") (@param "Second expression (it won't be evaluated)"))) (@return "Unit atom if both expressions after evaluation are not equal, error - otherwise"))
</span>$1 = (@doc assertNotEqualToResult (@desc "Same as assertNotEqual but it doesn't evaluate second argument. Second argument is considered as a set of values of the first argument's evaluation") (@params ((@param "First expression (it will be evaluated)") (@param "Second expression (it won't be evaluated)"))) (@return "Unit atom if both expressions after evaluation are not equal, error - otherwise"))

NDet Result(572): <span class="ansi33"
>(: assertNotEqualToResult (-> Atom Atom Atom))
</span>$1 = (: assertNotEqualToResult (-> Atom Atom Atom))

NDet Result(573): <span class="ansi33"
>(iz superpose MeTTa)
</span>$1 = (iz superpose MeTTa)

NDet Result(574): <span class="ansi33"
>(@doc superpose (@desc "Turns a tuple (first argument) into a nondeterministic result") (@params ((@param "Tuple to be converted"))) (@return "Argument converted to nondeterministic result"))
</span>$1 = (@doc superpose (@desc "Turns a tuple (first argument) into a nondeterministic result") (@params ((@param "Tuple to be converted"))) (@return "Argument converted to nondeterministic result"))

NDet Result(575): <span class="ansi33"
>(: superpose (-> Expression %Undefined%))
</span>$1 = (: superpose (-> Expression %Undefined%))

NDet Result(576): <span class="ansi33"
>(iz collapse MeTTa)
</span>$1 = (iz collapse MeTTa)

NDet Result(577): <span class="ansi33"
>(@doc collapse (@desc "Converts a nondeterministic result into a tuple") (@params ((@param "Atom which will be evaluated"))) (@return "Tuple"))
</span>$1 = (@doc collapse (@desc "Converts a nondeterministic result into a tuple") (@params ((@param "Atom which will be evaluated"))) (@return "Tuple"))

NDet Result(578): <span class="ansi33"
>(: collapse (-> Atom Atom))
</span>$1 = (: collapse (-> Atom Atom))

NDet Result(579): <span class="ansi33"
>(iz case MeTTa)
</span>$1 = (iz case MeTTa)

NDet Result(580): <span class="ansi33"
>(@doc case (@desc "Subsequently tests multiple pattern-matching conditions (second argument) for the given value (first argument)") (@params ((@param "Atom (it will be evaluated)") (@param "Tuple of pairs mapping condition patterns to results"))) (@return "Result of evaluating Atom bound to met condition"))
</span>$1 = (@doc case (@desc "Subsequently tests multiple pattern-matching conditions (second argument) for the given value (first argument)") (@params ((@param "Atom (it will be evaluated)") (@param "Tuple of pairs mapping condition patterns to results"))) (@return "Result of evaluating Atom bound to met condition"))

NDet Result(581): <span class="ansi33"
>(: case (-> Atom Expression Atom))
</span>$1 = (: case (-> Atom Expression Atom))

NDet Result(582): <span class="ansi33"
>(iz capture MeTTa)
</span>$1 = (iz capture MeTTa)

NDet Result(583): <span class="ansi33"
>(@doc capture (@desc "Wraps an atom and captures the current space") (@params ((@param "Function name which space needs to be captured"))) (@return "Function"))
</span>$1 = (@doc capture (@desc "Wraps an atom and captures the current space") (@params ((@param "Function name which space needs to be captured"))) (@return "Function"))

NDet Result(584): <span class="ansi33"
>(: capture (-> Atom Atom))
</span>$1 = (: capture (-> Atom Atom))

NDet Result(585): <span class="ansi33"
>(iz hyperpose MeTTa)
</span>$1 = (iz hyperpose MeTTa)

NDet Result(586): <span class="ansi33"
>(@doc hyperpose (@desc "Turns a tuple (first argument) into a nondeterministic result, as superpose, but is explicitly concurrent. Each item of the tuple may be processed in parallel, depending on the number of threads available (which is the minimum of the tuple size and the number of cores available).") (@params ((@param "Tuple to be converted"))) (@return "Argument converted to nondeterministic result"))
</span>$1 = (@doc hyperpose (@desc "Turns a tuple (first argument) into a nondeterministic result, as superpose, but is explicitly concurrent. Each item of the tuple may be processed in parallel, depending on the number of threads available (which is the minimum of the tuple size and the number of cores available).") (@params ((@param "Tuple to be converted"))) (@return "Argument converted to nondeterministic result"))

NDet Result(587): <span class="ansi33"
>(: hyperpose (-> Expression %Undefined%))
</span>$1 = (: hyperpose (-> Expression %Undefined%))

NDet Result(588): <span class="ansi33"
>(iz sequential MeTTa)
</span>$1 = (iz sequential MeTTa)

NDet Result(589): <span class="ansi33"
>(@doc sequential (@desc "Turns a tuple (first argument) into a nondeterministic result, as superpose, but evaluation order of the elements of the tuple is fixed left to right. In that sense the result order is deterministic iff evaluating the tuple elements is deterministic.") (@params ((@param "Tuple to be evaluated"))) (@return "Sequential results of the tuple's elements."))
</span>$1 = (@doc sequential (@desc "Turns a tuple (first argument) into a nondeterministic result, as superpose, but evaluation order of the elements of the tuple is fixed left to right. In that sense the result order is deterministic iff evaluating the tuple elements is deterministic.") (@params ((@param "Tuple to be evaluated"))) (@return "Sequential results of the tuple's elements."))

NDet Result(590): <span class="ansi33"
>(: sequential (-> Expression %Undefined%))
</span>$1 = (: sequential (-> Expression %Undefined%))

NDet Result(591): <span class="ansi33"
>(iz do MeTTa)
</span>$1 = (iz do MeTTa)

NDet Result(592): <span class="ansi33"
>(@doc do (@desc "Completely evaluates form, returning nothing. Typically used for side-effects. A common pattern is (sequential ((do <side-effect-form>) <form-that-needs-side-effect>)).") (@params ((@param "Form"))) (@return "None"))
</span>$1 = (@doc do (@desc "Completely evaluates form, returning nothing. Typically used for side-effects. A common pattern is (sequential ((do <side-effect-form>) <form-that-needs-side-effect>)).") (@params ((@param "Form"))) (@return "None"))

NDet Result(593): <span class="ansi33"
>(: do (-> Expression %Undefined%))
</span>$1 = (: do (-> Expression %Undefined%))

NDet Result(594): <span class="ansi33"
>(iz pragma! MeTTa)
</span>$1 = (iz pragma! MeTTa)

NDet Result(595): <span class="ansi33"
>(@doc pragma! (@desc "Changes global key's (first argument) value to a new one (second argument)") (@params ((@param "Key's name") (@param "New value"))) (@return "Unit atom"))
</span>$1 = (@doc pragma! (@desc "Changes global key's (first argument) value to a new one (second argument)") (@params ((@param "Key's name") (@param "New value"))) (@return "Unit atom"))

NDet Result(596): <span class="ansi33"
>(: pragma! (-> Symbol %Undefined% (->)))
</span>$1 = (: pragma! (-> Symbol %Undefined% (->)))

NDet Result(597): <span class="ansi33"
>(iz import! MeTTa)
</span>$1 = (iz import! MeTTa)

NDet Result(598): <span class="ansi33"
>(@doc import! (@desc "Imports module using its relative path (second argument) and binds it to the token (first argument) which will represent imported atomspace. If first argument is &self then everything will be imported to current atomspace. The source is imported only the first time import! is called. Can load Python code (.py) or MeTTa (.metta); if ambiguous, assumes Python.") (@params ((@param "Symbol, which is turned into the token for accessing the imported module") (@param "Module name"))) (@return "Unit atom"))
</span>$1 = (@doc import! (@desc "Imports module using its relative path (second argument) and binds it to the token (first argument) which will represent imported atomspace. If first argument is &self then everything will be imported to current atomspace. The source is imported only the first time import! is called. Can load Python code (.py) or MeTTa (.metta); if ambiguous, assumes Python.") (@params ((@param "Symbol, which is turned into the token for accessing the imported module") (@param "Module name"))) (@return "Unit atom"))

NDet Result(599): <span class="ansi33"
>(: import! (-> Atom Atom (->)))
</span>$1 = (: import! (-> Atom Atom (->)))

NDet Result(600): <span class="ansi33"
>(iz include MeTTa)
</span>$1 = (iz include MeTTa)

NDet Result(601): <span class="ansi33"
>(@doc include (@desc "Works just like include! but with &self as a first argument. So everything from input file will be included in the current atomspace and evaluated") (@params ((@param "Name of metta script to import"))) (@return "Unit atom"))
</span>$1 = (@doc include (@desc "Works just like include! but with &self as a first argument. So everything from input file will be included in the current atomspace and evaluated") (@params ((@param "Name of metta script to import"))) (@return "Unit atom"))

NDet Result(602): <span class="ansi33"
>(: include (-> Atom Atom))
</span>$1 = (: include (-> Atom Atom))

NDet Result(603): <span class="ansi33"
>(iz include! MeTTa)
</span>$1 = (iz include! MeTTa)

NDet Result(604): <span class="ansi33"
>(@doc include! (@desc "Everything from input file will be included in the current atomspace and evaluated, as if it were being evaluated at the REPL. Unlike import!, the source is evaluated every time include! is called.") (@params ((@param "Space") (@param "Filename"))) (@return "Expression"))
</span>$1 = (@doc include! (@desc "Everything from input file will be included in the current atomspace and evaluated, as if it were being evaluated at the REPL. Unlike import!, the source is evaluated every time include! is called.") (@params ((@param "Space") (@param "Filename"))) (@return "Expression"))

NDet Result(605): <span class="ansi33"
>(: include! (-> hyperon::space::DynSpace String Expression))
</span>$1 = (: include! (-> hyperon::space::DynSpace String Expression))

NDet Result(606): <span class="ansi33"
>(iz bind! MeTTa)
</span>$1 = (iz bind! MeTTa)

NDet Result(607): <span class="ansi33"
>(@doc bind! (@desc "Registers a new token which is replaced with an atom during the parsing of the rest of the program") (@params ((@param "Token name") (@param "Atom, which is associated with the token after reduction"))) (@return "Unit atom"))
</span>$1 = (@doc bind! (@desc "Registers a new token which is replaced with an atom during the parsing of the rest of the program") (@params ((@param "Token name") (@param "Atom, which is associated with the token after reduction"))) (@return "Unit atom"))

NDet Result(608): <span class="ansi33"
>(: bind! (-> Symbol %Undefined% (->)))
</span>$1 = (: bind! (-> Symbol %Undefined% (->)))

NDet Result(609): <span class="ansi33"
>(iz trace! MeTTa)
</span>$1 = (iz trace! MeTTa)

NDet Result(610): <span class="ansi33"
>(@doc trace! (@desc "Prints its first argument and returns second. Both arguments will be evaluated before processing") (@params ((@param "Atom to print") (@param "Atom to return"))) (@return "Evaluated second input"))
</span>$1 = (@doc trace! (@desc "Prints its first argument and returns second. Both arguments will be evaluated before processing") (@params ((@param "Atom to print") (@param "Atom to return"))) (@return "Evaluated second input"))

NDet Result(611): <span class="ansi33"
>(: trace! (-> %Undefined% $10000 $10000))
</span>$1 = (: trace! (-> %Undefined% $10000 $10000))

NDet Result(612): <span class="ansi33"
>(iz println! MeTTa)
</span>$1 = (iz println! MeTTa)

NDet Result(613): <span class="ansi33"
>(@doc println! (@desc "Prints a line of text to the console") (@params ((@param "Expression/atom to be printed out"))) (@return "Unit atom"))
</span>$1 = (@doc println! (@desc "Prints a line of text to the console") (@params ((@param "Expression/atom to be printed out"))) (@return "Unit atom"))

NDet Result(614): <span class="ansi33"
>(: println! (-> %Undefined% (->)))
</span>$1 = (: println! (-> %Undefined% (->)))

NDet Result(615): <span class="ansi33"
>(iz format-args MeTTa)
</span>$1 = (iz format-args MeTTa)

NDet Result(616): <span class="ansi33"
>(@doc format-args (@desc "Fills {} symbols in the input expression with atoms from the second expression. E.g. (format-args (Probability of {} is {}%) (head 50)) gives [(Probability of head is 50%)]. Atoms in the second input value could be variables") (@params ((@param "Expression with {} symbols to be replaced") (@param "Atoms to be placed inside expression instead of {}"))) (@return "Expression with replaced {} with atoms"))
</span>$1 = (@doc format-args (@desc "Fills {} symbols in the input expression with atoms from the second expression. E.g. (format-args (Probability of {} is {}%) (head 50)) gives [(Probability of head is 50%)]. Atoms in the second input value could be variables") (@params ((@param "Expression with {} symbols to be replaced") (@param "Atoms to be placed inside expression instead of {}"))) (@return "Expression with replaced {} with atoms"))

NDet Result(617): <span class="ansi33"
>(: format-args (-> String Atom String))
</span>$1 = (: format-args (-> String Atom String))

NDet Result(618): <span class="ansi33"
>(iz sealed MeTTa)
</span>$1 = (iz sealed MeTTa)

NDet Result(619): <span class="ansi33"
>(@doc sealed (@desc "Replaces all occurrences of any var from var list (first argument) inside atom (second argument) by unique variable. Can be used to create a locally scoped variables") (@params ((@param "Variable list e.g. ($x $y)") (@param "Atom which uses those variables"))) (@return "Second argument but with variables being replaced with unique variables"))
</span>$1 = (@doc sealed (@desc "Replaces all occurrences of any var from var list (first argument) inside atom (second argument) by unique variable. Can be used to create a locally scoped variables") (@params ((@param "Variable list e.g. ($x $y)") (@param "Atom which uses those variables"))) (@return "Second argument but with variables being replaced with unique variables"))

NDet Result(620): <span class="ansi33"
>(: sealed (-> Expression Atom Atom))
</span>$1 = (: sealed (-> Expression Atom Atom))

NDet Result(621): <span class="ansi33"
>(iz &self MeTTa)
</span>$1 = (iz &self MeTTa)

NDet Result(622): <span class="ansi33"
>(@doc &self (@desc "Returns reference to the current atomspace") (@params ()) (@return "Reference to the current atomspace"))
</span>$1 = (@doc &self (@desc "Returns reference to the current atomspace") (@params ()) (@return "Reference to the current atomspace"))

NDet Result(623): <span class="ansi33"
>(iz + MeTTa)
</span>$1 = (iz + MeTTa)

NDet Result(624): <span class="ansi33"
>(@doc + (@desc "Sums two numbers") (@params ((@param "Addend") (@param "Augend"))) (@return "Sum"))
</span>$1 = (@doc + (@desc "Sums two numbers") (@params ((@param "Addend") (@param "Augend"))) (@return "Sum"))

NDet Result(625): <span class="ansi33"
>(: + (-> Number Number Number))
</span>$1 = (: + (-> Number Number Number))

NDet Result(626): <span class="ansi33"
>(iz - MeTTa)
</span>$1 = (iz - MeTTa)

NDet Result(627): <span class="ansi33"
>(@doc - (@desc "Subtracts second argument from first one") (@params ((@param "Minuend") (@param "Deductible"))) (@return "Difference"))
</span>$1 = (@doc - (@desc "Subtracts second argument from first one") (@params ((@param "Minuend") (@param "Deductible"))) (@return "Difference"))

NDet Result(628): <span class="ansi33"
>(: - (-> Number Number Number))
</span>$1 = (: - (-> Number Number Number))

NDet Result(629): <span class="ansi33"
>(iz * MeTTa)
</span>$1 = (iz * MeTTa)

NDet Result(630): <span class="ansi33"
>(@doc * (@desc "Multiplies two numbers") (@params ((@param "Multiplier") (@param "Multiplicand"))) (@return "Product"))
</span>$1 = (@doc * (@desc "Multiplies two numbers") (@params ((@param "Multiplier") (@param "Multiplicand"))) (@return "Product"))

NDet Result(631): <span class="ansi33"
>(: * (-> Number Number Number))
</span>$1 = (: * (-> Number Number Number))

NDet Result(632): <span class="ansi33"
>(iz / MeTTa)
</span>$1 = (iz / MeTTa)

NDet Result(633): <span class="ansi33"
>(@doc / (@desc "Divides first argument by second one") (@params ((@param "Dividend") (@param "Divisor"))) (@return "Fraction"))
</span>$1 = (@doc / (@desc "Divides first argument by second one") (@params ((@param "Dividend") (@param "Divisor"))) (@return "Fraction"))

NDet Result(634): <span class="ansi33"
>(: / (-> Number Number Number))
</span>$1 = (: / (-> Number Number Number))

NDet Result(635): <span class="ansi33"
>(iz % MeTTa)
</span>$1 = (iz % MeTTa)

NDet Result(636): <span class="ansi33"
>(@doc % (@desc "Modulo operator. It returns remainder of dividing first argument by second argument") (@params ((@param "Dividend") (@param "Divisor"))) (@return "Remainder"))
</span>$1 = (@doc % (@desc "Modulo operator. It returns remainder of dividing first argument by second argument") (@params ((@param "Dividend") (@param "Divisor"))) (@return "Remainder"))

NDet Result(637): <span class="ansi33"
>(: % (-> Number Number Number))
</span>$1 = (: % (-> Number Number Number))

NDet Result(638): <span class="ansi33"
>(iz < MeTTa)
</span>$1 = (iz < MeTTa)

NDet Result(639): <span class="ansi33"
>(@doc < (@desc "Less than. Checks if first argument is less than second one") (@params ((@param "First number") (@param "Second number"))) (@return "True if first argument is less than second, False - otherwise"))
</span>$1 = (@doc < (@desc "Less than. Checks if first argument is less than second one") (@params ((@param "First number") (@param "Second number"))) (@return "True if first argument is less than second, False - otherwise"))

NDet Result(640): <span class="ansi33"
>(: < (-> Number Number Bool))
</span>$1 = (: < (-> Number Number Bool))

NDet Result(641): <span class="ansi33"
>(iz > MeTTa)
</span>$1 = (iz > MeTTa)

NDet Result(642): <span class="ansi33"
>(@doc > (@desc "Greater than. Checks if first argument is greater than second one") (@params ((@param "First number") (@param "Second number"))) (@return "True if first argument is greater than second, False - otherwise"))
</span>$1 = (@doc > (@desc "Greater than. Checks if first argument is greater than second one") (@params ((@param "First number") (@param "Second number"))) (@return "True if first argument is greater than second, False - otherwise"))

NDet Result(643): <span class="ansi33"
>(: > (-> Number Number Bool))
</span>$1 = (: > (-> Number Number Bool))

NDet Result(644): <span class="ansi33"
>(iz <= MeTTa)
</span>$1 = (iz <= MeTTa)

NDet Result(645): <span class="ansi33"
>(@doc <= (@desc "Less than or equal. Checks if first argument is less than or equal to second one") (@params ((@param "First number") (@param "Second number"))) (@return "True if first argument is less than or equal to second, False - otherwise"))
</span>$1 = (@doc <= (@desc "Less than or equal. Checks if first argument is less than or equal to second one") (@params ((@param "First number") (@param "Second number"))) (@return "True if first argument is less than or equal to second, False - otherwise"))

NDet Result(646): <span class="ansi33"
>(: <= (-> Number Number Bool))
</span>$1 = (: <= (-> Number Number Bool))

NDet Result(647): <span class="ansi33"
>(iz >= MeTTa)
</span>$1 = (iz >= MeTTa)

NDet Result(648): <span class="ansi33"
>(@doc >= (@desc "Greater than or equal. Checks if first argument is greater than or equal to second one") (@params ((@param "First number") (@param "Second number"))) (@return "True if first argument is greater than or equal to second, False - otherwise"))
</span>$1 = (@doc >= (@desc "Greater than or equal. Checks if first argument is greater than or equal to second one") (@params ((@param "First number") (@param "Second number"))) (@return "True if first argument is greater than or equal to second, False - otherwise"))

NDet Result(649): <span class="ansi33"
>(: >= (-> Number Number Bool))
</span>$1 = (: >= (-> Number Number Bool))

NDet Result(650): <span class="ansi33"
>(iz == MeTTa)
</span>$1 = (iz == MeTTa)

NDet Result(651): <span class="ansi33"
>(@doc == (@desc "Checks equality for two arguments of the same type") (@params ((@param "First argument") (@param "Second argument"))) (@return "Returns True if two arguments are equal, False - otherwise. If arguments are of different type function returns Error currently"))
</span>$1 = (@doc == (@desc "Checks equality for two arguments of the same type") (@params ((@param "First argument") (@param "Second argument"))) (@return "Returns True if two arguments are equal, False - otherwise. If arguments are of different type function returns Error currently"))

NDet Result(652): <span class="ansi33"
>(: == (-> $10000 $10000 Bool))
</span>$1 = (: == (-> $10000 $10000 Bool))

NDet Result(653): <span class="ansi33"
>(iz xor MeTTa)
</span>$1 = (iz xor MeTTa)

NDet Result(654): <span class="ansi33"
>(@doc xor (@desc "Exclusive disjunction of two arguments") (@params ((@param "First argument") (@param "Second argument"))) (@return "Return values are the same as logical disjunction, but when both arguments are True xor will return False"))
</span>$1 = (@doc xor (@desc "Exclusive disjunction of two arguments") (@params ((@param "First argument") (@param "Second argument"))) (@return "Return values are the same as logical disjunction, but when both arguments are True xor will return False"))

NDet Result(655): <span class="ansi33"
>(: xor (-> Bool Bool Bool))
</span>$1 = (: xor (-> Bool Bool Bool))

NDet Result(656): <span class="ansi33"
>(iz flip MeTTa)
</span>$1 = (iz flip MeTTa)

NDet Result(657): <span class="ansi33"
>(@doc flip (@desc "Produces random boolean value") (@params ()) (@return "Random boolean value"))
</span>$1 = (@doc flip (@desc "Produces random boolean value") (@params ()) (@return "Random boolean value"))

NDet Result(658): <span class="ansi33"
>(@doc unique-atom (@desc "Function takes tuple and returns only unique entities. E.g. (unique-atom (a b c d d)) -> (a b c d)") (@params ((@param "List of values"))) (@return "Unique values from input set"))
</span>$1 = (@doc unique-atom (@desc "Function takes tuple and returns only unique entities. E.g. (unique-atom (a b c d d)) -> (a b c d)") (@params ((@param "List of values"))) (@return "Unique values from input set"))

NDet Result(659): <span class="ansi33"
>(= (unique-atom $10000)  
  (collapse (unique (superpose $10000))))
</span>$1 = (= (unique-atom $10000)  
  (collapse (unique (superpose $10000))))

NDet Result(660): <span class="ansi33"
>(: unique-atom (-> Expression Expression))
</span>$1 = (: unique-atom (-> Expression Expression))

NDet Result(661): <span class="ansi33"
>(@doc union-atom (@desc "Function takes two tuples and returns their union. E.g. (union-atom (a b b c) (b c c d)) -> (a b b c b c c d)") (@params ((@param "List of values") (@param "List of values"))) (@return "Union of sets"))
</span>$1 = (@doc union-atom (@desc "Function takes two tuples and returns their union. E.g. (union-atom (a b b c) (b c c d)) -> (a b b c b c c d)") (@params ((@param "List of values") (@param "List of values"))) (@return "Union of sets"))

NDet Result(662): <span class="ansi33"
>(= (union-atom $10000 $10001)  
  (collapse (union (superpose $10000) (superpose $10001))))
</span>$1 = (= (union-atom $10000 $10001)  
  (collapse (union (superpose $10000) (superpose $10001))))

NDet Result(663): <span class="ansi33"
>(: union-atom (-> Expression Expression Expression))
</span>$1 = (: union-atom (-> Expression Expression Expression))

NDet Result(664): <span class="ansi33"
>(@doc intersection-atom (@desc "Function takes two tuples and returns their intersection. E.g. (intersection-atom (a b c c) (b c c c d)) -> (b c c)") (@params ((@param "List of values") (@param "List of values"))) (@return "Intersection of sets"))
</span>$1 = (@doc intersection-atom (@desc "Function takes two tuples and returns their intersection. E.g. (intersection-atom (a b c c) (b c c c d)) -> (b c c)") (@params ((@param "List of values") (@param "List of values"))) (@return "Intersection of sets"))

NDet Result(665): <span class="ansi33"
>(= (intersection-atom $10000 $10001)  
  (collapse (intersection (superpose $10000) (superpose $10001))))
</span>$1 = (= (intersection-atom $10000 $10001)  
  (collapse (intersection (superpose $10000) (superpose $10001))))

NDet Result(666): <span class="ansi33"
>(: intersection-atom (-> Expression Expression Expression))
</span>$1 = (: intersection-atom (-> Expression Expression Expression))

NDet Result(667): <span class="ansi33"
>(@doc subtraction-atom (@desc "Function takes two tuples and returns their subtraction. E.g. !(subtraction-atom (a b b c) (b c c d)) -> (a b)") (@params ((@param "List of values") (@param "List of values"))) (@return "Subtraction of sets"))
</span>$1 = (@doc subtraction-atom (@desc "Function takes two tuples and returns their subtraction. E.g. !(subtraction-atom (a b b c) (b c c d)) -> (a b)") (@params ((@param "List of values") (@param "List of values"))) (@return "Subtraction of sets"))

NDet Result(668): <span class="ansi33"
>(= (subtraction-atom $10000 $10001)  
  (collapse (subtraction (superpose $10000) (superpose $10001))))
</span>$1 = (= (subtraction-atom $10000 $10001)  
  (collapse (subtraction (superpose $10000) (superpose $10001))))

NDet Result(669): <span class="ansi33"
>(: subtraction-atom (-> Expression Expression Expression))
</span>$1 = (: subtraction-atom (-> Expression Expression Expression))

NDet Result(670): <span class="ansi33"
>(iz git-module! MeTTa)
</span>$1 = (iz git-module! MeTTa)

NDet Result(671): <span class="ansi33"
>(@doc git-module! (@desc "Provides access to module in a remote git repo, from within MeTTa code. Similar to `register-module!`, this op will bypass the catalog search") (@params ((@param "URL to github repo"))) (@return "Unit atom"))
</span>$1 = (@doc git-module! (@desc "Provides access to module in a remote git repo, from within MeTTa code. Similar to `register-module!`, this op will bypass the catalog search") (@params ((@param "URL to github repo"))) (@return "Unit atom"))

NDet Result(672): <span class="ansi33"
>(: git-module! (-> Atom (->)))
</span>$1 = (: git-module! (-> Atom (->)))

NDet Result(673): <span class="ansi33"
>(iz findall! MeTTaLog)
</span>$1 = (iz findall! MeTTaLog)

NDet Result(674): <span class="ansi33"
>(@doc findall! (@desc "Takes a Template and a Goal. Returns the list resulting from substituting all bindings from solving Goal into Template.\n  See Prolog's built-in predicate findall/3.") (@params ((@param "Template") (@param "Goal"))) (@return "Result list of all bindings for Goal substituted into Template"))
</span>$1 = (@doc findall! (@desc "Takes a Template and a Goal. Returns the list resulting from substituting all bindings from solving Goal into Template.\n  See Prolog's built-in predicate findall/3.") (@params ((@param "Template") (@param "Goal"))) (@return "Result list of all bindings for Goal substituted into Template"))

NDet Result(675): <span class="ansi33"
>(: findall! (-> Expression Expression Expression))
</span>$1 = (: findall! (-> Expression Expression Expression))

NDet Result(676): <span class="ansi33"
>(iz maplist! MeTTaLog)
</span>$1 = (iz maplist! MeTTaLog)

NDet Result(677): <span class="ansi33"
>(@doc maplist! (@desc "Takes a function F and one to three lists; Returns the result of applying F to each item in the list(s). \n The provided lists are not evaluated (this matches the behavior of e.g. cons-atom).\n F must have the number of lists provided as a valid arity (i.e. unary for one list, binary for two, ternary for three).\n Use concurrent-maplist! for a multi-threaded, nondeterministic version.\n See Prolog's built-in predicate maplist.") (@params ((@param "Function to be applied") (@param "List"))) (@return "Result of applying Function to List(s)"))
</span>$1 = (@doc maplist! (@desc "Takes a function F and one to three lists; Returns the result of applying F to each item in the list(s). \n The provided lists are not evaluated (this matches the behavior of e.g. cons-atom).\n F must have the number of lists provided as a valid arity (i.e. unary for one list, binary for two, ternary for three).\n Use concurrent-maplist! for a multi-threaded, nondeterministic version.\n See Prolog's built-in predicate maplist.") (@params ((@param "Function to be applied") (@param "List"))) (@return "Result of applying Function to List(s)"))

NDet Result(678): <span class="ansi33"
>(: maplist! (-> Function Expression Expression))
</span>$1 = (: maplist! (-> Function Expression Expression))

NDet Result(679): <span class="ansi33"
>(: maplist! (-> Function Expression Expression Expression))
</span>$1 = (: maplist! (-> Function Expression Expression Expression))

NDet Result(680): <span class="ansi33"
>(: maplist! (-> Function Expression Expression Expression Expression))
</span>$1 = (: maplist! (-> Function Expression Expression Expression Expression))

NDet Result(681): <span class="ansi33"
>(iz concurrent-maplist! MeTTaLog)
</span>$1 = (iz concurrent-maplist! MeTTaLog)

NDet Result(682): <span class="ansi33"
>(@doc concurrent-maplist! (@desc "Takes a function F and one to three lists; Returns the result of applying F to each item in the list(s). \n The provided lists are not evaluated (this matches the behavior of e.g. cons-atom).\n F must have the number of lists provided as a valid arity (i.e. unary for one list, binary for two, ternary for three).\n The applications of F to the list items are processed in parallel. Because of the overhead of this approach, a speedup is only likely if F is expensive to evaluate.\n Use maplist! for a single-threaded, deterministic version.\n See Prolog's built-in predicate concurrent-maplist.") (@params ((@param "Function to be applied") (@param "List"))) (@return "Result of applying Function to List(s)"))
</span>$1 = (@doc concurrent-maplist! (@desc "Takes a function F and one to three lists; Returns the result of applying F to each item in the list(s). \n The provided lists are not evaluated (this matches the behavior of e.g. cons-atom).\n F must have the number of lists provided as a valid arity (i.e. unary for one list, binary for two, ternary for three).\n The applications of F to the list items are processed in parallel. Because of the overhead of this approach, a speedup is only likely if F is expensive to evaluate.\n Use maplist! for a single-threaded, deterministic version.\n See Prolog's built-in predicate concurrent-maplist.") (@params ((@param "Function to be applied") (@param "List"))) (@return "Result of applying Function to List(s)"))

NDet Result(683): <span class="ansi33"
>(: concurrent-maplist! (-> Function Expression Expression))
</span>$1 = (: concurrent-maplist! (-> Function Expression Expression))

NDet Result(684): <span class="ansi33"
>(: concurrent-maplist! (-> Function Expression Expression Expression))
</span>$1 = (: concurrent-maplist! (-> Function Expression Expression Expression))

NDet Result(685): <span class="ansi33"
>(: concurrent-maplist! (-> Function Expression Expression Expression Expression))
</span>$1 = (: concurrent-maplist! (-> Function Expression Expression Expression Expression))

NDet Result(686): <span class="ansi33"
>(iz throw MeTTaLog)
</span>$1 = (iz throw MeTTaLog)

NDet Result(687): <span class="ansi33"
>(@doc throw (@desc "Raises an exception. See also `catch`; the system will look for the innermost catch such that Exception unifies with Catcher.") (@params ((@param "Exception"))) (@return "Does not return - raises an exception"))
</span>$1 = (@doc throw (@desc "Raises an exception. See also `catch`; the system will look for the innermost catch such that Exception unifies with Catcher.") (@params ((@param "Exception"))) (@return "Does not return - raises an exception"))

NDet Result(688): <span class="ansi33"
>(: throw (-> Atom ErrorType))
</span>$1 = (: throw (-> Atom ErrorType))

NDet Result(689): <span class="ansi33"
>(iz catch MeTTaLog)
</span>$1 = (iz catch MeTTaLog)

NDet Result(690): <span class="ansi33"
>(@doc catch (@desc "Executes Form. If an exception is raised with `throw` during execution of Form while this is the innermost catch such that Catcher unifies with Exception, the exception is caught. Recover is then executed with bindings from Catcher.") (@params ((@param "Form") (@param "Catcher") (@param "Recover"))) (@return "Result of Form if no exception is raised. Result of Recover (with bindings from Catcher) if an exception is caught."))
</span>$1 = (@doc catch (@desc "Executes Form. If an exception is raised with `throw` during execution of Form while this is the innermost catch such that Catcher unifies with Exception, the exception is caught. Recover is then executed with bindings from Catcher.") (@params ((@param "Form") (@param "Catcher") (@param "Recover"))) (@return "Result of Form if no exception is raised. Result of Recover (with bindings from Catcher) if an exception is caught."))

NDet Result(691): <span class="ansi33"
>(: catch (-> Atom Atom Atom Atom))
</span>$1 = (: catch (-> Atom Atom Atom Atom))

NDet Result(692): <span class="ansi33"
>(iz max-time! MeTTaLog)
</span>$1 = (iz max-time! MeTTaLog)

NDet Result(693): <span class="ansi33"
>(@doc max-time! (@desc "Executes Form. If execution takes longer than Time, will raise a time_limit_exceeded exception. See also `catch`.") (@params ((@param "Time (in seconds)") (@param "Form"))) (@return "Result of Form if execution completes within Time. Raises an exception otherwise."))
</span>$1 = (@doc max-time! (@desc "Executes Form. If execution takes longer than Time, will raise a time_limit_exceeded exception. See also `catch`.") (@params ((@param "Time (in seconds)") (@param "Form"))) (@return "Result of Form if execution completes within Time. Raises an exception otherwise."))

NDet Result(694): <span class="ansi33"
>(: max-time! (-> Number Atom Atom))
</span>$1 = (: max-time! (-> Number Atom Atom))

NDet Result(695): <span class="ansi33"
>(iz sleep! MeTTaLog)
</span>$1 = (iz sleep! MeTTaLog)

NDet Result(696): <span class="ansi33"
>(@doc sleep! (@desc "Sleeps for N seconds.") (@params ((@param "N"))) (@return "Returns True after sleeping completes."))
</span>$1 = (@doc sleep! (@desc "Sleeps for N seconds.") (@params ((@param "N"))) (@return "Returns True after sleeping completes."))

NDet Result(697): <span class="ansi33"
>(: sleep! (-> Number Bool))
</span>$1 = (: sleep! (-> Number Bool))

NDet Result(698): <span class="ansi33"
>(iz limit! MeTTaLog)
</span>$1 = (iz limit! MeTTaLog)

NDet Result(699): <span class="ansi33"
>(@doc limit! (@desc "Executes Form generating at most Limit results. Results are returned as soon as they become available.") (@params ((@param "Limit") (@param "Form"))) (@return "First Limit results of Form."))
</span>$1 = (@doc limit! (@desc "Executes Form generating at most Limit results. Results are returned as soon as they become available.") (@params ((@param "Limit") (@param "Form"))) (@return "First Limit results of Form."))

NDet Result(700): <span class="ansi33"
>(: limit! (-> Number Atom Atom))
</span>$1 = (: limit! (-> Number Atom Atom))

NDet Result(701): <span class="ansi33"
>(iz number-of MeTTaLog)
</span>$1 = (iz number-of MeTTaLog)

NDet Result(702): <span class="ansi33"
>(@doc number-of (@desc "Returns the number of results Form generates") (@params ((@param "Form"))) (@return "Number of results of Form."))
</span>$1 = (@doc number-of (@desc "Returns the number of results Form generates") (@params ((@param "Form"))) (@return "Number of results of Form."))

NDet Result(703): <span class="ansi33"
>(: number-of (-> Atom Number))
</span>$1 = (: number-of (-> Atom Number))

NDet Result(704): <span class="ansi33"
>(iz offset! MeTTaLog)
</span>$1 = (iz offset! MeTTaLog)

NDet Result(705): <span class="ansi33"
>(@doc offset! (@desc "Executes Form ignoring the first Count results. Results are returned as soon as they become available.") (@params ((@param "Count") (@param "Form"))) (@return "Results of Form after ignoring the first Count results that are generated."))
</span>$1 = (@doc offset! (@desc "Executes Form ignoring the first Count results. Results are returned as soon as they become available.") (@params ((@param "Count") (@param "Form"))) (@return "Results of Form after ignoring the first Count results that are generated."))

NDet Result(706): <span class="ansi33"
>(: offset! (-> Number Atom Atom))
</span>$1 = (: offset! (-> Number Atom Atom))

NDet Result(707): <span class="ansi33"
>(iz call! MeTTaLog)
</span>$1 = (iz call! MeTTaLog)

NDet Result(708): <span class="ansi33"
>(@doc call! (@desc "Trampolines to Prolog's call. Only works when the predicate and each arg are provided separately. e.g. !(call! ls /) will print the root directory but !(call! ls(/)) will fail.") (@params ((@param "Form"))) (@return "True if the call succeeds, False otherwise."))
</span>$1 = (@doc call! (@desc "Trampolines to Prolog's call. Only works when the predicate and each arg are provided separately. e.g. !(call! ls /) will print the root directory but !(call! ls(/)) will fail.") (@params ((@param "Form"))) (@return "True if the call succeeds, False otherwise."))

NDet Result(709): <span class="ansi33"
>(: call! (-> Atom Atom))
</span>$1 = (: call! (-> Atom Atom))

NDet Result(710): <span class="ansi33"
>(iz call-p! MeTTaLog)
</span>$1 = (iz call-p! MeTTaLog)

NDet Result(711): <span class="ansi33"
>(@doc call-p! (@desc "Like call-fn! except it does not append the called term with a return arg.") (@params ((@param "Form"))) (@return "True if the call succeeds, False otherwise."))
</span>$1 = (@doc call-p! (@desc "Like call-fn! except it does not append the called term with a return arg.") (@params ((@param "Form"))) (@return "True if the call succeeds, False otherwise."))

NDet Result(712): <span class="ansi33"
>(: call-p! (-> Atom Atom))
</span>$1 = (: call-p! (-> Atom Atom))

NDet Result(713): <span class="ansi33"
>(iz call-fn! MeTTaLog)
</span>$1 = (iz call-fn! MeTTaLog)

NDet Result(714): <span class="ansi33"
>(@doc call-fn! (@desc "Trampolines to Prolog's call after appending the return argument.  Each arg are provided separately. e.g. !(call-fn! length (1 2 3)) will return 3.") (@params ((@param "Form"))) (@return "appends a return argument to a form and calls it"))
</span>$1 = (@doc call-fn! (@desc "Trampolines to Prolog's call after appending the return argument.  Each arg are provided separately. e.g. !(call-fn! length (1 2 3)) will return 3.") (@params ((@param "Form"))) (@return "appends a return argument to a form and calls it"))

NDet Result(715): <span class="ansi33"
>(: call-fn! (-> Atom Atom))
</span>$1 = (: call-fn! (-> Atom Atom))

NDet Result(716): <span class="ansi33"
>(iz call-string! MeTTaLog)
</span>$1 = (iz call-string! MeTTaLog)

NDet Result(717): <span class="ansi33"
>(@doc call-string! (@desc "Executes String as Prolog code. For example, (call-string! \"member(1,[1,2,3])\") returns [()] while (call-string! \"member(4,[1,2,3])\") returns []. (call-string! \"member(X,[1,2,3])\") returns [(1), (2), (3)].") (@params ((@param "PrologSrc"))) (@return "A list of the binding values. If there are no bindings but the Prolog query is True, returns the empty list."))
</span>$1 = (@doc call-string! (@desc "Executes String as Prolog code. For example, (call-string! \"member(1,[1,2,3])\") returns [()] while (call-string! \"member(4,[1,2,3])\") returns []. (call-string! \"member(X,[1,2,3])\") returns [(1), (2), (3)].") (@params ((@param "PrologSrc"))) (@return "A list of the binding values. If there are no bindings but the Prolog query is True, returns the empty list."))

NDet Result(718): <span class="ansi33"
>(: call-string! (-> String Atom))
</span>$1 = (: call-string! (-> String Atom))

NDet Result(719): <span class="ansi33"
>(iz call-cleanup! MeTTaLog)
</span>$1 = (iz call-cleanup! MeTTaLog)

NDet Result(720): <span class="ansi33"
>(@doc call-cleanup! (@desc "Same as (setup-call-cleanup! true Form Cleanup). setup-call-cleanup! is recommended instead if Cleanup is intended to undo prior side-effects - place those side-effects in Setup.") (@params ((@param "Form") (@param "Cleanup"))) (@return "Result of Form."))
</span>$1 = (@doc call-cleanup! (@desc "Same as (setup-call-cleanup! true Form Cleanup). setup-call-cleanup! is recommended instead if Cleanup is intended to undo prior side-effects - place those side-effects in Setup.") (@params ((@param "Form") (@param "Cleanup"))) (@return "Result of Form."))

NDet Result(721): <span class="ansi33"
>(: call-cleanup! (-> Atom Atom Atom))
</span>$1 = (: call-cleanup! (-> Atom Atom Atom))

NDet Result(722): <span class="ansi33"
>(iz setup-call-cleanup! MeTTaLog)
</span>$1 = (iz setup-call-cleanup! MeTTaLog)

NDet Result(723): <span class="ansi33"
>(@doc setup-call-cleanup! (@desc "Executes Setup, then Form, then finally Cleanup. Setup is protected from interrupts (e.g. max-time!). In most uses, Setup will perform temporary side-effects required by Form that are finally undone by Cleanup. Cleanup is run even if Form raises an exception. For each result of Setup, Form is run to completion, then Cleanup is run.") (@params ((@param "Setup") (@param "Form") (@param "Cleanup"))) (@return "Result of Form."))
</span>$1 = (@doc setup-call-cleanup! (@desc "Executes Setup, then Form, then finally Cleanup. Setup is protected from interrupts (e.g. max-time!). In most uses, Setup will perform temporary side-effects required by Form that are finally undone by Cleanup. Cleanup is run even if Form raises an exception. For each result of Setup, Form is run to completion, then Cleanup is run.") (@params ((@param "Setup") (@param "Form") (@param "Cleanup"))) (@return "Result of Form."))

NDet Result(724): <span class="ansi33"
>(: setup-call-cleanup! (-> Atom Atom Atom Atom))
</span>$1 = (: setup-call-cleanup! (-> Atom Atom Atom Atom))

NDet Result(725): <span class="ansi33"
>(@doc predicate-arity (@desc "Returns the arity of Function's predicate form, i.e. the function-arity + 1. (The additional argument being the function's result as an argument to the predicate.)") (@params ((@param "Function"))) (@return "Arity of Function's predicate form."))
</span>$1 = (@doc predicate-arity (@desc "Returns the arity of Function's predicate form, i.e. the function-arity + 1. (The additional argument being the function's result as an argument to the predicate.)") (@params ((@param "Function"))) (@return "Arity of Function's predicate form."))

NDet Result(726): <span class="ansi33"
>(iz function-arity MeTTaLog)
</span>$1 = (iz function-arity MeTTaLog)

NDet Result(727): <span class="ansi33"
>(@doc function-arity (@desc "Returns the arity of Function.") (@params ((@param "Function"))) (@return "Arity of Function."))
</span>$1 = (@doc function-arity (@desc "Returns the arity of Function.") (@params ((@param "Function"))) (@return "Arity of Function."))

NDet Result(728): <span class="ansi33"
>(iz open! MeTTaLog)
</span>$1 = (iz open! MeTTaLog)

NDet Result(729): <span class="ansi33"
>(@doc open! (@desc "Opens Filename as a stream under Mode. Mode is one of read, write, append, or update. Mode append opens the file for writing, positioning the file pointer at the end. Mode update opens the file for writing, positioning the file pointer at the beginning of the file without truncating the file.") (@params ((@param "Filename") (@param "Mode"))) (@return "Stream"))
</span>$1 = (@doc open! (@desc "Opens Filename as a stream under Mode. Mode is one of read, write, append, or update. Mode append opens the file for writing, positioning the file pointer at the end. Mode update opens the file for writing, positioning the file pointer at the beginning of the file without truncating the file.") (@params ((@param "Filename") (@param "Mode"))) (@return "Stream"))

NDet Result(730): <span class="ansi33"
>(: open! (-> String Atom Stream))
</span>$1 = (: open! (-> String Atom Stream))

NDet Result(731): <span class="ansi33"
>(iz close! MeTTaLog)
</span>$1 = (iz close! MeTTaLog)

NDet Result(732): <span class="ansi33"
>(@doc close! (@desc "Closes Steam, returning True on success.") (@params ((@param "Stream"))) (@return "Boolean"))
</span>$1 = (@doc close! (@desc "Closes Steam, returning True on success.") (@params ((@param "Stream"))) (@return "Boolean"))

NDet Result(733): <span class="ansi33"
>(: close! (-> Stream Boolean))
</span>$1 = (: close! (-> Stream Boolean))

NDet Result(734): <span class="ansi33"
>(iz with-output-to! MeTTaLog)
</span>$1 = (iz with-output-to! MeTTaLog)

NDet Result(735): <span class="ansi33"
>(@doc with-output-to! (@desc "Evaluates expression with all outupt (e.g. from print) redirected to Stream. See also open! and close!.") (@params ((@param "Stream") (@param "Expression"))) (@return "Result of Expression"))
</span>$1 = (@doc with-output-to! (@desc "Evaluates expression with all outupt (e.g. from print) redirected to Stream. See also open! and close!.") (@params ((@param "Stream") (@param "Expression"))) (@return "Result of Expression"))

NDet Result(736): <span class="ansi33"
>(: with-output-to! (-> Stream Expression Atom))
</span>$1 = (: with-output-to! (-> Stream Expression Atom))

NDet Result(737): <span class="ansi33"
>(iz load-file! MeTTaLog)
</span>$1 = (iz load-file! MeTTaLog)

NDet Result(738): <span class="ansi33"
>(@doc load-file! (@desc "Loads the contents of Filename into Space, returning () if successful. Can load Python code (.py) or MeTTa (.metta); if ambiguous, assumes MeTTa. Like import! but favors MeTTa over Python when the file type is ambiguous.") (@params ((@param "Space") (@param "Filename"))) (@return "Expression"))
</span>$1 = (@doc load-file! (@desc "Loads the contents of Filename into Space, returning () if successful. Can load Python code (.py) or MeTTa (.metta); if ambiguous, assumes MeTTa. Like import! but favors MeTTa over Python when the file type is ambiguous.") (@params ((@param "Space") (@param "Filename"))) (@return "Expression"))

NDet Result(739): <span class="ansi33"
>(: load-file! (-> hyperon::space::DynSpace String Expression))
</span>$1 = (: load-file! (-> hyperon::space::DynSpace String Expression))

NDet Result(740): <span class="ansi33"
>(iz load-ascii MeTTa)
</span>$1 = (iz load-ascii MeTTa)

NDet Result(741): <span class="ansi33"
>(@doc load-ascii (@desc "Loads the contents of Filename into Space, returning () if successful. Assumes the file is an ASCII file. Works like include!.") (@params ((@param "Space") (@param "Filename"))) (@return "Expression"))
</span>$1 = (@doc load-ascii (@desc "Loads the contents of Filename into Space, returning () if successful. Assumes the file is an ASCII file. Works like include!.") (@params ((@param "Space") (@param "Filename"))) (@return "Expression"))

NDet Result(742): <span class="ansi33"
>(: load-ascii (-> hyperon::space::DynSpace String Expression))
</span>$1 = (: load-ascii (-> hyperon::space::DynSpace String Expression))

NDet Result(743): <span class="ansi33"
>(iz transfer! MeTTa)
</span>$1 = (iz transfer! MeTTa)

NDet Result(744): <span class="ansi33"
>(@doc transfer! (@desc "Loads the contents of Filename into &self, as include. Returns () if successful, throws an exception otherwise.") (@params ((@param "Filename"))) (@return "Expression"))
</span>$1 = (@doc transfer! (@desc "Loads the contents of Filename into &self, as include. Returns () if successful, throws an exception otherwise.") (@params ((@param "Filename"))) (@return "Expression"))

NDet Result(745): <span class="ansi33"
>(: transfer! (-> String (->)))
</span>$1 = (: transfer! (-> String (->)))

NDet Result(746): <span class="ansi33"
>(iz save-space! MeTTa)
</span>$1 = (iz save-space! MeTTa)

NDet Result(747): <span class="ansi33"
>(@doc save-space! (@desc "Writes the contents of Space into Filename, returning () if successful.") (@params ((@param "Space") (@param "Filename"))) (@return "Expression"))
</span>$1 = (@doc save-space! (@desc "Writes the contents of Space into Filename, returning () if successful.") (@params ((@param "Space") (@param "Filename"))) (@return "Expression"))

NDet Result(748): <span class="ansi33"
>(: save-space! (-> hyperon::space::DynSpace String Expression))
</span>$1 = (: save-space! (-> hyperon::space::DynSpace String Expression))

NDet Result(749): <span class="ansi33"
>(iz rtrace! MeTTaLog)
</span>$1 = (iz rtrace! MeTTaLog)

NDet Result(750): <span class="ansi33"
>(@doc rtrace! (@desc "Fully evaluates input Atom, providing a complete trace of the evaluation.") (@params ((@param "Atom to be evaluated"))) (@return "Result of evaluation"))
</span>$1 = (@doc rtrace! (@desc "Fully evaluates input Atom, providing a complete trace of the evaluation.") (@params ((@param "Atom to be evaluated"))) (@return "Result of evaluation"))

NDet Result(751): <span class="ansi33"
>(: rtrace! (-> Atom Atom))
</span>$1 = (: rtrace! (-> Atom Atom))

NDet Result(752): <span class="ansi33"
>(iz rust MeTTaLog)
</span>$1 = (iz rust MeTTaLog)

NDet Result(753): <span class="ansi33"
>(@doc rust (@desc "Interface with the rust / Hyperon MeTTa implementation. Enters Atom into rust atomspace. If Atom is evaluated (i.e. by being of the form !<atom>), returns the result of evaluation. See also rust!.") (@params ((@param "Atom to be entered into the space"))) (@return "Result of entering Atom into the space"))
</span>$1 = (@doc rust (@desc "Interface with the rust / Hyperon MeTTa implementation. Enters Atom into rust atomspace. If Atom is evaluated (i.e. by being of the form !<atom>), returns the result of evaluation. See also rust!.") (@params ((@param "Atom to be entered into the space"))) (@return "Result of entering Atom into the space"))

NDet Result(754): <span class="ansi33"
>(: rust (-> Atom Atom))
</span>$1 = (: rust (-> Atom Atom))

NDet Result(755): <span class="ansi33"
>(iz rust! MeTTaLog)
</span>$1 = (iz rust! MeTTaLog)

NDet Result(756): <span class="ansi33"
>(@doc rust! (@desc "Like rust but evaluates the atom rather than entering into the space. (rust! <atom>) and (rust !<atom>) are identical.") (@params ((@param "Atom to be evaluated"))) (@return "Result of evaluation"))
</span>$1 = (@doc rust! (@desc "Like rust but evaluates the atom rather than entering into the space. (rust! <atom>) and (rust !<atom>) are identical.") (@params ((@param "Atom to be evaluated"))) (@return "Result of evaluation"))

NDet Result(757): <span class="ansi33"
>(: rust! (-> Atom Atom))
</span>$1 = (: rust! (-> Atom Atom))

NDet Result(758): <span class="ansi33"
>(iz coerce MeTTaLog)
</span>$1 = (iz coerce MeTTaLog)

NDet Result(759): <span class="ansi33"
>(@doc coerce (@desc "Cast (coerce) Value to be of Type. Supports the basic types Atom (no-op), Number, String, and Bool.\n  Number: Converts number strings and bools to numbers. True is 1, False is 0.\n  String: Coerced as if Value were printed.\n  Bool: False, 0, and () are False, all other values are True.") (@params ((@param "Type") (@param "Value"))) (@return "Value cast to Type"))
</span>$1 = (@doc coerce (@desc "Cast (coerce) Value to be of Type. Supports the basic types Atom (no-op), Number, String, and Bool.\n  Number: Converts number strings and bools to numbers. True is 1, False is 0.\n  String: Coerced as if Value were printed.\n  Bool: False, 0, and () are False, all other values are True.") (@params ((@param "Type") (@param "Value"))) (@return "Value cast to Type"))

NDet Result(760): <span class="ansi33"
>(: coerce (-> Type Atom Atom))
</span>$1 = (: coerce (-> Type Atom Atom))

NDet Result(761): <span class="ansi33"
>(is-fn-1 sqrt sqrt)
</span>$1 = (is-fn-1 sqrt sqrt)

NDet Result(762): <span class="ansi33"
>(is-fn-1 abs abs)
</span>$1 = (is-fn-1 abs abs)

NDet Result(763): <span class="ansi33"
>(is-fn-1 trunc trunc)
</span>$1 = (is-fn-1 trunc trunc)

NDet Result(764): <span class="ansi33"
>(is-fn-1 ceil ceil)
</span>$1 = (is-fn-1 ceil ceil)

NDet Result(765): <span class="ansi33"
>(is-fn-1 floor floor)
</span>$1 = (is-fn-1 floor floor)

NDet Result(766): <span class="ansi33"
>(is-fn-1 round round)
</span>$1 = (is-fn-1 round round)

NDet Result(767): <span class="ansi33"
>(is-fn-1 sin sin)
</span>$1 = (is-fn-1 sin sin)

NDet Result(768): <span class="ansi33"
>(is-fn-1 asin asin)
</span>$1 = (is-fn-1 asin asin)

NDet Result(769): <span class="ansi33"
>(is-fn-1 cos cos)
</span>$1 = (is-fn-1 cos cos)

NDet Result(770): <span class="ansi33"
>(is-fn-1 acos acos)
</span>$1 = (is-fn-1 acos acos)

NDet Result(771): <span class="ansi33"
>(is-fn-1 tan tan)
</span>$1 = (is-fn-1 tan tan)

NDet Result(772): <span class="ansi33"
>(is-fn-1 atan atan)
</span>$1 = (is-fn-1 atan atan)

NDet Result(773): <span class="ansi33"
>(: sqrt (-> Number Number))
</span>$1 = (: sqrt (-> Number Number))

NDet Result(774): <span class="ansi33"
>(: abs (-> Number Number))
</span>$1 = (: abs (-> Number Number))

NDet Result(775): <span class="ansi33"
>(: trunc (-> Number Number))
</span>$1 = (: trunc (-> Number Number))

NDet Result(776): <span class="ansi33"
>(: ceil (-> Number Number))
</span>$1 = (: ceil (-> Number Number))

NDet Result(777): <span class="ansi33"
>(: floor (-> Number Number))
</span>$1 = (: floor (-> Number Number))

NDet Result(778): <span class="ansi33"
>(: round (-> Number Number))
</span>$1 = (: round (-> Number Number))

NDet Result(779): <span class="ansi33"
>(: sin (-> Number Number))
</span>$1 = (: sin (-> Number Number))

NDet Result(780): <span class="ansi33"
>(: asin (-> Number Number))
</span>$1 = (: asin (-> Number Number))

NDet Result(781): <span class="ansi33"
>(: cos (-> Number Number))
</span>$1 = (: cos (-> Number Number))

NDet Result(782): <span class="ansi33"
>(: acos (-> Number Number))
</span>$1 = (: acos (-> Number Number))

NDet Result(783): <span class="ansi33"
>(: tan (-> Number Number))
</span>$1 = (: tan (-> Number Number))

NDet Result(784): <span class="ansi33"
>(: atan (-> Number Number))
</span>$1 = (: atan (-> Number Number))

NDet Result(785): <span class="ansi33"
>(is-fn-2 powf pow)
</span>$1 = (is-fn-2 powf pow)

NDet Result(786): <span class="ansi33"
>(is-fn-2 pow pow)
</span>$1 = (is-fn-2 pow pow)

NDet Result(787): <span class="ansi33"
>(is-fn-2 log log2)
</span>$1 = (is-fn-2 log log2)

NDet Result(788): <span class="ansi33"
>(is-fn-2 random-int random)
</span>$1 = (is-fn-2 random-int random)

NDet Result(789): <span class="ansi33"
>(: powf (-> Number Number Number))
</span>$1 = (: powf (-> Number Number Number))

NDet Result(790): <span class="ansi33"
>(: pow (-> Number Number Number))
</span>$1 = (: pow (-> Number Number Number))

NDet Result(791): <span class="ansi33"
>(: log (-> Number Number Number))
</span>$1 = (: log (-> Number Number Number))

NDet Result(792): <span class="ansi33"
>(: random-int (-> Number Number Number))
</span>$1 = (: random-int (-> Number Number Number))

NDet Result(793): <span class="ansi33"
>(is-pred-1 isnan is_NaN)
</span>$1 = (is-pred-1 isnan is_NaN)

NDet Result(794): <span class="ansi33"
>(is-pred-1 isinf is_Inf)
</span>$1 = (is-pred-1 isinf is_Inf)

NDet Result(795): <span class="ansi33"
>(: isnan (-> Number Bool))
</span>$1 = (: isnan (-> Number Bool))

NDet Result(796): <span class="ansi33"
>(: isinf (-> Number Bool))
</span>$1 = (: isinf (-> Number Bool))

NDet Result(797): <span class="ansi33"
>(= (max-atom $10000)  
  (call-fn! max_list $10000))
</span>$1 = (= (max-atom $10000)  
  (call-fn! max_list $10000))

NDet Result(798): <span class="ansi33"
>(= (size-atom $10000)  
  (call-fn! length $10000))
</span>$1 = (= (size-atom $10000)  
  (call-fn! length $10000))

NDet Result(799): <span class="ansi33"
>(= (py-list $10000)  
  (call-fn! py_list $10000))
</span>$1 = (= (py-list $10000)  
  (call-fn! py_list $10000))

NDet Result(800): <span class="ansi33"
>(= (sqrt $10000)  
  (call-fn! sqrt $10000))
</span>$1 = (= (sqrt $10000)  
  (call-fn! sqrt $10000))

NDet Result(801): <span class="ansi33"
>(= (abs $10000)  
  (call-fn! abs $10000))
</span>$1 = (= (abs $10000)  
  (call-fn! abs $10000))

NDet Result(802): <span class="ansi33"
>(= (trunc $10000)  
  (call-fn! trunc $10000))
</span>$1 = (= (trunc $10000)  
  (call-fn! trunc $10000))

NDet Result(803): <span class="ansi33"
>(= (ceil $10000)  
  (call-fn! ceil $10000))
</span>$1 = (= (ceil $10000)  
  (call-fn! ceil $10000))

NDet Result(804): <span class="ansi33"
>(= (floor $10000)  
  (call-fn! floor $10000))
</span>$1 = (= (floor $10000)  
  (call-fn! floor $10000))

NDet Result(805): <span class="ansi33"
>(= (round $10000)  
  (call-fn! round $10000))
</span>$1 = (= (round $10000)  
  (call-fn! round $10000))

NDet Result(806): <span class="ansi33"
>(= (sin $10000)  
  (call-fn! sin $10000))
</span>$1 = (= (sin $10000)  
  (call-fn! sin $10000))

NDet Result(807): <span class="ansi33"
>(= (asin $10000)  
  (call-fn! asin $10000))
</span>$1 = (= (asin $10000)  
  (call-fn! asin $10000))

NDet Result(808): <span class="ansi33"
>(= (cos $10000)  
  (call-fn! cos $10000))
</span>$1 = (= (cos $10000)  
  (call-fn! cos $10000))

NDet Result(809): <span class="ansi33"
>(= (acos $10000)  
  (call-fn! acos $10000))
</span>$1 = (= (acos $10000)  
  (call-fn! acos $10000))

NDet Result(810): <span class="ansi33"
>(= (tan $10000)  
  (call-fn! tan $10000))
</span>$1 = (= (tan $10000)  
  (call-fn! tan $10000))

NDet Result(811): <span class="ansi33"
>(= (atan $10000)  
  (call-fn! atan $10000))
</span>$1 = (= (atan $10000)  
  (call-fn! atan $10000))

NDet Result(812): <span class="ansi33"
>(= (powf $10000 $10001)  
  (call-fn! pow $10000 $10001))
</span>$1 = (= (powf $10000 $10001)  
  (call-fn! pow $10000 $10001))

NDet Result(813): <span class="ansi33"
>(= (pow $10000 $10001)  
  (call-fn! pow $10000 $10001))
</span>$1 = (= (pow $10000 $10001)  
  (call-fn! pow $10000 $10001))

NDet Result(814): <span class="ansi33"
>(= (log $10000 $10001)  
  (call-fn! log2 $10000 $10001))
</span>$1 = (= (log $10000 $10001)  
  (call-fn! log2 $10000 $10001))

NDet Result(815): <span class="ansi33"
>(= (random-int $10000 $10001)  
  (call-fn! random $10000 $10001))
</span>$1 = (= (random-int $10000 $10001)  
  (call-fn! random $10000 $10001))

NDet Result(816): <span class="ansi33"
>(= (index-atom $10000 $10001)  
  (call-fn! nth0 $10001 $10000))
</span>$1 = (= (index-atom $10000 $10001)  
  (call-fn! nth0 $10001 $10000))

NDet Result(817): <span class="ansi33"
>(= (isnan $10000)  
  (call-p! is_NaN $10000))
</span>$1 = (= (isnan $10000)  
  (call-p! is_NaN $10000))

Last Result(818): <span class="ansi33"
>(= (isinf $10000)  
  (call-p! is_Inf $10000))
</span>$1 = (= (isinf $10000)  
  (call-p! is_Inf $10000))
<span class="ansi38-013099040"
>!(get-atoms &self)

</span>
NDet Result(1): <span class="ansi33"
>&corelib
</span>
NDet Result(2): <span class="ansi33"
>&stdlib
</span>
NDet Result(3): <span class="ansi33"
>(= (Rel-P P P P)  10)
</span>
NDet Result(4): <span class="ansi33"
>(Rel-P A B)
</span>
NDet Result(5): <span class="ansi33"
>(Rel-Q A C)
</span>
NDet Result(6): <span class="ansi33"
>(@doc Any (@desc "The universal type; any value belongs to this type."))
</span>
NDet Result(7): <span class="ansi33"
>(: Any Type)
</span>
NDet Result(8): <span class="ansi33"
>(@doc Atom (@desc "Type representing any atom."))
</span>
NDet Result(9): <span class="ansi33"
>(: Atom Type)
</span>
NDet Result(10): <span class="ansi33"
>(@doc LazyEvaluatable (@desc "A type of Atom/Value that hyperon does not implicitly evaluate"))
</span>
NDet Result(11): <span class="ansi33"
>(: LazyEvaluatable Type)
</span>
NDet Result(12): <span class="ansi33"
>(:> Atom LazyEvaluatable)
</span>
NDet Result(13): <span class="ansi33"
>(@doc Bool (@desc "Boolean type of True or False."))
</span>
NDet Result(14): <span class="ansi33"
>(: Bool Type)
</span>
NDet Result(15): <span class="ansi33"
>(@doc LazyBool (@desc "A LazyEvaluatable that when evaluated returns True or False."))
</span>
NDet Result(16): <span class="ansi33"
>(: LazyBool Type)
</span>
NDet Result(17): <span class="ansi33"
>(:> LazyBool LazyEvaluatable)
</span>
NDet Result(18): <span class="ansi33"
>(@doc Expression (@desc "Type representing an S-Expression, which is a combination of atoms."))
</span>
NDet Result(19): <span class="ansi33"
>(: Expression Type)
</span>
NDet Result(20): <span class="ansi33"
>(:> Expression LazyEvaluatable)
</span>
NDet Result(21): <span class="ansi33"
>(@doc Number (@desc "Numeric type, including integers and floating-point numbers."))
</span>
NDet Result(22): <span class="ansi33"
>(: Number Type)
</span>
NDet Result(23): <span class="ansi33"
>(@doc hyperon::space::DynSpace (@desc "Dynamic space type, representing an Atomspace."))
</span>
NDet Result(24): <span class="ansi33"
>(: hyperon::space::DynSpace Type)
</span>
NDet Result(25): <span class="ansi33"
>(@doc ReturnType (@desc "Type representing a function's return value."))
</span>
NDet Result(26): <span class="ansi33"
>(: ReturnType Type)
</span>
NDet Result(27): <span class="ansi33"
>(@doc Symbol (@desc "Type representing a symbol or identifier."))
</span>
NDet Result(28): <span class="ansi33"
>(: Symbol Type)
</span>
NDet Result(29): <span class="ansi33"
>(@doc StateMonad (@desc "Type representing a state monad, used for encapsulating stateful computations."))
</span>
NDet Result(30): <span class="ansi33"
>(: StateMonad Type)
</span>
NDet Result(31): <span class="ansi33"
>(@doc Type (@desc "Type representing a type."))
</span>
NDet Result(32): <span class="ansi33"
>(: Type Type)
</span>
NDet Result(33): <span class="ansi33"
>(@doc True (@desc "Boolean value representing truth."))
</span>
NDet Result(34): <span class="ansi33"
>(: True Bool)
</span>
NDet Result(35): <span class="ansi33"
>(@doc False (@desc "Boolean value representing falsehood."))
</span>
NDet Result(36): <span class="ansi33"
>(: False Bool)
</span>
NDet Result(37): <span class="ansi33"
>(@doc %Undefined% (@desc "Special type representing an undefined value or type."))
</span>
NDet Result(38): <span class="ansi33"
>(: %Undefined% Type)
</span>
NDet Result(39): <span class="ansi33"
>(@doc Variable (@desc "Type representing a variable in the language."))
</span>
NDet Result(40): <span class="ansi33"
>(: Variable Type)
</span>
NDet Result(41): <span class="ansi33"
>(@doc : (@desc "Type declarion operator"))
</span>
NDet Result(42): <span class="ansi33"
>(@doc <: (@desc "Super Type declarion operator"))
</span>
NDet Result(43): <span class="ansi33"
>(: : %Undefined%)
</span>
NDet Result(44): <span class="ansi33"
>(: if-empty (-> Atom Atom Atom Atom))
</span>
NDet Result(45): <span class="ansi33"
>(: if-non-empty-expression (-> Atom Atom Atom Atom))
</span>
NDet Result(46): <span class="ansi33"
>(: if-not-reducible (-> Atom Atom Atom Atom))
</span>
NDet Result(47): <span class="ansi33"
>(: return (-> Atom ReturnType))
</span>
NDet Result(48): <span class="ansi33"
>(: switch (-> %Undefined% Expression Atom))
</span>
NDet Result(49): <span class="ansi33"
>(: unify (-> Atom Atom Atom Atom %Undefined%))
</span>
NDet Result(50): <span class="ansi33"
>(: get-type (-> Atom Type))
</span>
NDet Result(51): <span class="ansi33"
>(: get-type0 (-> Atom Atom))
</span>
NDet Result(52): <span class="ansi33"
>(: get-ftype (-> Atom Atom))
</span>
NDet Result(53): <span class="ansi33"
>(: pragma! (-> Atom Atom (->)))
</span>
NDet Result(54): <span class="ansi33"
>(: = (-> Atom Atom %Undefined%))
</span>
NDet Result(55): <span class="ansi33"
>(: match (-> hyperon::space::DynSpace Atom Atom %Undefined%))
</span>
NDet Result(56): <span class="ansi33"
>(: case (-> Expression Atom Atom))
</span>
NDet Result(57): <span class="ansi33"
>(: combine (-> $10000 $10000 $10000))
</span>
NDet Result(58): <span class="ansi33"
>(: import! (-> hyperon::space::DynSpace Atom (->)))
</span>
NDet Result(59): <span class="ansi33"
>(: If (-> Bool Atom Atom Atom))
</span>
NDet Result(60): <span class="ansi33"
>(: If (-> Bool Atom Atom))
</span>
NDet Result(61): <span class="ansi33"
>(= (If True $10000)  $10000)
</span>
NDet Result(62): <span class="ansi33"
>(= (If False $10000)  
  (let $10001 0 
    (let $10001 1 $10001)))
</span>
NDet Result(63): <span class="ansi33"
>(= (If $10000 $10001 $10002)  
  (if $10000 $10001 $10002))
</span>
NDet Result(64): <span class="ansi33"
>(iz predicate-arity MeTTaLog)
</span>
NDet Result(65): <span class="ansi33"
>(@doc predicate-arity (@desc "Specifies the arity (number of arguments) for a given predicate, allowing it to be queriable in the system's match framework. This is particularly useful for enabling built-in functions, such as `size-atom`, to be used as predicates in declarative contexts and run in reverse to compute inputs based on outputs.\n\n\nFor example:\n  ; Enable the built-in function `size-atom` that takes an atom and returns the size\n    as a predicate with arity 2\n  (predicate-arity size-atom 2)\n\n\n  ; Now `size-atom` can be used as a predicate in pattern matching\n  !(match &dyn-space '(size-atom (a b c) $size) \n         (The abc tuple was len $size))\n  ; This pattern will resolve `Size = 3` and execute the action.\n\n\nAdditionally, by running `size-atom` in reverse, you can compute a new atom based on a desired size:\n  !(match &dyn-space '(size-atom $new-atom 4) \n         (The new atom is $new-atom))\n  ; This resolves `$new-atom` to a tuple of size 4, such as ($1 $2 $3 $4).\n\n\nThis reverse functionality is made possible because predicates can describe relationships, allowing you to infer inputs from outputs.") (@params ((@param "Predicate symbol" "The name of the predicate whose arity is being defined."))) (@return "The number of arguments required for the predicate."))
</span>
NDet Result(66): <span class="ansi33"
>(: predicate-arity (-> Symbol Number))
</span>
NDet Result(67): <span class="ansi33"
>(predicate-arity predicate-arity 2)
</span>
NDet Result(68): <span class="ansi33"
>(function-arity predicate-arity 1)
</span>
NDet Result(69): <span class="ansi33"
>(@doc function-arity (@desc "Defines the arity of a function, allowing predicates or built-in facts to also behave as callable functions. This enables procedural-style execution where the last argument of the predicate becomes the function's return value, and the system internally resolves the function using a `match` query. \n\n\nFor example:\n  ; Declare the built-in predicate `max` with arity 3\n  (predicate-arity max 3)\n\n  ; Enable `max` as a function\n  (function-arity max 2)\n\n\n  ; Define the rules for `max`\n  (= (max $X $Y $Y) (<= $X $Y))\n  (= (max $X $Y $X) (> $X $Y))\n\n\n  ; Using `max` declaratively as a predicate\n  !(match &self (max (5 10) $max)\n         (The maximum is $max))\n  [(The maximum is 10)]\n\n\n  ; Using `max` procedurally as a function\n  !(max 5 10)\n  [10]\n  \n\n\n  ; Reverse execution with `max`\n  !(let True (== (max $a $b) 10) ($a $b)) ; as a function\n  [(#(exists $a (=< $a 10)) 10), (10 #(exists $b (=< 10 $b )))]\n  !(match &self (max $a $b 10) ($a $b)) ; or as a predicate\n  [(#(exists $a (=< $a 10)) 10), (10 #(exists $b (=< 10 $b )))]\n\n\n  This dual behavior allows predicates to act as functions, bridging procedural and declarative paradigms. By defining `function-arity`, the function automatically resolves using the logic of the associated predicate.") (@params ((@param "Function symbol" "The name of the function or predicate to enable as a callable function."))) (@return "The number of arguments expected by the function."))
</span>
NDet Result(70): <span class="ansi33"
>(: function-arity (-> Symbol Number))
</span>
NDet Result(71): <span class="ansi33"
>(predicate-arity function-arity 2)
</span>
NDet Result(72): <span class="ansi33"
>(function-arity function-arity 1)
</span>
NDet Result(73): <span class="ansi33"
>(iz If MeTTa)
</span>
NDet Result(74): <span class="ansi33"
>(@doc If (@desc "Conditional function that evaluates and returns one of the provided atoms based on a boolean condition.") (@params ((@param "Boolean condition") (@param "Atom to return if condition is True") (@param "Atom to return if condition is False (optional)"))) (@return "Either the second or third argument depending on the condition"))
</span>
NDet Result(75): <span class="ansi33"
>(predicate-arity : 2)
</span>
NDet Result(76): <span class="ansi33"
>(= (: $10000 P1)  
  (predicate-arity $10000 1))
</span>
NDet Result(77): <span class="ansi33"
>(iz SrcPredicate MeTTa)
</span>
NDet Result(78): <span class="ansi33"
>(@doc SrcPredicate (@desc "Type representing a source predicate."))
</span>
NDet Result(79): <span class="ansi33"
>(: SrcPredicate Type)
</span>
NDet Result(80): <span class="ansi33"
>(iz SrcFunction MeTTa)
</span>
NDet Result(81): <span class="ansi33"
>(@doc SrcFunction (@desc "Type representing a source function."))
</span>
NDet Result(82): <span class="ansi33"
>(: SrcFunction Type)
</span>
NDet Result(83): <span class="ansi33"
>(iz MeTTaResult MeTTa)
</span>
NDet Result(84): <span class="ansi33"
>(@doc MeTTaResult (@desc "Type representing the result of a MeTTa evaluation."))
</span>
NDet Result(85): <span class="ansi33"
>(: MeTTaResult Type)
</span>
NDet Result(86): <span class="ansi33"
>(iz NotReducible MeTTaResult)
</span>
NDet Result(87): <span class="ansi33"
>(@doc NotReducible (@desc "Result indicating that an atom cannot be reduced further."))
</span>
NDet Result(88): <span class="ansi33"
>(: NotReducible MeTTaResult)
</span>
NDet Result(89): <span class="ansi33"
>Empty
</span>
NDet Result(90): <span class="ansi33"
>Empty
</span>
NDet Result(91): <span class="ansi33"
>Empty
</span>
NDet Result(92): <span class="ansi33"
>(iz ValueAtom MeTTa)
</span>
NDet Result(93): <span class="ansi33"
>(@doc ValueAtom (@desc "Type representing a value atom."))
</span>
NDet Result(94): <span class="ansi33"
>(:> ValueAtom Atom)
</span>
NDet Result(95): <span class="ansi33"
>(iz ForeignObject MeTTa)
</span>
NDet Result(96): <span class="ansi33"
>(@doc ForeignObject (@desc "Type representing a foreign object, such as a Python object."))
</span>
NDet Result(97): <span class="ansi33"
>(: ForeignObject Type)
</span>
NDet Result(98): <span class="ansi33"
>(:> ValueAtom Grounded)
</span>
NDet Result(99): <span class="ansi33"
>(:> ForeignObject ValueAtom)
</span>
NDet Result(100): <span class="ansi33"
>(iz PyObject MeTTa)
</span>
NDet Result(101): <span class="ansi33"
>(@doc PyObject (@desc "Type representing a Python object."))
</span>
NDet Result(102): <span class="ansi33"
>(:> PyObject ForeignObject)
</span>
NDet Result(103): <span class="ansi33"
>(:> hyperon::space::DynSpace Grounded)
</span>
NDet Result(104): <span class="ansi33"
>(iz py-list MeTTa)
</span>
NDet Result(105): <span class="ansi33"
>(@doc py-list (@desc "Converts a MeTTa Expression into a Python list and returns it as a PyObject.") (@params ((@param (@desc "A MeTTa List that will be converted into a Python list")))) (@return (@desc "A Python list object that represents the given MeTTa Expression as a PyObject")))
</span>
NDet Result(106): <span class="ansi33"
>(: py-list (-> Expression PyObject))
</span>
NDet Result(107): <span class="ansi33"
>(iz py-chain MeTTa)
</span>
NDet Result(108): <span class="ansi33"
>(@doc py-chain (@desc "Chains together a list of Python objects contained in a MeTTa Expression, applying the Python vertical bar | OR operation jointly to all elements.") (@params ((@param (@desc "A MeTTa list of atoms, each embedding a Python object.")))) (@return (@desc "A MeTTa atom which embeds the result of applying the Python OR | operator to all elements of the list.")))
</span>
NDet Result(109): <span class="ansi33"
>(: py-chain (-> Expression PyObject))
</span>
NDet Result(110): <span class="ansi33"
>(iz py-eval MeTTaLog)
</span>
NDet Result(111): <span class="ansi33"
>(@doc py-eval (@desc "Evaluates a Python expression from a string and returns the result as a PyObject.") (@params ((@param (@desc "A string representing a Python expression that will be evaluated")))) (@return (@desc "The result of evaluating the Python expression as a PyObject")))
</span>
NDet Result(112): <span class="ansi33"
>(: py-eval (-> String PyObject))
</span>
NDet Result(113): <span class="ansi33"
>(iz py-exec! MeTTaLog)
</span>
NDet Result(114): <span class="ansi33"
>(@doc py-exec! (@desc "Executes some Python sourcecode from a string !(py-exec! \"import torch\") -> True.  !(py-exec! \"import torche\") -> False. ") (@params ((@param (@type String) (@desc "A string representing a Python sourcecode that will be executed")))) (@return (@desc "The True|False results of executing the Python expression")))
</span>
NDet Result(115): <span class="ansi33"
>(: py-exec! (-> String Bool))
</span>
NDet Result(116): <span class="ansi33"
>(iz = MeTTa)
</span>
NDet Result(117): <span class="ansi33"
>(@doc = (@desc "A symbol used to define reduction rules for expressions.") (@params ((@param "Pattern to be matched against expression to be reduced") (@param "Result of reduction or transformation of the first pattern"))) (@return "Not reduced itself unless custom equalities over equalities are added"))
</span>
NDet Result(118): <span class="ansi33"
>(: = (-> $10000 $10000 Atom))
</span>
NDet Result(119): <span class="ansi33"
>(: = (-> Atom Atom Atom))
</span>
NDet Result(120): <span class="ansi33"
>(iz ErrorType MeTTa)
</span>
NDet Result(121): <span class="ansi33"
>(@doc ErrorType (@desc "Type of the atom which contains error"))
</span>
NDet Result(122): <span class="ansi33"
>(: ErrorType Type)
</span>
NDet Result(123): <span class="ansi33"
>(iz Error MeTTa)
</span>
NDet Result(124): <span class="ansi33"
>(@doc Error (@desc "Error constructor") (@params ((@param "Atom which contains error") (@param "Error message, can be one of the reserved symbols: BadType, IncorrectNumberOfArguments"))) (@return "Instance of the error atom"))
</span>
NDet Result(125): <span class="ansi33"
>(: Error (-> Atom Atom ErrorType))
</span>
NDet Result(126): <span class="ansi33"
>(iz return MinimalMeTTa)
</span>
NDet Result(127): <span class="ansi33"
>(@doc return (@desc "Returns value from the (function ...) expression") (@params ((@param "Value to be returned"))) (@return "Passed argument"))
</span>
NDet Result(128): <span class="ansi33"
>(: return (-> $10000 $10000))
</span>
NDet Result(129): <span class="ansi33"
>(iz function MinimalMeTTa)
</span>
NDet Result(130): <span class="ansi33"
>(@doc function (@desc "Evaluates the argument until it becomes (return <result>). Then (function (return <result>)) is reduced to the <result>.") (@params ((@param "Atom to be evaluated"))) (@return "Result of atom's evaluation"))
</span>
NDet Result(131): <span class="ansi33"
>(: function (-> Atom Atom))
</span>
NDet Result(132): <span class="ansi33"
>(iz eval MinimalMeTTa)
</span>
NDet Result(133): <span class="ansi33"
>(@doc eval (@desc "Evaluates input Atom, performs one step of the evaluation. Empty results (Empty, ()) are removed from the result set. If no results are produced for a non-grounded function, eval returns NotReducible.") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function"))) (@return "Result of evaluation"))
</span>
NDet Result(134): <span class="ansi33"
>(: eval (-> Atom Atom))
</span>
NDet Result(135): <span class="ansi33"
>(@doc evalc (@desc "Evaluates input atom, makes one step of the evaluation") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function") (@param "Space to evaluate atom in its context"))) (@return "Result of evaluation"))
</span>
NDet Result(136): <span class="ansi33"
>(: evalc (-> Atom Grounded Atom))
</span>
NDet Result(137): <span class="ansi33"
>(iz chain MinimalMeTTa)
</span>
NDet Result(138): <span class="ansi33"
>(@doc chain (@desc "Evaluates first argument Atom, binds it to the Variable (second argument) and then evaluates third argument Template with Variable substituted in. When evaluation of the first Atom brings more than a single result, chain returns one instance of the Template expression for each result. The first argument Atom is only evaluated if it is part of the Minimal MeTTa specification; evaluation of non-Minimal MeTTa atoms can be controlled by wrapping in a call to eval (for one evaluation step) or metta (for full evaluation).") (@params ((@param "Atom to be evaluated") (@param "Variable") (@param "Template which will be evaluated at the end with Variable substituted"))) (@return "Result of evaluating third input argument"))
</span>
NDet Result(139): <span class="ansi33"
>(: chain (-> Atom Variable Atom Atom))
</span>
NDet Result(140): <span class="ansi33"
>(iz unify MeTTa)
</span>
NDet Result(141): <span class="ansi33"
>(@doc unify (@desc "Like Match but allows any sort of container for the first argument. (Match only allows MeTTa spaces.)") (@params ((@param "The collection or space to match") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when found or fourth one otherwise"))
</span>
NDet Result(142): <span class="ansi33"
>(: unify (-> Atom Atom Atom Atom Atom))
</span>
NDet Result(143): <span class="ansi33"
>(iz if-unify MinimalMeTTaHelper)
</span>
NDet Result(144): <span class="ansi33"
>(@doc if-unify (@desc "Matches two first terms and returns third argument if they are matched and fourth argument otherwise") (@params ((@param "First term to unify with") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when first two atoms are unifiable or fourth one otherwise"))
</span>
NDet Result(145): <span class="ansi33"
>(: if-unify (-> Atom Atom Atom Atom %Undefined%))
</span>
NDet Result(146): <span class="ansi33"
>(ALT= $10000 $10000)
</span>
#(failed #( : user once ) #( : user #(if_or_else #(eval = $10000 498 &self (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003) #(call eval (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003)) ))


#(on_mettalog_error #(failed #( : user once ) #( : user #(if_or_else #(eval = $10000 498 &self (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003) #(call eval (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003)) )))

^  <span class="ansi1 ansi32"
>Call: </span>(249) [user] call(user:once, user:if_or_else(eval(=, _416824, 498, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130), call(eval, [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130)))
^  <span class="ansi1 ansi32"
>Call: </span>(250) [user] once(user:if_or_else(eval(=, _416824, 498, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130), call(eval, [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130)))
   <span class="ansi1 ansi32"
>Call: </span>(251) [user] if_or_else(eval(=, _416824, 498, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130), call(eval, [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130))
^  <span class="ansi1 ansi32"
>Call: </span>(252) [user] eval(=, _416824, 498, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130)
^  <span class="ansi1 ansi32"
>Call: </span>(253) [user] catch_metta_return(eval_args(=, _416824, 498, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130), _420130)
^  <span class="ansi1 ansi32"
>Call: </span>(255) [user] eval_args(=, _416824, 498, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130)
   <span class="ansi1 ansi32"
>Call: </span>(256) [system] var([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Call: </span>(257) [system] setup_call_cleanup('$notrace'(_438204, _438206), once(user:self_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])), '$restore_trace'(_438204, _438206))
^  <span class="ansi1 ansi32"
>Call: </span>(258) [system] sig_atomic(system:'$notrace'(_438204, _438206))
^  <span class="ansi1 ansi32"
>Call: </span>(257) [system] setup_call_cleanup('$notrace'(_440116, _440118), once(user:nonvar(_420130)), '$restore_trace'(_440116, _440118))
^  <span class="ansi1 ansi32"
>Call: </span>(258) [system] sig_atomic(system:'$notrace'(_440116, _440118))
^  <span class="ansi1 ansi32"
>Call: </span>(257) [system] setup_call_cleanup('$notrace'(_442028, _442030), once(user:nonvar(_420130)), '$restore_trace'(_442028, _442030))
^  <span class="ansi1 ansi32"
>Call: </span>(258) [system] sig_atomic(system:'$notrace'(_442028, _442030))
   <span class="ansi1 ansi32"
>Call: </span>(256) [system] [['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(256) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(256) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(256) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(256) [user] self_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Call: </span>(258) [system] setup_call_cleanup('$notrace'(_448568, _448570), once(user:self_eval0([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])), '$restore_trace'(_448568, _448570))
^  <span class="ansi1 ansi32"
>Call: </span>(259) [system] sig_atomic(system:'$notrace'(_448568, _448570))
^  <span class="ansi1 ansi31"
>Fail: </span>(256) [user] self_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Call: </span>(256) [user] eval_00(=, _416824, 498, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130)
^  <span class="ansi1 ansi32"
>Call: </span>(257) [user] self_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Call: </span>(259) [system] setup_call_cleanup('$notrace'(_453272, _453274), once(user:self_eval0([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])), '$restore_trace'(_453272, _453274))
^  <span class="ansi1 ansi32"
>Call: </span>(260) [system] sig_atomic(system:'$notrace'(_453272, _453274))
^  <span class="ansi1 ansi31"
>Fail: </span>(257) [user] self_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Call: </span>(257) [user] eval_01(=, _416824, 498, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130)
   <span class="ansi1 ansi32"
>Call: </span>(258) [system] [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(258) [system] [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(258) [user] if_t((498<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(260) [system] 498<1
   <span class="ansi1 ansi31"
>Fail: </span>(260) [system] 498<1
^  <span class="ansi1 ansi32"
>Exit: </span>(258) [user] if_t((498<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(259) [system] setup_call_cleanup('$notrace'(_462666, _462668), once(user:(_462642 is 498-1, copy_term([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _462656))), '$restore_trace'(_462666, _462668))
^  <span class="ansi1 ansi32"
>Call: </span>(260) [system] sig_atomic(system:'$notrace'(_462666, _462668))
^  <span class="ansi1 ansi32"
>Exit: </span>(259) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(497 is 498-1, copy_term([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], [case, ['if-unify-or-empty', _464588, _464588], [['Empty', _464618]]]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(258) [user] trace_eval(eval_20(=, _416824), e, 497, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _465566)
^  <span class="ansi1 ansi32"
>Call: </span>(259) [user] must_det_ll((notrace((flag(eval_num, _466532, _466532+1), _466550 is _466532 mod 500, _466568 is 99-497 mod 100, _466592=_466594, option_else('trace-length', _466606, 500), option_else('trace-depth', _466614, 30))), quietly(if_t((nop(stop_rtrace), _466550>_466606), (set_debug(eval, false), _466670 is _466606+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_466670])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_466722)))))
^  <span class="ansi1 ansi32"
>Call: </span>(260) [user] once(user:(notrace((flag(eval_num, _466532, _466532+1), _466550 is _466532 mod 500, _466568 is 99-497 mod 100, _466592=_466594, option_else('trace-length', _466606, 500), option_else('trace-depth', _466614, 30))), quietly(if_t((nop(stop_rtrace), _466550>_466606), (set_debug(eval, false), _466670 is _466606+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_466670])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_466722)))))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [system] setup_call_cleanup('$notrace'(_468592, _468594), once(user:(flag(eval_num, _466532, _466532+1), _466550 is _466532 mod 500, _466568 is 99-497 mod 100, _466592=_466594, option_else('trace-length', _466606, 500), option_else('trace-depth', _466614, 30))), '$restore_trace'(_468592, _468594))
^  <span class="ansi1 ansi32"
>Call: </span>(264) [system] sig_atomic(system:'$notrace'(_468592, _468594))
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 14, 14+1), 14 is 14 mod 500, 2 is 99-497 mod 100, _466592=_466592, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 14>500), (set_debug(eval, false), _466670 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_466670])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 14>500), (set_debug(eval, false), _466670 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_466670])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(262) [user] nop(notrace(no_repeats_var(_466722)))
   <span class="ansi1 ansi32"
>Exit: </span>(262) [user] nop(notrace(no_repeats_var(_466722)))
^  <span class="ansi1 ansi32"
>Exit: </span>(260) [system] once(user:(notrace((flag(eval_num, 14, 14+1), 14 is 14 mod 500, 2 is 99-497 mod 100, _466592=_466592, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 14>500), (set_debug(eval, false), _466670 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_466670])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_466722)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(259) [user] must_det_ll(user:(notrace((flag(eval_num, 14, 14+1), 14 is 14 mod 500, 2 is 99-497 mod 100, _466592=_466592, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 14>500), (set_debug(eval, false), _466670 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_466670])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_466722)))))
   <span class="ansi1 ansi32"
>Call: </span>(259) [occurs] occurs:sub_term(_477276, e)
   <span class="ansi1 ansi32"
>Exit: </span>(259) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(259) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(259) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(260) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(260) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(259) [occurs] occurs:sub_term(_477276, e)
   <span class="ansi1 ansi32"
>Call: </span>(259) [system] _483766=e
   <span class="ansi1 ansi32"
>Exit: </span>(259) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(259) [user] if_trace((eval;e), (_466592=1, indentq(2, 14, -->, [e, [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(261) [system] setup_call_cleanup('$notrace'(_486642, _486644), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _466592=1, indentq(2, 14, -->, [e, [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]]))), _486600, fbug((_486600-->if_trace((eval;e), (_466592=1, indentq(2, 14, -->, [e, [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]])))))))), '$restore_trace'(_486642, _486644))
^  <span class="ansi1 ansi32"
>Call: </span>(262) [system] sig_atomic(system:'$notrace'(_486642, _486644))
^  <span class="ansi1 ansi32"
>Exit: </span>(261) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _466592=1, indentq(2, 14, -->, [e, [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]]))), _486600, fbug((_486600-->if_trace((eval;e), (_466592=1, indentq(2, 14, -->, [e, [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(259) [user] if_trace((eval;e), (_466592=1, indentq(2, 14, -->, [e, [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]])))
   <span class="ansi1 ansi32"
>Call: </span>(259) [system] _490486=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(259) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(259) [system] _492348=(\+ \+ (flag(eval_num, _492368, _492368+1), (retval(fail)\=@=retval(fail), nonvar(_465566)->indentq(2, _492368, <--, [e, _465566]);indentq(2, _492368, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(259) [system] (\+ \+ (flag(eval_num, _492368, _492368+1), (retval(fail)\=@=retval(fail), nonvar(_465566)->indentq(2, _492368, <--, [e, _465566]);indentq(2, _492368, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _492368, _492368+1), (retval(fail)\=@=retval(fail), nonvar(_465566)->indentq(2, _492368, <--, [e, _465566]);indentq(2, _492368, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(259) [user] call_cleanup(((call(eval_20(=, _416824), 497, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _465566)*->nb_setarg(1, retval(fail), _465566);fail, trace, call(eval_20(=, _416824), 497, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _465566)), ignore(notrace((\+_465566\=_466722, nb_setarg(1, retval(fail), _465566))))), ignore((_466592==1->ignore(\+ \+ (flag(eval_num, _492368, _492368+1), (retval(fail)\=@=retval(fail), nonvar(_465566)->indentq(2, _492368, <--, [e, _465566]);indentq(2, _492368, <--, [e, retval(fail)]))));notrace(ignore(if_t(2<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _492368, _492368+1), (retval(fail)\=@=retval(fail), nonvar(_465566)->indentq(2, _492368, <--, [e, _465566]);indentq(2, _492368, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(261) [user] eval_20(=, _416824, 497, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _465566)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] atom([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] no_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] self_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Call: </span>(265) [system] setup_call_cleanup('$notrace'(_499140, _499142), once(user:self_eval0([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])), '$restore_trace'(_499140, _499142))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [system] sig_atomic(system:'$notrace'(_499140, _499142))
^  <span class="ansi1 ansi31"
>Fail: </span>(263) [user] self_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
   <span class="ansi1 ansi32"
>Call: </span>(263) [system] atomic(case)
   <span class="ansi1 ansi32"
>Exit: </span>(263) [system] atomic(case)
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] is_sl(case)
   <span class="ansi1 ansi32"
>Call: </span>(264) [system] number(case)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] [['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(262) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] callable(case)
   <span class="ansi1 ansi32"
>Exit: </span>(262) [system] callable(case)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] [['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] is_list([['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
   <span class="ansi1 ansi32"
>Exit: </span>(262) [system] is_list([['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] is_list(case)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] is_list([['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
   <span class="ansi1 ansi32"
>Exit: </span>(262) [system] is_list([['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] is_list([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
   <span class="ansi1 ansi32"
>Exit: </span>(262) [system] is_list([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] once(expand_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _519548))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] expand_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _519548)
   <span class="ansi1 ansi32"
>Call: </span>(264) [system] is_list([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
   <span class="ansi1 ansi32"
>Exit: </span>(264) [system] is_list([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
   <span class="ansi1 ansi32"
>Call: </span>(264) [system] ground(case)
   <span class="ansi1 ansi32"
>Exit: </span>(264) [system] ground(case)
^  <span class="ansi1 ansi32"
>Call: </span>(264) [user] apply:maplist(expand_eval, [['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _525120)
   <span class="ansi1 ansi32"
>Call: </span>(265) [apply] apply:maplist_([['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _525120, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] expand_eval(['if-unify-or-empty', _407092, _407092], _527000)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] is_list(['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] is_list(['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] apply:maplist(expand_eval, [_407092, _407092], _531638)
   <span class="ansi1 ansi32"
>Call: </span>(268) [apply] apply:maplist_([_407092, _407092], _531638, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] expand_eval(_407092, _533518)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] is_list(_407092)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] _407092=_533518
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] _407092=_407092
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] expand_eval(_407092, _407092)
   <span class="ansi1 ansi32"
>Call: </span>(269) [apply] apply:maplist_([_407092], _533520, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] expand_eval(_407092, _539092)
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] is_list(_407092)
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] _407092=_539092
   <span class="ansi1 ansi32"
>Exit: </span>(271) [system] _407092=_407092
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [user] expand_eval(_407092, _407092)
   <span class="ansi1 ansi32"
>Call: </span>(270) [apply] apply:maplist_([], _539094, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(270) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(269) [apply] apply:maplist_([_407092], [_407092], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(268) [apply] apply:maplist_([_407092, _407092], [_407092, _407092], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [apply] apply:maplist(user:expand_eval, [_407092, _407092], [_407092, _407092])
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] expand_eval(['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(266) [apply] apply:maplist_([[['Empty', _407110]]], _527002, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] expand_eval([['Empty', _407110]], _550260)
   <span class="ansi1 ansi32"
>Call: </span>(268) [system] is_list([['Empty', _407110]])
   <span class="ansi1 ansi32"
>Exit: </span>(268) [system] is_list([['Empty', _407110]])
   <span class="ansi1 ansi32"
>Call: </span>(268) [system] ground(['Empty', _407110])
^  <span class="ansi1 ansi32"
>Call: </span>(268) [user] apply:maplist(expand_eval, [], _553044)
   <span class="ansi1 ansi32"
>Call: </span>(269) [apply] apply:maplist_([], _553044, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(269) [apply] apply:maplist_([], [], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [apply] apply:maplist(user:expand_eval, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [user] expand_eval([['Empty', _407110]], [['Empty', _407110]])
   <span class="ansi1 ansi32"
>Call: </span>(267) [apply] apply:maplist_([], _550262, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(267) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(266) [apply] apply:maplist_([[['Empty', _407110]]], [[['Empty', _407110]]], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(265) [apply] apply:maplist_([['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], [['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(264) [apply] apply:maplist(user:expand_eval, [['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], [['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [user] expand_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(262) [system] once(user:expand_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]))
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]\==[case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] is_progn(case)
   <span class="ansi1 ansi32"
>Call: </span>(263) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] is_space_op(case)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] must_det_ll([]==[])
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] once(user:([]==[]))
   <span class="ansi1 ansi32"
>Call: </span>(264) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(264) [system] []==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [system] once(user:([]==[]))
^  <span class="ansi1 ansi32"
>Exit: </span>(262) [user] must_det_ll(user:([]==[]))
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] into_case_list([['Empty', _407110]], _576288)
   <span class="ansi1 ansi32"
>Call: </span>(263) [system] is_list([['Empty', _407110]])
   <span class="ansi1 ansi32"
>Exit: </span>(263) [system] is_list([['Empty', _407110]])
^  <span class="ansi1 ansi32"
>Exit: </span>(262) [user] into_case_list([['Empty', _407110]], [['Empty', _407110]])
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] into_case_keys(1, [['Empty', _407110]], _579994)
   <span class="ansi1 ansi32"
>Call: </span>(263) [system] _580946 is 1+1
   <span class="ansi1 ansi32"
>Exit: </span>(263) [system] 2 is 1+1
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] is_case(_580936, ['Empty', _407110], _580938)
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [user] is_case('Empty', ['Empty', _407110], _407110)
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_407110)))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [system] setup_call_cleanup('$notrace'(_585672, _585674), once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_407110))), _585630, fbug((_585630-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_407110)))))))), '$restore_trace'(_585672, _585674))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [system] sig_atomic(system:'$notrace'(_585672, _585674))
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_407110))), _585630, fbug((_585630-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_407110)))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_407110)))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] into_case_keys(2, [], _580932)
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [user] into_case_keys(2, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(262) [user] into_case_keys(1, [['Empty', _407110]], ['Empty'-_407110])
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] eval_case(=, _416824, 497, '&self', ['if-unify-or-empty', _407092, _407092], ['Empty'-_407110], _465566)
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _407092, _407092]))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [system] setup_call_cleanup('$notrace'(_594248, _594250), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _407092, _407092]))), _594206, fbug((_594206-->if_trace(case, writeqln(case=['if-unify-or-empty', _407092, _407092]))))))), '$restore_trace'(_594248, _594250))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [system] sig_atomic(system:'$notrace'(_594248, _594250))
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _407092, _407092]))), _594206, fbug((_594206-->if_trace(case, writeqln(case=['if-unify-or-empty', _407092, _407092]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _407092, _407092]))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] eval_args(=, _598170, 497, '&self', ['if-unify-or-empty', _407092, _407092], _598092)
   <span class="ansi1 ansi32"
>Call: </span>(264) [system] var(['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(265) [system] setup_call_cleanup('$notrace'(_599974, _599976), once(user:self_eval(['if-unify-or-empty', _407092, _407092])), '$restore_trace'(_599974, _599976))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [system] sig_atomic(system:'$notrace'(_599974, _599976))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [system] setup_call_cleanup('$notrace'(_601886, _601888), once(user:nonvar(_598092)), '$restore_trace'(_601886, _601888))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [system] sig_atomic(system:'$notrace'(_601886, _601888))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [system] setup_call_cleanup('$notrace'(_603798, _603800), once(user:nonvar(_598092)), '$restore_trace'(_603798, _603800))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [system] sig_atomic(system:'$notrace'(_603798, _603800))
   <span class="ansi1 ansi32"
>Call: </span>(264) [system] [_407092, _407092]==[]
   <span class="ansi1 ansi32"
>Call: </span>(264) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(264) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(264) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(264) [user] self_eval(['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(266) [system] setup_call_cleanup('$notrace'(_610338, _610340), once(user:self_eval0(['if-unify-or-empty', _407092, _407092])), '$restore_trace'(_610338, _610340))
^  <span class="ansi1 ansi32"
>Call: </span>(267) [system] sig_atomic(system:'$notrace'(_610338, _610340))
^  <span class="ansi1 ansi31"
>Fail: </span>(264) [user] self_eval(['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(264) [user] eval_00(=, _613162, 497, '&self', ['if-unify-or-empty', _407092, _407092], _598092)
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] self_eval(['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(267) [system] setup_call_cleanup('$notrace'(_615044, _615046), once(user:self_eval0(['if-unify-or-empty', _407092, _407092])), '$restore_trace'(_615044, _615046))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] sig_atomic(system:'$notrace'(_615044, _615046))
^  <span class="ansi1 ansi31"
>Fail: </span>(265) [user] self_eval(['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] eval_01(=, _613162, 497, '&self', ['if-unify-or-empty', _407092, _407092], _598092)
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] ['if-unify-or-empty', _407092, _407092]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(266) [system] ['if-unify-or-empty', _407092, _407092]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] if_t((497<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(268) [system] 497<1
   <span class="ansi1 ansi31"
>Fail: </span>(268) [system] 497<1
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] if_t((497<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(267) [system] setup_call_cleanup('$notrace'(_624438, _624440), once(user:(_624414 is 497-1, copy_term(['if-unify-or-empty', _407092, _407092], _624428))), '$restore_trace'(_624438, _624440))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] sig_atomic(system:'$notrace'(_624438, _624440))
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(496 is 497-1, copy_term(['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _626348, _626348]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] trace_eval(eval_20(=, _613162), e, 496, '&self', ['if-unify-or-empty', _407092, _407092], _627302)
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] must_det_ll((notrace((flag(eval_num, _628268, _628268+1), _628286 is _628268 mod 500, _628304 is 99-496 mod 100, _628328=_628330, option_else('trace-length', _628342, 500), option_else('trace-depth', _628350, 30))), quietly(if_t((nop(stop_rtrace), _628286>_628342), (set_debug(eval, false), _628406 is _628342+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_628406])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_628458)))))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [user] once(user:(notrace((flag(eval_num, _628268, _628268+1), _628286 is _628268 mod 500, _628304 is 99-496 mod 100, _628328=_628330, option_else('trace-length', _628342, 500), option_else('trace-depth', _628350, 30))), quietly(if_t((nop(stop_rtrace), _628286>_628342), (set_debug(eval, false), _628406 is _628342+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_628406])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_628458)))))
^  <span class="ansi1 ansi32"
>Call: </span>(271) [system] setup_call_cleanup('$notrace'(_630328, _630330), once(user:(flag(eval_num, _628268, _628268+1), _628286 is _628268 mod 500, _628304 is 99-496 mod 100, _628328=_628330, option_else('trace-length', _628342, 500), option_else('trace-depth', _628350, 30))), '$restore_trace'(_630328, _630330))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] sig_atomic(system:'$notrace'(_630328, _630330))
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 15, 15+1), 15 is 15 mod 500, 3 is 99-496 mod 100, _628328=_628328, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(271) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 15>500), (set_debug(eval, false), _628406 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_628406])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 15>500), (set_debug(eval, false), _628406 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_628406])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(270) [user] nop(notrace(no_repeats_var(_628458)))
   <span class="ansi1 ansi32"
>Exit: </span>(270) [user] nop(notrace(no_repeats_var(_628458)))
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [system] once(user:(notrace((flag(eval_num, 15, 15+1), 15 is 15 mod 500, 3 is 99-496 mod 100, _628328=_628328, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 15>500), (set_debug(eval, false), _628406 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_628406])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_628458)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [user] must_det_ll(user:(notrace((flag(eval_num, 15, 15+1), 15 is 15 mod 500, 3 is 99-496 mod 100, _628328=_628328, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 15>500), (set_debug(eval, false), _628406 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_628406])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_628458)))))
   <span class="ansi1 ansi32"
>Call: </span>(267) [occurs] occurs:sub_term(_639012, e)
   <span class="ansi1 ansi32"
>Exit: </span>(267) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(267) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(268) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(268) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(267) [occurs] occurs:sub_term(_639012, e)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] _645502=e
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] if_trace((eval;e), (_628328=1, indentq(3, 15, -->, [e, ['if-unify-or-empty', _407092, _407092]])))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] setup_call_cleanup('$notrace'(_648378, _648380), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _628328=1, indentq(3, 15, -->, [e, ['if-unify-or-empty', _407092, _407092]]))), _648336, fbug((_648336-->if_trace((eval;e), (_628328=1, indentq(3, 15, -->, [e, ['if-unify-or-empty', _407092, _407092]])))))))), '$restore_trace'(_648378, _648380))
^  <span class="ansi1 ansi32"
>Call: </span>(270) [system] sig_atomic(system:'$notrace'(_648378, _648380))
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _628328=1, indentq(3, 15, -->, [e, ['if-unify-or-empty', _407092, _407092]]))), _648336, fbug((_648336-->if_trace((eval;e), (_628328=1, indentq(3, 15, -->, [e, ['if-unify-or-empty', _407092, _407092]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [user] if_trace((eval;e), (_628328=1, indentq(3, 15, -->, [e, ['if-unify-or-empty', _407092, _407092]])))
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] _652222=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] _654084=(\+ \+ (flag(eval_num, _654104, _654104+1), (retval(fail)\=@=retval(fail), nonvar(_627302)->indentq(3, _654104, <--, [e, _627302]);indentq(3, _654104, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] (\+ \+ (flag(eval_num, _654104, _654104+1), (retval(fail)\=@=retval(fail), nonvar(_627302)->indentq(3, _654104, <--, [e, _627302]);indentq(3, _654104, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _654104, _654104+1), (retval(fail)\=@=retval(fail), nonvar(_627302)->indentq(3, _654104, <--, [e, _627302]);indentq(3, _654104, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] call_cleanup(((call(eval_20(=, _613162), 496, '&self', ['if-unify-or-empty', _407092, _407092], _627302)*->nb_setarg(1, retval(fail), _627302);fail, trace, call(eval_20(=, _613162), 496, '&self', ['if-unify-or-empty', _407092, _407092], _627302)), ignore(notrace((\+_627302\=_628458, nb_setarg(1, retval(fail), _627302))))), ignore((_628328==1->ignore(\+ \+ (flag(eval_num, _654104, _654104+1), (retval(fail)\=@=retval(fail), nonvar(_627302)->indentq(3, _654104, <--, [e, _627302]);indentq(3, _654104, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _654104, _654104+1), (retval(fail)\=@=retval(fail), nonvar(_627302)->indentq(3, _654104, <--, [e, _627302]);indentq(3, _654104, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] eval_20(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _627302)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] atom(['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] no_eval(['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] self_eval(['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(273) [system] setup_call_cleanup('$notrace'(_660876, _660878), once(user:self_eval0(['if-unify-or-empty', _407092, _407092])), '$restore_trace'(_660876, _660878))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [system] sig_atomic(system:'$notrace'(_660876, _660878))
^  <span class="ansi1 ansi31"
>Fail: </span>(271) [user] self_eval(['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] atomic('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(271) [system] atomic('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] is_sl('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(272) [system] number('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] [_407092, _407092]==[]
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] _671102==eval
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] [_407092, _407092]==[]
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] is_list([_407092, _407092])
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] is_list([_407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] is_list('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] is_list([_407092, _407092])
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] is_list([_407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] is_list(['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] is_list(['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] once(expand_eval(['if-unify-or-empty', _407092, _407092], _682224))
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] expand_eval(['if-unify-or-empty', _407092, _407092], _682224)
   <span class="ansi1 ansi32"
>Call: </span>(272) [system] is_list(['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Exit: </span>(272) [system] is_list(['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(272) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(272) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] apply:maplist(expand_eval, [_407092, _407092], _687796)
   <span class="ansi1 ansi32"
>Call: </span>(273) [apply] apply:maplist_([_407092, _407092], _687796, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] expand_eval(_407092, _689676)
   <span class="ansi1 ansi32"
>Call: </span>(275) [system] is_list(_407092)
   <span class="ansi1 ansi32"
>Call: </span>(275) [system] _407092=_689676
   <span class="ansi1 ansi32"
>Exit: </span>(275) [system] _407092=_407092
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [user] expand_eval(_407092, _407092)
   <span class="ansi1 ansi32"
>Call: </span>(274) [apply] apply:maplist_([_407092], _689678, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] expand_eval(_407092, _695250)
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] is_list(_407092)
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] _407092=_695250
   <span class="ansi1 ansi32"
>Exit: </span>(276) [system] _407092=_407092
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] expand_eval(_407092, _407092)
   <span class="ansi1 ansi32"
>Call: </span>(275) [apply] apply:maplist_([], _695252, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(275) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(274) [apply] apply:maplist_([_407092], [_407092], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(273) [apply] apply:maplist_([_407092, _407092], [_407092, _407092], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [apply] apply:maplist(user:expand_eval, [_407092, _407092], [_407092, _407092])
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [user] expand_eval(['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [system] once(user:expand_eval(['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _407092, _407092]))
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] ['if-unify-or-empty', _407092, _407092]\==['if-unify-or-empty', _407092, _407092]
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] is_progn('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] is_space_op('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] arg(_711128, v('catch!', 'throw!', 'number-of!', 'limit!', 'offset!', 'max-time!', 'findall!', 'setup-call-cleanup!', 'call-cleanup!', 'call-cleanup!', 'with-output-to!'), 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] _711986='if-unify-or-empty'
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] 'if-unify-or-empty'='if-unify-or-empty'
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _713844)
^  <span class="ansi1 ansi31"
>Fail: </span>(270) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _713844)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] is_list(['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] is_list(['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] apply:maplist(self_eval, ['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(271) [apply] apply:maplist_(['if-unify-or-empty', _407092, _407092], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] self_eval('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(274) [system] setup_call_cleanup('$notrace'(_720362, _720364), once(user:self_eval0('if-unify-or-empty')), '$restore_trace'(_720362, _720364))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] sig_atomic(system:'$notrace'(_720362, _720364))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0('if-unify-or-empty')), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] self_eval('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(272) [apply] apply:maplist_([_407092, _407092], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] self_eval(_407092)
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] setup_call_cleanup('$notrace'(_725988, _725990), once(user:self_eval0(_407092)), '$restore_trace'(_725988, _725990))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [system] sig_atomic(system:'$notrace'(_725988, _725990))
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_407092)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(273) [user] self_eval(_407092)
   <span class="ansi1 ansi32"
>Call: </span>(273) [apply] apply:maplist_([_407092], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] self_eval(_407092)
^  <span class="ansi1 ansi32"
>Call: </span>(276) [system] setup_call_cleanup('$notrace'(_731614, _731616), once(user:self_eval0(_407092)), '$restore_trace'(_731614, _731616))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [system] sig_atomic(system:'$notrace'(_731614, _731616))
^  <span class="ansi1 ansi32"
>Exit: </span>(276) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_407092)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [user] self_eval(_407092)
   <span class="ansi1 ansi32"
>Call: </span>(274) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(274) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(273) [apply] apply:maplist_([_407092], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(272) [apply] apply:maplist_([_407092, _407092], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(271) [apply] apply:maplist_(['if-unify-or-empty', _407092, _407092], user:self_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [apply] apply:maplist(user:self_eval, ['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] ['if-unify-or-empty', _407092, _407092]=[_740952|_740954]
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] ['if-unify-or-empty', _407092, _407092]=['if-unify-or-empty', _407092, _407092]
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] _744660=do_more_defs(true)
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] do_more_defs(true)=do_more_defs(true)
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] clause(eval_21(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _627302), _746536)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] 'if-unify-or-empty'==(/)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] 'if-unify-or-empty'== ===
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] 'if-unify-or-empty'== ====
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] eval_40(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256)
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] eval_selfless(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256)
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] eval_selfless_0(['if-unify-or-empty', _407092, _407092], _750256)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] is_assignment('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(274) [system] atom('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] eval_selfless_1(['if-unify-or-empty', _407092, _407092], _750256)
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] allow_clp
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] false_flag
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(276) [system] fail
^  <span class="ansi1 ansi31"
>Fail: </span>(275) [user] false_flag
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] eval_selfless_2(['if-unify-or-empty', _407092, _407092], _750256)
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] fake_notrace((ground(['if-unify-or-empty', _407092, _407092]), ['if-unify-or-empty', _407092, _407092]=[_764160, _764166, _764172], atom(_764160), catch_warn(current_op(_764198, yfx, _764160)), ['if-unify-or-empty', _407092, _407092]\=[_764218], s2ps(['if-unify-or-empty', _407092, _407092], _764226)))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] real_notrace(user:(ground(['if-unify-or-empty', _407092, _407092]), ['if-unify-or-empty', _407092, _407092]=[_764160, _764166, _764172], atom(_764160), catch_warn(current_op(_764198, yfx, _764160)), ['if-unify-or-empty', _407092, _407092]\=[_764218], s2ps(['if-unify-or-empty', _407092, _407092], _764226)))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] setup_call_cleanup('$notrace'(_766084, _766086), once(user:(ground(['if-unify-or-empty', _407092, _407092]), ['if-unify-or-empty', _407092, _407092]=[_764160, _764166, _764172], atom(_764160), catch_warn(current_op(_764198, yfx, _764160)), ['if-unify-or-empty', _407092, _407092]\=[_764218], s2ps(['if-unify-or-empty', _407092, _407092], _764226))), '$restore_trace'(_766084, _766086))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [system] sig_atomic(user:'$notrace'(_766084, _766086))
^  <span class="ansi1 ansi31"
>Fail: </span>(275) [user] real_notrace(user:(ground(['if-unify-or-empty', _407092, _407092]), ['if-unify-or-empty', _407092, _407092]=[_764160, _764166, _764172], atom(_764160), catch_warn(current_op(_764198, yfx, _764160)), ['if-unify-or-empty', _407092, _407092]\=[_764218], s2ps(['if-unify-or-empty', _407092, _407092], _764226)))
^  <span class="ansi1 ansi31"
>Fail: </span>(274) [user] fake_notrace(user:(ground(['if-unify-or-empty', _407092, _407092]), ['if-unify-or-empty', _407092, _407092]=[_764160, _764166, _764172], atom(_764160), catch_warn(current_op(_764198, yfx, _764160)), ['if-unify-or-empty', _407092, _407092]\=[_764218], s2ps(['if-unify-or-empty', _407092, _407092], _764226)))
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] 'if-unify-or-empty'==(==)
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] 'if-unify-or-empty'==(==)
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] eval_41(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256)
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] eval_adjust_args(=, _613162, _778128, _750256, 496, '&self', ['if-unify-or-empty', _407092, _407092], _778130)
   <span class="ansi1 ansi32"
>Call: </span>(273) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _613162, _778128, _750256, 496, '&self', ['if-unify-or-empty', _407092, _407092], _778130)), eval_adjust_args1(=, _613162, _778128, _750256, 496, '&self', ['if-unify-or-empty', _407092, _407092], _778130))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(276) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] eval_adjust_args2(=, _613162, _778128, _750256, 496, '&self', ['if-unify-or-empty', _407092, _407092], _778130)
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] apply:maplist(must_eval_args(=, _784668, 496, '&self'), [_407092, _407092], _784662)
   <span class="ansi1 ansi32"
>Call: </span>(277) [apply] apply:maplist_([_407092, _407092], _784662, user:must_eval_args(=, _784668, 496, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] must_eval_args(=, _784668, 496, '&self', _407092, _786552)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(280) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(282) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] was_option_value(nodebug, _796748)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] current_prolog_flag(nodebug, _797678)
   <span class="ansi1 ansi31"
>Fail: </span>(284) [system] current_prolog_flag(nodebug, _797678)
   <span class="ansi1 ansi32"
>Call: </span>(284) [$syspreds] prolog_load_context(nodebug, _799536)
   <span class="ansi1 ansi31"
>Fail: </span>(284) [$syspreds] prolog_load_context(nodebug, _799536)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] nb_current(nodebug, _801394)
   <span class="ansi1 ansi31"
>Fail: </span>(284) [system] nb_current(nodebug, _801394)
^  <span class="ansi1 ansi31"
>Fail: </span>(283) [user] was_option_value(nodebug, _796748)
^  <span class="ansi1 ansi31"
>Fail: </span>(282) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(282) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(283) [system] setup_call_cleanup('$notrace'(_806978, _806980), once(user:option_value0(nodebug, true)), '$restore_trace'(_806978, _806980))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] sig_atomic(system:'$notrace'(_806978, _806980))
^  <span class="ansi1 ansi31"
>Fail: </span>(281) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(280) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(280) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(280) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(281) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(280) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(281) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(280) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(280) [prolog_debug] prolog_debug:debugging(metta(eval_args), _825558)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [prolog_debug] prolog_debug:debugging(metta(eval_args), _825558, _826566)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_830228, _830230, _830232), defined)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(283) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(283) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_830228, _830230, _830232))
   <span class="ansi1 ansi32"
>Call: </span>(284) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_830228, _830230, _830232))
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] callable(debugging_logicmoo_setting(_830228, _830230, _830232))
   <span class="ansi1 ansi32"
>Exit: </span>(285) [system] callable(debugging_logicmoo_setting(_830228, _830230, _830232))
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(285) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(284) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_830228, _830230, _830232))
   <span class="ansi1 ansi32"
>Exit: </span>(283) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_830228, _830230, _830232))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_830228, _830230, _830232), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _825558, _841356)
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(280) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] eval_args(=, _784668, 496, '&self', _407092, _786552)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] var(_407092)
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] var(_407092)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] nonvar(_786552)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [system] setup_call_cleanup('$notrace'(_851614, _851616), once(user:self_eval(_407092)), '$restore_trace'(_851614, _851616))
^  <span class="ansi1 ansi32"
>Call: </span>(282) [system] sig_atomic(system:'$notrace'(_851614, _851616))
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_407092)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] _786552=_407092
   <span class="ansi1 ansi32"
>Exit: </span>(280) [system] _407092=_407092
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] eval_args(=, _784668, 496, '&self', _407092, _407092)
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [user] must_eval_args(=, _784668, 496, '&self', _407092, _407092)
   <span class="ansi1 ansi32"
>Call: </span>(278) [apply] apply:maplist_([_407092], _786554, user:must_eval_args(=, _784668, 496, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] must_eval_args(=, _784668, 496, '&self', _407092, _859174)
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(281) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(283) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(283) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] was_option_value(nodebug, _869370)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] current_prolog_flag(nodebug, _870300)
   <span class="ansi1 ansi31"
>Fail: </span>(285) [system] current_prolog_flag(nodebug, _870300)
   <span class="ansi1 ansi32"
>Call: </span>(285) [$syspreds] prolog_load_context(nodebug, _872158)
   <span class="ansi1 ansi31"
>Fail: </span>(285) [$syspreds] prolog_load_context(nodebug, _872158)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] nb_current(nodebug, _874016)
   <span class="ansi1 ansi31"
>Fail: </span>(285) [system] nb_current(nodebug, _874016)
^  <span class="ansi1 ansi31"
>Fail: </span>(284) [user] was_option_value(nodebug, _869370)
^  <span class="ansi1 ansi31"
>Fail: </span>(283) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(283) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] setup_call_cleanup('$notrace'(_879600, _879602), once(user:option_value0(nodebug, true)), '$restore_trace'(_879600, _879602))
^  <span class="ansi1 ansi32"
>Call: </span>(285) [system] sig_atomic(system:'$notrace'(_879600, _879602))
^  <span class="ansi1 ansi31"
>Fail: </span>(282) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(281) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(281) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(281) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(282) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(281) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(282) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(281) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(281) [prolog_debug] prolog_debug:debugging(metta(eval_args), _898180)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [prolog_debug] prolog_debug:debugging(metta(eval_args), _898180, _899188)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_902850, _902852, _902854), defined)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(284) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(284) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_902850, _902852, _902854))
   <span class="ansi1 ansi32"
>Call: </span>(285) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_902850, _902852, _902854))
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] callable(debugging_logicmoo_setting(_902850, _902852, _902854))
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] callable(debugging_logicmoo_setting(_902850, _902852, _902854))
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(285) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_902850, _902852, _902854))
   <span class="ansi1 ansi32"
>Exit: </span>(284) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_902850, _902852, _902854))
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_902850, _902852, _902854), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _898180, _913978)
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(281) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(280) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] eval_args(=, _784668, 496, '&self', _407092, _859174)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] var(_407092)
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] var(_407092)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] nonvar(_859174)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [system] setup_call_cleanup('$notrace'(_924236, _924238), once(user:self_eval(_407092)), '$restore_trace'(_924236, _924238))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [system] sig_atomic(system:'$notrace'(_924236, _924238))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_407092)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] _859174=_407092
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] _407092=_407092
^  <span class="ansi1 ansi32"
>Exit: </span>(280) [user] eval_args(=, _784668, 496, '&self', _407092, _407092)
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] must_eval_args(=, _784668, 496, '&self', _407092, _407092)
   <span class="ansi1 ansi32"
>Call: </span>(279) [apply] apply:maplist_([], _859176, user:must_eval_args(=, _784668, 496, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(279) [apply] apply:maplist_([], [], user:must_eval_args(=, _784668, 496, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(278) [apply] apply:maplist_([_407092], [_407092], user:must_eval_args(=, _784668, 496, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(277) [apply] apply:maplist_([_407092, _407092], [_407092, _407092], user:must_eval_args(=, _784668, 496, '&self'))
^  <span class="ansi1 ansi32"
>Exit: </span>(276) [apply] apply:maplist(user:must_eval_args(=, _784668, 496, '&self'), [_407092, _407092], [_407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] _778128=_750256
   <span class="ansi1 ansi32"
>Exit: </span>(276) [system] _750256=_750256
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] eval_adjust_args2(=, _613162, _750256, _750256, 496, '&self', ['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Exit: </span>(273) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _613162, _750256, _750256, 496, '&self', ['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _407092, _407092])), eval_adjust_args1(=, _613162, _750256, _750256, 496, '&self', ['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _407092, _407092]))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] eval_adjust_args(=, _613162, _750256, _750256, 496, '&self', ['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] if_trace((e;args), (['if-unify-or-empty', _407092, _407092]\==['if-unify-or-empty', _407092, _407092]->color_g_mesg('#773733', indentq2(496, (['if-unify-or-empty', _407092, _407092]->['if-unify-or-empty', _407092, _407092])));nop(indentq2(496, same(['if-unify-or-empty', _407092, _407092])))))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [system] setup_call_cleanup('$notrace'(_941238, _941240), once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _407092, _407092]\==['if-unify-or-empty', _407092, _407092]->color_g_mesg('#773733', indentq2(496, (['if-unify-or-empty', _407092, _407092]->['if-unify-or-empty', _407092, _407092])));nop(indentq2(496, same(['if-unify-or-empty', _407092, _407092])))))), _941196, fbug((_941196-->if_trace((e;args), (['if-unify-or-empty', _407092, _407092]\==['if-unify-or-empty', _407092, _407092]->color_g_mesg('#773733', indentq2(496, (['if-unify-or-empty', _407092, _407092]->['if-unify-or-empty', _407092, _407092])));nop(indentq2(496, same(['if-unify-or-empty', _407092, _407092])))))))))), '$restore_trace'(_941238, _941240))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] sig_atomic(system:'$notrace'(_941238, _941240))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _407092, _407092]\==['if-unify-or-empty', _407092, _407092]->color_g_mesg('#773733', indentq2(496, (['if-unify-or-empty', _407092, _407092]->['if-unify-or-empty', _407092, _407092])));nop(indentq2(496, same(['if-unify-or-empty', _407092, _407092])))))), _941196, fbug((_941196-->if_trace((e;args), (['if-unify-or-empty', _407092, _407092]\==['if-unify-or-empty', _407092, _407092]->color_g_mesg('#773733', indentq2(496, (['if-unify-or-empty', _407092, _407092]->['if-unify-or-empty', _407092, _407092])));nop(indentq2(496, same(['if-unify-or-empty', _407092, _407092])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] if_trace((e;args), (['if-unify-or-empty', _407092, _407092]\==['if-unify-or-empty', _407092, _407092]->color_g_mesg('#773733', indentq2(496, (['if-unify-or-empty', _407092, _407092]->['if-unify-or-empty', _407092, _407092])));nop(indentq2(496, same(['if-unify-or-empty', _407092, _407092])))))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] eval_70(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256)
   <span class="ansi1 ansi32"
>Call: </span>(273) [user] if_or_else(eval_maybe_python(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256), if_or_else(eval_maybe_host_predicate(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256), if_or_else(eval_maybe_host_function(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256), if_or_else(eval_maybe_defn(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256), eval_maybe_subst(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256)))))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] eval_maybe_python(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256)
   <span class="ansi1 ansi32"
>Call: </span>(275) [user] metta_atom('&self', ['registered-python-function', _947982, _947988, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] typed_list('&self', _948992, _948914)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(277) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(276) [user] typed_list('&self', _951772, _948914)
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] metta_atom_in_file('&self', ['registered-python-function', _947982, _947988, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] metta_atom_in_file('&self', ['registered-python-function', _947982, _947988, 'if-unify-or-empty'], _954562, _954564)
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] loaded_into_kb('&self', _955420)
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [user] loaded_into_kb('&self', '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] once(user:asserted_metta_pred(_957286, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] asserted_metta_pred(_957286, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(279) [user] asserted_metta_pred(_957286, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
   <span class="ansi1 ansi32"
>Call: </span>(276) [user] metta_atom_asserted('&self', ['registered-python-function', _947982, _947988, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] metta_atom_asserted_deduced('&self', ['registered-python-function', _947982, _947988, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(276) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(276) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(276) [user] metta_atom('&corelib', ['registered-python-function', _947982, _947988, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] typed_list('&corelib', _968470, _968392)
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(278) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(277) [user] typed_list('&corelib', _971250, _968392)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] metta_atom_in_file('&corelib', ['registered-python-function', _947982, _947988, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] metta_atom_in_file('&corelib', ['registered-python-function', _947982, _947988, 'if-unify-or-empty'], _974040, _974042)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] loaded_into_kb('&corelib', _974898)
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] loaded_into_kb('&corelib', '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] once(user:asserted_metta_pred(_976764, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] asserted_metta_pred(_976764, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(280) [user] asserted_metta_pred(_976764, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] loaded_into_kb('&corelib', '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] once(user:asserted_metta_pred(_980490, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] asserted_metta_pred(_980490, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(280) [user] asserted_metta_pred(_980490, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
   <span class="ansi1 ansi32"
>Call: </span>(277) [user] metta_atom_asserted('&corelib', ['registered-python-function', _947982, _947988, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] metta_atom_asserted_deduced('&corelib', ['registered-python-function', _947982, _947988, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(274) [user] if_or_else(eval_maybe_host_predicate(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256), if_or_else(eval_maybe_host_function(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256), if_or_else(eval_maybe_defn(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256), eval_maybe_subst(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256))))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] eval_maybe_host_predicate(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256)
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(276) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] once((is_system_pred('if-unify-or-empty'), length([_407092, _407092], _992536), is_syspred('if-unify-or-empty', _992536, _992544)))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] atom_concat(_996328, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] atom_concat(_999108, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] atom_concat(_1001888, '-p', 'if-unify-or-empty')
^  <span class="ansi1 ansi31"
>Fail: </span>(278) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(275) [user] if_or_else(eval_maybe_host_function(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256), if_or_else(eval_maybe_defn(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256), eval_maybe_subst(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256)))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] eval_maybe_host_function(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256)
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(278) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] atom_concat(_1010208, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(278) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] atom_concat(_1012988, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(278) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] atom_concat(_1015768, '-p', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(276) [user] if_or_else(eval_maybe_defn(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256), eval_maybe_subst(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] eval_maybe_defn(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256)
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] trace_eval(eval_defn_choose_candidates(=, _613162), defn, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] must_det_ll((notrace((flag(eval_num, _1024976, _1024976+1), _1024994 is _1024976 mod 500, _1025012 is 99-496 mod 100, _1025036=_1025038, option_else('trace-length', _1025050, 500), option_else('trace-depth', _1025058, 30))), quietly(if_t((nop(stop_rtrace), _1024994>_1025050), (set_debug(eval, false), _1025114 is _1025050+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1025114])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1025166)))))
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] once(user:(notrace((flag(eval_num, _1024976, _1024976+1), _1024994 is _1024976 mod 500, _1025012 is 99-496 mod 100, _1025036=_1025038, option_else('trace-length', _1025050, 500), option_else('trace-depth', _1025058, 30))), quietly(if_t((nop(stop_rtrace), _1024994>_1025050), (set_debug(eval, false), _1025114 is _1025050+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1025114])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1025166)))))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [system] setup_call_cleanup('$notrace'(_1027036, _1027038), once(user:(flag(eval_num, _1024976, _1024976+1), _1024994 is _1024976 mod 500, _1025012 is 99-496 mod 100, _1025036=_1025038, option_else('trace-length', _1025050, 500), option_else('trace-depth', _1025058, 30))), '$restore_trace'(_1027036, _1027038))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] sig_atomic(system:'$notrace'(_1027036, _1027038))
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 16, 16+1), 16 is 16 mod 500, 3 is 99-496 mod 100, _1025036=_1025036, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 16>500), (set_debug(eval, false), _1025114 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1025114])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 16>500), (set_debug(eval, false), _1025114 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1025114])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(282) [user] nop(notrace(no_repeats_var(_1025166)))
   <span class="ansi1 ansi32"
>Exit: </span>(282) [user] nop(notrace(no_repeats_var(_1025166)))
^  <span class="ansi1 ansi32"
>Exit: </span>(280) [system] once(user:(notrace((flag(eval_num, 16, 16+1), 16 is 16 mod 500, 3 is 99-496 mod 100, _1025036=_1025036, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 16>500), (set_debug(eval, false), _1025114 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1025114])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1025166)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] must_det_ll(user:(notrace((flag(eval_num, 16, 16+1), 16 is 16 mod 500, 3 is 99-496 mod 100, _1025036=_1025036, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 16>500), (set_debug(eval, false), _1025114 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1025114])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1025166)))))
   <span class="ansi1 ansi32"
>Call: </span>(279) [occurs] occurs:sub_term(_1035720, defn)
   <span class="ansi1 ansi32"
>Exit: </span>(279) [occurs] occurs:sub_term(defn, defn)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] defn\=defn
   <span class="ansi1 ansi31"
>Fail: </span>(279) [system] defn\=defn
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(280) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(279) [occurs] occurs:sub_term(_1035720, defn)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] _1042210=defn
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] defn=defn
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] if_trace((eval;defn), (_1025036=1, indentq(3, 16, -->, [defn, ['if-unify-or-empty', _407092, _407092]])))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [system] setup_call_cleanup('$notrace'(_1045086, _1045088), once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _1025036=1, indentq(3, 16, -->, [defn, ['if-unify-or-empty', _407092, _407092]]))), _1045044, fbug((_1045044-->if_trace((eval;defn), (_1025036=1, indentq(3, 16, -->, [defn, ['if-unify-or-empty', _407092, _407092]])))))))), '$restore_trace'(_1045086, _1045088))
^  <span class="ansi1 ansi32"
>Call: </span>(282) [system] sig_atomic(system:'$notrace'(_1045086, _1045088))
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _1025036=1, indentq(3, 16, -->, [defn, ['if-unify-or-empty', _407092, _407092]]))), _1045044, fbug((_1045044-->if_trace((eval;defn), (_1025036=1, indentq(3, 16, -->, [defn, ['if-unify-or-empty', _407092, _407092]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] if_trace((eval;defn), (_1025036=1, indentq(3, 16, -->, [defn, ['if-unify-or-empty', _407092, _407092]])))
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] _1048930=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] _1050792=(\+ \+ (flag(eval_num, _1050812, _1050812+1), (retval(fail)\=@=retval(fail), nonvar(_750256)->indentq(3, _1050812, <--, [defn, _750256]);indentq(3, _1050812, <--, [defn, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] (\+ \+ (flag(eval_num, _1050812, _1050812+1), (retval(fail)\=@=retval(fail), nonvar(_750256)->indentq(3, _1050812, <--, [defn, _750256]);indentq(3, _1050812, <--, [defn, retval(fail)]))))=(\+ \+ (flag(eval_num, _1050812, _1050812+1), (retval(fail)\=@=retval(fail), nonvar(_750256)->indentq(3, _1050812, <--, [defn, _750256]);indentq(3, _1050812, <--, [defn, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] call_cleanup(((call(eval_defn_choose_candidates(=, _613162), 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256)*->nb_setarg(1, retval(fail), _750256);fail, trace, call(eval_defn_choose_candidates(=, _613162), 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256)), ignore(notrace((\+_750256\=_1025166, nb_setarg(1, retval(fail), _750256))))), ignore((_1025036==1->ignore(\+ \+ (flag(eval_num, _1050812, _1050812+1), (retval(fail)\=@=retval(fail), nonvar(_750256)->indentq(3, _1050812, <--, [defn, _750256]);indentq(3, _1050812, <--, [defn, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1050812, _1050812+1), (retval(fail)\=@=retval(fail), nonvar(_750256)->indentq(3, _1050812, <--, [defn, _750256]);indentq(3, _1050812, <--, [defn, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] eval_defn_choose_candidates(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] findall((_1054802->_1054804), get_defn_expansions(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _1054802, _1054804), _1054822)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [$bags] findall((_1054802->_1054804), user:get_defn_expansions(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _1054802, _1054804), _1054822, [])
^  <span class="ansi1 ansi32"
>Call: </span>(284) [$bags] cleanup_bag(findall_loop((_1054802->_1054804), user:get_defn_expansions(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _1054802, _1054804), _1054822, []), '$destroy_findall_bag')
   <span class="ansi1 ansi32"
>Call: </span>(285) [$bags] findall_loop((_1054802->_1054804), user:get_defn_expansions(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _1054802, _1054804), _1054822, [])
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] get_defn_expansions(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _1054802, _1054804)
^  <span class="ansi1 ansi32"
>Call: </span>(287) [user] same_len_copy([_407092, _407092], _1059554)
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] length([_407092, _407092], _1060484)
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] var(_1060484)
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] var(_1060484)
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] []==[]
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] _1060484=2
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] 2=2
   <span class="ansi1 ansi32"
>Exit: </span>(288) [system] length([_407092, _407092], 2)
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] length(_1059554, 2)
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] var(2)
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] integer(2)
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] integer(2)
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] _1059554==[]
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] var(_1059554)
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] var(_1059554)
   <span class="ansi1 ansi32"
>Exit: </span>(288) [system] length([_1074388, _1074394], 2)
^  <span class="ansi1 ansi32"
>Exit: </span>(287) [user] same_len_copy([_407092, _407092], [_1074388, _1074394])
   <span class="ansi1 ansi32"
>Call: </span>(287) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _1074388, _1074394], _1054804)
^  <span class="ansi1 ansi32"
>Call: </span>(288) [user] ignore((=)=(=))
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] (=)=(=)
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] (=)=(=)
^  <span class="ansi1 ansi32"
>Exit: </span>(288) [system] ignore(user:((=)=(=)))
   <span class="ansi1 ansi32"
>Call: </span>(288) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _1074388, _1074394], _1054804]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _1074388, _1074394], _1054804]))
   <span class="ansi1 ansi32"
>Call: </span>(289) [user] metta_atom('&self', [=, ['if-unify-or-empty', _1074388, _1074394], _1054804])
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] typed_list('&self', _1082870, _1082792)
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(291) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(290) [user] typed_list('&self', _1085650, _1082792)
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _1074388, _1074394], _1054804])
^  <span class="ansi1 ansi32"
>Call: </span>(291) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _1074388, _1074394], _1054804], _1088440, _1088442)
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] loaded_into_kb('&self', _1089298)
^  <span class="ansi1 ansi32"
>Exit: </span>(292) [user] loaded_into_kb('&self', '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] once(user:asserted_metta_pred(_1091164, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] asserted_metta_pred(_1091164, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(293) [user] asserted_metta_pred(_1091164, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
   <span class="ansi1 ansi32"
>Call: </span>(290) [user] metta_atom_asserted('&self', [=, ['if-unify-or-empty', _1074388, _1074394], _1054804])
^  <span class="ansi1 ansi32"
>Call: </span>(291) [user] metta_atom_asserted_deduced('&self', [=, ['if-unify-or-empty', _1074388, _1074394], _1054804])
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(290) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(290) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(290) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _1074388, _1074394], _1054804])
^  <span class="ansi1 ansi32"
>Call: </span>(291) [user] typed_list('&corelib', _1102348, _1102270)
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(292) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(291) [user] typed_list('&corelib', _1105128, _1102270)
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(291) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _1074388, _1074394], _1054804])
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _1074388, _1074394], _1054804], _1107918, _1107920)
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] loaded_into_kb('&corelib', _1108776)
^  <span class="ansi1 ansi32"
>Exit: </span>(293) [user] loaded_into_kb('&corelib', '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] once(user:asserted_metta_pred(_1110642, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] asserted_metta_pred(_1110642, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(294) [user] asserted_metta_pred(_1110642, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi32"
>Exit: </span>(293) [user] loaded_into_kb('&corelib', '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] once(user:asserted_metta_pred(_1114368, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] asserted_metta_pred(_1114368, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(294) [user] asserted_metta_pred(_1114368, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
   <span class="ansi1 ansi32"
>Call: </span>(291) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _1074388, _1074394], _1054804])
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] metta_atom_asserted_deduced('&corelib', [=, ['if-unify-or-empty', _1074388, _1074394], _1054804])
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] fail
   <span class="ansi1 ansi32"
>Exit: </span>(291) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _1074388, _1074388], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(290) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _1074388, _1074388], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(289) [user] metta_atom('&self', [=, ['if-unify-or-empty', _1074388, _1074388], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(288) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _1074388, _1074388], unified]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _1074388, _1074388], unified]))
   <span class="ansi1 ansi32"
>Exit: </span>(287) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _1074388, _1074388], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [user] get_defn_expansions(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _1074388, _1074388], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(291) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _1074388, _1074394], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(290) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _1074388, _1074394], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(289) [user] metta_atom('&self', [=, ['if-unify-or-empty', _1074388, _1074394], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(288) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _1074388, _1074394], [empty]]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _1074388, _1074394], [empty]]))
   <span class="ansi1 ansi32"
>Exit: </span>(287) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _1074388, _1074394], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [user] get_defn_expansions(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _1074388, _1074394], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(285) [$bags] findall_loop((_1054802->_1054804), user:get_defn_expansions(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _1054802, _1054804), [(['if-unify-or-empty', _1133830, _1133830]->unified), (['if-unify-or-empty', _1133794, _1133800]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [$bags] cleanup_bag('$bags':findall_loop((_1054802->_1054804), user:get_defn_expansions(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _1054802, _1054804), [(['if-unify-or-empty', _1133830, _1133830]->unified), (['if-unify-or-empty', _1133794, _1133800]->[empty])], []), '$bags':'$destroy_findall_bag')
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [$bags] findall((_1054802->_1054804), user:get_defn_expansions(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _1054802, _1054804), [(['if-unify-or-empty', _1133830, _1133830]->unified), (['if-unify-or-empty', _1133794, _1133800]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [$bags] findall((_1054802->_1054804), user:get_defn_expansions(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _1054802, _1054804), [(['if-unify-or-empty', _1133830, _1133830]->unified), (['if-unify-or-empty', _1133794, _1133800]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] eval_defn_bodies(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256, [(['if-unify-or-empty', _1133830, _1133830]->unified), (['if-unify-or-empty', _1133794, _1133800]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] if_trace(e, maplist(print_templates(496, '   '), [(['if-unify-or-empty', _1133830, _1133830]->unified), (['if-unify-or-empty', _1133794, _1133800]->[empty])]))
^  <span class="ansi1 ansi32"
>Call: </span>(285) [system] setup_call_cleanup('$notrace'(_1139534, _1139536), once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(496, '   '), [(['if-unify-or-empty', _1133830, _1133830]->unified), (['if-unify-or-empty', _1133794, _1133800]->[empty])]))), _1139492, fbug((_1139492-->if_trace(e, maplist(print_templates(496, '   '), [(['if-unify-or-empty', _1133830, _1133830]->unified), (['if-unify-or-empty', _1133794, _1133800]->[empty])]))))))), '$restore_trace'(_1139534, _1139536))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [system] sig_atomic(system:'$notrace'(_1139534, _1139536))
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(496, '   '), [(['if-unify-or-empty', _1133830, _1133830]->unified), (['if-unify-or-empty', _1133794, _1133800]->[empty])]))), _1139492, fbug((_1139492-->if_trace(e, maplist(print_templates(496, '   '), [(['if-unify-or-empty', _1133830, _1133830]->unified), (['if-unify-or-empty', _1133794, _1133800]->[empty])]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [user] if_trace(e, maplist(print_templates(496, '   '), [(['if-unify-or-empty', _1133830, _1133830]->unified), (['if-unify-or-empty', _1133794, _1133800]->[empty])]))
   <span class="ansi1 ansi32"
>Call: </span>(283) [user] if_or_else((member((_1143392->_1143394), [(['if-unify-or-empty', _1133830, _1133830]->unified), (['if-unify-or-empty', _1133794, _1133800]->[empty])]), copy_term((_1143392->_1143394), _1143406), eval_defn_success(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256, _1143392, _1143394, _1143406)), eval_defn_failure(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256))
   <span class="ansi1 ansi32"
>Call: </span>(285) [lists] lists:member((_1143392->_1143394), [(['if-unify-or-empty', _1133830, _1133830]->unified), (['if-unify-or-empty', _1133794, _1133800]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(286) [lists] lists:member_([(['if-unify-or-empty', _1133794, _1133800]->[empty])], (_1143392->_1143394), (['if-unify-or-empty', _1133830, _1133830]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(286) [lists] lists:member_([(['if-unify-or-empty', _1133794, _1133800]->[empty])], (['if-unify-or-empty', _1133830, _1133830]->unified), (['if-unify-or-empty', _1133830, _1133830]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(285) [lists] lists:member((['if-unify-or-empty', _1133830, _1133830]->unified), [(['if-unify-or-empty', _1133830, _1133830]->unified), (['if-unify-or-empty', _1133794, _1133800]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] copy_term((['if-unify-or-empty', _1133830, _1133830]->unified), _1143406)
   <span class="ansi1 ansi32"
>Exit: </span>(285) [system] copy_term((['if-unify-or-empty', _1133830, _1133830]->unified), (['if-unify-or-empty', _1149028, _1149028]->unified))
^  <span class="ansi1 ansi32"
>Call: </span>(285) [user] eval_defn_success(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256, ['if-unify-or-empty', _1133830, _1133830], unified, (['if-unify-or-empty', _1149028, _1149028]->unified))
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] ['if-unify-or-empty', _407092, _407092]=['if-unify-or-empty', _1133830, _1133830]
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] ['if-unify-or-empty', _407092, _407092]=['if-unify-or-empty', _407092, _407092]
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] _750256=unified
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] unified=unified
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] ['if-unify-or-empty', _407092, _407092]\=@=unified
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] ['if-unify-or-empty', _407092, _407092]\=@=unified
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] if_trace(e, color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1149028, _1149028]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(288) [system] setup_call_cleanup('$notrace'(_1157484, _1157486), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1149028, _1149028]->unified)))))), _1157442, fbug((_1157442-->if_trace(e, color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1149028, _1149028]->unified)))))))))), '$restore_trace'(_1157484, _1157486))
^  <span class="ansi1 ansi32"
>Call: </span>(289) [system] sig_atomic(system:'$notrace'(_1157484, _1157486))
^  <span class="ansi1 ansi32"
>Exit: </span>(288) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1149028, _1149028]->unified)))))), _1157442, fbug((_1157442-->if_trace(e, color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1149028, _1149028]->unified)))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [user] if_trace(e, color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1149028, _1149028]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] light_eval(=, _613162, 496, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [user] light_eval(=, _613162, 496, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [user] eval_defn_success(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified, ['if-unify-or-empty', _407092, _407092], unified, (['if-unify-or-empty', _1149028, _1149028]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(283) [user] if_or_else((member((['if-unify-or-empty', _407092, _407092]->unified), [(['if-unify-or-empty', _407092, _407092]->unified), (['if-unify-or-empty', _1133794, _1133800]->[empty])]), copy_term((['if-unify-or-empty', _407092, _407092]->unified), (['if-unify-or-empty', _1149028, _1149028]->unified)), eval_defn_success(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified, ['if-unify-or-empty', _407092, _407092], unified, (['if-unify-or-empty', _1149028, _1149028]->unified))), eval_defn_failure(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] eval_defn_bodies(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified, [(['if-unify-or-empty', _407092, _407092]->unified), (['if-unify-or-empty', _1133794, _1133800]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [user] eval_defn_choose_candidates(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] ignore(notrace((\+unified\=_1025166, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [system] setup_call_cleanup('$notrace'(_1169788, _1169790), once(user:(\+unified\=_1025166, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_1169788, _1169790))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] sig_atomic(system:'$notrace'(_1169788, _1169790))
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_1025166, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [system] ignore(user:notrace((\+unified\=_1025166, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _613162), 496, '&self', ['if-unify-or-empty', _407092, _407092], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_defn_choose_candidates(=, _613162), 496, '&self', ['if-unify-or-empty', _407092, _407092], unified)), ignore(notrace((\+unified\=_1025166, nb_setarg(1, retval(unified), unified))))), user:ignore((_1025036==1->ignore(\+ \+ (flag(eval_num, _1050812, _1050812+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(3, _1050812, <--, [defn, unified]);indentq(3, _1050812, <--, [defn, retval(unified)]))));notrace(ignore(if_t(3<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1050812, _1050812+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(3, _1050812, <--, [defn, unified]);indentq(3, _1050812, <--, [defn, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [user] trace_eval(eval_defn_choose_candidates(=, _613162), defn, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [user] eval_maybe_defn(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(276) [user] if_or_else(eval_maybe_defn(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified), eval_maybe_subst(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified))
   <span class="ansi1 ansi32"
>Exit: </span>(275) [user] if_or_else(eval_maybe_host_function(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified), if_or_else(eval_maybe_defn(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified), eval_maybe_subst(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified)))
   <span class="ansi1 ansi32"
>Exit: </span>(274) [user] if_or_else(eval_maybe_host_predicate(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified), if_or_else(eval_maybe_host_function(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified), if_or_else(eval_maybe_defn(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified), eval_maybe_subst(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified))))
   <span class="ansi1 ansi32"
>Exit: </span>(273) [user] if_or_else(eval_maybe_python(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified), if_or_else(eval_maybe_host_predicate(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified), if_or_else(eval_maybe_host_function(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified), if_or_else(eval_maybe_defn(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified), eval_maybe_subst(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] eval_70(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] check_returnval(=, _613162, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] check_returnval(=, _613162, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [user] eval_41(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [user] eval_40(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] unified=_627302
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] eval_20(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified)
   <span class="ansi1 ansi32"
>Call: </span>(269) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(269) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] ignore(notrace((\+unified\=_628458, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(271) [system] setup_call_cleanup('$notrace'(_1192206, _1192208), once(user:(\+unified\=_628458, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_1192206, _1192208))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] sig_atomic(system:'$notrace'(_1192206, _1192208))
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_628458, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [system] ignore(user:notrace((\+unified\=_628458, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [system] call_cleanup(user:((call(eval_20(=, _613162), 496, '&self', ['if-unify-or-empty', _407092, _407092], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_20(=, _613162), 496, '&self', ['if-unify-or-empty', _407092, _407092], unified)), ignore(notrace((\+unified\=_628458, nb_setarg(1, retval(unified), unified))))), user:ignore((_628328==1->ignore(\+ \+ (flag(eval_num, _654104, _654104+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(3, _654104, <--, [e, unified]);indentq(3, _654104, <--, [e, retval(unified)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _654104, _654104+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(3, _654104, <--, [e, unified]);indentq(3, _654104, <--, [e, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] trace_eval(eval_20(=, _613162), e, 496, '&self', ['if-unify-or-empty', _407092, _407092], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] self_eval(unified)
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_1200648, _1200650), once(user:self_eval0(unified)), '$restore_trace'(_1200648, _1200650))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_1200648, _1200650))
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(unified)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] self_eval(unified)
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] _598092=unified
   <span class="ansi1 ansi32"
>Exit: </span>(266) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [user] eval_01(=, _613162, 497, '&self', ['if-unify-or-empty', _407092, _407092], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(264) [user] eval_00(=, _613162, 497, '&self', ['if-unify-or-empty', _407092, _407092], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [user] eval_args(=, _613162, 497, '&self', ['if-unify-or-empty', _407092, _407092], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [system] setup_call_cleanup('$notrace'(_1210086, _1210088), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _1210044, fbug((_1210044-->if_trace(case, writeqln(switch=unified))))))), '$restore_trace'(_1210086, _1210088))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [system] sig_atomic(system:'$notrace'(_1210086, _1210088))
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _1210044, fbug((_1210044-->if_trace(case, writeqln(switch=unified))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] select_case(497, '&self', unified, ['Empty'-_407110], _1213930)
^  <span class="ansi1 ansi32"
>Call: </span>(264) [user] best_key(unified, ['Empty'-_407110], _1213930)
   <span class="ansi1 ansi32"
>Call: </span>(265) [lists] lists:member(_1215806-_1213930, ['Empty'-_407110])
   <span class="ansi1 ansi32"
>Call: </span>(266) [lists] lists:member_([], _1215806-_1213930, 'Empty'-_407110)
   <span class="ansi1 ansi32"
>Exit: </span>(266) [lists] lists:member_([], 'Empty'-_407110, 'Empty'-_407110)
   <span class="ansi1 ansi32"
>Exit: </span>(265) [lists] lists:member('Empty'-_407110, ['Empty'-_407110])
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] unified='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(265) [lists] lists:member(_1220460-_1213930, ['Empty'-_407110])
   <span class="ansi1 ansi32"
>Call: </span>(266) [lists] lists:member_([], _1220460-_1213930, 'Empty'-_407110)
   <span class="ansi1 ansi32"
>Exit: </span>(266) [lists] lists:member_([], 'Empty'-_407110, 'Empty'-_407110)
   <span class="ansi1 ansi32"
>Exit: </span>(265) [lists] lists:member('Empty'-_407110, ['Empty'-_407110])
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] unified=='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(265) [lists] lists:member(_1225114-_1213930, ['Empty'-_407110])
   <span class="ansi1 ansi32"
>Call: </span>(266) [lists] lists:member_([], _1225114-_1213930, 'Empty'-_407110)
   <span class="ansi1 ansi32"
>Exit: </span>(266) [lists] lists:member_([], 'Empty'-_407110, 'Empty'-_407110)
   <span class="ansi1 ansi32"
>Exit: </span>(265) [lists] lists:member('Empty'-_407110, ['Empty'-_407110])
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] unified=@='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(265) [lists] lists:member(_1229768-_1213930, ['Empty'-_407110])
   <span class="ansi1 ansi32"
>Call: </span>(266) [lists] lists:member_([], _1229768-_1213930, 'Empty'-_407110)
   <span class="ansi1 ansi32"
>Exit: </span>(266) [lists] lists:member_([], 'Empty'-_407110, 'Empty'-_407110)
   <span class="ansi1 ansi32"
>Exit: </span>(265) [lists] lists:member('Empty'-_407110, ['Empty'-_407110])
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] unified='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(264) [user] maybe_special_keys(497, '&self', ['Empty'-_407110], _1234420)
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] eval_args(497, '&self', 'Empty', _1235366)
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] eval_args(=, _1236382, 497, '&self', 'Empty', _1235366)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] var('Empty')
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_1238186, _1238188), once(user:self_eval('Empty')), '$restore_trace'(_1238186, _1238188))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_1238186, _1238188))
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval('Empty')), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] _1235366='Empty'
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] 'Empty'='Empty'
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] eval_args(=, _1243000, 497, '&self', 'Empty', 'Empty')
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [user] eval_args(497, '&self', 'Empty', 'Empty')
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] 'Empty'\=@='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] maybe_special_keys(497, '&self', [], _1234420)
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [user] maybe_special_keys(497, '&self', [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(264) [user] maybe_special_keys(497, '&self', ['Empty'-_407110], [])
^  <span class="ansi1 ansi32"
>Call: </span>(264) [user] best_key(unified, [], _1213930)
   <span class="ansi1 ansi32"
>Call: </span>(265) [lists] lists:member(_1249474-_1213930, [])
   <span class="ansi1 ansi32"
>Call: </span>(265) [lists] lists:member(_1250408-_1213930, [])
   <span class="ansi1 ansi32"
>Call: </span>(265) [lists] lists:member(_1251342-_1213930, [])
   <span class="ansi1 ansi32"
>Call: </span>(265) [lists] lists:member(_1252276-_1213930, [])
   <span class="ansi1 ansi32"
>Call: </span>(264) [lists] lists:member(_1253210-_1213930, [])
   <span class="ansi1 ansi32"
>Call: </span>(263) [lists] lists:member(_1254144-_1254146, ['Empty'-_407110])
   <span class="ansi1 ansi32"
>Call: </span>(264) [lists] lists:member_([], _1254144-_1254146, 'Empty'-_407110)
   <span class="ansi1 ansi32"
>Exit: </span>(264) [lists] lists:member_([], 'Empty'-_407110, 'Empty'-_407110)
   <span class="ansi1 ansi32"
>Exit: </span>(263) [lists] lists:member('Empty'-_407110, ['Empty'-_407110])
   <span class="ansi1 ansi32"
>Call: </span>(263) [system] 'Empty'=='%void%'
   <span class="ansi1 ansi32"
>Call: </span>(287) [lists] lists:member_([], (_1143392->_1143394), (['if-unify-or-empty', _1133794, _1133800]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(287) [lists] lists:member_([], (['if-unify-or-empty', _1133794, _1133800]->[empty]), (['if-unify-or-empty', _1133794, _1133800]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(286) [lists] lists:member_([(['if-unify-or-empty', _1133794, _1133800]->[empty])], (['if-unify-or-empty', _1133794, _1133800]->[empty]), (['if-unify-or-empty', _1133830, _1133830]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(285) [lists] lists:member((['if-unify-or-empty', _1133794, _1133800]->[empty]), [(['if-unify-or-empty', _1133830, _1133830]->unified), (['if-unify-or-empty', _1133794, _1133800]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] copy_term((['if-unify-or-empty', _1133794, _1133800]->[empty]), _1143406)
   <span class="ansi1 ansi32"
>Exit: </span>(285) [system] copy_term((['if-unify-or-empty', _1133794, _1133800]->[empty]), (['if-unify-or-empty', _1263464, _1263470]->[empty]))
^  <span class="ansi1 ansi32"
>Call: </span>(285) [user] eval_defn_success(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], _750256, ['if-unify-or-empty', _1133794, _1133800], [empty], (['if-unify-or-empty', _1263464, _1263470]->[empty]))
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] ['if-unify-or-empty', _407092, _407092]=['if-unify-or-empty', _1133794, _1133800]
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] ['if-unify-or-empty', _407092, _407092]=['if-unify-or-empty', _407092, _407092]
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] _750256=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] [empty]=[empty]
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] ['if-unify-or-empty', _407092, _407092]\=@=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] ['if-unify-or-empty', _407092, _407092]\=@=[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] if_trace(e, color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1263464, _1263470]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(288) [system] setup_call_cleanup('$notrace'(_1271920, _1271922), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1263464, _1263470]->[empty])))))), _1271878, fbug((_1271878-->if_trace(e, color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1263464, _1263470]->[empty])))))))))), '$restore_trace'(_1271920, _1271922))
^  <span class="ansi1 ansi32"
>Call: </span>(289) [system] sig_atomic(system:'$notrace'(_1271920, _1271922))
^  <span class="ansi1 ansi32"
>Exit: </span>(288) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1263464, _1263470]->[empty])))))), _1271878, fbug((_1271878-->if_trace(e, color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1263464, _1263470]->[empty])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [user] if_trace(e, color_g_mesg('#773700', indentq2(496, defs_used((['if-unify-or-empty', _1263464, _1263470]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] light_eval(=, _613162, 496, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [user] light_eval(=, _613162, 496, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [user] eval_defn_success(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty], ['if-unify-or-empty', _407092, _407092], [empty], (['if-unify-or-empty', _1263464, _1263470]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(283) [user] if_or_else((member((['if-unify-or-empty', _407092, _407092]->[empty]), [(['if-unify-or-empty', _1133830, _1133830]->unified), (['if-unify-or-empty', _407092, _407092]->[empty])]), copy_term((['if-unify-or-empty', _407092, _407092]->[empty]), (['if-unify-or-empty', _1263464, _1263470]->[empty])), eval_defn_success(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty], ['if-unify-or-empty', _407092, _407092], [empty], (['if-unify-or-empty', _1263464, _1263470]->[empty]))), eval_defn_failure(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty]))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] eval_defn_bodies(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty], [(['if-unify-or-empty', _1133830, _1133830]->unified), (['if-unify-or-empty', _407092, _407092]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [user] eval_defn_choose_candidates(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] ignore(notrace((\+[empty]\=_1025166, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [system] setup_call_cleanup('$notrace'(_1284232, _1284234), once(user:(\+[empty]\=_1025166, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_1284232, _1284234))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] sig_atomic(system:'$notrace'(_1284232, _1284234))
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_1025166, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [system] ignore(user:notrace((\+[empty]\=_1025166, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] ignore((_1025036==1->ignore(\+ \+ (flag(eval_num, _1050812, _1050812+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1050812, <--, [defn, [empty]]);indentq(3, _1050812, <--, [defn, retval([empty])]))));notrace(ignore(if_t(3<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1050812, _1050812+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1050812, <--, [defn, [empty]]);indentq(3, _1050812, <--, [defn, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] _1025036==1
   <span class="ansi1 ansi31"
>Fail: </span>(283) [system] _1025036==1
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] setup_call_cleanup('$notrace'(_1290808, _1290810), once(user:ignore(if_t(3<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1050812, _1050812+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1050812, <--, [defn, [empty]]);indentq(3, _1050812, <--, [defn, retval([empty])])))))))), '$restore_trace'(_1290808, _1290810))
^  <span class="ansi1 ansi32"
>Call: </span>(285) [system] sig_atomic(system:'$notrace'(_1290808, _1290810))
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(3<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1050812, _1050812+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1050812, <--, [defn, [empty]]);indentq(3, _1050812, <--, [defn, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [system] ignore(user:(_1025036==1->ignore(\+ \+ (flag(eval_num, _1050812, _1050812+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1050812, <--, [defn, [empty]]);indentq(3, _1050812, <--, [defn, retval([empty])]))));notrace(ignore(if_t(3<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1050812, _1050812+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1050812, <--, [defn, [empty]]);indentq(3, _1050812, <--, [defn, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _613162), 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_defn_choose_candidates(=, _613162), 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty])), ignore(notrace((\+[empty]\=_1025166, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_1025036==1->ignore(\+ \+ (flag(eval_num, _1050812, _1050812+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1050812, <--, [defn, [empty]]);indentq(3, _1050812, <--, [defn, retval([empty])]))));notrace(ignore(if_t(3<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1050812, _1050812+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _1050812, <--, [defn, [empty]]);indentq(3, _1050812, <--, [defn, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [user] trace_eval(eval_defn_choose_candidates(=, _613162), defn, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [user] eval_maybe_defn(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(276) [user] if_or_else(eval_maybe_defn(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty]), eval_maybe_subst(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(275) [user] if_or_else(eval_maybe_host_function(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty]), if_or_else(eval_maybe_defn(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty]), eval_maybe_subst(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty])))
   <span class="ansi1 ansi32"
>Exit: </span>(274) [user] if_or_else(eval_maybe_host_predicate(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty]), if_or_else(eval_maybe_host_function(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty]), if_or_else(eval_maybe_defn(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty]), eval_maybe_subst(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty]))))
   <span class="ansi1 ansi32"
>Exit: </span>(273) [user] if_or_else(eval_maybe_python(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty]), if_or_else(eval_maybe_host_predicate(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty]), if_or_else(eval_maybe_host_function(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty]), if_or_else(eval_maybe_defn(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty]), eval_maybe_subst(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty])))))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] eval_70(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] check_returnval(=, _613162, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] check_returnval(=, _613162, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [user] eval_41(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [user] eval_40(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] [empty]=_627302
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] [empty]=[empty]
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] eval_20(=, _613162, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(269) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(269) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] ignore(notrace((\+[empty]\=_628458, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(271) [system] setup_call_cleanup('$notrace'(_1313400, _1313402), once(user:(\+[empty]\=_628458, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_1313400, _1313402))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] sig_atomic(system:'$notrace'(_1313400, _1313402))
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_628458, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [system] ignore(user:notrace((\+[empty]\=_628458, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] ignore((_628328==1->ignore(\+ \+ (flag(eval_num, _654104, _654104+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _654104, <--, [e, [empty]]);indentq(3, _654104, <--, [e, retval([empty])]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _654104, _654104+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _654104, <--, [e, [empty]]);indentq(3, _654104, <--, [e, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] _628328==1
   <span class="ansi1 ansi31"
>Fail: </span>(271) [system] _628328==1
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] setup_call_cleanup('$notrace'(_1319976, _1319978), once(user:ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _654104, _654104+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _654104, <--, [e, [empty]]);indentq(3, _654104, <--, [e, retval([empty])])))))))), '$restore_trace'(_1319976, _1319978))
^  <span class="ansi1 ansi32"
>Call: </span>(273) [system] sig_atomic(system:'$notrace'(_1319976, _1319978))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _654104, _654104+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _654104, <--, [e, [empty]]);indentq(3, _654104, <--, [e, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [system] ignore(user:(_628328==1->ignore(\+ \+ (flag(eval_num, _654104, _654104+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _654104, <--, [e, [empty]]);indentq(3, _654104, <--, [e, retval([empty])]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _654104, _654104+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _654104, <--, [e, [empty]]);indentq(3, _654104, <--, [e, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [system] call_cleanup(user:((call(eval_20(=, _613162), 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_20(=, _613162), 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty])), ignore(notrace((\+[empty]\=_628458, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_628328==1->ignore(\+ \+ (flag(eval_num, _654104, _654104+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _654104, <--, [e, [empty]]);indentq(3, _654104, <--, [e, retval([empty])]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _654104, _654104+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(3, _654104, <--, [e, [empty]]);indentq(3, _654104, <--, [e, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] trace_eval(eval_20(=, _613162), e, 496, '&self', ['if-unify-or-empty', _407092, _407092], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_1328584, _1328586), once(user:self_eval0([empty])), '$restore_trace'(_1328584, _1328586))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_1328584, _1328586))
^  <span class="ansi1 ansi31"
>Fail: </span>(266) [user] self_eval([empty])
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] [empty]=@=['if-unify-or-empty', _626348, _626348]
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] eval_01(=, _613162, 496, '&self', [empty], _1332336)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] [empty]\==[empty]
   <span class="ansi1 ansi32"
>Call: </span>(263) [lists] lists:member(_1334218-_1334220, ['Empty'-_407110])
   <span class="ansi1 ansi32"
>Call: </span>(264) [lists] lists:member_([], _1334218-_1334220, 'Empty'-_407110)
   <span class="ansi1 ansi32"
>Exit: </span>(264) [lists] lists:member_([], 'Empty'-_407110, 'Empty'-_407110)
   <span class="ansi1 ansi32"
>Exit: </span>(263) [lists] lists:member('Empty'-_407110, ['Empty'-_407110])
   <span class="ansi1 ansi32"
>Call: </span>(263) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi31"
>Fail: </span>(261) [user] eval_20(=, _416824, 497, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _465566)
   <span class="ansi1 ansi32"
>Call: </span>(261) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(261) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(261) [user] ignore((_466592==1->ignore(\+ \+ (flag(eval_num, _492368, _492368+1), (retval(fail)\=@=retval(fail), nonvar(_465566)->indentq(2, _492368, <--, [e, _465566]);indentq(2, _492368, <--, [e, retval(fail)]))));notrace(ignore(if_t(2<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _492368, _492368+1), (retval(fail)\=@=retval(fail), nonvar(_465566)->indentq(2, _492368, <--, [e, _465566]);indentq(2, _492368, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(263) [system] _466592==1
   <span class="ansi1 ansi31"
>Fail: </span>(263) [system] _466592==1
^  <span class="ansi1 ansi32"
>Call: </span>(264) [system] setup_call_cleanup('$notrace'(_1344446, _1344448), once(user:ignore(if_t(2<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _492368, _492368+1), (retval(fail)\=@=retval(fail), nonvar(_465566)->indentq(2, _492368, <--, [e, _465566]);indentq(2, _492368, <--, [e, retval(fail)])))))))), '$restore_trace'(_1344446, _1344448))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [system] sig_atomic(system:'$notrace'(_1344446, _1344448))
^  <span class="ansi1 ansi32"
>Exit: </span>(264) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(2<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _492368, _492368+1), (retval(fail)\=@=retval(fail), nonvar(_465566)->indentq(2, _492368, <--, [e, _465566]);indentq(2, _492368, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(261) [system] ignore(user:(_466592==1->ignore(\+ \+ (flag(eval_num, _492368, _492368+1), (retval(fail)\=@=retval(fail), nonvar(_465566)->indentq(2, _492368, <--, [e, _465566]);indentq(2, _492368, <--, [e, retval(fail)]))));notrace(ignore(if_t(2<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _492368, _492368+1), (retval(fail)\=@=retval(fail), nonvar(_465566)->indentq(2, _492368, <--, [e, _465566]);indentq(2, _492368, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(259) [system] call_cleanup(user:((call(eval_20(=, _416824), 497, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _465566)*->nb_setarg(1, retval(fail), _465566);fail, trace, call(eval_20(=, _416824), 497, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _465566)), ignore(notrace((\+_465566\=_466722, nb_setarg(1, retval(fail), _465566))))), user:ignore((_466592==1->ignore(\+ \+ (flag(eval_num, _492368, _492368+1), (retval(fail)\=@=retval(fail), nonvar(_465566)->indentq(2, _492368, <--, [e, _465566]);indentq(2, _492368, <--, [e, retval(fail)]))));notrace(ignore(if_t(2<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _492368, _492368+1), (retval(fail)\=@=retval(fail), nonvar(_465566)->indentq(2, _492368, <--, [e, _465566]);indentq(2, _492368, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(258) [user] trace_eval(eval_20(=, _416824), e, 497, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _465566)
^  <span class="ansi1 ansi31"
>Fail: </span>(255) [user] eval_args(=, _416824, 498, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130)
^  <span class="ansi1 ansi32"
>Call: </span>(252) [user] call(eval, [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130)
   <span class="ansi1 ansi32"
>Call: </span>(253) [user] eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130)
^  <span class="ansi1 ansi32"
>Call: </span>(254) [user] current_self(_1353062)
   <span class="ansi1 ansi32"
>Call: </span>(255) [system] nb_current(self_space, _1353062)
   <span class="ansi1 ansi32"
>Exit: </span>(255) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(255) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(255) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(254) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(254) [user] eval('&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130)
   <span class="ansi1 ansi32"
>Call: </span>(255) [user] eval_H(500, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130)
^  <span class="ansi1 ansi32"
>Call: </span>(256) [user] fast_option_value(compile, save)
   <span class="ansi1 ansi32"
>Call: </span>(257) [system] atom(compile)
   <span class="ansi1 ansi32"
>Exit: </span>(257) [system] atom(compile)
   <span class="ansi1 ansi32"
>Call: </span>(257) [system] current_prolog_flag(compile, save)
   <span class="ansi1 ansi31"
>Fail: </span>(257) [system] current_prolog_flag(compile, save)
^  <span class="ansi1 ansi31"
>Fail: </span>(256) [user] fast_option_value(compile, save)
^  <span class="ansi1 ansi32"
>Call: </span>(256) [user] catch_metta_return(eval_args(=, _1366032, 500, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130), _420130)
^  <span class="ansi1 ansi32"
>Call: </span>(258) [user] eval_args(=, _1366032, 500, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130)
   <span class="ansi1 ansi32"
>Call: </span>(259) [system] var([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Call: </span>(260) [system] setup_call_cleanup('$notrace'(_1368878, _1368880), once(user:self_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])), '$restore_trace'(_1368878, _1368880))
^  <span class="ansi1 ansi32"
>Call: </span>(261) [system] sig_atomic(system:'$notrace'(_1368878, _1368880))
^  <span class="ansi1 ansi32"
>Call: </span>(260) [system] setup_call_cleanup('$notrace'(_1370790, _1370792), once(user:nonvar(_420130)), '$restore_trace'(_1370790, _1370792))
^  <span class="ansi1 ansi32"
>Call: </span>(261) [system] sig_atomic(system:'$notrace'(_1370790, _1370792))
^  <span class="ansi1 ansi32"
>Call: </span>(260) [system] setup_call_cleanup('$notrace'(_1372702, _1372704), once(user:nonvar(_420130)), '$restore_trace'(_1372702, _1372704))
^  <span class="ansi1 ansi32"
>Call: </span>(261) [system] sig_atomic(system:'$notrace'(_1372702, _1372704))
   <span class="ansi1 ansi32"
>Call: </span>(259) [system] [['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(259) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(259) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(259) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(259) [user] self_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Call: </span>(261) [system] setup_call_cleanup('$notrace'(_1379242, _1379244), once(user:self_eval0([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])), '$restore_trace'(_1379242, _1379244))
^  <span class="ansi1 ansi32"
>Call: </span>(262) [system] sig_atomic(system:'$notrace'(_1379242, _1379244))
^  <span class="ansi1 ansi31"
>Fail: </span>(259) [user] self_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Call: </span>(259) [user] eval_00(=, _1366032, 500, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130)
^  <span class="ansi1 ansi32"
>Call: </span>(260) [user] self_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Call: </span>(262) [system] setup_call_cleanup('$notrace'(_1383946, _1383948), once(user:self_eval0([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])), '$restore_trace'(_1383946, _1383948))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [system] sig_atomic(system:'$notrace'(_1383946, _1383948))
^  <span class="ansi1 ansi31"
>Fail: </span>(260) [user] self_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Call: </span>(260) [user] eval_01(=, _1366032, 500, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _420130)
   <span class="ansi1 ansi32"
>Call: </span>(261) [system] [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(261) [system] [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(261) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(263) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(263) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(261) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(262) [system] setup_call_cleanup('$notrace'(_1393340, _1393342), once(user:(_1393316 is 500-1, copy_term([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _1393330))), '$restore_trace'(_1393340, _1393342))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [system] sig_atomic(system:'$notrace'(_1393340, _1393342))
^  <span class="ansi1 ansi32"
>Exit: </span>(262) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], [case, ['if-unify-or-empty', _1395262, _1395262], [['Empty', _1395292]]]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(261) [user] trace_eval(eval_20(=, _1366032), e, 499, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _1396240)
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] must_det_ll((notrace((flag(eval_num, _1397206, _1397206+1), _1397224 is _1397206 mod 500, _1397242 is 99-499 mod 100, _1397266=_1397268, option_else('trace-length', _1397280, 500), option_else('trace-depth', _1397288, 30))), quietly(if_t((nop(stop_rtrace), _1397224>_1397280), (set_debug(eval, false), _1397344 is _1397280+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1397344])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1397396)))))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [user] once(user:(notrace((flag(eval_num, _1397206, _1397206+1), _1397224 is _1397206 mod 500, _1397242 is 99-499 mod 100, _1397266=_1397268, option_else('trace-length', _1397280, 500), option_else('trace-depth', _1397288, 30))), quietly(if_t((nop(stop_rtrace), _1397224>_1397280), (set_debug(eval, false), _1397344 is _1397280+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1397344])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1397396)))))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [system] setup_call_cleanup('$notrace'(_1399266, _1399268), once(user:(flag(eval_num, _1397206, _1397206+1), _1397224 is _1397206 mod 500, _1397242 is 99-499 mod 100, _1397266=_1397268, option_else('trace-length', _1397280, 500), option_else('trace-depth', _1397288, 30))), '$restore_trace'(_1399266, _1399268))
^  <span class="ansi1 ansi32"
>Call: </span>(267) [system] sig_atomic(system:'$notrace'(_1399266, _1399268))
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 17, 17+1), 17 is 17 mod 500, 0 is 99-499 mod 100, _1397266=_1397266, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 17>500), (set_debug(eval, false), _1397344 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1397344])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 17>500), (set_debug(eval, false), _1397344 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1397344])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(265) [user] nop(notrace(no_repeats_var(_1397396)))
   <span class="ansi1 ansi32"
>Exit: </span>(265) [user] nop(notrace(no_repeats_var(_1397396)))
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [system] once(user:(notrace((flag(eval_num, 17, 17+1), 17 is 17 mod 500, 0 is 99-499 mod 100, _1397266=_1397266, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 17>500), (set_debug(eval, false), _1397344 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1397344])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1397396)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(262) [user] must_det_ll(user:(notrace((flag(eval_num, 17, 17+1), 17 is 17 mod 500, 0 is 99-499 mod 100, _1397266=_1397266, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 17>500), (set_debug(eval, false), _1397344 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1397344])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1397396)))))
   <span class="ansi1 ansi32"
>Call: </span>(262) [occurs] occurs:sub_term(_1407950, e)
   <span class="ansi1 ansi32"
>Exit: </span>(262) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(262) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(263) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(263) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(262) [occurs] occurs:sub_term(_1407950, e)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] _1414440=e
   <span class="ansi1 ansi32"
>Exit: </span>(262) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] if_trace((eval;e), (_1397266=1, indentq(0, 17, -->, [e, [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(264) [system] setup_call_cleanup('$notrace'(_1417316, _1417318), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _1397266=1, indentq(0, 17, -->, [e, [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]]))), _1417274, fbug((_1417274-->if_trace((eval;e), (_1397266=1, indentq(0, 17, -->, [e, [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]])))))))), '$restore_trace'(_1417316, _1417318))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [system] sig_atomic(system:'$notrace'(_1417316, _1417318))
^  <span class="ansi1 ansi32"
>Exit: </span>(264) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _1397266=1, indentq(0, 17, -->, [e, [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]]))), _1417274, fbug((_1417274-->if_trace((eval;e), (_1397266=1, indentq(0, 17, -->, [e, [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(262) [user] if_trace((eval;e), (_1397266=1, indentq(0, 17, -->, [e, [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]])))
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] _1421160=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(262) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(262) [system] _1423022=(\+ \+ (flag(eval_num, _1423042, _1423042+1), (retval(fail)\=@=retval(fail), nonvar(_1396240)->indentq(0, _1423042, <--, [e, _1396240]);indentq(0, _1423042, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(262) [system] (\+ \+ (flag(eval_num, _1423042, _1423042+1), (retval(fail)\=@=retval(fail), nonvar(_1396240)->indentq(0, _1423042, <--, [e, _1396240]);indentq(0, _1423042, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _1423042, _1423042+1), (retval(fail)\=@=retval(fail), nonvar(_1396240)->indentq(0, _1423042, <--, [e, _1396240]);indentq(0, _1423042, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(262) [user] call_cleanup(((call(eval_20(=, _1366032), 499, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _1396240)*->nb_setarg(1, retval(fail), _1396240);fail, trace, call(eval_20(=, _1366032), 499, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _1396240)), ignore(notrace((\+_1396240\=_1397396, nb_setarg(1, retval(fail), _1396240))))), ignore((_1397266==1->ignore(\+ \+ (flag(eval_num, _1423042, _1423042+1), (retval(fail)\=@=retval(fail), nonvar(_1396240)->indentq(0, _1423042, <--, [e, _1396240]);indentq(0, _1423042, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1423042, _1423042+1), (retval(fail)\=@=retval(fail), nonvar(_1396240)->indentq(0, _1423042, <--, [e, _1396240]);indentq(0, _1423042, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(264) [user] eval_20(=, _1366032, 499, '&self', [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _1396240)
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] atom([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] no_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] self_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_1429814, _1429816), once(user:self_eval0([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])), '$restore_trace'(_1429814, _1429816))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_1429814, _1429816))
^  <span class="ansi1 ansi31"
>Fail: </span>(266) [user] self_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] atomic(case)
   <span class="ansi1 ansi32"
>Exit: </span>(266) [system] atomic(case)
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] is_sl(case)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] number(case)
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] [['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(265) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] callable(case)
   <span class="ansi1 ansi32"
>Exit: </span>(265) [system] callable(case)
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] [['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] is_list([['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
   <span class="ansi1 ansi32"
>Exit: </span>(265) [system] is_list([['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] is_list(case)
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] is_list([['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
   <span class="ansi1 ansi32"
>Exit: </span>(265) [system] is_list([['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] is_list([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
   <span class="ansi1 ansi32"
>Exit: </span>(265) [system] is_list([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] once(expand_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _1450222))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] expand_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _1450222)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] is_list([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] is_list([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] ground(case)
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] ground(case)
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] apply:maplist(expand_eval, [['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _1455794)
   <span class="ansi1 ansi32"
>Call: </span>(268) [apply] apply:maplist_([['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], _1455794, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] expand_eval(['if-unify-or-empty', _407092, _407092], _1457674)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] is_list(['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] is_list(['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] apply:maplist(expand_eval, [_407092, _407092], _1462312)
   <span class="ansi1 ansi32"
>Call: </span>(271) [apply] apply:maplist_([_407092, _407092], _1462312, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] expand_eval(_407092, _1464192)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] is_list(_407092)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] _407092=_1464192
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] _407092=_407092
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] expand_eval(_407092, _407092)
   <span class="ansi1 ansi32"
>Call: </span>(272) [apply] apply:maplist_([_407092], _1464194, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] expand_eval(_407092, _1469766)
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] is_list(_407092)
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] _407092=_1469766
   <span class="ansi1 ansi32"
>Exit: </span>(274) [system] _407092=_407092
^  <span class="ansi1 ansi32"
>Exit: </span>(273) [user] expand_eval(_407092, _407092)
   <span class="ansi1 ansi32"
>Call: </span>(273) [apply] apply:maplist_([], _1469768, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(273) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(272) [apply] apply:maplist_([_407092], [_407092], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(271) [apply] apply:maplist_([_407092, _407092], [_407092, _407092], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [apply] apply:maplist(user:expand_eval, [_407092, _407092], [_407092, _407092])
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] expand_eval(['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(269) [apply] apply:maplist_([[['Empty', _407110]]], _1457676, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] expand_eval([['Empty', _407110]], _1480934)
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] is_list([['Empty', _407110]])
   <span class="ansi1 ansi32"
>Exit: </span>(271) [system] is_list([['Empty', _407110]])
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] ground(['Empty', _407110])
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] apply:maplist(expand_eval, [], _1483718)
   <span class="ansi1 ansi32"
>Call: </span>(272) [apply] apply:maplist_([], _1483718, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(272) [apply] apply:maplist_([], [], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [apply] apply:maplist(user:expand_eval, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [user] expand_eval([['Empty', _407110]], [['Empty', _407110]])
   <span class="ansi1 ansi32"
>Call: </span>(270) [apply] apply:maplist_([], _1480936, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(270) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(269) [apply] apply:maplist_([[['Empty', _407110]]], [[['Empty', _407110]]], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(268) [apply] apply:maplist_([['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], [['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [apply] apply:maplist(user:expand_eval, [['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], [['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] expand_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [system] once(user:expand_eval([case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]], [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]))
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] [case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]\==[case, ['if-unify-or-empty', _407092, _407092], [['Empty', _407110]]]
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] is_progn(case)
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] is_space_op(case)
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(265) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] must_det_ll([]==[])
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] once(user:([]==[]))
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] []==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [system] once(user:([]==[]))
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [user] must_det_ll(user:([]==[]))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] into_case_list([['Empty', _407110]], _1506962)
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] is_list([['Empty', _407110]])
   <span class="ansi1 ansi32"
>Exit: </span>(266) [system] is_list([['Empty', _407110]])
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [user] into_case_list([['Empty', _407110]], [['Empty', _407110]])
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] into_case_keys(1, [['Empty', _407110]], _1510668)
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] _1511620 is 1+1
   <span class="ansi1 ansi32"
>Exit: </span>(266) [system] 2 is 1+1
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] is_case(_1511610, ['Empty', _407110], _1511612)
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] is_case('Empty', ['Empty', _407110], _407110)
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_407110)))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_1516346, _1516348), once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_407110))), _1516304, fbug((_1516304-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_407110)))))))), '$restore_trace'(_1516346, _1516348))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_1516346, _1516348))
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_407110))), _1516304, fbug((_1516304-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_407110)))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_407110)))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] into_case_keys(2, [], _1511606)
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] into_case_keys(2, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(265) [user] into_case_keys(1, [['Empty', _407110]], ['Empty'-_407110])
^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] eval_case(=, _1366032, 499, '&self', ['if-unify-or-empty', _407092, _407092], ['Empty'-_407110], _1396240)
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _407092, _407092]))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_1524922, _1524924), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _407092, _407092]))), _1524880, fbug((_1524880-->if_trace(case, writeqln(case=['if-unify-or-empty', _407092, _407092]))))))), '$restore_trace'(_1524922, _1524924))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_1524922, _1524924))
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _407092, _407092]))), _1524880, fbug((_1524880-->if_trace(case, writeqln(case=['if-unify-or-empty', _407092, _407092]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _407092, _407092]))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] eval_args(=, _1528844, 499, '&self', ['if-unify-or-empty', _407092, _407092], _1528766)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] var(['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_1530648, _1530650), once(user:self_eval(['if-unify-or-empty', _407092, _407092])), '$restore_trace'(_1530648, _1530650))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_1530648, _1530650))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_1532560, _1532562), once(user:nonvar(_1528766)), '$restore_trace'(_1532560, _1532562))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_1532560, _1532562))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_1534472, _1534474), once(user:nonvar(_1528766)), '$restore_trace'(_1534472, _1534474))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_1534472, _1534474))
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] [_407092, _407092]==[]
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(267) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] self_eval(['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] setup_call_cleanup('$notrace'(_1541012, _1541014), once(user:self_eval0(['if-unify-or-empty', _407092, _407092])), '$restore_trace'(_1541012, _1541014))
^  <span class="ansi1 ansi32"
>Call: </span>(270) [system] sig_atomic(system:'$notrace'(_1541012, _1541014))
^  <span class="ansi1 ansi31"
>Fail: </span>(267) [user] self_eval(['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] eval_00(=, _1543836, 499, '&self', ['if-unify-or-empty', _407092, _407092], _1528766)
^  <span class="ansi1 ansi32"
>Call: </span>(268) [user] self_eval(['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(270) [system] setup_call_cleanup('$notrace'(_1545718, _1545720), once(user:self_eval0(['if-unify-or-empty', _407092, _407092])), '$restore_trace'(_1545718, _1545720))
^  <span class="ansi1 ansi32"
>Call: </span>(271) [system] sig_atomic(system:'$notrace'(_1545718, _1545720))
^  <span class="ansi1 ansi31"
>Fail: </span>(268) [user] self_eval(['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(268) [user] eval_01(=, _1543836, 499, '&self', ['if-unify-or-empty', _407092, _407092], _1528766)
   <span class="ansi1 ansi32"
>Call: </span>(269) [system] ['if-unify-or-empty', _407092, _407092]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(269) [system] ['if-unify-or-empty', _407092, _407092]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] if_t((499<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] 499<1
   <span class="ansi1 ansi31"
>Fail: </span>(271) [system] 499<1
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] if_t((499<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(270) [system] setup_call_cleanup('$notrace'(_1555112, _1555114), once(user:(_1555088 is 499-1, copy_term(['if-unify-or-empty', _407092, _407092], _1555102))), '$restore_trace'(_1555112, _1555114))
^  <span class="ansi1 ansi32"
>Call: </span>(271) [system] sig_atomic(system:'$notrace'(_1555112, _1555114))
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(498 is 499-1, copy_term(['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _1557022, _1557022]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] trace_eval(eval_20(=, _1543836), e, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1557976)
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] must_det_ll((notrace((flag(eval_num, _1558942, _1558942+1), _1558960 is _1558942 mod 500, _1558978 is 99-498 mod 100, _1559002=_1559004, option_else('trace-length', _1559016, 500), option_else('trace-depth', _1559024, 30))), quietly(if_t((nop(stop_rtrace), _1558960>_1559016), (set_debug(eval, false), _1559080 is _1559016+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1559080])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1559132)))))
^  <span class="ansi1 ansi32"
>Call: </span>(271) [user] once(user:(notrace((flag(eval_num, _1558942, _1558942+1), _1558960 is _1558942 mod 500, _1558978 is 99-498 mod 100, _1559002=_1559004, option_else('trace-length', _1559016, 500), option_else('trace-depth', _1559024, 30))), quietly(if_t((nop(stop_rtrace), _1558960>_1559016), (set_debug(eval, false), _1559080 is _1559016+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1559080])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1559132)))))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [system] setup_call_cleanup('$notrace'(_1561002, _1561004), once(user:(flag(eval_num, _1558942, _1558942+1), _1558960 is _1558942 mod 500, _1558978 is 99-498 mod 100, _1559002=_1559004, option_else('trace-length', _1559016, 500), option_else('trace-depth', _1559024, 30))), '$restore_trace'(_1561002, _1561004))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] sig_atomic(system:'$notrace'(_1561002, _1561004))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 18, 18+1), 18 is 18 mod 500, 1 is 99-498 mod 100, _1559002=_1559002, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 18>500), (set_debug(eval, false), _1559080 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1559080])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 18>500), (set_debug(eval, false), _1559080 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1559080])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(273) [user] nop(notrace(no_repeats_var(_1559132)))
   <span class="ansi1 ansi32"
>Exit: </span>(273) [user] nop(notrace(no_repeats_var(_1559132)))
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [system] once(user:(notrace((flag(eval_num, 18, 18+1), 18 is 18 mod 500, 1 is 99-498 mod 100, _1559002=_1559002, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 18>500), (set_debug(eval, false), _1559080 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1559080])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1559132)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [user] must_det_ll(user:(notrace((flag(eval_num, 18, 18+1), 18 is 18 mod 500, 1 is 99-498 mod 100, _1559002=_1559002, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 18>500), (set_debug(eval, false), _1559080 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1559080])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1559132)))))
   <span class="ansi1 ansi32"
>Call: </span>(270) [occurs] occurs:sub_term(_1569686, e)
   <span class="ansi1 ansi32"
>Exit: </span>(270) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(270) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(271) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(271) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(270) [occurs] occurs:sub_term(_1569686, e)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] _1576176=e
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] if_trace((eval;e), (_1559002=1, indentq(1, 18, -->, [e, ['if-unify-or-empty', _407092, _407092]])))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] setup_call_cleanup('$notrace'(_1579052, _1579054), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _1559002=1, indentq(1, 18, -->, [e, ['if-unify-or-empty', _407092, _407092]]))), _1579010, fbug((_1579010-->if_trace((eval;e), (_1559002=1, indentq(1, 18, -->, [e, ['if-unify-or-empty', _407092, _407092]])))))))), '$restore_trace'(_1579052, _1579054))
^  <span class="ansi1 ansi32"
>Call: </span>(273) [system] sig_atomic(system:'$notrace'(_1579052, _1579054))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _1559002=1, indentq(1, 18, -->, [e, ['if-unify-or-empty', _407092, _407092]]))), _1579010, fbug((_1579010-->if_trace((eval;e), (_1559002=1, indentq(1, 18, -->, [e, ['if-unify-or-empty', _407092, _407092]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [user] if_trace((eval;e), (_1559002=1, indentq(1, 18, -->, [e, ['if-unify-or-empty', _407092, _407092]])))
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] _1582896=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] _1584758=(\+ \+ (flag(eval_num, _1584778, _1584778+1), (retval(fail)\=@=retval(fail), nonvar(_1557976)->indentq(1, _1584778, <--, [e, _1557976]);indentq(1, _1584778, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] (\+ \+ (flag(eval_num, _1584778, _1584778+1), (retval(fail)\=@=retval(fail), nonvar(_1557976)->indentq(1, _1584778, <--, [e, _1557976]);indentq(1, _1584778, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _1584778, _1584778+1), (retval(fail)\=@=retval(fail), nonvar(_1557976)->indentq(1, _1584778, <--, [e, _1557976]);indentq(1, _1584778, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(270) [user] call_cleanup(((call(eval_20(=, _1543836), 498, '&self', ['if-unify-or-empty', _407092, _407092], _1557976)*->nb_setarg(1, retval(fail), _1557976);fail, trace, call(eval_20(=, _1543836), 498, '&self', ['if-unify-or-empty', _407092, _407092], _1557976)), ignore(notrace((\+_1557976\=_1559132, nb_setarg(1, retval(fail), _1557976))))), ignore((_1559002==1->ignore(\+ \+ (flag(eval_num, _1584778, _1584778+1), (retval(fail)\=@=retval(fail), nonvar(_1557976)->indentq(1, _1584778, <--, [e, _1557976]);indentq(1, _1584778, <--, [e, retval(fail)]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1584778, _1584778+1), (retval(fail)\=@=retval(fail), nonvar(_1557976)->indentq(1, _1584778, <--, [e, _1557976]);indentq(1, _1584778, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] eval_20(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1557976)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] atom(['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] no_eval(['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] self_eval(['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(276) [system] setup_call_cleanup('$notrace'(_1591550, _1591552), once(user:self_eval0(['if-unify-or-empty', _407092, _407092])), '$restore_trace'(_1591550, _1591552))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [system] sig_atomic(system:'$notrace'(_1591550, _1591552))
^  <span class="ansi1 ansi31"
>Fail: </span>(274) [user] self_eval(['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] atomic('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(274) [system] atomic('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] is_sl('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(275) [system] number('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] [_407092, _407092]==[]
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] _1601776==eval
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] [_407092, _407092]==[]
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] is_list([_407092, _407092])
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] is_list([_407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] is_list('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] is_list([_407092, _407092])
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] is_list([_407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] is_list(['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] is_list(['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] once(expand_eval(['if-unify-or-empty', _407092, _407092], _1612898))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] expand_eval(['if-unify-or-empty', _407092, _407092], _1612898)
   <span class="ansi1 ansi32"
>Call: </span>(275) [system] is_list(['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Exit: </span>(275) [system] is_list(['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(275) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(275) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] apply:maplist(expand_eval, [_407092, _407092], _1618470)
   <span class="ansi1 ansi32"
>Call: </span>(276) [apply] apply:maplist_([_407092, _407092], _1618470, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] expand_eval(_407092, _1620350)
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] is_list(_407092)
   <span class="ansi1 ansi32"
>Call: </span>(278) [system] _407092=_1620350
   <span class="ansi1 ansi32"
>Exit: </span>(278) [system] _407092=_407092
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [user] expand_eval(_407092, _407092)
   <span class="ansi1 ansi32"
>Call: </span>(277) [apply] apply:maplist_([_407092], _1620352, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] expand_eval(_407092, _1625924)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] is_list(_407092)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] _407092=_1625924
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] _407092=_407092
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [user] expand_eval(_407092, _407092)
   <span class="ansi1 ansi32"
>Call: </span>(278) [apply] apply:maplist_([], _1625926, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(278) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(277) [apply] apply:maplist_([_407092], [_407092], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(276) [apply] apply:maplist_([_407092, _407092], [_407092, _407092], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [apply] apply:maplist(user:expand_eval, [_407092, _407092], [_407092, _407092])
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [user] expand_eval(['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Exit: </span>(273) [system] once(user:expand_eval(['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _407092, _407092]))
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] ['if-unify-or-empty', _407092, _407092]\==['if-unify-or-empty', _407092, _407092]
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] is_progn('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] is_space_op('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] arg(_1641802, v('catch!', 'throw!', 'number-of!', 'limit!', 'offset!', 'max-time!', 'findall!', 'setup-call-cleanup!', 'call-cleanup!', 'call-cleanup!', 'with-output-to!'), 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] _1642660='if-unify-or-empty'
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] 'if-unify-or-empty'='if-unify-or-empty'
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _1644518)
^  <span class="ansi1 ansi31"
>Fail: </span>(273) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _1644518)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] is_list(['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] is_list(['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] apply:maplist(self_eval, ['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(274) [apply] apply:maplist_(['if-unify-or-empty', _407092, _407092], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] self_eval('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(277) [system] setup_call_cleanup('$notrace'(_1651036, _1651038), once(user:self_eval0('if-unify-or-empty')), '$restore_trace'(_1651036, _1651038))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [system] sig_atomic(system:'$notrace'(_1651036, _1651038))
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0('if-unify-or-empty')), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] self_eval('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(275) [apply] apply:maplist_([_407092, _407092], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] self_eval(_407092)
^  <span class="ansi1 ansi32"
>Call: </span>(278) [system] setup_call_cleanup('$notrace'(_1656662, _1656664), once(user:self_eval0(_407092)), '$restore_trace'(_1656662, _1656664))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [system] sig_atomic(system:'$notrace'(_1656662, _1656664))
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_407092)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(276) [user] self_eval(_407092)
   <span class="ansi1 ansi32"
>Call: </span>(276) [apply] apply:maplist_([_407092], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] self_eval(_407092)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [system] setup_call_cleanup('$notrace'(_1662288, _1662290), once(user:self_eval0(_407092)), '$restore_trace'(_1662288, _1662290))
^  <span class="ansi1 ansi32"
>Call: </span>(280) [system] sig_atomic(system:'$notrace'(_1662288, _1662290))
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_407092)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [user] self_eval(_407092)
   <span class="ansi1 ansi32"
>Call: </span>(277) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(277) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(276) [apply] apply:maplist_([_407092], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(275) [apply] apply:maplist_([_407092, _407092], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(274) [apply] apply:maplist_(['if-unify-or-empty', _407092, _407092], user:self_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(273) [apply] apply:maplist(user:self_eval, ['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] ['if-unify-or-empty', _407092, _407092]=[_1671626|_1671628]
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] ['if-unify-or-empty', _407092, _407092]=['if-unify-or-empty', _407092, _407092]
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] _1675334=do_more_defs(true)
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] do_more_defs(true)=do_more_defs(true)
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] clause(eval_21(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1557976), _1677210)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] 'if-unify-or-empty'==(/)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] 'if-unify-or-empty'== ===
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] 'if-unify-or-empty'== ====
^  <span class="ansi1 ansi32"
>Call: </span>(273) [user] eval_40(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930)
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] eval_selfless(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930)
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] eval_selfless_0(['if-unify-or-empty', _407092, _407092], _1680930)
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] is_assignment('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(277) [system] atom('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] eval_selfless_1(['if-unify-or-empty', _407092, _407092], _1680930)
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] allow_clp
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] false_flag
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(279) [system] fail
^  <span class="ansi1 ansi31"
>Fail: </span>(278) [user] false_flag
^  <span class="ansi1 ansi32"
>Call: </span>(276) [user] eval_selfless_2(['if-unify-or-empty', _407092, _407092], _1680930)
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] fake_notrace((ground(['if-unify-or-empty', _407092, _407092]), ['if-unify-or-empty', _407092, _407092]=[_1694834, _1694840, _1694846], atom(_1694834), catch_warn(current_op(_1694872, yfx, _1694834)), ['if-unify-or-empty', _407092, _407092]\=[_1694892], s2ps(['if-unify-or-empty', _407092, _407092], _1694900)))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] real_notrace(user:(ground(['if-unify-or-empty', _407092, _407092]), ['if-unify-or-empty', _407092, _407092]=[_1694834, _1694840, _1694846], atom(_1694834), catch_warn(current_op(_1694872, yfx, _1694834)), ['if-unify-or-empty', _407092, _407092]\=[_1694892], s2ps(['if-unify-or-empty', _407092, _407092], _1694900)))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] setup_call_cleanup('$notrace'(_1696758, _1696760), once(user:(ground(['if-unify-or-empty', _407092, _407092]), ['if-unify-or-empty', _407092, _407092]=[_1694834, _1694840, _1694846], atom(_1694834), catch_warn(current_op(_1694872, yfx, _1694834)), ['if-unify-or-empty', _407092, _407092]\=[_1694892], s2ps(['if-unify-or-empty', _407092, _407092], _1694900))), '$restore_trace'(_1696758, _1696760))
^  <span class="ansi1 ansi32"
>Call: </span>(280) [system] sig_atomic(user:'$notrace'(_1696758, _1696760))
^  <span class="ansi1 ansi31"
>Fail: </span>(278) [user] real_notrace(user:(ground(['if-unify-or-empty', _407092, _407092]), ['if-unify-or-empty', _407092, _407092]=[_1694834, _1694840, _1694846], atom(_1694834), catch_warn(current_op(_1694872, yfx, _1694834)), ['if-unify-or-empty', _407092, _407092]\=[_1694892], s2ps(['if-unify-or-empty', _407092, _407092], _1694900)))
^  <span class="ansi1 ansi31"
>Fail: </span>(277) [user] fake_notrace(user:(ground(['if-unify-or-empty', _407092, _407092]), ['if-unify-or-empty', _407092, _407092]=[_1694834, _1694840, _1694846], atom(_1694834), catch_warn(current_op(_1694872, yfx, _1694834)), ['if-unify-or-empty', _407092, _407092]\=[_1694892], s2ps(['if-unify-or-empty', _407092, _407092], _1694900)))
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] 'if-unify-or-empty'==(==)
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] 'if-unify-or-empty'==(==)
^  <span class="ansi1 ansi32"
>Call: </span>(274) [user] eval_41(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930)
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(276) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(277) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] eval_adjust_args(=, _1543836, _1708802, _1680930, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1708804)
   <span class="ansi1 ansi32"
>Call: </span>(276) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _1543836, _1708802, _1680930, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1708804)), eval_adjust_args1(=, _1543836, _1708802, _1680930, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1708804))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] eval_adjust_args2(=, _1543836, _1708802, _1680930, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1708804)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] apply:maplist(must_eval_args(=, _1715342, 498, '&self'), [_407092, _407092], _1715336)
   <span class="ansi1 ansi32"
>Call: </span>(280) [apply] apply:maplist_([_407092, _407092], _1715336, user:must_eval_args(=, _1715342, 498, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] must_eval_args(=, _1715342, 498, '&self', _407092, _1717226)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(283) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(285) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(285) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(285) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] was_option_value(nodebug, _1727422)
   <span class="ansi1 ansi32"
>Call: </span>(287) [system] current_prolog_flag(nodebug, _1728352)
   <span class="ansi1 ansi31"
>Fail: </span>(287) [system] current_prolog_flag(nodebug, _1728352)
   <span class="ansi1 ansi32"
>Call: </span>(287) [$syspreds] prolog_load_context(nodebug, _1730210)
   <span class="ansi1 ansi31"
>Fail: </span>(287) [$syspreds] prolog_load_context(nodebug, _1730210)
   <span class="ansi1 ansi32"
>Call: </span>(287) [system] nb_current(nodebug, _1732068)
   <span class="ansi1 ansi31"
>Fail: </span>(287) [system] nb_current(nodebug, _1732068)
^  <span class="ansi1 ansi31"
>Fail: </span>(286) [user] was_option_value(nodebug, _1727422)
^  <span class="ansi1 ansi31"
>Fail: </span>(285) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(285) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(286) [system] setup_call_cleanup('$notrace'(_1737652, _1737654), once(user:option_value0(nodebug, true)), '$restore_trace'(_1737652, _1737654))
^  <span class="ansi1 ansi32"
>Call: </span>(287) [system] sig_atomic(system:'$notrace'(_1737652, _1737654))
^  <span class="ansi1 ansi31"
>Fail: </span>(284) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(283) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(283) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(283) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(284) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(284) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(283) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(284) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(284) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(283) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(283) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1756232)
^  <span class="ansi1 ansi32"
>Call: </span>(284) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1756232, _1757240)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(285) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(285) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_1760902, _1760904, _1760906), defined)
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(286) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1760902, _1760904, _1760906))
   <span class="ansi1 ansi32"
>Call: </span>(287) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1760902, _1760904, _1760906))
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] callable(debugging_logicmoo_setting(_1760902, _1760904, _1760906))
   <span class="ansi1 ansi32"
>Exit: </span>(288) [system] callable(debugging_logicmoo_setting(_1760902, _1760904, _1760906))
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(288) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(287) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1760902, _1760904, _1760906))
   <span class="ansi1 ansi32"
>Exit: </span>(286) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1760902, _1760904, _1760906))
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_1760902, _1760904, _1760906), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(285) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _1756232, _1772030)
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(283) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(283) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] eval_args(=, _1715342, 498, '&self', _407092, _1717226)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] var(_407092)
   <span class="ansi1 ansi32"
>Exit: </span>(283) [system] var(_407092)
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] nonvar(_1717226)
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] setup_call_cleanup('$notrace'(_1782288, _1782290), once(user:self_eval(_407092)), '$restore_trace'(_1782288, _1782290))
^  <span class="ansi1 ansi32"
>Call: </span>(285) [system] sig_atomic(system:'$notrace'(_1782288, _1782290))
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_407092)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] _1717226=_407092
   <span class="ansi1 ansi32"
>Exit: </span>(283) [system] _407092=_407092
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] eval_args(=, _1715342, 498, '&self', _407092, _407092)
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [user] must_eval_args(=, _1715342, 498, '&self', _407092, _407092)
   <span class="ansi1 ansi32"
>Call: </span>(281) [apply] apply:maplist_([_407092], _1717228, user:must_eval_args(=, _1715342, 498, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] must_eval_args(=, _1715342, 498, '&self', _407092, _1789848)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(284) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(285) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(286) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(286) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(287) [user] was_option_value(nodebug, _1800044)
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] current_prolog_flag(nodebug, _1800974)
   <span class="ansi1 ansi31"
>Fail: </span>(288) [system] current_prolog_flag(nodebug, _1800974)
   <span class="ansi1 ansi32"
>Call: </span>(288) [$syspreds] prolog_load_context(nodebug, _1802832)
   <span class="ansi1 ansi31"
>Fail: </span>(288) [$syspreds] prolog_load_context(nodebug, _1802832)
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] nb_current(nodebug, _1804690)
   <span class="ansi1 ansi31"
>Fail: </span>(288) [system] nb_current(nodebug, _1804690)
^  <span class="ansi1 ansi31"
>Fail: </span>(287) [user] was_option_value(nodebug, _1800044)
^  <span class="ansi1 ansi31"
>Fail: </span>(286) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(286) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(287) [system] setup_call_cleanup('$notrace'(_1810274, _1810276), once(user:option_value0(nodebug, true)), '$restore_trace'(_1810274, _1810276))
^  <span class="ansi1 ansi32"
>Call: </span>(288) [system] sig_atomic(system:'$notrace'(_1810274, _1810276))
^  <span class="ansi1 ansi31"
>Fail: </span>(285) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(284) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(284) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(284) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(285) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(285) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(284) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(285) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(285) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(284) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(284) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1828854)
^  <span class="ansi1 ansi32"
>Call: </span>(285) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1828854, _1829862)
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(286) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(286) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_1833524, _1833526, _1833528), defined)
   <span class="ansi1 ansi32"
>Call: </span>(287) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(287) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(287) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1833524, _1833526, _1833528))
   <span class="ansi1 ansi32"
>Call: </span>(288) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1833524, _1833526, _1833528))
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] callable(debugging_logicmoo_setting(_1833524, _1833526, _1833528))
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] callable(debugging_logicmoo_setting(_1833524, _1833526, _1833528))
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(288) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1833524, _1833526, _1833528))
   <span class="ansi1 ansi32"
>Exit: </span>(287) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1833524, _1833526, _1833528))
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_1833524, _1833526, _1833528), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(286) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _1828854, _1844652)
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(284) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(284) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] eval_args(=, _1715342, 498, '&self', _407092, _1789848)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] var(_407092)
   <span class="ansi1 ansi32"
>Exit: </span>(284) [system] var(_407092)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] nonvar(_1789848)
^  <span class="ansi1 ansi32"
>Call: </span>(285) [system] setup_call_cleanup('$notrace'(_1854910, _1854912), once(user:self_eval(_407092)), '$restore_trace'(_1854910, _1854912))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [system] sig_atomic(system:'$notrace'(_1854910, _1854912))
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_407092)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] _1789848=_407092
   <span class="ansi1 ansi32"
>Exit: </span>(284) [system] _407092=_407092
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [user] eval_args(=, _1715342, 498, '&self', _407092, _407092)
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] must_eval_args(=, _1715342, 498, '&self', _407092, _407092)
   <span class="ansi1 ansi32"
>Call: </span>(282) [apply] apply:maplist_([], _1789850, user:must_eval_args(=, _1715342, 498, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(282) [apply] apply:maplist_([], [], user:must_eval_args(=, _1715342, 498, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(281) [apply] apply:maplist_([_407092], [_407092], user:must_eval_args(=, _1715342, 498, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(280) [apply] apply:maplist_([_407092, _407092], [_407092, _407092], user:must_eval_args(=, _1715342, 498, '&self'))
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [apply] apply:maplist(user:must_eval_args(=, _1715342, 498, '&self'), [_407092, _407092], [_407092, _407092])
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] _1708802=_1680930
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] _1680930=_1680930
^  <span class="ansi1 ansi32"
>Exit: </span>(278) [user] eval_adjust_args2(=, _1543836, _1680930, _1680930, 498, '&self', ['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _407092, _407092])
   <span class="ansi1 ansi32"
>Exit: </span>(276) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _1543836, _1680930, _1680930, 498, '&self', ['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _407092, _407092])), eval_adjust_args1(=, _1543836, _1680930, _1680930, 498, '&self', ['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _407092, _407092]))
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] eval_adjust_args(=, _1543836, _1680930, _1680930, 498, '&self', ['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] if_trace((e;args), (['if-unify-or-empty', _407092, _407092]\==['if-unify-or-empty', _407092, _407092]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _407092, _407092]->['if-unify-or-empty', _407092, _407092])));nop(indentq2(498, same(['if-unify-or-empty', _407092, _407092])))))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [system] setup_call_cleanup('$notrace'(_1871912, _1871914), once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _407092, _407092]\==['if-unify-or-empty', _407092, _407092]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _407092, _407092]->['if-unify-or-empty', _407092, _407092])));nop(indentq2(498, same(['if-unify-or-empty', _407092, _407092])))))), _1871870, fbug((_1871870-->if_trace((e;args), (['if-unify-or-empty', _407092, _407092]\==['if-unify-or-empty', _407092, _407092]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _407092, _407092]->['if-unify-or-empty', _407092, _407092])));nop(indentq2(498, same(['if-unify-or-empty', _407092, _407092])))))))))), '$restore_trace'(_1871912, _1871914))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [system] sig_atomic(system:'$notrace'(_1871912, _1871914))
^  <span class="ansi1 ansi32"
>Exit: </span>(277) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _407092, _407092]\==['if-unify-or-empty', _407092, _407092]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _407092, _407092]->['if-unify-or-empty', _407092, _407092])));nop(indentq2(498, same(['if-unify-or-empty', _407092, _407092])))))), _1871870, fbug((_1871870-->if_trace((e;args), (['if-unify-or-empty', _407092, _407092]\==['if-unify-or-empty', _407092, _407092]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _407092, _407092]->['if-unify-or-empty', _407092, _407092])));nop(indentq2(498, same(['if-unify-or-empty', _407092, _407092])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] if_trace((e;args), (['if-unify-or-empty', _407092, _407092]\==['if-unify-or-empty', _407092, _407092]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _407092, _407092]->['if-unify-or-empty', _407092, _407092])));nop(indentq2(498, same(['if-unify-or-empty', _407092, _407092])))))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] eval_70(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930)
   <span class="ansi1 ansi32"
>Call: </span>(276) [user] if_or_else(eval_maybe_python(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930), if_or_else(eval_maybe_host_predicate(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930), if_or_else(eval_maybe_host_function(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930), if_or_else(eval_maybe_defn(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930), eval_maybe_subst(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930)))))
^  <span class="ansi1 ansi32"
>Call: </span>(277) [user] eval_maybe_python(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930)
   <span class="ansi1 ansi32"
>Call: </span>(278) [user] metta_atom('&self', ['registered-python-function', _1878656, _1878662, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] typed_list('&self', _1879666, _1879588)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(280) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(279) [user] typed_list('&self', _1882446, _1879588)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] metta_atom_in_file('&self', ['registered-python-function', _1878656, _1878662, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] metta_atom_in_file('&self', ['registered-python-function', _1878656, _1878662, 'if-unify-or-empty'], _1885236, _1885238)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] loaded_into_kb('&self', _1886094)
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [user] loaded_into_kb('&self', '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] once(user:asserted_metta_pred(_1887960, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] asserted_metta_pred(_1887960, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(282) [user] asserted_metta_pred(_1887960, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
   <span class="ansi1 ansi32"
>Call: </span>(279) [user] metta_atom_asserted('&self', ['registered-python-function', _1878656, _1878662, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] metta_atom_asserted_deduced('&self', ['registered-python-function', _1878656, _1878662, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(279) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(279) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(279) [user] metta_atom('&corelib', ['registered-python-function', _1878656, _1878662, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] typed_list('&corelib', _1899144, _1899066)
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(281) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(280) [user] typed_list('&corelib', _1901924, _1899066)
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] metta_atom_in_file('&corelib', ['registered-python-function', _1878656, _1878662, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] metta_atom_in_file('&corelib', ['registered-python-function', _1878656, _1878662, 'if-unify-or-empty'], _1904714, _1904716)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] loaded_into_kb('&corelib', _1905572)
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] loaded_into_kb('&corelib', '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] once(user:asserted_metta_pred(_1907438, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] asserted_metta_pred(_1907438, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(283) [user] asserted_metta_pred(_1907438, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] loaded_into_kb('&corelib', '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] once(user:asserted_metta_pred(_1911164, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] asserted_metta_pred(_1911164, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(283) [user] asserted_metta_pred(_1911164, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
   <span class="ansi1 ansi32"
>Call: </span>(280) [user] metta_atom_asserted('&corelib', ['registered-python-function', _1878656, _1878662, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] metta_atom_asserted_deduced('&corelib', ['registered-python-function', _1878656, _1878662, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(280) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(277) [user] if_or_else(eval_maybe_host_predicate(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930), if_or_else(eval_maybe_host_function(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930), if_or_else(eval_maybe_defn(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930), eval_maybe_subst(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930))))
^  <span class="ansi1 ansi32"
>Call: </span>(278) [user] eval_maybe_host_predicate(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930)
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(279) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] once((is_system_pred('if-unify-or-empty'), length([_407092, _407092], _1923210), is_syspred('if-unify-or-empty', _1923210, _1923218)))
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] atom_concat(_1927002, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] atom_concat(_1929782, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] atom_concat(_1932562, '-p', 'if-unify-or-empty')
^  <span class="ansi1 ansi31"
>Fail: </span>(281) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(278) [user] if_or_else(eval_maybe_host_function(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930), if_or_else(eval_maybe_defn(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930), eval_maybe_subst(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930)))
^  <span class="ansi1 ansi32"
>Call: </span>(279) [user] eval_maybe_host_function(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930)
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(280) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] atom_concat(_1940882, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] atom_concat(_1943662, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(281) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(281) [system] atom_concat(_1946442, '-p', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(279) [user] if_or_else(eval_maybe_defn(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930), eval_maybe_subst(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930))
^  <span class="ansi1 ansi32"
>Call: </span>(280) [user] eval_maybe_defn(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930)
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _407092, _407092])
^  <span class="ansi1 ansi32"
>Call: </span>(281) [user] trace_eval(eval_defn_choose_candidates(=, _1543836), defn, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930)
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] must_det_ll((notrace((flag(eval_num, _1955650, _1955650+1), _1955668 is _1955650 mod 500, _1955686 is 99-498 mod 100, _1955710=_1955712, option_else('trace-length', _1955724, 500), option_else('trace-depth', _1955732, 30))), quietly(if_t((nop(stop_rtrace), _1955668>_1955724), (set_debug(eval, false), _1955788 is _1955724+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1955788])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1955840)))))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] once(user:(notrace((flag(eval_num, _1955650, _1955650+1), _1955668 is _1955650 mod 500, _1955686 is 99-498 mod 100, _1955710=_1955712, option_else('trace-length', _1955724, 500), option_else('trace-depth', _1955732, 30))), quietly(if_t((nop(stop_rtrace), _1955668>_1955724), (set_debug(eval, false), _1955788 is _1955724+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1955788])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1955840)))))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [system] setup_call_cleanup('$notrace'(_1957710, _1957712), once(user:(flag(eval_num, _1955650, _1955650+1), _1955668 is _1955650 mod 500, _1955686 is 99-498 mod 100, _1955710=_1955712, option_else('trace-length', _1955724, 500), option_else('trace-depth', _1955732, 30))), '$restore_trace'(_1957710, _1957712))
^  <span class="ansi1 ansi32"
>Call: </span>(287) [system] sig_atomic(system:'$notrace'(_1957710, _1957712))
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 19, 19+1), 19 is 19 mod 500, 1 is 99-498 mod 100, _1955710=_1955710, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 19>500), (set_debug(eval, false), _1955788 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1955788])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 19>500), (set_debug(eval, false), _1955788 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1955788])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(285) [user] nop(notrace(no_repeats_var(_1955840)))
   <span class="ansi1 ansi32"
>Exit: </span>(285) [user] nop(notrace(no_repeats_var(_1955840)))
^  <span class="ansi1 ansi32"
>Exit: </span>(283) [system] once(user:(notrace((flag(eval_num, 19, 19+1), 19 is 19 mod 500, 1 is 99-498 mod 100, _1955710=_1955710, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 19>500), (set_debug(eval, false), _1955788 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1955788])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1955840)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] must_det_ll(user:(notrace((flag(eval_num, 19, 19+1), 19 is 19 mod 500, 1 is 99-498 mod 100, _1955710=_1955710, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 19>500), (set_debug(eval, false), _1955788 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1955788])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1955840)))))
   <span class="ansi1 ansi32"
>Call: </span>(282) [occurs] occurs:sub_term(_1966394, defn)
   <span class="ansi1 ansi32"
>Exit: </span>(282) [occurs] occurs:sub_term(defn, defn)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] defn\=defn
   <span class="ansi1 ansi31"
>Fail: </span>(282) [system] defn\=defn
   <span class="ansi1 ansi32"
>Call: </span>(283) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(283) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(282) [occurs] occurs:sub_term(_1966394, defn)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] _1972884=defn
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] defn=defn
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] if_trace((eval;defn), (_1955710=1, indentq(1, 19, -->, [defn, ['if-unify-or-empty', _407092, _407092]])))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [system] setup_call_cleanup('$notrace'(_1975760, _1975762), once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _1955710=1, indentq(1, 19, -->, [defn, ['if-unify-or-empty', _407092, _407092]]))), _1975718, fbug((_1975718-->if_trace((eval;defn), (_1955710=1, indentq(1, 19, -->, [defn, ['if-unify-or-empty', _407092, _407092]])))))))), '$restore_trace'(_1975760, _1975762))
^  <span class="ansi1 ansi32"
>Call: </span>(285) [system] sig_atomic(system:'$notrace'(_1975760, _1975762))
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _1955710=1, indentq(1, 19, -->, [defn, ['if-unify-or-empty', _407092, _407092]]))), _1975718, fbug((_1975718-->if_trace((eval;defn), (_1955710=1, indentq(1, 19, -->, [defn, ['if-unify-or-empty', _407092, _407092]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [user] if_trace((eval;defn), (_1955710=1, indentq(1, 19, -->, [defn, ['if-unify-or-empty', _407092, _407092]])))
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] _1979604=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] _1981466=(\+ \+ (flag(eval_num, _1981486, _1981486+1), (retval(fail)\=@=retval(fail), nonvar(_1680930)->indentq(1, _1981486, <--, [defn, _1680930]);indentq(1, _1981486, <--, [defn, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] (\+ \+ (flag(eval_num, _1981486, _1981486+1), (retval(fail)\=@=retval(fail), nonvar(_1680930)->indentq(1, _1981486, <--, [defn, _1680930]);indentq(1, _1981486, <--, [defn, retval(fail)]))))=(\+ \+ (flag(eval_num, _1981486, _1981486+1), (retval(fail)\=@=retval(fail), nonvar(_1680930)->indentq(1, _1981486, <--, [defn, _1680930]);indentq(1, _1981486, <--, [defn, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] call_cleanup(((call(eval_defn_choose_candidates(=, _1543836), 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930)*->nb_setarg(1, retval(fail), _1680930);fail, trace, call(eval_defn_choose_candidates(=, _1543836), 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930)), ignore(notrace((\+_1680930\=_1955840, nb_setarg(1, retval(fail), _1680930))))), ignore((_1955710==1->ignore(\+ \+ (flag(eval_num, _1981486, _1981486+1), (retval(fail)\=@=retval(fail), nonvar(_1680930)->indentq(1, _1981486, <--, [defn, _1680930]);indentq(1, _1981486, <--, [defn, retval(fail)]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1981486, _1981486+1), (retval(fail)\=@=retval(fail), nonvar(_1680930)->indentq(1, _1981486, <--, [defn, _1680930]);indentq(1, _1981486, <--, [defn, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] eval_defn_choose_candidates(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930)
^  <span class="ansi1 ansi32"
>Call: </span>(285) [user] findall((_1985476->_1985478), get_defn_expansions(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1985476, _1985478), _1985496)
^  <span class="ansi1 ansi32"
>Call: </span>(286) [$bags] findall((_1985476->_1985478), user:get_defn_expansions(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1985476, _1985478), _1985496, [])
^  <span class="ansi1 ansi32"
>Call: </span>(287) [$bags] cleanup_bag(findall_loop((_1985476->_1985478), user:get_defn_expansions(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1985476, _1985478), _1985496, []), '$destroy_findall_bag')
   <span class="ansi1 ansi32"
>Call: </span>(288) [$bags] findall_loop((_1985476->_1985478), user:get_defn_expansions(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1985476, _1985478), _1985496, [])
^  <span class="ansi1 ansi32"
>Call: </span>(289) [user] get_defn_expansions(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1985476, _1985478)
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] same_len_copy([_407092, _407092], _1990228)
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] length([_407092, _407092], _1991158)
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] var(_1991158)
   <span class="ansi1 ansi32"
>Exit: </span>(292) [system] var(_1991158)
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(292) [system] []==[]
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] _1991158=2
   <span class="ansi1 ansi32"
>Exit: </span>(292) [system] 2=2
   <span class="ansi1 ansi32"
>Exit: </span>(291) [system] length([_407092, _407092], 2)
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] length(_1990228, 2)
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] var(2)
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] integer(2)
   <span class="ansi1 ansi32"
>Exit: </span>(292) [system] integer(2)
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] _1990228==[]
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] var(_1990228)
   <span class="ansi1 ansi32"
>Exit: </span>(292) [system] var(_1990228)
   <span class="ansi1 ansi32"
>Exit: </span>(291) [system] length([_2005062, _2005068], 2)
^  <span class="ansi1 ansi32"
>Exit: </span>(290) [user] same_len_copy([_407092, _407092], [_2005062, _2005068])
   <span class="ansi1 ansi32"
>Call: </span>(290) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _2005062, _2005068], _1985478)
^  <span class="ansi1 ansi32"
>Call: </span>(291) [user] ignore((=)=(=))
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] (=)=(=)
   <span class="ansi1 ansi32"
>Exit: </span>(292) [system] (=)=(=)
^  <span class="ansi1 ansi32"
>Exit: </span>(291) [system] ignore(user:((=)=(=)))
   <span class="ansi1 ansi32"
>Call: </span>(291) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _2005062, _2005068], _1985478]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _2005062, _2005068], _1985478]))
   <span class="ansi1 ansi32"
>Call: </span>(292) [user] metta_atom('&self', [=, ['if-unify-or-empty', _2005062, _2005068], _1985478])
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] typed_list('&self', _2013544, _2013466)
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(294) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(293) [user] typed_list('&self', _2016324, _2013466)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _2005062, _2005068], _1985478])
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _2005062, _2005068], _1985478], _2019114, _2019116)
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] loaded_into_kb('&self', _2019972)
^  <span class="ansi1 ansi32"
>Exit: </span>(295) [user] loaded_into_kb('&self', '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] once(user:asserted_metta_pred(_2021838, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] asserted_metta_pred(_2021838, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(296) [user] asserted_metta_pred(_2021838, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
   <span class="ansi1 ansi32"
>Call: </span>(293) [user] metta_atom_asserted('&self', [=, ['if-unify-or-empty', _2005062, _2005068], _1985478])
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] metta_atom_asserted_deduced('&self', [=, ['if-unify-or-empty', _2005062, _2005068], _1985478])
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(293) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _2005062, _2005068], _1985478])
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] typed_list('&corelib', _2033022, _2032944)
   <span class="ansi1 ansi32"
>Call: </span>(295) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(295) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(294) [user] typed_list('&corelib', _2035802, _2032944)
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _2005062, _2005068], _1985478])
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _2005062, _2005068], _1985478], _2038592, _2038594)
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] loaded_into_kb('&corelib', _2039450)
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] loaded_into_kb('&corelib', '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] once(user:asserted_metta_pred(_2041316, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] asserted_metta_pred(_2041316, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(297) [user] asserted_metta_pred(_2041316, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] loaded_into_kb('&corelib', '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] once(user:asserted_metta_pred(_2045042, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] asserted_metta_pred(_2045042, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(297) [user] asserted_metta_pred(_2045042, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
   <span class="ansi1 ansi32"
>Call: </span>(294) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _2005062, _2005068], _1985478])
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] metta_atom_asserted_deduced('&corelib', [=, ['if-unify-or-empty', _2005062, _2005068], _1985478])
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] fail
   <span class="ansi1 ansi32"
>Exit: </span>(294) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _2005062, _2005062], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(293) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _2005062, _2005062], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(292) [user] metta_atom('&self', [=, ['if-unify-or-empty', _2005062, _2005062], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(291) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _2005062, _2005062], unified]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _2005062, _2005062], unified]))
   <span class="ansi1 ansi32"
>Exit: </span>(290) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _2005062, _2005062], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(289) [user] get_defn_expansions(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _2005062, _2005062], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(294) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _2005062, _2005068], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(293) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _2005062, _2005068], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(292) [user] metta_atom('&self', [=, ['if-unify-or-empty', _2005062, _2005068], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(291) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _2005062, _2005068], [empty]]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _2005062, _2005068], [empty]]))
   <span class="ansi1 ansi32"
>Exit: </span>(290) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _2005062, _2005068], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(289) [user] get_defn_expansions(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], ['if-unify-or-empty', _2005062, _2005068], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(288) [$bags] findall_loop((_1985476->_1985478), user:get_defn_expansions(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1985476, _1985478), [(['if-unify-or-empty', _2064504, _2064504]->unified), (['if-unify-or-empty', _2064468, _2064474]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(287) [$bags] cleanup_bag('$bags':findall_loop((_1985476->_1985478), user:get_defn_expansions(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1985476, _1985478), [(['if-unify-or-empty', _2064504, _2064504]->unified), (['if-unify-or-empty', _2064468, _2064474]->[empty])], []), '$bags':'$destroy_findall_bag')
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [$bags] findall((_1985476->_1985478), user:get_defn_expansions(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1985476, _1985478), [(['if-unify-or-empty', _2064504, _2064504]->unified), (['if-unify-or-empty', _2064468, _2064474]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [$bags] findall((_1985476->_1985478), user:get_defn_expansions(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1985476, _1985478), [(['if-unify-or-empty', _2064504, _2064504]->unified), (['if-unify-or-empty', _2064468, _2064474]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(285) [user] eval_defn_bodies(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930, [(['if-unify-or-empty', _2064504, _2064504]->unified), (['if-unify-or-empty', _2064468, _2064474]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _2064504, _2064504]->unified), (['if-unify-or-empty', _2064468, _2064474]->[empty])]))
^  <span class="ansi1 ansi32"
>Call: </span>(288) [system] setup_call_cleanup('$notrace'(_2070208, _2070210), once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(498, '   '), [(['if-unify-or-empty', _2064504, _2064504]->unified), (['if-unify-or-empty', _2064468, _2064474]->[empty])]))), _2070166, fbug((_2070166-->if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _2064504, _2064504]->unified), (['if-unify-or-empty', _2064468, _2064474]->[empty])]))))))), '$restore_trace'(_2070208, _2070210))
^  <span class="ansi1 ansi32"
>Call: </span>(289) [system] sig_atomic(system:'$notrace'(_2070208, _2070210))
^  <span class="ansi1 ansi32"
>Exit: </span>(288) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(498, '   '), [(['if-unify-or-empty', _2064504, _2064504]->unified), (['if-unify-or-empty', _2064468, _2064474]->[empty])]))), _2070166, fbug((_2070166-->if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _2064504, _2064504]->unified), (['if-unify-or-empty', _2064468, _2064474]->[empty])]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [user] if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _2064504, _2064504]->unified), (['if-unify-or-empty', _2064468, _2064474]->[empty])]))
   <span class="ansi1 ansi32"
>Call: </span>(286) [user] if_or_else((member((_2074066->_2074068), [(['if-unify-or-empty', _2064504, _2064504]->unified), (['if-unify-or-empty', _2064468, _2064474]->[empty])]), copy_term((_2074066->_2074068), _2074080), eval_defn_success(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930, _2074066, _2074068, _2074080)), eval_defn_failure(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930))
   <span class="ansi1 ansi32"
>Call: </span>(288) [lists] lists:member((_2074066->_2074068), [(['if-unify-or-empty', _2064504, _2064504]->unified), (['if-unify-or-empty', _2064468, _2064474]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(289) [lists] lists:member_([(['if-unify-or-empty', _2064468, _2064474]->[empty])], (_2074066->_2074068), (['if-unify-or-empty', _2064504, _2064504]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(289) [lists] lists:member_([(['if-unify-or-empty', _2064468, _2064474]->[empty])], (['if-unify-or-empty', _2064504, _2064504]->unified), (['if-unify-or-empty', _2064504, _2064504]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(288) [lists] lists:member((['if-unify-or-empty', _2064504, _2064504]->unified), [(['if-unify-or-empty', _2064504, _2064504]->unified), (['if-unify-or-empty', _2064468, _2064474]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] copy_term((['if-unify-or-empty', _2064504, _2064504]->unified), _2074080)
   <span class="ansi1 ansi32"
>Exit: </span>(288) [system] copy_term((['if-unify-or-empty', _2064504, _2064504]->unified), (['if-unify-or-empty', _2079702, _2079702]->unified))
^  <span class="ansi1 ansi32"
>Call: </span>(288) [user] eval_defn_success(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], _1680930, ['if-unify-or-empty', _2064504, _2064504], unified, (['if-unify-or-empty', _2079702, _2079702]->unified))
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] ['if-unify-or-empty', _407092, _407092]=['if-unify-or-empty', _2064504, _2064504]
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] ['if-unify-or-empty', _407092, _407092]=['if-unify-or-empty', _407092, _407092]
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] _1680930=unified
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] unified=unified
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] ['if-unify-or-empty', _407092, _407092]\=@=unified
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] ['if-unify-or-empty', _407092, _407092]\=@=unified
^  <span class="ansi1 ansi32"
>Call: </span>(289) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _2079702, _2079702]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] setup_call_cleanup('$notrace'(_2088158, _2088160), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _2079702, _2079702]->unified)))))), _2088116, fbug((_2088116-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _2079702, _2079702]->unified)))))))))), '$restore_trace'(_2088158, _2088160))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] sig_atomic(system:'$notrace'(_2088158, _2088160))
^  <span class="ansi1 ansi32"
>Exit: </span>(291) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _2079702, _2079702]->unified)))))), _2088116, fbug((_2088116-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _2079702, _2079702]->unified)))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(289) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _2079702, _2079702]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(289) [user] light_eval(=, _1543836, 498, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(289) [user] light_eval(=, _1543836, 498, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(288) [user] eval_defn_success(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], unified, ['if-unify-or-empty', _407092, _407092], unified, (['if-unify-or-empty', _2079702, _2079702]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(286) [user] if_or_else((member((['if-unify-or-empty', _407092, _407092]->unified), [(['if-unify-or-empty', _407092, _407092]->unified), (['if-unify-or-empty', _2064468, _2064474]->[empty])]), copy_term((['if-unify-or-empty', _407092, _407092]->unified), (['if-unify-or-empty', _2079702, _2079702]->unified)), eval_defn_success(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], unified, ['if-unify-or-empty', _407092, _407092], unified, (['if-unify-or-empty', _2079702, _2079702]->unified))), eval_defn_failure(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], unified))
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [user] eval_defn_bodies(=, _1543836, 498, '&self', ['if-unify-or-empty', _407092, _407092], unified, [(['if-unify-or-empty', _407092, _407092]->unified), (['if-unify-or-empty', _2064468, _2064474]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [user] eval_defn_choose_candidates(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(284) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] ignore(notrace((\+unified\=_7820, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [system] setup_call_cleanup('$notrace'(_11848, _11850), once(user:(\+unified\=_7820, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_11848, _11850))
^  <span class="ansi1 ansi32"
>Call: </span>(287) [system] sig_atomic(system:'$notrace'(_11848, _11850))
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_7820, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [system] ignore(user:notrace((\+unified\=_7820, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _7358), 498, '&self', ['if-unify-or-empty', _5666, _5666], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_defn_choose_candidates(=, _7358), 498, '&self', ['if-unify-or-empty', _5666, _5666], unified)), ignore(notrace((\+unified\=_7820, nb_setarg(1, retval(unified), unified))))), user:ignore((_7812==1->ignore(\+ \+ (flag(eval_num, _7850, _7850+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _7850, <--, [defn, unified]);indentq(1, _7850, <--, [defn, retval(unified)]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _7850, _7850+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _7850, <--, [defn, unified]);indentq(1, _7850, <--, [defn, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [user] trace_eval(eval_defn_choose_candidates(=, _7358), defn, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(280) [user] eval_maybe_defn(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(279) [user] if_or_else(eval_maybe_defn(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified), eval_maybe_subst(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified))
   <span class="ansi1 ansi32"
>Exit: </span>(278) [user] if_or_else(eval_maybe_host_function(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified), if_or_else(eval_maybe_defn(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified), eval_maybe_subst(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified)))
   <span class="ansi1 ansi32"
>Exit: </span>(277) [user] if_or_else(eval_maybe_host_predicate(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified), if_or_else(eval_maybe_host_function(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified), if_or_else(eval_maybe_defn(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified), eval_maybe_subst(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified))))
   <span class="ansi1 ansi32"
>Exit: </span>(276) [user] if_or_else(eval_maybe_python(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified), if_or_else(eval_maybe_host_predicate(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified), if_or_else(eval_maybe_host_function(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified), if_or_else(eval_maybe_defn(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified), eval_maybe_subst(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] eval_70(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] check_returnval(=, _7358, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] check_returnval(=, _7358, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [user] eval_41(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(273) [user] eval_40(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified)
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] unified=_7388
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] eval_20(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified)
   <span class="ansi1 ansi32"
>Call: </span>(272) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(272) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] ignore(notrace((\+unified\=_7404, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [system] setup_call_cleanup('$notrace'(_34266, _34268), once(user:(\+unified\=_7404, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_34266, _34268))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] sig_atomic(system:'$notrace'(_34266, _34268))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_7404, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [system] ignore(user:notrace((\+unified\=_7404, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [system] call_cleanup(user:((call(eval_20(=, _7358), 498, '&self', ['if-unify-or-empty', _5666, _5666], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_20(=, _7358), 498, '&self', ['if-unify-or-empty', _5666, _5666], unified)), ignore(notrace((\+unified\=_7404, nb_setarg(1, retval(unified), unified))))), user:ignore((_7396==1->ignore(\+ \+ (flag(eval_num, _7434, _7434+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _7434, <--, [e, unified]);indentq(1, _7434, <--, [e, retval(unified)]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _7434, _7434+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _7434, <--, [e, unified]);indentq(1, _7434, <--, [e, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] trace_eval(eval_20(=, _7358), e, 498, '&self', ['if-unify-or-empty', _5666, _5666], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] self_eval(unified)
^  <span class="ansi1 ansi32"
>Call: </span>(271) [system] setup_call_cleanup('$notrace'(_42708, _42710), once(user:self_eval0(unified)), '$restore_trace'(_42708, _42710))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] sig_atomic(system:'$notrace'(_42708, _42710))
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(unified)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] self_eval(unified)
   <span class="ansi1 ansi32"
>Call: </span>(269) [system] _7356=unified
   <span class="ansi1 ansi32"
>Exit: </span>(269) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [user] eval_01(=, _7358, 499, '&self', ['if-unify-or-empty', _5666, _5666], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [user] eval_00(=, _7358, 499, '&self', ['if-unify-or-empty', _5666, _5666], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] eval_args(=, _7358, 499, '&self', ['if-unify-or-empty', _5666, _5666], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] setup_call_cleanup('$notrace'(_52146, _52148), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _52104, fbug((_52104-->if_trace(case, writeqln(switch=unified))))))), '$restore_trace'(_52146, _52148))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] sig_atomic(system:'$notrace'(_52146, _52148))
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _52104, fbug((_52104-->if_trace(case, writeqln(switch=unified))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(266) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] select_case(499, '&self', unified, ['Empty'-_5684], _55990)
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] best_key(unified, ['Empty'-_5684], _55990)
   <span class="ansi1 ansi32"
>Call: </span>(268) [lists] lists:member(_57866-_55990, ['Empty'-_5684])
   <span class="ansi1 ansi32"
>Call: </span>(269) [lists] lists:member_([], _57866-_55990, 'Empty'-_5684)
   <span class="ansi1 ansi32"
>Exit: </span>(269) [lists] lists:member_([], 'Empty'-_5684, 'Empty'-_5684)
   <span class="ansi1 ansi32"
>Exit: </span>(268) [lists] lists:member('Empty'-_5684, ['Empty'-_5684])
   <span class="ansi1 ansi32"
>Call: </span>(268) [system] unified='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(268) [lists] lists:member(_62520-_55990, ['Empty'-_5684])
   <span class="ansi1 ansi32"
>Call: </span>(269) [lists] lists:member_([], _62520-_55990, 'Empty'-_5684)
   <span class="ansi1 ansi32"
>Exit: </span>(269) [lists] lists:member_([], 'Empty'-_5684, 'Empty'-_5684)
   <span class="ansi1 ansi32"
>Exit: </span>(268) [lists] lists:member('Empty'-_5684, ['Empty'-_5684])
   <span class="ansi1 ansi32"
>Call: </span>(268) [system] unified=='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(268) [lists] lists:member(_67174-_55990, ['Empty'-_5684])
   <span class="ansi1 ansi32"
>Call: </span>(269) [lists] lists:member_([], _67174-_55990, 'Empty'-_5684)
   <span class="ansi1 ansi32"
>Exit: </span>(269) [lists] lists:member_([], 'Empty'-_5684, 'Empty'-_5684)
   <span class="ansi1 ansi32"
>Exit: </span>(268) [lists] lists:member('Empty'-_5684, ['Empty'-_5684])
   <span class="ansi1 ansi32"
>Call: </span>(268) [system] unified=@='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(268) [lists] lists:member(_71828-_55990, ['Empty'-_5684])
   <span class="ansi1 ansi32"
>Call: </span>(269) [lists] lists:member_([], _71828-_55990, 'Empty'-_5684)
   <span class="ansi1 ansi32"
>Exit: </span>(269) [lists] lists:member_([], 'Empty'-_5684, 'Empty'-_5684)
   <span class="ansi1 ansi32"
>Exit: </span>(268) [lists] lists:member('Empty'-_5684, ['Empty'-_5684])
   <span class="ansi1 ansi32"
>Call: </span>(268) [system] unified='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] maybe_special_keys(499, '&self', ['Empty'-_5684], _76480)
^  <span class="ansi1 ansi32"
>Call: </span>(268) [user] eval_args(499, '&self', 'Empty', _77426)
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] eval_args(=, _78442, 499, '&self', 'Empty', _77426)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] var('Empty')
^  <span class="ansi1 ansi32"
>Call: </span>(271) [system] setup_call_cleanup('$notrace'(_80246, _80248), once(user:self_eval('Empty')), '$restore_trace'(_80246, _80248))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] sig_atomic(system:'$notrace'(_80246, _80248))
^  <span class="ansi1 ansi32"
>Exit: </span>(271) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval('Empty')), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] _77426='Empty'
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] 'Empty'='Empty'
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] eval_args(=, _85060, 499, '&self', 'Empty', 'Empty')
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [user] eval_args(499, '&self', 'Empty', 'Empty')
   <span class="ansi1 ansi32"
>Call: </span>(268) [system] 'Empty'\=@='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(268) [user] maybe_special_keys(499, '&self', [], _76480)
^  <span class="ansi1 ansi32"
>Exit: </span>(268) [user] maybe_special_keys(499, '&self', [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [user] maybe_special_keys(499, '&self', ['Empty'-_5684], [])
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] best_key(unified, [], _55990)
   <span class="ansi1 ansi32"
>Call: </span>(268) [lists] lists:member(_91534-_55990, [])
   <span class="ansi1 ansi32"
>Call: </span>(268) [lists] lists:member(_92468-_55990, [])
   <span class="ansi1 ansi32"
>Call: </span>(268) [lists] lists:member(_93402-_55990, [])
   <span class="ansi1 ansi32"
>Call: </span>(268) [lists] lists:member(_94336-_55990, [])
   <span class="ansi1 ansi32"
>Call: </span>(267) [lists] lists:member(_95270-_55990, [])
   <span class="ansi1 ansi32"
>Call: </span>(266) [lists] lists:member(_96204-_96206, ['Empty'-_5684])
   <span class="ansi1 ansi32"
>Call: </span>(267) [lists] lists:member_([], _96204-_96206, 'Empty'-_5684)
   <span class="ansi1 ansi32"
>Exit: </span>(267) [lists] lists:member_([], 'Empty'-_5684, 'Empty'-_5684)
   <span class="ansi1 ansi32"
>Exit: </span>(266) [lists] lists:member('Empty'-_5684, ['Empty'-_5684])
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] 'Empty'=='%void%'
   <span class="ansi1 ansi32"
>Call: </span>(290) [lists] lists:member_([], (_8190->_8192), (['if-unify-or-empty', _8124, _8130]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(290) [lists] lists:member_([], (['if-unify-or-empty', _8124, _8130]->[empty]), (['if-unify-or-empty', _8124, _8130]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(289) [lists] lists:member_([(['if-unify-or-empty', _8124, _8130]->[empty])], (['if-unify-or-empty', _8124, _8130]->[empty]), '<garbage_collected>')
   <span class="ansi1 ansi32"
>Exit: </span>(288) [lists] lists:member((['if-unify-or-empty', _8124, _8130]->[empty]), [(['if-unify-or-empty', _8160, _8160]->unified), (['if-unify-or-empty', _8124, _8130]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] copy_term((['if-unify-or-empty', _8124, _8130]->[empty]), _8204)
   <span class="ansi1 ansi32"
>Exit: </span>(288) [system] copy_term((['if-unify-or-empty', _8124, _8130]->[empty]), (['if-unify-or-empty', _105524, _105530]->[empty]))
^  <span class="ansi1 ansi32"
>Call: </span>(288) [user] eval_defn_success(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], _7688, ['if-unify-or-empty', _8124, _8130], [empty], (['if-unify-or-empty', _105524, _105530]->[empty]))
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] ['if-unify-or-empty', _5666, _5666]=['if-unify-or-empty', _8124, _8130]
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] ['if-unify-or-empty', _5666, _5666]=['if-unify-or-empty', _5666, _5666]
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] _7688=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] [empty]=[empty]
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] ['if-unify-or-empty', _5666, _5666]\=@=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] ['if-unify-or-empty', _5666, _5666]\=@=[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(289) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _105524, _105530]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] setup_call_cleanup('$notrace'(_113980, _113982), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _105524, _105530]->[empty])))))), _113938, fbug((_113938-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _105524, _105530]->[empty])))))))))), '$restore_trace'(_113980, _113982))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] sig_atomic(system:'$notrace'(_113980, _113982))
^  <span class="ansi1 ansi32"
>Exit: </span>(291) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _105524, _105530]->[empty])))))), _113938, fbug((_113938-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _105524, _105530]->[empty])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(289) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _105524, _105530]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(289) [user] light_eval(=, _7358, 498, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(289) [user] light_eval(=, _7358, 498, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(288) [user] eval_defn_success(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty], ['if-unify-or-empty', _5666, _5666], [empty], (['if-unify-or-empty', _105524, _105530]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(286) [user] if_or_else((member((['if-unify-or-empty', _5666, _5666]->[empty]), [(['if-unify-or-empty', _8160, _8160]->unified), (['if-unify-or-empty', _5666, _5666]->[empty])]), copy_term((['if-unify-or-empty', _5666, _5666]->[empty]), (['if-unify-or-empty', _105524, _105530]->[empty])), eval_defn_success(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty], ['if-unify-or-empty', _5666, _5666], [empty], (['if-unify-or-empty', _105524, _105530]->[empty]))), eval_defn_failure(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty]))
^  <span class="ansi1 ansi32"
>Exit: </span>(285) [user] eval_defn_bodies(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty], [(['if-unify-or-empty', _8160, _8160]->unified), (['if-unify-or-empty', _5666, _5666]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [user] eval_defn_choose_candidates(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(284) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] ignore(notrace((\+[empty]\=_7820, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [system] setup_call_cleanup('$notrace'(_126292, _126294), once(user:(\+[empty]\=_7820, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_126292, _126294))
^  <span class="ansi1 ansi32"
>Call: </span>(287) [system] sig_atomic(system:'$notrace'(_126292, _126294))
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_7820, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [system] ignore(user:notrace((\+[empty]\=_7820, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] ignore((_7812==1->ignore(\+ \+ (flag(eval_num, _7850, _7850+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _7850, <--, [defn, [empty]]);indentq(1, _7850, <--, [defn, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _7850, _7850+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _7850, <--, [defn, [empty]]);indentq(1, _7850, <--, [defn, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(286) [system] _7812==1
   <span class="ansi1 ansi31"
>Fail: </span>(286) [system] _7812==1
^  <span class="ansi1 ansi32"
>Call: </span>(287) [system] setup_call_cleanup('$notrace'(_132868, _132870), once(user:ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _7850, _7850+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _7850, <--, [defn, [empty]]);indentq(1, _7850, <--, [defn, retval([empty])])))))))), '$restore_trace'(_132868, _132870))
^  <span class="ansi1 ansi32"
>Call: </span>(288) [system] sig_atomic(system:'$notrace'(_132868, _132870))
^  <span class="ansi1 ansi32"
>Exit: </span>(287) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _7850, _7850+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _7850, <--, [defn, [empty]]);indentq(1, _7850, <--, [defn, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(284) [system] ignore(user:(_7812==1->ignore(\+ \+ (flag(eval_num, _7850, _7850+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _7850, <--, [defn, [empty]]);indentq(1, _7850, <--, [defn, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _7850, _7850+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _7850, <--, [defn, [empty]]);indentq(1, _7850, <--, [defn, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(282) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _7358), 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_defn_choose_candidates(=, _7358), 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty])), ignore(notrace((\+[empty]\=_7820, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_7812==1->ignore(\+ \+ (flag(eval_num, _7850, _7850+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _7850, <--, [defn, [empty]]);indentq(1, _7850, <--, [defn, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _7850, _7850+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _7850, <--, [defn, [empty]]);indentq(1, _7850, <--, [defn, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(282) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(282) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(281) [user] trace_eval(eval_defn_choose_candidates(=, _7358), defn, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(280) [user] eval_maybe_defn(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(279) [user] if_or_else(eval_maybe_defn(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty]), eval_maybe_subst(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(278) [user] if_or_else(eval_maybe_host_function(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty]), if_or_else(eval_maybe_defn(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty]), eval_maybe_subst(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty])))
   <span class="ansi1 ansi32"
>Exit: </span>(277) [user] if_or_else(eval_maybe_host_predicate(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty]), if_or_else(eval_maybe_host_function(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty]), if_or_else(eval_maybe_defn(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty]), eval_maybe_subst(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty]))))
   <span class="ansi1 ansi32"
>Exit: </span>(276) [user] if_or_else(eval_maybe_python(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty]), if_or_else(eval_maybe_host_predicate(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty]), if_or_else(eval_maybe_host_function(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty]), if_or_else(eval_maybe_defn(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty]), eval_maybe_subst(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty])))))
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] eval_70(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(275) [user] check_returnval(=, _7358, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [user] check_returnval(=, _7358, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [user] eval_41(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(273) [user] eval_40(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(273) [system] [empty]=_7388
   <span class="ansi1 ansi32"
>Exit: </span>(273) [system] [empty]=[empty]
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [user] eval_20(=, _7358, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(272) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(272) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] ignore(notrace((\+[empty]\=_7404, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(274) [system] setup_call_cleanup('$notrace'(_155460, _155462), once(user:(\+[empty]\=_7404, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_155460, _155462))
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] sig_atomic(system:'$notrace'(_155460, _155462))
^  <span class="ansi1 ansi32"
>Exit: </span>(274) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_7404, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [system] ignore(user:notrace((\+[empty]\=_7404, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [user] ignore((_7396==1->ignore(\+ \+ (flag(eval_num, _7434, _7434+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _7434, <--, [e, [empty]]);indentq(1, _7434, <--, [e, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _7434, _7434+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _7434, <--, [e, [empty]]);indentq(1, _7434, <--, [e, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(274) [system] _7396==1
   <span class="ansi1 ansi31"
>Fail: </span>(274) [system] _7396==1
^  <span class="ansi1 ansi32"
>Call: </span>(275) [system] setup_call_cleanup('$notrace'(_162036, _162038), once(user:ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _7434, _7434+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _7434, <--, [e, [empty]]);indentq(1, _7434, <--, [e, retval([empty])])))))))), '$restore_trace'(_162036, _162038))
^  <span class="ansi1 ansi32"
>Call: </span>(276) [system] sig_atomic(system:'$notrace'(_162036, _162038))
^  <span class="ansi1 ansi32"
>Exit: </span>(275) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _7434, _7434+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _7434, <--, [e, [empty]]);indentq(1, _7434, <--, [e, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(272) [system] ignore(user:(_7396==1->ignore(\+ \+ (flag(eval_num, _7434, _7434+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _7434, <--, [e, [empty]]);indentq(1, _7434, <--, [e, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _7434, _7434+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _7434, <--, [e, [empty]]);indentq(1, _7434, <--, [e, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(270) [system] call_cleanup(user:((call(eval_20(=, _7358), 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_20(=, _7358), 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty])), ignore(notrace((\+[empty]\=_7404, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_7396==1->ignore(\+ \+ (flag(eval_num, _7434, _7434+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _7434, <--, [e, [empty]]);indentq(1, _7434, <--, [e, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _7434, _7434+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _7434, <--, [e, [empty]]);indentq(1, _7434, <--, [e, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(270) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [user] trace_eval(eval_20(=, _7358), e, 498, '&self', ['if-unify-or-empty', _5666, _5666], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(271) [system] setup_call_cleanup('$notrace'(_170644, _170646), once(user:self_eval0([empty])), '$restore_trace'(_170644, _170646))
^  <span class="ansi1 ansi32"
>Call: </span>(272) [system] sig_atomic(system:'$notrace'(_170644, _170646))
^  <span class="ansi1 ansi31"
>Fail: </span>(269) [user] self_eval([empty])
   <span class="ansi1 ansi32"
>Call: </span>(269) [system] [empty]=@=['if-unify-or-empty', _7372, _7372]
^  <span class="ansi1 ansi32"
>Call: </span>(269) [user] eval_01(=, _7358, 498, '&self', [empty], _174396)
   <span class="ansi1 ansi32"
>Call: </span>(270) [system] [empty]\==[empty]
   <span class="ansi1 ansi32"
>Call: </span>(266) [lists] lists:member(_176278-_176280, ['Empty'-_5684])
   <span class="ansi1 ansi32"
>Call: </span>(267) [lists] lists:member_([], _176278-_176280, 'Empty'-_5684)
   <span class="ansi1 ansi32"
>Exit: </span>(267) [lists] lists:member_([], 'Empty'-_5684, 'Empty'-_5684)
   <span class="ansi1 ansi32"
>Exit: </span>(266) [lists] lists:member('Empty'-_5684, ['Empty'-_5684])
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi31"
>Fail: </span>(264) [user] eval_20(=, _6936, 499, '&self', [case, ['if-unify-or-empty', _5666, _5666], [['Empty', _5684]]], _7038)
   <span class="ansi1 ansi32"
>Call: </span>(264) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(264) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(264) [user] ignore((_7046==1->ignore(\+ \+ (flag(eval_num, _7084, _7084+1), (retval(fail)\=@=retval(fail), nonvar(_7038)->indentq(0, _7084, <--, [e, _7038]);indentq(0, _7084, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _7084, _7084+1), (retval(fail)\=@=retval(fail), nonvar(_7038)->indentq(0, _7084, <--, [e, _7038]);indentq(0, _7084, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(266) [system] _7046==1
   <span class="ansi1 ansi31"
>Fail: </span>(266) [system] _7046==1
^  <span class="ansi1 ansi32"
>Call: </span>(267) [system] setup_call_cleanup('$notrace'(_186506, _186508), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _7084, _7084+1), (retval(fail)\=@=retval(fail), nonvar(_7038)->indentq(0, _7084, <--, [e, _7038]);indentq(0, _7084, <--, [e, retval(fail)])))))))), '$restore_trace'(_186506, _186508))
^  <span class="ansi1 ansi32"
>Call: </span>(268) [system] sig_atomic(system:'$notrace'(_186506, _186508))
^  <span class="ansi1 ansi32"
>Exit: </span>(267) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _7084, _7084+1), (retval(fail)\=@=retval(fail), nonvar(_7038)->indentq(0, _7084, <--, [e, _7038]);indentq(0, _7084, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(264) [system] ignore(user:(_7046==1->ignore(\+ \+ (flag(eval_num, _7084, _7084+1), (retval(fail)\=@=retval(fail), nonvar(_7038)->indentq(0, _7084, <--, [e, _7038]);indentq(0, _7084, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _7084, _7084+1), (retval(fail)\=@=retval(fail), nonvar(_7038)->indentq(0, _7084, <--, [e, _7038]);indentq(0, _7084, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(262) [system] call_cleanup(user:((call(eval_20(=, _6936), 499, '&self', [case, ['if-unify-or-empty', _5666, _5666], [['Empty', _5684]]], _7038)*->nb_setarg(1, retval(fail), _7038);fail, trace, call(eval_20(=, _6936), 499, '&self', [case, ['if-unify-or-empty', _5666, _5666], [['Empty', _5684]]], _7038)), ignore(notrace((\+_7038\=_7054, nb_setarg(1, retval(fail), _7038))))), user:ignore((_7046==1->ignore(\+ \+ (flag(eval_num, _7084, _7084+1), (retval(fail)\=@=retval(fail), nonvar(_7038)->indentq(0, _7084, <--, [e, _7038]);indentq(0, _7084, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _7084, _7084+1), (retval(fail)\=@=retval(fail), nonvar(_7038)->indentq(0, _7084, <--, [e, _7038]);indentq(0, _7084, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(261) [user] trace_eval(eval_20(=, _6936), e, 499, '&self', [case, ['if-unify-or-empty', _5666, _5666], [['Empty', _5684]]], _7038)
^  <span class="ansi1 ansi31"
>Fail: </span>(258) [user] eval_args(=, _6936, 500, '&self', [case, ['if-unify-or-empty', _5666, _5666], [['Empty', _5684]]], _6388)
^  <span class="ansi1 ansi31"
>Fail: </span>(249) [system] call(user:once, user:if_or_else(eval(=, _6368, 498, '&self', [case, ['if-unify-or-empty', _5666, _5666], [['Empty', _5684]]], _6388), call(eval, [case, ['if-unify-or-empty', _5666, _5666], [['Empty', _5684]]], _6388)))
^  <span class="ansi1 ansi32"
>Call: </span>(249) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(251) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(251) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(253) [system] setup_call_cleanup('$notrace'(_197000, _197002), once(rtrace:retract(t_l:tracer_reset(_196990))), '$restore_trace'(_197000, _197002))
^  <span class="ansi1 ansi32"
>Call: </span>(254) [system] sig_atomic(system:'$notrace'(_197000, _197002))
^  <span class="ansi1 ansi32"
>Exit: </span>(253) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(253) [rtrace] tAt(false, 271, 271, false)

NDet Result(147): <span class="ansi33"
>Empty
</span>
NDet Result(148): <span class="ansi33"
>(iz if-unify-or-empty MinimalMeTTaHelper)
</span>
NDet Result(149): <span class="ansi33"
>(@doc if-unify-or-empty (@desc "Attempts to unify two atoms and returns a result. Returns Empty if they cannot be unified.") (@params ((@param "First atom") (@param "Second atom"))) (@return "Unification result or Empty"))
</span>
NDet Result(150): <span class="ansi33"
>(: if-unify-or-empty (-> Atom Atom Atom))
</span>
NDet Result(151): <span class="ansi33"
>(= (if-unify-or-empty $10000 $10000)  unified)
</span>
NDet Result(152): <span class="ansi33"
>(= (if-unify-or-empty $10000 $10001)  
  (empty))
</span>
NDet Result(153): <span class="ansi33"
>(iz cons-atom MinimalMeTTa)
</span>
NDet Result(154): <span class="ansi33"
>(@doc cons-atom (@desc "Constructs an expression using two arguments") (@params ((@param "Head of an expression") (@param "Tail of an expression"))) (@return "New expression consisting of the two input arguments"))
</span>
NDet Result(155): <span class="ansi33"
>(: cons-atom (-> Atom Expression Expression))
</span>
NDet Result(156): <span class="ansi33"
>(iz decons-atom MinimalMeTTa)
</span>
NDet Result(157): <span class="ansi33"
>(@doc decons-atom (@desc "Works as a reverse to cons-atom function. It gets Expression as an input and returns it split into head and tail, e.g. (decons-atom (Cons X Nil)) -> (Cons (X Nil))") (@params ((@param "Expression to be Deconsed"))) (@return "Deconsed expression"))
</span>
NDet Result(158): <span class="ansi33"
>(: decons-atom (-> Expression Expression))
</span>
NDet Result(159): <span class="ansi33"
>(iz min-atom MeTTa)
</span>
NDet Result(160): <span class="ansi33"
>(@doc min-atom (@desc "Returns atom with minimum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Minimum value in the expression. Error if expression contains non-numeric value or is empty."))
</span>
NDet Result(161): <span class="ansi33"
>(: min-atom (-> Expression Number))
</span>
NDet Result(162): <span class="ansi33"
>(= (min-atom $10000)  
  (call-fn! min_list $10000))
</span>
NDet Result(163): <span class="ansi33"
>(iz max-atom MeTTa)
</span>
NDet Result(164): <span class="ansi33"
>(@doc max-atom (@desc "Returns atom with maximum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Maximum value in the expression. Error if expression contains non-numeric value or is empty."))
</span>
NDet Result(165): <span class="ansi33"
>(: max-atom (-> Expression Number))
</span>
NDet Result(166): <span class="ansi33"
>(is-fn-1 max-atom max_list)
</span>
NDet Result(167): <span class="ansi33"
>(iz size-atom MeTTa)
</span>
NDet Result(168): <span class="ansi33"
>(@doc size-atom (@desc "Returns the size of an expression (first argument).") (@params ((@param "Expression to measure the size of"))) (@return "Size of the expression"))
</span>
NDet Result(169): <span class="ansi33"
>(: size-atom (-> Expression Integer))
</span>
NDet Result(170): <span class="ansi33"
>(is-fn-1 size-atom length)
</span>
NDet Result(171): <span class="ansi33"
>(iz index-atom MeTTa)
</span>
NDet Result(172): <span class="ansi33"
>(@doc index-atom (@desc "Returns atom from an expression (first argument) using index (second argument) or error if index is out of bounds.") (@params ((@param "Expression") (@param "Index"))) (@return "Atom at the specified index in the expression. Error if index is out of bounds."))
</span>
NDet Result(173): <span class="ansi33"
>(: index-atom (-> Expression Number Atom))
</span>
NDet Result(174): <span class="ansi33"
>(is-fn-21 index-atom nth0)
</span>
NDet Result(175): <span class="ansi33"
>(iz powi MeTTa)
</span>
NDet Result(176): <span class="ansi33"
>(@doc powi (@desc "Takes base (first argument) and power (second argument) and returns the result of raising the base to the power.") (@params ((@param "Base. Could be a float.") (@param "Power. Must be an integer."))) (@return "Result of base raised to the power"))
</span>
NDet Result(177): <span class="ansi33"
>(= (powi $10000 $10001)  
  (call-fn! pow $10000 $10001))
</span>
NDet Result(178): <span class="ansi33"
>(==> (is-op-1 $10000 $10001) (is-fn-1 $10000 $10001))
</span>
NDet Result(179): <span class="ansi33"
>(==> (is-op-1 $10000 $10001) (: $10000 (-> Number Number)))
</span>
NDet Result(180): <span class="ansi33"
>(==> (is-op-2 $10000 $10001) (is-fn-2 $10000 $10001))
</span>
NDet Result(181): <span class="ansi33"
>(==> (is-op-2 $10000 $10001) (: $10000 (-> Number Number Number)))
</span>
NDet Result(182): <span class="ansi33"
>(==> (is-pred $10000 $10001) (is-pred-1 $10000 $10001))
</span>
NDet Result(183): <span class="ansi33"
>(==> (is-pred $10000 $10001) (: $10000 (-> Number Bool)))
</span>
NDet Result(184): <span class="ansi33"
>(==> (is-fn-1 $10000 $10001) (= ($10000 $10002)  
  (call-fn! $10001 $10002)))
</span>
NDet Result(185): <span class="ansi33"
>(==> (is-fn-r $10000 $10001) (= ($10000 $10002)  
  (call-fn-r! $10001 $10002)))
</span>
NDet Result(186): <span class="ansi33"
>(==> (is-fn-2 $10000 $10001) (= ($10000 $10002 $10003)  
  (call-fn! $10001 $10002 $10003)))
</span>
NDet Result(187): <span class="ansi33"
>(==> (is-fn-21 $10000 $10001) (= ($10000 $10002 $10003)  
  (call-fn! $10001 $10003 $10002)))
</span>
NDet Result(188): <span class="ansi33"
>(==> (is-pred-1 $10000 $10001) (= ($10000 $10002)  
  (call-p! $10001 $10002)))
</span>
NDet Result(189): <span class="ansi33"
>(==> (is-pred-2 $10000 $10001) (= ($10000 $10002 $10003)  
  (call-p! $10001 $10002 $10003)))
</span>
NDet Result(190): <span class="ansi33"
>(is-fn-1 py-list py_list)
</span>
NDet Result(191): <span class="ansi33"
>(iz powf MeTTa)
</span>
NDet Result(192): <span class="ansi33"
>(@doc powf (@desc "Takes base (first argument) and power (second argument) and returns the result of raising the base to the power.") (@params ((@param "Base. Could be afloat.") (@param "Power. Could be afloat."))) (@return "Result of base raisedtothepower "))
</span>
NDet Result(193): <span class="ansi33"
>(is-op-2 powf pow)
</span>
NDet Result(194): <span class="ansi33"
>(is-op-2 pow pow)
</span>
NDet Result(195): <span class="ansi33"
>(iz sqrt MeTTa)
</span>
NDet Result(196): <span class="ansi33"
>(@doc sqrt (@desc "Returns square root for input number (first argument) which should be >= 0") (@params ((@param "Input number"))) (@return "Result of a square root function"))
</span>
NDet Result(197): <span class="ansi33"
>(is-op-1 sqrt sqrt)
</span>
NDet Result(198): <span class="ansi33"
>(iz abs MeTTa)
</span>
NDet Result(199): <span class="ansi33"
>(@doc abs (@desc "Returns absolute value of input number (first argument)") (@params ((@param "Input number"))) (@return "Absolute value"))
</span>
NDet Result(200): <span class="ansi33"
>(is-op-1 abs abs)
</span>
NDet Result(201): <span class="ansi33"
>(iz log MeTTa)
</span>
NDet Result(202): <span class="ansi33"
>(@doc log (@desc "Returns result of a logarithm function given base (first argument) and input number (second argument)") (@params ((@param "Base") (@param "Input number"))) (@return "Result of log function"))
</span>
NDet Result(203): <span class="ansi33"
>(is-op-2 log log2)
</span>
NDet Result(204): <span class="ansi33"
>(iz trunc MeTTa)
</span>
NDet Result(205): <span class="ansi33"
>(@doc trunc (@desc "Returns integer part of the input value (first argument)") (@params ((@param "Float value"))) (@return "Integer part of float"))
</span>
NDet Result(206): <span class="ansi33"
>(is-op-1 trunc trunc)
</span>
NDet Result(207): <span class="ansi33"
>(iz ceil MeTTa)
</span>
NDet Result(208): <span class="ansi33"
>(@doc ceil (@desc "Returns the smallest integer greater than or equal to the input value (first argument)") (@params ((@param "Float value"))) (@return "Integer value greater than or equal to the input"))
</span>
NDet Result(209): <span class="ansi33"
>(is-op-1 ceil ceil)
</span>
NDet Result(210): <span class="ansi33"
>(iz floor MeTTa)
</span>
NDet Result(211): <span class="ansi33"
>(@doc floor (@desc "Returns the smallest integer less than or equal to the input value (first argument)") (@params ((@param "Float value"))) (@return "Integer value less than or equal to the input"))
</span>
NDet Result(212): <span class="ansi33"
>(is-op-1 floor floor)
</span>
NDet Result(213): <span class="ansi33"
>(iz round MeTTa)
</span>
NDet Result(214): <span class="ansi33"
>(@doc round (@desc "Returns the nearest integer to the input float value (first argument)") (@params ((@param "Float value"))) (@return "Nearest integer to the input"))
</span>
NDet Result(215): <span class="ansi33"
>(is-op-1 round round)
</span>
NDet Result(216): <span class="ansi33"
>(iz sin MeTTa)
</span>
NDet Result(217): <span class="ansi33"
>(@doc sin (@desc "Returns result of the sine function for an input value in radians (first argument)") (@params ((@param "Angle in radians"))) (@return "Result of the sine function"))
</span>
NDet Result(218): <span class="ansi33"
>(is-op-1 sin sin)
</span>
NDet Result(219): <span class="ansi33"
>(iz asin MeTTa)
</span>
NDet Result(220): <span class="ansi33"
>(@doc asin (@desc "Returns result of the arcsine function for an input value (first argument)") (@params ((@param "Float number"))) (@return "Result of the arcsine function"))
</span>
NDet Result(221): <span class="ansi33"
>(is-op-1 asin asin)
</span>
NDet Result(222): <span class="ansi33"
>(iz cos MeTTa)
</span>
NDet Result(223): <span class="ansi33"
>(@doc cos (@desc "Returns result of the cosine function for an input value in radians (first argument)") (@params ((@param "Angle in radians"))) (@return "Result of the cosine function"))
</span>
NDet Result(224): <span class="ansi33"
>(is-op-1 cos cos)
</span>
NDet Result(225): <span class="ansi33"
>(iz acos MeTTa)
</span>
NDet Result(226): <span class="ansi33"
>(@doc acos (@desc "Returns result of the arccosine function for an input value (first argument)") (@params ((@param "Float number"))) (@return "Result of the arccosine function"))
</span>
NDet Result(227): <span class="ansi33"
>(is-op-1 acos acos)
</span>
NDet Result(228): <span class="ansi33"
>(iz tan MeTTa)
</span>
NDet Result(229): <span class="ansi33"
>(@doc tan (@desc "Returns result of the tangent function for an input value in radians (first argument)") (@params ((@param "Angle in radians"))) (@return "Result of the tangent function"))
</span>
NDet Result(230): <span class="ansi33"
>(is-op-1 tan tan)
</span>
NDet Result(231): <span class="ansi33"
>(iz atan MeTTa)
</span>
NDet Result(232): <span class="ansi33"
>(@doc atan (@desc "Returns result of the arctangent function for an input value (first argument)") (@params ((@param "Float number"))) (@return "Result of the tangent function"))
</span>
NDet Result(233): <span class="ansi33"
>(is-op-1 atan atan)
</span>
NDet Result(234): <span class="ansi33"
>(iz isnan MeTTa)
</span>
NDet Result(235): <span class="ansi33"
>(@doc isnan (@desc "Returns True if input value is NaN. False - otherwise") (@params ((@param "Number"))) (@return "True/False"))
</span>
NDet Result(236): <span class="ansi33"
>(is-pred isnan is_NaN)
</span>
NDet Result(237): <span class="ansi33"
>(iz isinf MeTTa)
</span>
NDet Result(238): <span class="ansi33"
>(@doc isinf (@desc "Returns True if input value is positive or negative infinity. False - otherwise") (@params ((@param "Number"))) (@return "True/False"))
</span>
NDet Result(239): <span class="ansi33"
>(is-pred isinf is_Inf)
</span>
NDet Result(240): <span class="ansi33"
>(iz random-int MeTTa)
</span>
NDet Result(241): <span class="ansi33"
>(@doc random-int (@desc "Returns random int number from range defined by two numbers (first and second argument)") (@params ((@param "Range start") (@param "Range end"))) (@return "Random int number from defined range"))
</span>
NDet Result(242): <span class="ansi33"
>(is-op-2 random-int random)
</span>
NDet Result(243): <span class="ansi33"
>(iz random-float MeTTa)
</span>
NDet Result(244): <span class="ansi33"
>(@doc random-float (@desc "Returns random float number from range defined by two numbers (first and second argument)") (@params ((@param "Range start") (@param "Range end"))) (@return "Random float number from defined range"))
</span>
NDet Result(245): <span class="ansi33"
>(iz collapse-bind MeTTa)
</span>
NDet Result(246): <span class="ansi33"
>(@doc collapse-bind (@desc "Evaluates the Atom (first argument) and returns an expression which contains all alternative evaluations in a form (Atom Bindings). Bindings are represented in a form of a grounded atom { <var> <- <binding>, ... }. See also the complement superpose-bind. Note that, like chain, collapse-bind only evaluates Minimal Metta expressions. Evaluation of non-Minimal MeTTa atoms can be controlled by wrapping in a call to eval (for one evaluation step) or metta (for full evaluation).") (@params ((@param "Atom to be evaluated"))) (@return "All alternative evaluations"))
</span>
NDet Result(247): <span class="ansi33"
>(: collapse-bind (-> Atom Expression))
</span>
NDet Result(248): <span class="ansi33"
>(iz superpose-bind MeTTa)
</span>
NDet Result(249): <span class="ansi33"
>(@doc superpose-bind (@desc "Complement to the collapse-bind. It takes result of collapse-bind (first argument) and returns only result atoms without bindings. Primarily used with some filtering step on the collapse-bind results, i.e. collapse-bind -> <filter> -> superpose-bind.") (@params ((@param "Expression in form (Atom Binding)"))) (@return "Non-deterministic list of Atoms"))
</span>
NDet Result(250): <span class="ansi33"
>(: superpose-bind (-> Expression Atom))
</span>
NDet Result(251): <span class="ansi33"
>(@doc metta (@desc "Run MeTTa interpreter on atom.") (@params ((@param "Atom to be interpreted") (@param "Type of input atom") (@param "Atomspace where intepretation should take place"))) (@return "Result of interpretation"))
</span>
NDet Result(252): <span class="ansi33"
>(: metta (-> Atom Type Grounded Atom))
</span>
NDet Result(253): <span class="ansi33"
>(iz id MinimalMeTTa)
</span>
NDet Result(254): <span class="ansi33"
>(@doc id (@desc "Returns its argument") (@params ((@param "Input argument"))) (@return "Input argument"))
</span>
NDet Result(255): <span class="ansi33"
>(: id (-> Atom Atom))
</span>
NDet Result(256): <span class="ansi33"
>(= (id $10000)  $10000)
</span>
NDet Result(257): <span class="ansi33"
>(iz atom-subst MinimalMeTTa)
</span>
NDet Result(258): <span class="ansi33"
>(@doc atom-subst (@desc "Substitutes variable passed as a second argument in the third argument by the first argument") (@params ((@param "Value to use for replacement") (@param "Variable to replace") (@param "Template to replace variable by the value"))) (@return "Template with substituted variable"))
</span>
NDet Result(259): <span class="ansi33"
>(: atom-subst (-> Atom Variable Atom Atom))
</span>
NDet Result(260): <span class="ansi33"
>(= (atom-subst $10000 $10001 $10002)  
  (function (chain (eval (id $10000)) $10001 (return $10002))))
</span>
NDet Result(261): <span class="ansi33"
>(iz if-decons-expr MinimalMeTTaHelper)
</span>
NDet Result(262): <span class="ansi33"
>(@doc if-decons-expr (@desc "Checks if first argument is non empty expression. If so gets tail and head from the first argument and returns forth argument using head and tail values. Returns fifth argument otherwise.") (@params ((@param "Expression to be deconstructed") (@param "Head variable") (@param "Tail variable") (@param "Template to return if first argument is a non-empty expression") (@param "Default value to return otherwise"))) (@return "Either template with head and tail replaced by values or default value"))
</span>
NDet Result(263): <span class="ansi33"
>(: if-decons-expr (-> Expression Variable Variable Atom Atom Atom))
</span>
NDet Result(264): <span class="ansi33"
>(= (if-decons-expr $10000 $10001 $10002 $10003 $10004)  
  (if-decons $10000 $10001 $10002 $10003 $10004))
</span>
NDet Result(265): <span class="ansi33"
>(: if-decons (-> Expression Variable Variable Atom Atom Atom))
</span>
NDet Result(266): <span class="ansi33"
>(ALT= $10000 $10001)
</span>
NDet Result(267): <span class="ansi33"
>(iz if-error MinimalMeTTaHelper)
</span>
NDet Result(268): <span class="ansi33"
>(@doc if-error (@desc "Checks if first argument is an error atom. Returns second argument if so or third argument otherwise.") (@params ((@param "Atom to be checked for the error") (@param "Value to return if first argument is an error") (@param "Value to return otherwise"))) (@return "Second or third argument"))
</span>
NDet Result(269): <span class="ansi33"
>(: if-error (-> Atom Atom Atom Atom))
</span>
NDet Result(270): <span class="ansi33"
>(= (if-error $10000 $10001 $10002)  
  (function (chain (eval (get-metatype $10000)) $10003 (eval (if-equal $10003 Expression (eval (if-equal $10000 () (return $10002) (chain (decons-atom $10000) $10004 (if-unify $10004 ($10005 $10006) (eval (if-equal $10005 Error (return $10001) (return $10002))) (return $10002))))) (return $10002))))))
</span>
NDet Result(271): <span class="ansi33"
>(iz return-on-error MinimalMeTTaHelper)
</span>
NDet Result(272): <span class="ansi33"
>(@doc return-on-error (@desc "Returns first argument if it is Empty or an error. Returns second argument otherwise.") (@params ((@param "Previous evaluation result") (@param "Atom for further evaluation"))) (@return "Return previous result if it is an error or Empty or continue evaluation"))
</span>
NDet Result(273): <span class="ansi33"
>(: return-on-error (-> Atom Atom Atom))
</span>
NDet Result(274): <span class="ansi33"
>Empty
</span>
NDet Result(275): <span class="ansi33"
>(iz switch MinimalMeTTaHelper)
</span>
NDet Result(276): <span class="ansi33"
>(@doc switch (@desc "Subsequently tests multiple pattern-matching conditions (second argument) for the given value (first argument)") (@params ((@param "Atom to be matched with patterns") (@param "Tuple of pairs mapping condition patterns to results"))) (@return "Result which corresponds to the pattern which is matched with the passed atom first"))
</span>
NDet Result(277): <span class="ansi33"
>(: switch (-> Atom Atom Atom))
</span>
NDet Result(278): <span class="ansi33"
>(= (switch $10000 $10001)  
  (case 
    (eval $10000) $10001))
</span>
NDet Result(279): <span class="ansi33"
>Empty
</span>
NDet Result(280): <span class="ansi33"
>(iz is-function MinimalMeTTaHelper)
</span>
NDet Result(281): <span class="ansi33"
>(@doc is-function (@desc "Function checks if input type is a function type") (@params ((@param "Type atom"))) (@return "True if type is a function type, False - otherwise"))
</span>
NDet Result(282): <span class="ansi33"
>(: is-function (-> Type Bool))
</span>
NDet Result(283): <span class="ansi33"
>(= (is-function $10000)  
  (function (chain (eval (get-metatype $10000)) $10001 (eval (switch ($10000 $10001) ((($10000 Expression) (eval (if-decons-expr $10000 $10002 $10003 (if-unify $10002 -> (return True) (return False)) (return (Error (is-function $10000) "is-function non-empty expression as an argument"))))) (($10000 $10001) (return False))))))))
</span>
NDet Result(284): <span class="ansi33"
>(iz type-cast MeTTa)
</span>
NDet Result(285): <span class="ansi33"
>(@doc type-cast (@desc "Casts atom passed as a first argument to the type passed as a second argument using space as a context") (@params ((@param "Atom to be casted") (@param "Type to cast atom to") (@param "Context atomspace"))) (@return "Atom if casting is successful, (Error ... BadType) otherwise"))
</span>
NDet Result(286): <span class="ansi33"
>(: type-cast (-> Atom Atom Atom Atom))
</span>
NDet Result(287): <span class="ansi33"
>(ALT= $10000 $10001)
</span>
NDet Result(288): <span class="ansi33"
>(iz match-types MeTTa)
</span>
NDet Result(289): <span class="ansi33"
>(@doc match-types (@desc "Checks if two types can be unified and returns third argument if so, fourth - otherwise") (@params ((@param "First type") (@param "Second type") (@param "Atom to be returned if types can be unified") (@param "Atom to be returned if types cannot be unified"))) (@return "Third or fourth argument"))
</span>
NDet Result(290): <span class="ansi33"
>(: match-types (-> Atom Atom Atom Atom Atom))
</span>
NDet Result(291): <span class="ansi33"
>(= (match-types $10000 $10001 $10002 $10003)  
  (function (eval (if-equal $10000 %Undefined% (return $10002) (eval (if-equal $10001 %Undefined% (return $10002) (eval (if-equal $10000 Atom (return $10002) (eval (if-equal $10001 Atom (return $10002) (if-unify $10000 $10001 (return $10002) (return $10003))))))))))))
</span>
NDet Result(292): <span class="ansi33"
>(iz first-from-pair MinimalMeTTaHelper)
</span>
NDet Result(293): <span class="ansi33"
>(@doc first-from-pair (@desc "Gets a pair as a first argument and returns first atom from pair") (@params ((@param "Pair"))) (@return "First atom from a pair"))
</span>
NDet Result(294): <span class="ansi33"
>(= (first-from-pair $10000)  
  (function (if-unify $10000 ($10001 $10002) (return $10001) (return (Error (first-from-pair $10000) "incorrect pair format")))))
</span>
NDet Result(295): <span class="ansi33"
>(iz match-type-or HelperMM)
</span>
NDet Result(296): <span class="ansi33"
>(@doc match-type-or (@desc "Checks if two types (second and third arguments) can be unified and returns result of OR operation between first argument and type checking result") (@params ((@param "Boolean value") (@param "First type") (@param "Second type"))) (@return "True or False"))
</span>
NDet Result(297): <span class="ansi33"
>(= (match-type-or $10000 $10001 $10002)  
  (function (chain (eval (match-types $10001 $10002 True False)) $10003 (chain (eval (or $10000 $10003)) $10004 (return $10004)))))
</span>
NDet Result(298): <span class="ansi33"
>(iz filter-atom MeTTa)
</span>
NDet Result(299): <span class="ansi33"
>(@doc filter-atom (@desc "Function takes list of atoms (first argument), variable (second argument) and filter predicate (third argument) and returns list with items which passed filter. E.g. (filter-atom (1 2 3 4) $v (eval (> $v 2))) will give (3 4)") (@params ((@param "List of atoms") (@param "Variable") (@param "Filter predicate"))) (@return "Filtered list"))
</span>
NDet Result(300): <span class="ansi33"
>(: filter-atom (-> Expression Variable Atom Expression))
</span>
NDet Result(301): <span class="ansi33"
>(= (filter-atom $10000 $10001 $10002)  
  (function (eval (if-decons-expr $10000 $10003 $10004 (chain (eval (filter-atom $10004 $10001 $10002)) $10005 (chain (eval (atom-subst $10003 $10001 $10002)) $10006 (chain $10006 $10007 (eval (if $10007 (chain (cons-atom $10003 $10005) $10008 (return $10008)) (return $10005)))))) (return ())))))
</span>
NDet Result(302): <span class="ansi33"
>(iz map-atom MeTTa)
</span>
NDet Result(303): <span class="ansi33"
>(@doc map-atom (@desc "Function takes list of atoms (first argument), variable to be used inside (second variable) and an expression which will be evaluated for each atom in list (third argument). Expression should contain variable. So e.g. (map-atom (1 2 3 4) $v (eval (+ $v 1))) will give (2 3 4 5)") (@params ((@param "List of atoms") (@param "Variable name") (@param "Template using variable"))) (@return "Result of evaluating template for each atom in a list"))
</span>
NDet Result(304): <span class="ansi33"
>(: map-atom (-> Expression Variable Atom Expression))
</span>
NDet Result(305): <span class="ansi33"
>(= (map-atom $10000 $10001 $10002)  
  (function (eval (if-decons-expr $10000 $10003 $10004 (chain (eval (map-atom $10004 $10001 $10002)) $10005 (chain (eval (atom-subst $10003 $10001 $10002)) $10006 (chain $10006 $10007 (chain (cons-atom $10007 $10005) $10008 (return $10008))))) (return ())))))
</span>
NDet Result(306): <span class="ansi33"
>(iz foldl-atom MeTTa)
</span>
NDet Result(307): <span class="ansi33"
>(@doc foldl-atom (@desc "Function takes list of values (first argument), initial value (second argument) and operation (fifth argument) and applies it consequently to the list of values, using init value as a start. It also takes two variables (third and fourth argument) to use them inside") (@params ((@param "List of values") (@param "Init value") (@param "Variable") (@param "Variable") (@param "Operation"))) (@return "Result of applying operation to the list of values"))
</span>
NDet Result(308): <span class="ansi33"
>(: foldl-atom (-> Expression Atom Variable Variable Atom Atom))
</span>
NDet Result(309): <span class="ansi33"
>(= (foldl-atom $10000 $10001 $10002 $10003 $10004)  
  (function (eval (if-decons-expr $10000 $10005 $10006 (chain (eval (atom-subst $10001 $10002 $10004)) $10007 (chain (eval (atom-subst $10005 $10003 $10007)) $10008 (chain $10008 $10009 (chain (eval (foldl-atom $10006 $10009 $10002 $10003 $10004)) $10010 (return $10010))))) (return $10001)))))
</span>
NDet Result(310): <span class="ansi33"
>(iz separate-errors MinimalMeTTaHelper)
</span>
NDet Result(311): <span class="ansi33"
>(: separate-errors (-> Expression Expression Expression))
</span>
NDet Result(312): <span class="ansi33"
>(= (separate-errors $10000 $10001)  
  (function (if-unify $10000 ($10002 $10003) (if-unify $10001 ($10004 $10005) (eval (if-error $10004 (chain (cons-atom $10001 $10003) $10006 (return ($10002 $10006))) (chain (cons-atom $10001 $10002) $10007 (return ($10007 $10003))))) (return $10000)) (return $10000))))
</span>
NDet Result(313): <span class="ansi33"
>(iz check-alternatives MinimalMeTTaHelper)
</span>
NDet Result(314): <span class="ansi33"
>(= (check-alternatives $10000)  
  (function (chain (collapse-bind $10000) $10001 (chain (eval (foldl-atom $10001 (() ()) $10002 $10003 (eval (separate-errors $10002 $10003)))) $10004 (if-unify $10004 ($10005 $10006) (chain (eval (if-equal $10005 () $10006 $10005)) $10007 (chain (superpose-bind $10007) $10008 (return $10008))) (return (Error (check-alternatives $10000) "list of results was not filtered correctly")))))))
</span>
NDet Result(315): <span class="ansi33"
>(iz interpret MeTTa)
</span>
NDet Result(316): <span class="ansi33"
>(= (interpret $10000 $10001 $10002)  
  (function (chain (eval (get-metatype $10000)) $10003 (eval (if-equal $10001 Atom (return $10000) (eval (if-equal $10001 $10003 (return $10000) (eval (switch ($10001 $10003) ((($10001 Variable) (return $10000)) (($10001 Symbol) (chain (eval (type-cast $10000 $10001 $10002)) $10004 (return $10004))) (($10001 Grounded) (chain (eval (type-cast $10000 $10001 $10002)) $10004 (return $10004))) (($10001 Expression) (chain (eval (check-alternatives (eval (interpret-expression $10000 $10001 $10002)))) $10004 (return $10004)))))))))))))
</span>
NDet Result(317): <span class="ansi33"
>(iz interpret-expression MinimalMeTTaHelper)
</span>
NDet Result(318): <span class="ansi33"
>(= (interpret-expression $10000 $10001 $10002)  
  (function (eval (if-decons $10000 $10003 $10004 (chain (eval (get-type $10003 $10002)) $10005 (chain (eval (is-function $10005)) $10006 (if-unify $10006 True (chain (eval (interpret-func $10000 $10005 $10001 $10002)) $10007 (chain (eval (metta-call $10007 $10001 $10002)) $10008 (return $10008))) (chain (eval (interpret-tuple $10000 $10002)) $10007 (chain (eval (metta-call $10007 $10001 $10002)) $10008 (return $10008)))))) (chain (eval (type-cast $10000 $10001 $10002)) $10008 (return $10008))))))
</span>
NDet Result(319): <span class="ansi33"
>(iz interpret-func MinimalMeTTaHelper)
</span>
NDet Result(320): <span class="ansi33"
>(= (interpret-func $10000 $10001 $10002 $10003)  
  (function (eval (if-decons $10000 $10004 $10005 (chain (eval (interpret $10004 $10001 $10003)) $10006 (eval (return-on-error $10006 (eval (if-decons $10001 $10007 $10008 (chain (eval (interpret-args $10000 $10005 $10008 $10002 $10003)) $10009 (eval (return-on-error $10009 (chain (cons-atom $10006 $10009) $10010 (return $10010))))) (return (Error $10001 "Function type expected"))))))) (return (Error $10000 "Non-empty expression atom is expected"))))))
</span>
NDet Result(321): <span class="ansi33"
>(iz interpret-args MinimalMeTTaHelper)
</span>
NDet Result(322): <span class="ansi33"
>(= (interpret-args $10000 $10001 $10002 $10003 $10004)  
  (function (if-unify $10001 () (eval (if-decons $10002 $10005 $10006 (chain (eval (== () $10006)) $10007 (eval (if $10007 (eval (match-types $10005 $10003 (return ()) (return (Error $10000 BadType)))) (return (Error $10000 BadType))))) (return (Error $10000 "Too many arguments")))) (eval (if-decons $10001 $10008 $10009 (eval (if-decons $10002 $10010 $10011 (chain (eval (interpret $10008 $10010 $10004)) $10012 (eval (if-equal $10012 $10008 (chain (eval (interpret-args-tail $10000 $10012 $10009 $10011 $10003 $10004)) $10013 (return $10013)) (eval (return-on-error $10012 (chain (eval (interpret-args-tail $10000 $10012 $10009 $10011 $10003 $10004)) $10013 (return $10013))))))) (return (Error $10000 BadType)))) (return (Error (interpret-atom $10000 $10001 $10002 $10004) "Non-empty expression atom is expected")))))))
</span>
NDet Result(323): <span class="ansi33"
>(iz interpret-args-tail MinimalMeTTaHelper)
</span>
NDet Result(324): <span class="ansi33"
>(= (interpret-args-tail $10000 $10001 $10002 $10003 $10004 $10005)  
  (function (chain (eval (interpret-args $10000 $10002 $10003 $10004 $10005)) $10006 (eval (return-on-error $10006 (chain (cons-atom $10001 $10006) $10007 (return $10007)))))))
</span>
NDet Result(325): <span class="ansi33"
>(iz interpret-tuple MinimalMeTTaHelper)
</span>
NDet Result(326): <span class="ansi33"
>Empty
</span>
NDet Result(327): <span class="ansi33"
>(iz metta-call MinimalMeTTaHelper)
</span>
NDet Result(328): <span class="ansi33"
>Empty
</span>
NDet Result(329): <span class="ansi33"
>(iz is-function-type MeTTa)
</span>
NDet Result(330): <span class="ansi33"
>(@doc is-function-type (@desc "Function checks if input type is a function type") (@params ((@param "Type notation"))) (@return "True if input type notation is a function type, False - otherwise"))
</span>
NDet Result(331): <span class="ansi33"
>(: is-function-type (-> Type Bool))
</span>
NDet Result(332): <span class="ansi33"
>(= (is-function-type $10000)  
  (let $10001 
    (get-metatype $10000) 
    (case $10001 
      ( (Expression (let $10002 (car-atom $10000) (if (== $10002 ->) True False))) ($10003 False)))))
</span>
NDet Result(333): <span class="ansi33"
>(iz if MeTTa)
</span>
NDet Result(334): <span class="ansi33"
>(@doc if (@desc "Replace itself by one of the arguments depending on condition.") (@params ((@param "Boolean condition") (@param "Result when condition is True") (@param "Result when condition is False"))) (@return "Second or third argument"))
</span>
NDet Result(335): <span class="ansi33"
>(: if (-> Bool Atom Atom $10000))
</span>
NDet Result(336): <span class="ansi33"
>(ALT= $10000 $10000)
</span>
NDet Result(337): <span class="ansi33"
>(ALT= $10000 $10000)
</span>
NDet Result(338): <span class="ansi33"
>(iz or MeTTa)
</span>
NDet Result(339): <span class="ansi33"
>(@doc or (@desc "Logical disjunction of two arguments") (@params ((@param "First argument") (@param "Second argument"))) (@return "True if any of input arguments is True, False - otherwise"))
</span>
NDet Result(340): <span class="ansi33"
>(: or (-> Bool LazyBool Bool))
</span>
NDet Result(341): <span class="ansi33"
>(ALT= False False)
</span>
NDet Result(342): <span class="ansi33"
>(ALT= True True)
</span>
NDet Result(343): <span class="ansi33"
>(ALT= True True)
</span>
NDet Result(344): <span class="ansi33"
>(ALT= True True)
</span>
NDet Result(345): <span class="ansi33"
>(ALT= True True)
</span>
NDet Result(346): <span class="ansi33"
>(iz and MeTTa)
</span>
NDet Result(347): <span class="ansi33"
>(@doc and (@desc "Logical conjunction of two arguments") (@params ((@param "First argument") (@param "Second argument"))) (@return "Returns True if both arguments are True, False - otherwise"))
</span>
NDet Result(348): <span class="ansi33"
>(: and (-> Bool LazyBool Bool))
</span>
NDet Result(349): <span class="ansi33"
>(ALT= False False)
</span>
NDet Result(350): <span class="ansi33"
>(ALT= False False)
</span>
NDet Result(351): <span class="ansi33"
>(ALT= False False)
</span>
NDet Result(352): <span class="ansi33"
>(ALT= True True)
</span>
NDet Result(353): <span class="ansi33"
>(iz not MeTTa)
</span>
NDet Result(354): <span class="ansi33"
>(@doc not (@desc "Logical negation") (@params ((@param "Argument"))) (@return "Negates boolean input argument (False -> True, True -> False)"))
</span>
NDet Result(355): <span class="ansi33"
>(: not (-> Bool Bool))
</span>
NDet Result(356): <span class="ansi33"
>(ALT= False False)
</span>
NDet Result(357): <span class="ansi33"
>(ALT= True True)
</span>
NDet Result(358): <span class="ansi33"
>(iz let MeTTa)
</span>
NDet Result(359): <span class="ansi33"
>(@doc let (@desc "Let function is utilized to establish temporary variable bindings within an expression. It allows introducing variables (first argument), assign values to them (second argument), and then use these values within the scope of the let block") (@params ((@param "Variable name (or several variables inside brackets ())") (@param "Expression to be bound to variable (it is being reduced before bind)") (@param "Expression which will be reduced and in which variable (first argument) could be used"))) (@return "Result of third argument's evaluation"))
</span>
NDet Result(360): <span class="ansi33"
>(: let (-> Atom %Undefined% Atom Atom))
</span>
NDet Result(361): <span class="ansi33"
>(ALT= $10000 $10000)
</span>
NDet Result(362): <span class="ansi33"
>(iz let* MeTTa)
</span>
NDet Result(363): <span class="ansi33"
>(@doc let* (@desc "Same as let, but first argument is a tuple containing tuples of variables and their bindings, e.g. (($v (+ 1 2)) ($v2 (* 5 6)))") (@params ((@param "Tuple of tuples with variables and their bindings") (@param "Expression which will be evaluated if each pair can be unified"))) (@return "Second argument or Empty"))
</span>
NDet Result(364): <span class="ansi33"
>(: let* (-> Expression Atom %Undefined%))
</span>
NDet Result(365): 

#(failed #( : user once ) #( : user #( \+ #( \+ #( , #(maybe_name_vars ()) #( , #(old_not_compatio #(write_bsrc (ALT= (let* (($10000 $10000) 
^  <span class="ansi1 ansi32"
>Call: </span>(246) [user] call(user:once, user:(\+ \+ (maybe_name_vars([]), old_not_compatio(write_bsrc(['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]])), true)))
^  <span class="ansi1 ansi32"
>Call: </span>(247) [user] once(user:(\+ \+ (maybe_name_vars([]), old_not_compatio(write_bsrc(['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]])), true)))
^  <span class="ansi1 ansi32"
>Call: </span>(249) [user] maybe_name_vars([])
   <span class="ansi1 ansi32"
>Call: </span>(250) [system] is_list([])
   <span class="ansi1 ansi32"
>Exit: </span>(250) [system] is_list([])
^  <span class="ansi1 ansi32"
>Exit: </span>(249) [user] maybe_name_vars([])
   <span class="ansi1 ansi32"
>Call: </span>(249) [user] old_not_compatio(write_bsrc(['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]]))
   <span class="ansi1 ansi32"
>Call: </span>(250) [user] write_bsrc(['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]])
   <span class="ansi1 ansi32"
>Call: </span>(251) [system] ['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]]=='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(251) [system] ground(['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]])
   <span class="ansi1 ansi32"
>Call: </span>(251) [$attvar] copy_term(['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]], _826936, _826938)
   <span class="ansi1 ansi32"
>Call: </span>(252) [system] term_attvars(['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]], _827872)
   <span class="ansi1 ansi32"
>Exit: </span>(252) [system] term_attvars(['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]], [])
   <span class="ansi1 ansi32"
>Call: </span>(252) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(252) [system] []==[]
   <span class="ansi1 ansi32"
>Call: </span>(252) [system] _826938=[]
   <span class="ansi1 ansi32"
>Exit: </span>(252) [system] []=[]
   <span class="ansi1 ansi32"
>Call: </span>(252) [system] copy_term(['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]], _826936)
   <span class="ansi1 ansi32"
>Exit: </span>(252) [system] copy_term(['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]], ['ALT=', ['let*', [[_834404, _834404]|_834400], _834416], ['let*', _834400, _834416]])
   <span class="ansi1 ansi32"
>Exit: </span>(251) [$attvar] copy_term(['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]], ['ALT=', ['let*', [[_834404, _834404]|_834400], _834416], ['let*', _834400, _834416]], [])
   <span class="ansi1 ansi32"
>Call: </span>(251) [system] ['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]]=['ALT=', ['let*', [[_834404, _834404]|_834400], _834416], ['let*', _834400, _834416]]
   <span class="ansi1 ansi32"
>Exit: </span>(251) [system] ['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]]=['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]]
   <span class="ansi1 ansi32"
>Call: </span>(251) [user] write_bsrc_goal(['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]], [])
^  <span class="ansi1 ansi32"
>Call: </span>(252) [user] write_src(['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]])
^  <span class="ansi1 ansi32"
>Call: </span>(254) [system] setup_call_cleanup('$notrace'(_840024, _840026), once(user:(src_vars(['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]], _840010), pp_sex(_840010))), '$restore_trace'(_840024, _840026))
^  <span class="ansi1 ansi32"
>Call: </span>(255) [system] sig_atomic(system:'$notrace'(_840024, _840026))
^  <span class="ansi1 ansi31"
>Fail: </span>(252) [user] write_src(['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]])
   <span class="ansi1 ansi31"
>Fail: </span>(249) [user] old_not_compatio(write_bsrc(['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(246) [system] call(user:once, user:(\+ \+ (maybe_name_vars([]), old_not_compatio(write_bsrc(['ALT=', ['let*', [[_784424, _784424]|_784436], _784382], ['let*', _784436, _784382]])), true)))
^  <span class="ansi1 ansi32"
>Call: </span>(246) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(248) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(248) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(250) [system] setup_call_cleanup('$notrace'(_847498, _847500), once(rtrace:retract(t_l:tracer_reset(_847488))), '$restore_trace'(_847498, _847500))
^  <span class="ansi1 ansi32"
>Call: </span>(251) [system] sig_atomic(system:'$notrace'(_847498, _847500))
^  <span class="ansi1 ansi32"
>Exit: </span>(250) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(250) [rtrace] tAt(false, 271, 271, false)

NDet Result(366): <span class="ansi33"
>(iz add-reduct MeTTa)
</span>
NDet Result(367): <span class="ansi33"
>(@doc add-reduct (@desc "Prevents atom from being reduced") (@params ((@param "Atom"))) (@return "Quoted atom"))
</span>
NDet Result(368): <span class="ansi33"
>(@doc add-reduct-rust1 (@desc "Adds atom into the atomspace reducing it first") (@params ((@param "Atomspace to add atom into") (@param "Atom to add"))) (@return "Unit atom"))
</span>
NDet Result(369): <span class="ansi33"
>(: add-reduct-rust1 (-> hyperon::space::DynSpace %Undefined% (->)))
</span>
NDet Result(370): <span class="ansi33"
>(= (add-reduct-minimal $10000 $10001)  
  (add-atom $10000 $10001))
</span>
NDet Result(371): <span class="ansi33"
>(: add-reduct (-> Grounded %Undefined% (->)))
</span>
NDet Result(372): <span class="ansi33"
>(= (add-reduct $10000 $10001)  
  (add-atom $10000 $10001))
</span>
NDet Result(373): <span class="ansi33"
>(iz stringToChars MeTTa)
</span>
NDet Result(374): <span class="ansi33"
>(@doc stringToChars (@desc "Converts a string into a list expression of characters.") (@params ((@param "String to be converted."))) (@return "Expression representing the list of characters."))
</span>
NDet Result(375): <span class="ansi33"
>(: stringToChars (-> String Expression))
</span>
NDet Result(376): <span class="ansi33"
>(iz charsToString MeTTa)
</span>
NDet Result(377): <span class="ansi33"
>(@doc charsToString (@desc "Converts a list expression of characters into a string.") (@params ((@param "Expression representing the list of characters."))) (@return "Converted string."))
</span>
NDet Result(378): <span class="ansi33"
>(: charsToString (-> Expression String))
</span>
NDet Result(379): <span class="ansi33"
>(iz parse MeTTa)
</span>
NDet Result(380): <span class="ansi33"
>(@doc parse (@desc "Parses MeTTa code from a string and returns the corresponding atom.") (@params ((@param "String containing MeTTa code."))) (@return "Parsed atom."))
</span>
NDet Result(381): <span class="ansi33"
>(: parse (-> String Atom))
</span>
NDet Result(382): <span class="ansi33"
>(iz repr MeTTa)
</span>
NDet Result(383): <span class="ansi33"
>(@doc repr (@desc "Creates a string representation of an atom.") (@params ((@param "Atom to be represented as a string."))) (@return "String representation of the atom."))
</span>
NDet Result(384): <span class="ansi33"
>(: repr (-> Atom String))
</span>
NDet Result(385): <span class="ansi33"
>(iz car-atom MeTTa)
</span>
NDet Result(386): <span class="ansi33"
>(@doc car-atom (@desc "Extracts the first atom of an expression as a tuple") (@params ((@param "Expression"))) (@return "First atom of an expression"))
</span>
NDet Result(387): <span class="ansi33"
>(: car-atom (-> Expression Atom))
</span>
NDet Result(388): <span class="ansi33"
>(ALT= $10000 $10000)
</span>
NDet Result(389): <span class="ansi33"
>(iz cdr-atom MeTTa)
</span>
NDet Result(390): <span class="ansi33"
>(@doc cdr-atom (@desc "Extracts the tail of an expression (all except first atom)") (@params ((@param "Expression"))) (@return "Tail of an expression"))
</span>
NDet Result(391): <span class="ansi33"
>(: cdr-atom (-> Expression Expression))
</span>
NDet Result(392): <span class="ansi33"
>(= (cdr-atom $10000)  
  (eval (if-decons-expr $10000 $10001 $10002 $10002 (Error (cdr-atom $10000) "cdr-atom expects a non-empty expression as an argument"))))
</span>
NDet Result(393): <span class="ansi33"
>(iz quote MeTTa)
</span>
NDet Result(394): <span class="ansi33"
>(@doc quote (@desc "Prevents atom from being reduced") (@params ((@param "Atom"))) (@return "Quoted atom"))
</span>
NDet Result(395): <span class="ansi33"
>(: quote (-> Atom Atom))
</span>
NDet Result(396): <span class="ansi33"
>(= (quote $10000)  NotReducible)
</span>
NDet Result(397): <span class="ansi33"
>(iz unquote MeTTa)
</span>
NDet Result(398): <span class="ansi33"
>(@doc unquote (@desc "Unquotes quoted atom, e.g. (unquote (quote $x)) returns $x") (@params ((@param "Quoted atom"))) (@return "Unquoted atom"))
</span>
NDet Result(399): <span class="ansi33"
>(: unquote (-> %Undefined% %Undefined%))
</span>
NDet Result(400): <span class="ansi33"
>(= (unquote (quote $10000))  $10000)
</span>
NDet Result(401): <span class="ansi33"
>(iz nop MeTTa)
</span>
NDet Result(402): <span class="ansi33"
>(@doc nop (@desc "Outputs unit atom") (@params ()) (@return "Unit atom"))
</span>
NDet Result(403): <span class="ansi33"
>(: nop (-> EmptyType))
</span>
NDet Result(404): <span class="ansi33"
>(ALT= () ())
</span>
NDet Result(405): <span class="ansi33"
>(@doc nop (@desc "Outputs unit atom for any input") (@params ((@param "Anything"))) (@return "Unit atom"))
</span>
NDet Result(406): <span class="ansi33"
>(: nop (-> Atom (->)))
</span>
NDet Result(407): <span class="ansi33"
>(ALT= () ())
</span>
NDet Result(408): <span class="ansi33"
>(iz empty MeTTa)
</span>
NDet Result(409): <span class="ansi33"
>(@doc empty (@desc "Cuts evaluation of the non-deterministic branch and removes it from the result") (@params ()) (@return "Nothing"))
</span>
NDet Result(410): <span class="ansi33"
>(: empty (-> %Undefined%))
</span>
#(failed #( : user once ) #( : user #(if_or_else #(eval = $10000 498 &self (empty) $10001) #(call eval (empty) $10001)) ))


#(on_mettalog_error #(failed #( : user once ) #( : user #(if_or_else #(eval = $10000 498 &self (empty) $10001) #(call eval (empty) $10001)) )))

^  <span class="ansi1 ansi32"
>Call: </span>(248) [user] call(user:once, user:if_or_else(eval(=, _1286160, 498, '&self', [empty], _1286174), call(eval, [empty], _1286174)))
^  <span class="ansi1 ansi32"
>Call: </span>(249) [user] once(user:if_or_else(eval(=, _1286160, 498, '&self', [empty], _1286174), call(eval, [empty], _1286174)))
   <span class="ansi1 ansi32"
>Call: </span>(250) [user] if_or_else(eval(=, _1286160, 498, '&self', [empty], _1286174), call(eval, [empty], _1286174))
^  <span class="ansi1 ansi32"
>Call: </span>(251) [user] eval(=, _1286160, 498, '&self', [empty], _1286174)
^  <span class="ansi1 ansi32"
>Call: </span>(252) [user] catch_metta_return(eval_args(=, _1286160, 498, '&self', [empty], _1286174), _1286174)
^  <span class="ansi1 ansi32"
>Call: </span>(254) [user] eval_args(=, _1286160, 498, '&self', [empty], _1286174)
   <span class="ansi1 ansi32"
>Call: </span>(255) [system] var([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(256) [system] setup_call_cleanup('$notrace'(_1293792, _1293794), once(user:self_eval([empty])), '$restore_trace'(_1293792, _1293794))
^  <span class="ansi1 ansi32"
>Call: </span>(257) [system] sig_atomic(system:'$notrace'(_1293792, _1293794))
^  <span class="ansi1 ansi32"
>Call: </span>(256) [system] setup_call_cleanup('$notrace'(_1295704, _1295706), once(user:nonvar(_1286174)), '$restore_trace'(_1295704, _1295706))
^  <span class="ansi1 ansi32"
>Call: </span>(257) [system] sig_atomic(system:'$notrace'(_1295704, _1295706))
^  <span class="ansi1 ansi32"
>Call: </span>(256) [system] setup_call_cleanup('$notrace'(_1297616, _1297618), once(user:nonvar(_1286174)), '$restore_trace'(_1297616, _1297618))
^  <span class="ansi1 ansi32"
>Call: </span>(257) [system] sig_atomic(system:'$notrace'(_1297616, _1297618))
   <span class="ansi1 ansi32"
>Call: </span>(255) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(255) [system] []==[]
   <span class="ansi1 ansi32"
>Call: </span>(255) [system] number(empty)
   <span class="ansi1 ansi32"
>Call: </span>(255) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(255) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(255) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(255) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(257) [system] setup_call_cleanup('$notrace'(_1306008, _1306010), once(user:self_eval0([empty])), '$restore_trace'(_1306008, _1306010))
^  <span class="ansi1 ansi32"
>Call: </span>(258) [system] sig_atomic(system:'$notrace'(_1306008, _1306010))
^  <span class="ansi1 ansi31"
>Fail: </span>(255) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(255) [user] eval_00(=, _1286160, 498, '&self', [empty], _1286174)
^  <span class="ansi1 ansi32"
>Call: </span>(256) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(258) [system] setup_call_cleanup('$notrace'(_1310712, _1310714), once(user:self_eval0([empty])), '$restore_trace'(_1310712, _1310714))
^  <span class="ansi1 ansi32"
>Call: </span>(259) [system] sig_atomic(system:'$notrace'(_1310712, _1310714))
^  <span class="ansi1 ansi31"
>Fail: </span>(256) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(256) [user] eval_01(=, _1286160, 498, '&self', [empty], _1286174)
   <span class="ansi1 ansi32"
>Call: </span>(257) [system] [empty]\==[empty]
^  <span class="ansi1 ansi31"
>Fail: </span>(254) [user] eval_args(=, _1286160, 498, '&self', [empty], _1286174)
^  <span class="ansi1 ansi32"
>Call: </span>(251) [user] call(eval, [empty], _1286174)
   <span class="ansi1 ansi32"
>Call: </span>(252) [user] eval([empty], _1286174)
^  <span class="ansi1 ansi32"
>Call: </span>(253) [user] current_self(_1318218)
   <span class="ansi1 ansi32"
>Call: </span>(254) [system] nb_current(self_space, _1318218)
   <span class="ansi1 ansi32"
>Exit: </span>(254) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(254) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(254) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(253) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(253) [user] eval('&self', [empty], _1286174)
   <span class="ansi1 ansi32"
>Call: </span>(254) [user] eval_H(500, '&self', [empty], _1286174)
^  <span class="ansi1 ansi32"
>Call: </span>(255) [user] fast_option_value(compile, save)
   <span class="ansi1 ansi32"
>Call: </span>(256) [system] atom(compile)
   <span class="ansi1 ansi32"
>Exit: </span>(256) [system] atom(compile)
   <span class="ansi1 ansi32"
>Call: </span>(256) [system] current_prolog_flag(compile, save)
   <span class="ansi1 ansi31"
>Fail: </span>(256) [system] current_prolog_flag(compile, save)
^  <span class="ansi1 ansi31"
>Fail: </span>(255) [user] fast_option_value(compile, save)
^  <span class="ansi1 ansi32"
>Call: </span>(255) [user] catch_metta_return(eval_args(=, _1331188, 500, '&self', [empty], _1286174), _1286174)
^  <span class="ansi1 ansi32"
>Call: </span>(257) [user] eval_args(=, _1331188, 500, '&self', [empty], _1286174)
   <span class="ansi1 ansi32"
>Call: </span>(258) [system] var([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(259) [system] setup_call_cleanup('$notrace'(_1334034, _1334036), once(user:self_eval([empty])), '$restore_trace'(_1334034, _1334036))
^  <span class="ansi1 ansi32"
>Call: </span>(260) [system] sig_atomic(system:'$notrace'(_1334034, _1334036))
^  <span class="ansi1 ansi32"
>Call: </span>(259) [system] setup_call_cleanup('$notrace'(_1335946, _1335948), once(user:nonvar(_1286174)), '$restore_trace'(_1335946, _1335948))
^  <span class="ansi1 ansi32"
>Call: </span>(260) [system] sig_atomic(system:'$notrace'(_1335946, _1335948))
^  <span class="ansi1 ansi32"
>Call: </span>(259) [system] setup_call_cleanup('$notrace'(_1337858, _1337860), once(user:nonvar(_1286174)), '$restore_trace'(_1337858, _1337860))
^  <span class="ansi1 ansi32"
>Call: </span>(260) [system] sig_atomic(system:'$notrace'(_1337858, _1337860))
   <span class="ansi1 ansi32"
>Call: </span>(258) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(258) [system] []==[]
   <span class="ansi1 ansi32"
>Call: </span>(258) [system] number(empty)
   <span class="ansi1 ansi32"
>Call: </span>(258) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(258) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(258) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(258) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(260) [system] setup_call_cleanup('$notrace'(_1346250, _1346252), once(user:self_eval0([empty])), '$restore_trace'(_1346250, _1346252))
^  <span class="ansi1 ansi32"
>Call: </span>(261) [system] sig_atomic(system:'$notrace'(_1346250, _1346252))
^  <span class="ansi1 ansi31"
>Fail: </span>(258) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(258) [user] eval_00(=, _1331188, 500, '&self', [empty], _1286174)
^  <span class="ansi1 ansi32"
>Call: </span>(259) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(261) [system] setup_call_cleanup('$notrace'(_1350954, _1350956), once(user:self_eval0([empty])), '$restore_trace'(_1350954, _1350956))
^  <span class="ansi1 ansi32"
>Call: </span>(262) [system] sig_atomic(system:'$notrace'(_1350954, _1350956))
^  <span class="ansi1 ansi31"
>Fail: </span>(259) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(259) [user] eval_01(=, _1331188, 500, '&self', [empty], _1286174)
   <span class="ansi1 ansi32"
>Call: </span>(260) [system] [empty]\==[empty]
^  <span class="ansi1 ansi31"
>Fail: </span>(257) [user] eval_args(=, _1331188, 500, '&self', [empty], _1286174)
^  <span class="ansi1 ansi31"
>Fail: </span>(248) [system] call(user:once, user:if_or_else(eval(=, _1286160, 498, '&self', [empty], _1286174), call(eval, [empty], _1286174)))
^  <span class="ansi1 ansi32"
>Call: </span>(248) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(250) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(250) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(252) [system] setup_call_cleanup('$notrace'(_1360338, _1360340), once(rtrace:retract(t_l:tracer_reset(_1360328))), '$restore_trace'(_1360338, _1360340))
^  <span class="ansi1 ansi32"
>Call: </span>(253) [system] sig_atomic(system:'$notrace'(_1360338, _1360340))
^  <span class="ansi1 ansi32"
>Exit: </span>(252) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(252) [rtrace] tAt(false, 271, 271, false)

NDet Result(411): <span class="ansi33"
>(ALT= (empty) (let a b never-happens))
</span>
NDet Result(412): <span class="ansi33"
>(iz unique MeTTa)
</span>
NDet Result(413): <span class="ansi33"
>(@doc unique (@desc "Function takes non-deterministic input (first argument) and returns only unique entities. E.g. (unique (superpose (a b c d d))) -> [a, b, c, d]") (@params ((@param "Non-deterministic set of values"))) (@return "Unique non-deterministic values from input set"))
</span>
NDet Result(414): <span class="ansi33"
>(: unique (-> Atom Atom))
</span>
NDet Result(415): <span class="ansi33"
>(iz union MeTTa)
</span>
NDet Result(416): <span class="ansi33"
>(@doc union (@desc "Function takes two non-deterministic inputs (first and second argument) and returns their union. E.g. (union (superpose (a b b c)) (superpose (b c c d))) -> [a, b, b, c, b, c, c, d]") (@params ((@param "Non-deterministic set of values") (@param "Another non-deterministic set of values"))) (@return "Non-deterministic Union of sets"))
</span>
NDet Result(417): <span class="ansi33"
>(: union (-> Atom Atom Atom))
</span>
NDet Result(418): <span class="ansi33"
>(iz intersection MeTTa)
</span>
NDet Result(419): <span class="ansi33"
>(@doc intersection (@desc "Function takes two non-deterministic inputs (first and second argument) and returns their intersection. E.g. (intersection (superpose (a b c c)) (superpose (b c c c d))) -> [b, c, c]") (@params ((@param "Non-deterministic set of values") (@param "Another non-deterministic set of values"))) (@return "Non-deterministic Intersection of sets"))
</span>
NDet Result(420): <span class="ansi33"
>(: intersection (-> Atom Atom Atom))
</span>
NDet Result(421): <span class="ansi33"
>(iz subtraction MeTTa)
</span>
NDet Result(422): <span class="ansi33"
>(@doc subtraction (@desc "Function takes two non-deterministic inputs (first and second argument) and returns their subtraction. E.g. !(subtraction (superpose (a b b c)) (superpose (b c c d))) -> [a, b]") (@params ((@param "Non-deterministic set of values") (@param "Another non-deterministic set of values"))) (@return "Non-deterministic Subtraction of sets"))
</span>
NDet Result(423): <span class="ansi33"
>(: subtraction (-> Atom Atom Atom))
</span>
NDet Result(424): <span class="ansi33"
>(iz @doc MeTTa)
</span>
NDet Result(425): <span class="ansi33"
>(@doc @doc (@desc "Used for documentation purposes. Function documentation starts with @doc") (@params ((@param "Function name") (@param "Function description. Starts with @desc") (@param "(Optional) parameters description starting with @params which should contain one or more @param symbols") (@param "(Optional) description of what function will return. Starts with @return"))) (@return "Function documentation using @doc-formal"))
</span>
NDet Result(426): <span class="ansi33"
>(: @doc (-> Atom DocDescription DocInformal))
</span>
NDet Result(427): <span class="ansi33"
>(: @doc (-> Atom DocDescription DocParameters DocReturnInformal DocInformal))
</span>
NDet Result(428): <span class="ansi33"
>(iz @doc DataFunctor)
</span>
NDet Result(429): <span class="ansi33"
>(iz @desc MeTTa)
</span>
NDet Result(430): <span class="ansi33"
>(@doc @desc (@desc "Used for documentation purposes. Description of function starts with @desc as a part of @doc") (@params ((@param "String containing function description"))) (@return "Function description"))
</span>
NDet Result(431): <span class="ansi33"
>(: @desc (-> String DocDescription))
</span>
NDet Result(432): <span class="ansi33"
>(iz @desc DataFunctor)
</span>
NDet Result(433): <span class="ansi33"
>(iz @param MeTTa)
</span>
NDet Result(434): <span class="ansi33"
>(@doc @param (@desc "Used for documentation purposes. Description of function parameter starts with @param as a part of @params which is a part of @doc") (@params ((@param "String containing parameter description"))) (@return "Parameter description"))
</span>
NDet Result(435): <span class="ansi33"
>(: @param (-> String DocParameterInformal))
</span>
NDet Result(436): <span class="ansi33"
>(: @param (-> DocType DocDescription DocParameter))
</span>
NDet Result(437): <span class="ansi33"
>(iz @param DataFunctor)
</span>
NDet Result(438): <span class="ansi33"
>(iz @return MeTTa)
</span>
NDet Result(439): <span class="ansi33"
>(@doc @return (@desc "Used for documentation purposes. Description of function return value starts with @return as a part of @doc") (@params ((@param "String containing return value description"))) (@return "Return value description"))
</span>
NDet Result(440): <span class="ansi33"
>(: @return (-> String DocReturnInformal))
</span>
NDet Result(441): <span class="ansi33"
>(: @return (-> DocType DocDescription DocReturn))
</span>
NDet Result(442): <span class="ansi33"
>(iz @return DataFunctor)
</span>
NDet Result(443): <span class="ansi33"
>(iz @doc-formal MeTTa)
</span>
NDet Result(444): <span class="ansi33"
>(@doc @doc-formal (@desc "Used for documentation purposes. get-doc returns documentation starting with @doc-formal symbol. @doc-formal contains 6 or 4 parameters depending on the entity being described (functions being described using 6 parameters, atoms - 4 parameters)") (@params ((@param "Function/Atom name for which documentation is to be displayed. Format (@item name)") (@param "Contains (@kind function) or (@kind atom) depends on entity which documentation is displayed") (@param "Contains type notation of function/atom") (@param "Function/atom description") (@param "(Functions only). Description of function parameters") (@param "(Functions only). Description of function's return value"))) (@return "Expression containing full documentation on function"))
</span>
NDet Result(445): <span class="ansi33"
>(: @doc-formal (-> DocItem DocKindFunction DocType DocDescription DocParameters DocReturn DocFormal))
</span>
NDet Result(446): <span class="ansi33"
>(: @doc-formal (-> DocItem DocKindAtom DocType DocDescription DocFormal))
</span>
NDet Result(447): <span class="ansi33"
>(iz @doc-formal DataFunctor)
</span>
NDet Result(448): <span class="ansi33"
>(iz @item MeTTa)
</span>
NDet Result(449): <span class="ansi33"
>(@doc @item (@desc "Used for documentation purposes. Converts atom/function's name to DocItem") (@params ((@param "Atom/Function name to be documented"))) (@return "(@item Atom) entity"))
</span>
NDet Result(450): <span class="ansi33"
>(: @item (-> Atom DocItem))
</span>
NDet Result(451): <span class="ansi33"
>(iz @item DataFunctor)
</span>
NDet Result(452): <span class="ansi33"
>(iz (@kind function) MeTTa)
</span>
NDet Result(453): <span class="ansi33"
>(@doc (@kind function) (@desc "Used for documentation purposes. Shows type of entity to be documented. (@kind function) in this case"))
</span>
NDet Result(454): <span class="ansi33"
>(: (@kind function) DocKindFunction)
</span>
NDet Result(455): <span class="ansi33"
>(iz (@kind function) DataFunctor)
</span>
NDet Result(456): <span class="ansi33"
>(iz (@kind atom) MeTTa)
</span>
NDet Result(457): <span class="ansi33"
>(@doc (@kind atom) (@desc "Used for documentation purposes. Shows type of entity to be documented. (@kind atom) in this case"))
</span>
NDet Result(458): <span class="ansi33"
>(: (@kind atom) DocKindAtom)
</span>
NDet Result(459): <span class="ansi33"
>(iz (@kind atom) DataFunctor)
</span>
NDet Result(460): <span class="ansi33"
>(iz @type MeTTa)
</span>
NDet Result(461): <span class="ansi33"
>(@doc @type (@desc "Used for documentation purposes. Converts atom/function's type to DocType") (@params ((@param "Atom/Function type to be documented"))) (@return "(@type Type) entity"))
</span>
NDet Result(462): <span class="ansi33"
>(: @type (-> Type DocType))
</span>
NDet Result(463): <span class="ansi33"
>(iz @type DataFunctor)
</span>
NDet Result(464): <span class="ansi33"
>(iz @params MeTTa)
</span>
NDet Result(465): <span class="ansi33"
>(@doc @params (@desc "Used for function documentation purposes. Contains several @param entities with description of each @param") (@params ((@param "Several (@param ...) entities"))) (@return "DocParameters containing description of all parameters of function in form of (@params ((@param ...) (@param ...) ...))"))
</span>
NDet Result(466): <span class="ansi33"
>(: @params (-> Expression DocParameters))
</span>
NDet Result(467): <span class="ansi33"
>(iz @params DataFunctor)
</span>
NDet Result(468): <span class="ansi33"
>(iz get-doc MeTTa)
</span>
NDet Result(469): <span class="ansi33"
>(@doc get-doc (@desc "Returns documentation for the given Atom/Function") (@params ((@param "Atom/Function name for which documentation is needed"))) (@return "Documentation for the given atom/function"))
</span>
NDet Result(470): <span class="ansi33"
>(: get-doc (-> Atom Atom))
</span>
NDet Result(471): <span class="ansi33"
>(: metta-get-doc (-> Atom Atom))
</span>
NDet Result(472): <span class="ansi33"
>(= (metta-get-doc $10000)  
  (let $10001 
    (get-metatype $10000) 
    (case $10001 
      ( (Expression (get-doc-atom $10000)) ($10002 (get-doc-single-atom $10000))))))
</span>
NDet Result(473): <span class="ansi33"
>(iz get-doc-single-atom PrivateRelation)
</span>
NDet Result(474): <span class="ansi33"
>(@doc get-doc-single-atom (@desc "Function used by get-doc to get documentation on either function or atom. It checks if input name is the name of function or atom and calls correspondent function") (@params ((@param "Atom/Function name for which documentation is needed"))) (@return "Documentation for the given atom/function"))
</span>
NDet Result(475): <span class="ansi33"
>(: get-doc-single-atom (-> Atom Atom))
</span>
NDet Result(476): <span class="ansi33"
>(= (get-doc-single-atom $10000)  
  (let $10001 
    (mod-space! top) 
    (let $10002 
      (get-type-space $10001 $10000) 
      (if 
        (is-function-type $10002) 
        (get-doc-function $10000 $10002) 
        (get-doc-atom $10000)))))
</span>
NDet Result(477): <span class="ansi33"
>(iz get-doc-function PrivateRelation)
</span>
NDet Result(478): <span class="ansi33"
>(@doc get-doc-function (@desc "Function used by get-doc-single-atom to get documentation on a function. It returns documentation on a function if it exists or default documentation with no description otherwise") (@params ((@param "Function name for which documentation is needed") (@param "Type notation for this function"))) (@return "Documentation for the given function"))
</span>
NDet Result(479): <span class="ansi33"
>(: get-doc-function (-> Atom Type Atom))
</span>
NDet Result(480): <span class="ansi33"
>(= (get-doc-function $10000 $10001)  
  (let $10002 
    (mod-space! top) 
    (unify $10002 
      (@doc $10000 $10003 
        (@params $10004) $10005) 
      (let $10006 
        (if 
          (== $10001 %Undefined%) 
          (undefined-doc-function-type $10004) 
          (cdr-atom $10001)) 
        (let 
          ($10007 $10008) 
          (get-doc-params $10004 $10005 $10006) 
          (@doc-formal 
            (@item $10000) 
            (@kind function) 
            (@type $10001) $10003 
            (@params $10007) $10008))) 
      (@doc-formal 
        (@item $10000) 
        (@kind function) 
        (@type $10001) 
        (@desc "No documentation")))))
</span>
NDet Result(481): <span class="ansi33"
>(iz undefined-doc-function-type PrivateRelation)
</span>
NDet Result(482): <span class="ansi33"
>(@doc undefined-doc-function-type (@desc "Function used by get-doc-single-atom in case of absence of function's type notation") (@params ((@param "List of parameters for the function we want to get documentation for"))) (@return "List of %Undefined% number of which depends on input list size. So for two parameters function will return (%Undefined% %Undefined% %Undefined%)"))
</span>
NDet Result(483): <span class="ansi33"
>(: undefined-doc-function-type (-> Expression Type))
</span>
NDet Result(484): <span class="ansi33"
>(= (undefined-doc-function-type $10000)  
  (if 
    (== () $10000) 
    (%Undefined%) 
    (let $10001 
      (cdr-atom $10000) 
      (let $10002 
        (undefined-doc-function-type $10001) 
        (cons-atom %Undefined% $10002)))))
</span>
NDet Result(485): <span class="ansi33"
>(iz get-doc-params PrivateRelation)
</span>
NDet Result(486): <span class="ansi33"
>(@doc get-doc-params (@desc "Function used by get-doc-function to get function's parameters documentation (including return value)") (@params ((@param "List of parameters in form of ((@param Description) (@param Description)...)") (@param "Return value's description in form of (@return Description)") (@param "Type notation without -> starting symbol e.g. (Atom Atom Atom)"))) (@return "United list of params and return value each augmented with its type. E.g. (((@param (@type Atom) (@desc Description)) (@param (@type Atom) (@desc Description2))) (@return (@type Atom) (@desc Description)))"))
</span>
NDet Result(487): <span class="ansi33"
>(: get-doc-params (-> Expression Atom Expression (Expression Atom)))
</span>
NDet Result(488): <span class="ansi33"
>(= (get-doc-params $10000 $10001 $10002)  
  (let $10003 
    (car-atom $10002) 
    (let $10004 
      (cdr-atom $10002) 
      (if 
        (== () $10000) 
        (let 
          (@return $10005) $10001 
          (() (@return (@type $10003) (@desc $10005)))) 
        (let 
          (@param $10006) 
          (car-atom $10000) 
          (let $10007 
            (cdr-atom $10000) 
            (let 
              ($10008 $10009) 
              (get-doc-params $10007 $10001 $10004) 
              (let $10010 
                (cons-atom 
                  (@param 
                    (@type $10003) 
                    (@desc $10006)) $10008) 
                ($10010 $10009)))))))))
</span>
NDet Result(489): <span class="ansi33"
>(iz get-doc-atom PrivateRelation)
</span>
NDet Result(490): <span class="ansi33"
>(@doc get-doc-atom (@desc "Function used by get-doc (in case of input type Expression) and get-doc-single-atom (in case input value is not a function) to get documentation on input value") (@params ((@param "Atom's name to get documentation for"))) (@return "Documentation on input Atom"))
</span>
NDet Result(491): <span class="ansi33"
>(: get-doc-atom (-> Atom Atom))
</span>
NDet Result(492): <span class="ansi33"
>(= (get-doc-atom $10000)  
  (let $10001 
    (mod-space! top) 
    (let $10002 
      (get-type-space $10001 $10000) 
      (unify $10001 
        (@doc $10000 $10003) 
        (@doc-formal 
          (@item $10000) 
          (@kind atom) 
          (@type $10002) $10003) 
        (unify $10001 
          (@doc $10000 $10004 
            (@params $10005) $10006) 
          (get-doc-function $10000 %Undefined%) 
          (@doc-formal 
            (@item $10000) 
            (@kind atom) 
            (@type $10002) 
            (@desc "No documentation")))))))
</span>
NDet Result(493): <span class="ansi33"
>(iz help! MeTTa)
</span>
NDet Result(494): <span class="ansi33"
>(@doc help! (@desc "Function prints documentation for the input atom.") (@params ((@param "Input to get documentation for"))) (@return "Unit atom"))
</span>
NDet Result(495): <span class="ansi33"
>(: help! (-> Atom (->)))
</span>
NDet Result(496): <span class="ansi33"
>(: metta-help! (-> Atom (->)))
</span>
NDet Result(497): <span class="ansi33"
>(= (metta-help! $10000)  
  (case 
    (get-doc $10000) 
    ( ( (@doc-formal 
          (@item $10001) 
          (@kind function) 
          (@type $10002) 
          (@desc $10003) 
          (@params $10004) 
          (@return 
            (@type $10005) 
            (@desc $10006))) (let () (println! (format-args "Function {}: {} {}" ($10001 $10002 $10003))) (let () (println! (format-args "Parameters:" ())) (let () (for-each-in-atom $10004 help-param!) (let () (println! (format-args "Return: (type {}) {}" ($10005 $10006))) ()))))) 
      ( (@doc-formal 
          (@item $10001) 
          (@kind function) 
          (@type $10002) 
          (@desc $10003)) (let () (println! (format-args "Function {} (type {}) {}" ($10001 $10002 $10003))) ())) 
      ( (@doc-formal 
          (@item $10001) 
          (@kind atom) 
          (@type $10002) 
          (@desc $10003)) (let () (println! (format-args "Atom {}: {} {}" ($10001 $10002 $10003))) ())) 
      ($10007 (Error $10007 "Cannot match @doc-formal structure")))))
</span>
NDet Result(498): <span class="ansi33"
>(iz help-param! PrivateRelation)
</span>
NDet Result(499): <span class="ansi33"
>(@doc help-param! (@desc "Function used by function help! to output parameters using println!") (@params ((@param "Parameters list"))) (@return "Unit atom"))
</span>
NDet Result(500): <span class="ansi33"
>(: help-param! (-> Atom (->)))
</span>
NDet Result(501): <span class="ansi33"
>(= (help-param! $10000)  
  (let 
    (@param 
      (@type $10001) 
      (@desc $10002)) $10000 
    (println! (format-args "  {} {}" ((type $10001) $10002)))))
</span>
NDet Result(502): <span class="ansi33"
>(iz for-each-in-atom PrivateRelation)
</span>
NDet Result(503): <span class="ansi33"
>(@doc for-each-in-atom (@desc "Applies function passed as a second argument to each atom inside first argument") (@params ((@param "Expression to each atom in which function will be applied") (@param "Function to apply"))) (@return "Unit atom"))
</span>
NDet Result(504): <span class="ansi33"
>(: for-each-in-atom (-> Expression Atom (->)))
</span>
NDet Result(505): <span class="ansi33"
>(= (for-each-in-atom $10000 $10001)  
  (if 
    (noreduce-eq $10000 ()) () 
    (let $10002 
      (car-atom $10000) 
      (let $10003 
        (cdr-atom $10000) 
        (let $10004 
          ($10001 $10002) 
          (for-each-in-atom $10003 $10001))))))
</span>
NDet Result(506): <span class="ansi33"
>(iz noreduce-eq PrivateRelation)
</span>
NDet Result(507): <span class="ansi33"
>(@doc noreduce-eq (@desc "Checks equality of two atoms without reducing them") (@params ((@param "First atom") (@param "Second atom"))) (@return "True if not reduced atoms are equal, False - otherwise"))
</span>
NDet Result(508): <span class="ansi33"
>(: noreduce-eq (-> Atom Atom Bool))
</span>
NDet Result(509): <span class="ansi33"
>(= (noreduce-eq $10000 $10001)  
  (== 
    (quote $10000) 
    (quote $10001)))
</span>
NDet Result(510): <span class="ansi33"
>(iz add-atom MeTTa)
</span>
NDet Result(511): <span class="ansi33"
>(@doc add-atom (@desc "Adds atom into the atomspace without reducing it") (@params ((@param "Atomspace to add atom into") (@param "Atom to add"))) (@return "Unit atom"))
</span>
NDet Result(512): <span class="ansi33"
>(: add-atom (-> hyperon::space::DynSpace Atom (->)))
</span>
NDet Result(513): <span class="ansi33"
>(iz get-type MeTTa)
</span>
NDet Result(514): <span class="ansi33"
>(@doc get-type (@desc "Returns type notation of input atom") (@params ((@param "Atom to get type for"))) (@return "Type notation or %Undefined% if there is no type for input Atom"))
</span>
NDet Result(515): <span class="ansi33"
>(: get-type (-> Atom Atom))
</span>
NDet Result(516): <span class="ansi33"
>(: get-type (-> Atom Atom Atom))
</span>
NDet Result(517): <span class="ansi33"
>(iz get-type-space MeTTa)
</span>
NDet Result(518): <span class="ansi33"
>(@doc get-type-space (@desc "Returns type notation of input Atom (second argument) relative to a specified atomspace (first argument)") (@params ((@param "Atomspace where type notation for input atom will be searched") (@param "Atom to get type for"))) (@return "Type notation or %Undefined% if there is no type for input Atom in provided atomspace"))
</span>
NDet Result(519): <span class="ansi33"
>(: get-type-space (-> Atom Atom Atom))
</span>
NDet Result(520): <span class="ansi33"
>(= (get-type-space $10000 $10001)  
  (get-type $10001 $10000))
</span>
NDet Result(521): <span class="ansi33"
>(iz get-metatype MeTTa)
</span>
NDet Result(522): <span class="ansi33"
>(@doc get-metatype (@desc "Returns metatype of the input atom") (@params ((@param "Atom to get metatype for"))) (@return "Metatype of input atom"))
</span>
NDet Result(523): <span class="ansi33"
>(: get-metatype (-> Atom Atom))
</span>
NDet Result(524): <span class="ansi33"
>(iz if-equal MinimalMeTTa)
</span>
NDet Result(525): <span class="ansi33"
>(@doc if-equal (@desc "Checks if first two arguments are equal and evaluates third argument if equal, fourth argument - otherwise") (@params ((@param "First argument") (@param "Second argument") (@param "Atom to be evaluated if arguments are equal") (@param "Atom to be evaluated if arguments are not equal"))) (@return "Evaluated third or fourth argument"))
</span>
NDet Result(526): <span class="ansi33"
>(iz new-space MeTTa)
</span>
NDet Result(527): <span class="ansi33"
>(@doc new-space (@desc "Creates new Atomspace which could be used further in the program as a separate from &self Atomspace") (@params ()) (@return "Reference to a new space"))
</span>
NDet Result(528): <span class="ansi33"
>(: new-space (-> hyperon::space::DynSpace))
</span>
NDet Result(529): <span class="ansi33"
>(iz remove-atom MeTTa)
</span>
NDet Result(530): <span class="ansi33"
>(@doc remove-atom (@desc "Removes atom from the input Atomspace") (@params ((@param "Reference to the space from which the Atom needs to be removed") (@param "Atom to be removed"))) (@return "Unit atom"))
</span>
NDet Result(531): <span class="ansi33"
>(: remove-atom (-> hyperon::space::DynSpace Atom (->)))
</span>
NDet Result(532): <span class="ansi33"
>(iz get-atoms MeTTa)
</span>
NDet Result(533): <span class="ansi33"
>(@doc get-atoms (@desc "Shows all atoms in the input Atomspace") (@params ((@param "Reference to the space"))) (@return "List of all atoms in the input space"))
</span>
NDet Result(534): <span class="ansi33"
>(: get-atoms (-> hyperon::space::DynSpace Atom))
</span>
NDet Result(535): <span class="ansi33"
>(iz new-state MeTTa)
</span>
NDet Result(536): <span class="ansi33"
>(@doc new-state (@desc "Creates a new state atom wrapping its argument") (@params ((@param "Atom to be wrapped"))) (@return "Returns (State $value) where $value is an argument to a new-state"))
</span>
NDet Result(537): <span class="ansi33"
>(: new-state (-> $10000 (StateMonad $10000)))
</span>
NDet Result(538): <span class="ansi33"
>(iz change-state! MeTTa)
</span>
NDet Result(539): <span class="ansi33"
>(@doc change-state! (@desc "Changes input state's wrapped atom to another value (second argument). E.g. (change-state! (State 5) 6) -> (State 6)") (@params ((@param "State created by new-state function") (@param "Atom which will replace wrapped atom in the input state"))) (@return "State with replaced wrapped atom"))
</span>
NDet Result(540): <span class="ansi33"
>(: change-state! (-> (StateMonad $10000) $10000 (StateMonad $10000)))
</span>
NDet Result(541): <span class="ansi33"
>(iz get-state MeTTa)
</span>
NDet Result(542): <span class="ansi33"
>(@doc get-state (@desc "Gets a state as an argument and returns its wrapped atom. E.g. (get-state (State 5)) -> 5") (@params ((@param "State"))) (@return "Atom wrapped by state"))
</span>
NDet Result(543): <span class="ansi33"
>(: get-state (-> (StateMonad $10000) $10000))
</span>
NDet Result(544): <span class="ansi33"
>(iz match MeTTa)
</span>
NDet Result(545): <span class="ansi33"
>(@doc match (@desc "Searches for all declared atoms corresponding to the given pattern (second argument) and produces the output pattern (third argument)") (@params ((@param "A grounded atom referencing a Space") (@param "Pattern atom to be searched") (@param "Output template typically containing variables from the input pattern"))) (@return "If match was successful it outputs template (third argument) with filled variables (if any were present in pattern) using matched pattern (second argument). Empty - otherwise"))
</span>
NDet Result(546): <span class="ansi33"
>(: match (-> Atom Atom Atom %Undefined%))
</span>
NDet Result(547): <span class="ansi33"
>(iz register-module! MeTTa)
</span>
NDet Result(548): <span class="ansi33"
>(@doc register-module! (@desc "Takes a file system path (first argument) and loads the module into the runner") (@params ((@param "File system path"))) (@return "Unit atom"))
</span>
NDet Result(549): <span class="ansi33"
>(: register-module! (-> Atom (->)))
</span>
NDet Result(550): <span class="ansi33"
>(iz mod-space! MeTTa)
</span>
NDet Result(551): <span class="ansi33"
>(@doc mod-space! (@desc "Returns the space of the module (first argument) and tries to load the module if it is not loaded into the module system") (@params ((@param "Module name"))) (@return "Space name"))
</span>
NDet Result(552): <span class="ansi33"
>(: mod-space! (-> Atom hyperon::space::DynSpace))
</span>
NDet Result(553): <span class="ansi33"
>(= (mod-space! self)  &self)
</span>
NDet Result(554): <span class="ansi33"
>(= (mod-space! top)  &self)
</span>
NDet Result(555): <span class="ansi33"
>(= (mod-space! corelib)  &corelib)
</span>
NDet Result(556): <span class="ansi33"
>(= (mod-space! stdlib)  &stdlib)
</span>
NDet Result(557): <span class="ansi33"
>(= (mod-space! catalog)  &catalog)
</span>
NDet Result(558): <span class="ansi33"
>(iz print-mods! MeTTa)
</span>
NDet Result(559): <span class="ansi33"
>(@doc print-mods! (@desc "Prints all modules with their correspondent spaces") (@params ()) (@return "Unit atom"))
</span>
NDet Result(560): <span class="ansi33"
>(: print-mods! (-> (->)))
</span>
NDet Result(561): <span class="ansi33"
>(iz assertEqual MeTTa)
</span>
NDet Result(562): <span class="ansi33"
>(@doc assertEqual (@desc "Compares (sets of) results of evaluation of two expressions") (@params ((@param "First expression") (@param "Second expression"))) (@return "Unit atom if both expression after evaluation is equal, error - otherwise"))
</span>
NDet Result(563): <span class="ansi33"
>(: assertEqual (-> Atom Atom Atom))
</span>
NDet Result(564): <span class="ansi33"
>(iz assertNotEqual MeTTaLog)
</span>
NDet Result(565): <span class="ansi33"
>(@doc assertNotEqual (@desc "Compares (sets of) results of evaluation of two expressions") (@params ((@param "First expression") (@param "Second expression"))) (@return "Unit atom if both expressions after evaluation are not equal, error - otherwise"))
</span>
NDet Result(566): <span class="ansi33"
>(: assertNotEqual (-> Atom Atom Atom))
</span>
NDet Result(567): <span class="ansi33"
>(iz assertEqualToResult MeTTa)
</span>
NDet Result(568): <span class="ansi33"
>(@doc assertEqualToResult (@desc "Same as assertEqual but it doesn't evaluate second argument. Second argument is considered as a set of values of the first argument's evaluation") (@params ((@param "First expression (it will be evaluated)") (@param "Second expression (it won't be evaluated)"))) (@return "Unit atom if both expression after evaluation is equal, error - otherwise"))
</span>
NDet Result(569): <span class="ansi33"
>(: assertEqualToResult (-> Atom Atom Atom))
</span>
NDet Result(570): <span class="ansi33"
>(iz assertNotEqualToResult MeTTaLog)
</span>
NDet Result(571): <span class="ansi33"
>(@doc assertNotEqualToResult (@desc "Same as assertNotEqual but it doesn't evaluate second argument. Second argument is considered as a set of values of the first argument's evaluation") (@params ((@param "First expression (it will be evaluated)") (@param "Second expression (it won't be evaluated)"))) (@return "Unit atom if both expressions after evaluation are not equal, error - otherwise"))
</span>
NDet Result(572): <span class="ansi33"
>(: assertNotEqualToResult (-> Atom Atom Atom))
</span>
NDet Result(573): <span class="ansi33"
>(iz superpose MeTTa)
</span>
NDet Result(574): <span class="ansi33"
>(@doc superpose (@desc "Turns a tuple (first argument) into a nondeterministic result") (@params ((@param "Tuple to be converted"))) (@return "Argument converted to nondeterministic result"))
</span>
NDet Result(575): <span class="ansi33"
>(: superpose (-> Expression %Undefined%))
</span>
NDet Result(576): <span class="ansi33"
>(iz collapse MeTTa)
</span>
NDet Result(577): <span class="ansi33"
>(@doc collapse (@desc "Converts a nondeterministic result into a tuple") (@params ((@param "Atom which will be evaluated"))) (@return "Tuple"))
</span>
NDet Result(578): <span class="ansi33"
>(: collapse (-> Atom Atom))
</span>
NDet Result(579): <span class="ansi33"
>(iz case MeTTa)
</span>
NDet Result(580): <span class="ansi33"
>(@doc case (@desc "Subsequently tests multiple pattern-matching conditions (second argument) for the given value (first argument)") (@params ((@param "Atom (it will be evaluated)") (@param "Tuple of pairs mapping condition patterns to results"))) (@return "Result of evaluating Atom bound to met condition"))
</span>
NDet Result(581): <span class="ansi33"
>(: case (-> Atom Expression Atom))
</span>
NDet Result(582): <span class="ansi33"
>(iz capture MeTTa)
</span>
NDet Result(583): <span class="ansi33"
>(@doc capture (@desc "Wraps an atom and captures the current space") (@params ((@param "Function name which space needs to be captured"))) (@return "Function"))
</span>
NDet Result(584): <span class="ansi33"
>(: capture (-> Atom Atom))
</span>
NDet Result(585): <span class="ansi33"
>(iz hyperpose MeTTa)
</span>
NDet Result(586): <span class="ansi33"
>(@doc hyperpose (@desc "Turns a tuple (first argument) into a nondeterministic result, as superpose, but is explicitly concurrent. Each item of the tuple may be processed in parallel, depending on the number of threads available (which is the minimum of the tuple size and the number of cores available).") (@params ((@param "Tuple to be converted"))) (@return "Argument converted to nondeterministic result"))
</span>
NDet Result(587): <span class="ansi33"
>(: hyperpose (-> Expression %Undefined%))
</span>
NDet Result(588): <span class="ansi33"
>(iz sequential MeTTa)
</span>
NDet Result(589): <span class="ansi33"
>(@doc sequential (@desc "Turns a tuple (first argument) into a nondeterministic result, as superpose, but evaluation order of the elements of the tuple is fixed left to right. In that sense the result order is deterministic iff evaluating the tuple elements is deterministic.") (@params ((@param "Tuple to be evaluated"))) (@return "Sequential results of the tuple's elements."))
</span>
NDet Result(590): <span class="ansi33"
>(: sequential (-> Expression %Undefined%))
</span>
NDet Result(591): <span class="ansi33"
>(iz do MeTTa)
</span>
NDet Result(592): <span class="ansi33"
>(@doc do (@desc "Completely evaluates form, returning nothing. Typically used for side-effects. A common pattern is (sequential ((do <side-effect-form>) <form-that-needs-side-effect>)).") (@params ((@param "Form"))) (@return "None"))
</span>
NDet Result(593): <span class="ansi33"
>(: do (-> Expression %Undefined%))
</span>
NDet Result(594): <span class="ansi33"
>(iz pragma! MeTTa)
</span>
NDet Result(595): <span class="ansi33"
>(@doc pragma! (@desc "Changes global key's (first argument) value to a new one (second argument)") (@params ((@param "Key's name") (@param "New value"))) (@return "Unit atom"))
</span>
NDet Result(596): <span class="ansi33"
>(: pragma! (-> Symbol %Undefined% (->)))
</span>
NDet Result(597): <span class="ansi33"
>(iz import! MeTTa)
</span>
NDet Result(598): <span class="ansi33"
>(@doc import! (@desc "Imports module using its relative path (second argument) and binds it to the token (first argument) which will represent imported atomspace. If first argument is &self then everything will be imported to current atomspace. The source is imported only the first time import! is called. Can load Python code (.py) or MeTTa (.metta); if ambiguous, assumes Python.") (@params ((@param "Symbol, which is turned into the token for accessing the imported module") (@param "Module name"))) (@return "Unit atom"))
</span>
NDet Result(599): <span class="ansi33"
>(: import! (-> Atom Atom (->)))
</span>
NDet Result(600): <span class="ansi33"
>(iz include MeTTa)
</span>
NDet Result(601): <span class="ansi33"
>(@doc include (@desc "Works just like include! but with &self as a first argument. So everything from input file will be included in the current atomspace and evaluated") (@params ((@param "Name of metta script to import"))) (@return "Unit atom"))
</span>
NDet Result(602): <span class="ansi33"
>(: include (-> Atom Atom))
</span>
NDet Result(603): <span class="ansi33"
>(iz include! MeTTa)
</span>
NDet Result(604): <span class="ansi33"
>(@doc include! (@desc "Everything from input file will be included in the current atomspace and evaluated, as if it were being evaluated at the REPL. Unlike import!, the source is evaluated every time include! is called.") (@params ((@param "Space") (@param "Filename"))) (@return "Expression"))
</span>
NDet Result(605): <span class="ansi33"
>(: include! (-> hyperon::space::DynSpace String Expression))
</span>
NDet Result(606): <span class="ansi33"
>(iz bind! MeTTa)
</span>
NDet Result(607): <span class="ansi33"
>(@doc bind! (@desc "Registers a new token which is replaced with an atom during the parsing of the rest of the program") (@params ((@param "Token name") (@param "Atom, which is associated with the token after reduction"))) (@return "Unit atom"))
</span>
NDet Result(608): <span class="ansi33"
>(: bind! (-> Symbol %Undefined% (->)))
</span>
NDet Result(609): <span class="ansi33"
>(iz trace! MeTTa)
</span>
NDet Result(610): <span class="ansi33"
>(@doc trace! (@desc "Prints its first argument and returns second. Both arguments will be evaluated before processing") (@params ((@param "Atom to print") (@param "Atom to return"))) (@return "Evaluated second input"))
</span>
NDet Result(611): <span class="ansi33"
>(: trace! (-> %Undefined% $10000 $10000))
</span>
NDet Result(612): <span class="ansi33"
>(iz println! MeTTa)
</span>
NDet Result(613): <span class="ansi33"
>(@doc println! (@desc "Prints a line of text to the console") (@params ((@param "Expression/atom to be printed out"))) (@return "Unit atom"))
</span>
NDet Result(614): <span class="ansi33"
>(: println! (-> %Undefined% (->)))
</span>
NDet Result(615): <span class="ansi33"
>(iz format-args MeTTa)
</span>
NDet Result(616): <span class="ansi33"
>(@doc format-args (@desc "Fills {} symbols in the input expression with atoms from the second expression. E.g. (format-args (Probability of {} is {}%) (head 50)) gives [(Probability of head is 50%)]. Atoms in the second input value could be variables") (@params ((@param "Expression with {} symbols to be replaced") (@param "Atoms to be placed inside expression instead of {}"))) (@return "Expression with replaced {} with atoms"))
</span>
NDet Result(617): <span class="ansi33"
>(: format-args (-> String Atom String))
</span>
NDet Result(618): <span class="ansi33"
>(iz sealed MeTTa)
</span>
NDet Result(619): <span class="ansi33"
>(@doc sealed (@desc "Replaces all occurrences of any var from var list (first argument) inside atom (second argument) by unique variable. Can be used to create a locally scoped variables") (@params ((@param "Variable list e.g. ($x $y)") (@param "Atom which uses those variables"))) (@return "Second argument but with variables being replaced with unique variables"))
</span>
NDet Result(620): <span class="ansi33"
>(: sealed (-> Expression Atom Atom))
</span>
NDet Result(621): <span class="ansi33"
>(iz &self MeTTa)
</span>
NDet Result(622): <span class="ansi33"
>(@doc &self (@desc "Returns reference to the current atomspace") (@params ()) (@return "Reference to the current atomspace"))
</span>
NDet Result(623): <span class="ansi33"
>(iz + MeTTa)
</span>
NDet Result(624): <span class="ansi33"
>(@doc + (@desc "Sums two numbers") (@params ((@param "Addend") (@param "Augend"))) (@return "Sum"))
</span>
NDet Result(625): <span class="ansi33"
>(: + (-> Number Number Number))
</span>
NDet Result(626): <span class="ansi33"
>(iz - MeTTa)
</span>
NDet Result(627): <span class="ansi33"
>(@doc - (@desc "Subtracts second argument from first one") (@params ((@param "Minuend") (@param "Deductible"))) (@return "Difference"))
</span>
NDet Result(628): <span class="ansi33"
>(: - (-> Number Number Number))
</span>
NDet Result(629): <span class="ansi33"
>(iz * MeTTa)
</span>
NDet Result(630): <span class="ansi33"
>(@doc * (@desc "Multiplies two numbers") (@params ((@param "Multiplier") (@param "Multiplicand"))) (@return "Product"))
</span>
NDet Result(631): <span class="ansi33"
>(: * (-> Number Number Number))
</span>
NDet Result(632): <span class="ansi33"
>(iz / MeTTa)
</span>
NDet Result(633): <span class="ansi33"
>(@doc / (@desc "Divides first argument by second one") (@params ((@param "Dividend") (@param "Divisor"))) (@return "Fraction"))
</span>
NDet Result(634): <span class="ansi33"
>(: / (-> Number Number Number))
</span>
NDet Result(635): <span class="ansi33"
>(iz % MeTTa)
</span>
NDet Result(636): <span class="ansi33"
>(@doc % (@desc "Modulo operator. It returns remainder of dividing first argument by second argument") (@params ((@param "Dividend") (@param "Divisor"))) (@return "Remainder"))
</span>
NDet Result(637): <span class="ansi33"
>(: % (-> Number Number Number))
</span>
NDet Result(638): <span class="ansi33"
>(iz < MeTTa)
</span>
NDet Result(639): <span class="ansi33"
>(@doc < (@desc "Less than. Checks if first argument is less than second one") (@params ((@param "First number") (@param "Second number"))) (@return "True if first argument is less than second, False - otherwise"))
</span>
NDet Result(640): <span class="ansi33"
>(: < (-> Number Number Bool))
</span>
NDet Result(641): <span class="ansi33"
>(iz > MeTTa)
</span>
NDet Result(642): <span class="ansi33"
>(@doc > (@desc "Greater than. Checks if first argument is greater than second one") (@params ((@param "First number") (@param "Second number"))) (@return "True if first argument is greater than second, False - otherwise"))
</span>
NDet Result(643): <span class="ansi33"
>(: > (-> Number Number Bool))
</span>
NDet Result(644): <span class="ansi33"
>(iz <= MeTTa)
</span>
NDet Result(645): <span class="ansi33"
>(@doc <= (@desc "Less than or equal. Checks if first argument is less than or equal to second one") (@params ((@param "First number") (@param "Second number"))) (@return "True if first argument is less than or equal to second, False - otherwise"))
</span>
NDet Result(646): <span class="ansi33"
>(: <= (-> Number Number Bool))
</span>
NDet Result(647): <span class="ansi33"
>(iz >= MeTTa)
</span>
NDet Result(648): <span class="ansi33"
>(@doc >= (@desc "Greater than or equal. Checks if first argument is greater than or equal to second one") (@params ((@param "First number") (@param "Second number"))) (@return "True if first argument is greater than or equal to second, False - otherwise"))
</span>
NDet Result(649): <span class="ansi33"
>(: >= (-> Number Number Bool))
</span>
NDet Result(650): <span class="ansi33"
>(iz == MeTTa)
</span>
NDet Result(651): <span class="ansi33"
>(@doc == (@desc "Checks equality for two arguments of the same type") (@params ((@param "First argument") (@param "Second argument"))) (@return "Returns True if two arguments are equal, False - otherwise. If arguments are of different type function returns Error currently"))
</span>
NDet Result(652): <span class="ansi33"
>(: == (-> $10000 $10000 Bool))
</span>
NDet Result(653): <span class="ansi33"
>(iz xor MeTTa)
</span>
NDet Result(654): <span class="ansi33"
>(@doc xor (@desc "Exclusive disjunction of two arguments") (@params ((@param "First argument") (@param "Second argument"))) (@return "Return values are the same as logical disjunction, but when both arguments are True xor will return False"))
</span>
NDet Result(655): <span class="ansi33"
>(: xor (-> Bool Bool Bool))
</span>
NDet Result(656): <span class="ansi33"
>(iz flip MeTTa)
</span>
NDet Result(657): <span class="ansi33"
>(@doc flip (@desc "Produces random boolean value") (@params ()) (@return "Random boolean value"))
</span>
NDet Result(658): <span class="ansi33"
>(@doc unique-atom (@desc "Function takes tuple and returns only unique entities. E.g. (unique-atom (a b c d d)) -> (a b c d)") (@params ((@param "List of values"))) (@return "Unique values from input set"))
</span>
NDet Result(659): <span class="ansi33"
>(= (unique-atom $10000)  
  (collapse (unique (superpose $10000))))
</span>
NDet Result(660): <span class="ansi33"
>(: unique-atom (-> Expression Expression))
</span>
NDet Result(661): <span class="ansi33"
>(@doc union-atom (@desc "Function takes two tuples and returns their union. E.g. (union-atom (a b b c) (b c c d)) -> (a b b c b c c d)") (@params ((@param "List of values") (@param "List of values"))) (@return "Union of sets"))
</span>
NDet Result(662): <span class="ansi33"
>(= (union-atom $10000 $10001)  
  (collapse (union (superpose $10000) (superpose $10001))))
</span>
NDet Result(663): <span class="ansi33"
>(: union-atom (-> Expression Expression Expression))
</span>
NDet Result(664): <span class="ansi33"
>(@doc intersection-atom (@desc "Function takes two tuples and returns their intersection. E.g. (intersection-atom (a b c c) (b c c c d)) -> (b c c)") (@params ((@param "List of values") (@param "List of values"))) (@return "Intersection of sets"))
</span>
NDet Result(665): <span class="ansi33"
>(= (intersection-atom $10000 $10001)  
  (collapse (intersection (superpose $10000) (superpose $10001))))
</span>
NDet Result(666): <span class="ansi33"
>(: intersection-atom (-> Expression Expression Expression))
</span>
NDet Result(667): <span class="ansi33"
>(@doc subtraction-atom (@desc "Function takes two tuples and returns their subtraction. E.g. !(subtraction-atom (a b b c) (b c c d)) -> (a b)") (@params ((@param "List of values") (@param "List of values"))) (@return "Subtraction of sets"))
</span>
NDet Result(668): <span class="ansi33"
>(= (subtraction-atom $10000 $10001)  
  (collapse (subtraction (superpose $10000) (superpose $10001))))
</span>
NDet Result(669): <span class="ansi33"
>(: subtraction-atom (-> Expression Expression Expression))
</span>
NDet Result(670): <span class="ansi33"
>(iz git-module! MeTTa)
</span>
NDet Result(671): <span class="ansi33"
>(@doc git-module! (@desc "Provides access to module in a remote git repo, from within MeTTa code. Similar to `register-module!`, this op will bypass the catalog search") (@params ((@param "URL to github repo"))) (@return "Unit atom"))
</span>
NDet Result(672): <span class="ansi33"
>(: git-module! (-> Atom (->)))
</span>
NDet Result(673): <span class="ansi33"
>(iz findall! MeTTaLog)
</span>
NDet Result(674): <span class="ansi33"
>(@doc findall! (@desc "Takes a Template and a Goal. Returns the list resulting from substituting all bindings from solving Goal into Template.\n  See Prolog's built-in predicate findall/3.") (@params ((@param "Template") (@param "Goal"))) (@return "Result list of all bindings for Goal substituted into Template"))
</span>
NDet Result(675): <span class="ansi33"
>(: findall! (-> Expression Expression Expression))
</span>
NDet Result(676): <span class="ansi33"
>(iz maplist! MeTTaLog)
</span>
NDet Result(677): <span class="ansi33"
>(@doc maplist! (@desc "Takes a function F and one to three lists; Returns the result of applying F to each item in the list(s). \n The provided lists are not evaluated (this matches the behavior of e.g. cons-atom).\n F must have the number of lists provided as a valid arity (i.e. unary for one list, binary for two, ternary for three).\n Use concurrent-maplist! for a multi-threaded, nondeterministic version.\n See Prolog's built-in predicate maplist.") (@params ((@param "Function to be applied") (@param "List"))) (@return "Result of applying Function to List(s)"))
</span>
NDet Result(678): <span class="ansi33"
>(: maplist! (-> Function Expression Expression))
</span>
NDet Result(679): <span class="ansi33"
>(: maplist! (-> Function Expression Expression Expression))
</span>
NDet Result(680): <span class="ansi33"
>(: maplist! (-> Function Expression Expression Expression Expression))
</span>
NDet Result(681): <span class="ansi33"
>(iz concurrent-maplist! MeTTaLog)
</span>
NDet Result(682): <span class="ansi33"
>(@doc concurrent-maplist! (@desc "Takes a function F and one to three lists; Returns the result of applying F to each item in the list(s). \n The provided lists are not evaluated (this matches the behavior of e.g. cons-atom).\n F must have the number of lists provided as a valid arity (i.e. unary for one list, binary for two, ternary for three).\n The applications of F to the list items are processed in parallel. Because of the overhead of this approach, a speedup is only likely if F is expensive to evaluate.\n Use maplist! for a single-threaded, deterministic version.\n See Prolog's built-in predicate concurrent-maplist.") (@params ((@param "Function to be applied") (@param "List"))) (@return "Result of applying Function to List(s)"))
</span>
NDet Result(683): <span class="ansi33"
>(: concurrent-maplist! (-> Function Expression Expression))
</span>
NDet Result(684): <span class="ansi33"
>(: concurrent-maplist! (-> Function Expression Expression Expression))
</span>
NDet Result(685): <span class="ansi33"
>(: concurrent-maplist! (-> Function Expression Expression Expression Expression))
</span>
NDet Result(686): <span class="ansi33"
>(iz throw MeTTaLog)
</span>
NDet Result(687): <span class="ansi33"
>(@doc throw (@desc "Raises an exception. See also `catch`; the system will look for the innermost catch such that Exception unifies with Catcher.") (@params ((@param "Exception"))) (@return "Does not return - raises an exception"))
</span>
NDet Result(688): <span class="ansi33"
>(: throw (-> Atom ErrorType))
</span>
NDet Result(689): <span class="ansi33"
>(iz catch MeTTaLog)
</span>
NDet Result(690): <span class="ansi33"
>(@doc catch (@desc "Executes Form. If an exception is raised with `throw` during execution of Form while this is the innermost catch such that Catcher unifies with Exception, the exception is caught. Recover is then executed with bindings from Catcher.") (@params ((@param "Form") (@param "Catcher") (@param "Recover"))) (@return "Result of Form if no exception is raised. Result of Recover (with bindings from Catcher) if an exception is caught."))
</span>
NDet Result(691): <span class="ansi33"
>(: catch (-> Atom Atom Atom Atom))
</span>
NDet Result(692): <span class="ansi33"
>(iz max-time! MeTTaLog)
</span>
NDet Result(693): <span class="ansi33"
>(@doc max-time! (@desc "Executes Form. If execution takes longer than Time, will raise a time_limit_exceeded exception. See also `catch`.") (@params ((@param "Time (in seconds)") (@param "Form"))) (@return "Result of Form if execution completes within Time. Raises an exception otherwise."))
</span>
NDet Result(694): <span class="ansi33"
>(: max-time! (-> Number Atom Atom))
</span>
NDet Result(695): <span class="ansi33"
>(iz sleep! MeTTaLog)
</span>
NDet Result(696): <span class="ansi33"
>(@doc sleep! (@desc "Sleeps for N seconds.") (@params ((@param "N"))) (@return "Returns True after sleeping completes."))
</span>
NDet Result(697): <span class="ansi33"
>(: sleep! (-> Number Bool))
</span>
NDet Result(698): <span class="ansi33"
>(iz limit! MeTTaLog)
</span>
NDet Result(699): <span class="ansi33"
>(@doc limit! (@desc "Executes Form generating at most Limit results. Results are returned as soon as they become available.") (@params ((@param "Limit") (@param "Form"))) (@return "First Limit results of Form."))
</span>
NDet Result(700): <span class="ansi33"
>(: limit! (-> Number Atom Atom))
</span>
NDet Result(701): <span class="ansi33"
>(iz number-of MeTTaLog)
</span>
NDet Result(702): <span class="ansi33"
>(@doc number-of (@desc "Returns the number of results Form generates") (@params ((@param "Form"))) (@return "Number of results of Form."))
</span>
NDet Result(703): <span class="ansi33"
>(: number-of (-> Atom Number))
</span>
NDet Result(704): <span class="ansi33"
>(iz offset! MeTTaLog)
</span>
NDet Result(705): <span class="ansi33"
>(@doc offset! (@desc "Executes Form ignoring the first Count results. Results are returned as soon as they become available.") (@params ((@param "Count") (@param "Form"))) (@return "Results of Form after ignoring the first Count results that are generated."))
</span>
NDet Result(706): <span class="ansi33"
>(: offset! (-> Number Atom Atom))
</span>
NDet Result(707): <span class="ansi33"
>(iz call! MeTTaLog)
</span>
NDet Result(708): <span class="ansi33"
>(@doc call! (@desc "Trampolines to Prolog's call. Only works when the predicate and each arg are provided separately. e.g. !(call! ls /) will print the root directory but !(call! ls(/)) will fail.") (@params ((@param "Form"))) (@return "True if the call succeeds, False otherwise."))
</span>
NDet Result(709): <span class="ansi33"
>(: call! (-> Atom Atom))
</span>
NDet Result(710): <span class="ansi33"
>(iz call-p! MeTTaLog)
</span>
NDet Result(711): <span class="ansi33"
>(@doc call-p! (@desc "Like call-fn! except it does not append the called term with a return arg.") (@params ((@param "Form"))) (@return "True if the call succeeds, False otherwise."))
</span>
NDet Result(712): <span class="ansi33"
>(: call-p! (-> Atom Atom))
</span>
NDet Result(713): <span class="ansi33"
>(iz call-fn! MeTTaLog)
</span>
NDet Result(714): <span class="ansi33"
>(@doc call-fn! (@desc "Trampolines to Prolog's call after appending the return argument.  Each arg are provided separately. e.g. !(call-fn! length (1 2 3)) will return 3.") (@params ((@param "Form"))) (@return "appends a return argument to a form and calls it"))
</span>
NDet Result(715): <span class="ansi33"
>(: call-fn! (-> Atom Atom))
</span>
NDet Result(716): <span class="ansi33"
>(iz call-string! MeTTaLog)
</span>
NDet Result(717): <span class="ansi33"
>(@doc call-string! (@desc "Executes String as Prolog code. For example, (call-string! \"member(1,[1,2,3])\") returns [()] while (call-string! \"member(4,[1,2,3])\") returns []. (call-string! \"member(X,[1,2,3])\") returns [(1), (2), (3)].") (@params ((@param "PrologSrc"))) (@return "A list of the binding values. If there are no bindings but the Prolog query is True, returns the empty list."))
</span>
NDet Result(718): <span class="ansi33"
>(: call-string! (-> String Atom))
</span>
NDet Result(719): <span class="ansi33"
>(iz call-cleanup! MeTTaLog)
</span>
NDet Result(720): <span class="ansi33"
>(@doc call-cleanup! (@desc "Same as (setup-call-cleanup! true Form Cleanup). setup-call-cleanup! is recommended instead if Cleanup is intended to undo prior side-effects - place those side-effects in Setup.") (@params ((@param "Form") (@param "Cleanup"))) (@return "Result of Form."))
</span>
NDet Result(721): <span class="ansi33"
>(: call-cleanup! (-> Atom Atom Atom))
</span>
NDet Result(722): <span class="ansi33"
>(iz setup-call-cleanup! MeTTaLog)
</span>
NDet Result(723): <span class="ansi33"
>(@doc setup-call-cleanup! (@desc "Executes Setup, then Form, then finally Cleanup. Setup is protected from interrupts (e.g. max-time!). In most uses, Setup will perform temporary side-effects required by Form that are finally undone by Cleanup. Cleanup is run even if Form raises an exception. For each result of Setup, Form is run to completion, then Cleanup is run.") (@params ((@param "Setup") (@param "Form") (@param "Cleanup"))) (@return "Result of Form."))
</span>
NDet Result(724): <span class="ansi33"
>(: setup-call-cleanup! (-> Atom Atom Atom Atom))
</span>
NDet Result(725): <span class="ansi33"
>(@doc predicate-arity (@desc "Returns the arity of Function's predicate form, i.e. the function-arity + 1. (The additional argument being the function's result as an argument to the predicate.)") (@params ((@param "Function"))) (@return "Arity of Function's predicate form."))
</span>
NDet Result(726): <span class="ansi33"
>(iz function-arity MeTTaLog)
</span>
NDet Result(727): <span class="ansi33"
>(@doc function-arity (@desc "Returns the arity of Function.") (@params ((@param "Function"))) (@return "Arity of Function."))
</span>
NDet Result(728): <span class="ansi33"
>(iz open! MeTTaLog)
</span>
NDet Result(729): <span class="ansi33"
>(@doc open! (@desc "Opens Filename as a stream under Mode. Mode is one of read, write, append, or update. Mode append opens the file for writing, positioning the file pointer at the end. Mode update opens the file for writing, positioning the file pointer at the beginning of the file without truncating the file.") (@params ((@param "Filename") (@param "Mode"))) (@return "Stream"))
</span>
NDet Result(730): <span class="ansi33"
>(: open! (-> String Atom Stream))
</span>
NDet Result(731): <span class="ansi33"
>(iz close! MeTTaLog)
</span>
NDet Result(732): <span class="ansi33"
>(@doc close! (@desc "Closes Steam, returning True on success.") (@params ((@param "Stream"))) (@return "Boolean"))
</span>
NDet Result(733): <span class="ansi33"
>(: close! (-> Stream Boolean))
</span>
NDet Result(734): <span class="ansi33"
>(iz with-output-to! MeTTaLog)
</span>
NDet Result(735): <span class="ansi33"
>(@doc with-output-to! (@desc "Evaluates expression with all outupt (e.g. from print) redirected to Stream. See also open! and close!.") (@params ((@param "Stream") (@param "Expression"))) (@return "Result of Expression"))
</span>
NDet Result(736): <span class="ansi33"
>(: with-output-to! (-> Stream Expression Atom))
</span>
NDet Result(737): <span class="ansi33"
>(iz load-file! MeTTaLog)
</span>
NDet Result(738): <span class="ansi33"
>(@doc load-file! (@desc "Loads the contents of Filename into Space, returning () if successful. Can load Python code (.py) or MeTTa (.metta); if ambiguous, assumes MeTTa. Like import! but favors MeTTa over Python when the file type is ambiguous.") (@params ((@param "Space") (@param "Filename"))) (@return "Expression"))
</span>
NDet Result(739): <span class="ansi33"
>(: load-file! (-> hyperon::space::DynSpace String Expression))
</span>
NDet Result(740): <span class="ansi33"
>(iz load-ascii MeTTa)
</span>
NDet Result(741): <span class="ansi33"
>(@doc load-ascii (@desc "Loads the contents of Filename into Space, returning () if successful. Assumes the file is an ASCII file. Works like include!.") (@params ((@param "Space") (@param "Filename"))) (@return "Expression"))
</span>
NDet Result(742): <span class="ansi33"
>(: load-ascii (-> hyperon::space::DynSpace String Expression))
</span>
NDet Result(743): <span class="ansi33"
>(iz transfer! MeTTa)
</span>
NDet Result(744): <span class="ansi33"
>(@doc transfer! (@desc "Loads the contents of Filename into &self, as include. Returns () if successful, throws an exception otherwise.") (@params ((@param "Filename"))) (@return "Expression"))
</span>
NDet Result(745): <span class="ansi33"
>(: transfer! (-> String (->)))
</span>
NDet Result(746): <span class="ansi33"
>(iz save-space! MeTTa)
</span>
NDet Result(747): <span class="ansi33"
>(@doc save-space! (@desc "Writes the contents of Space into Filename, returning () if successful.") (@params ((@param "Space") (@param "Filename"))) (@return "Expression"))
</span>
NDet Result(748): <span class="ansi33"
>(: save-space! (-> hyperon::space::DynSpace String Expression))
</span>
NDet Result(749): <span class="ansi33"
>(iz rtrace! MeTTaLog)
</span>
NDet Result(750): <span class="ansi33"
>(@doc rtrace! (@desc "Fully evaluates input Atom, providing a complete trace of the evaluation.") (@params ((@param "Atom to be evaluated"))) (@return "Result of evaluation"))
</span>
NDet Result(751): <span class="ansi33"
>(: rtrace! (-> Atom Atom))
</span>
NDet Result(752): <span class="ansi33"
>(iz rust MeTTaLog)
</span>
NDet Result(753): <span class="ansi33"
>(@doc rust (@desc "Interface with the rust / Hyperon MeTTa implementation. Enters Atom into rust atomspace. If Atom is evaluated (i.e. by being of the form !<atom>), returns the result of evaluation. See also rust!.") (@params ((@param "Atom to be entered into the space"))) (@return "Result of entering Atom into the space"))
</span>
NDet Result(754): <span class="ansi33"
>(: rust (-> Atom Atom))
</span>
NDet Result(755): <span class="ansi33"
>(iz rust! MeTTaLog)
</span>
NDet Result(756): <span class="ansi33"
>(@doc rust! (@desc "Like rust but evaluates the atom rather than entering into the space. (rust! <atom>) and (rust !<atom>) are identical.") (@params ((@param "Atom to be evaluated"))) (@return "Result of evaluation"))
</span>
NDet Result(757): <span class="ansi33"
>(: rust! (-> Atom Atom))
</span>
NDet Result(758): <span class="ansi33"
>(iz coerce MeTTaLog)
</span>
NDet Result(759): <span class="ansi33"
>(@doc coerce (@desc "Cast (coerce) Value to be of Type. Supports the basic types Atom (no-op), Number, String, and Bool.\n  Number: Converts number strings and bools to numbers. True is 1, False is 0.\n  String: Coerced as if Value were printed.\n  Bool: False, 0, and () are False, all other values are True.") (@params ((@param "Type") (@param "Value"))) (@return "Value cast to Type"))
</span>
NDet Result(760): <span class="ansi33"
>(: coerce (-> Type Atom Atom))
</span>
NDet Result(761): <span class="ansi33"
>(is-fn-1 sqrt sqrt)
</span>
NDet Result(762): <span class="ansi33"
>(is-fn-1 abs abs)
</span>
NDet Result(763): <span class="ansi33"
>(is-fn-1 trunc trunc)
</span>
NDet Result(764): <span class="ansi33"
>(is-fn-1 ceil ceil)
</span>
NDet Result(765): <span class="ansi33"
>(is-fn-1 floor floor)
</span>
NDet Result(766): <span class="ansi33"
>(is-fn-1 round round)
</span>
NDet Result(767): <span class="ansi33"
>(is-fn-1 sin sin)
</span>
NDet Result(768): <span class="ansi33"
>(is-fn-1 asin asin)
</span>
NDet Result(769): <span class="ansi33"
>(is-fn-1 cos cos)
</span>
NDet Result(770): <span class="ansi33"
>(is-fn-1 acos acos)
</span>
NDet Result(771): <span class="ansi33"
>(is-fn-1 tan tan)
</span>
NDet Result(772): <span class="ansi33"
>(is-fn-1 atan atan)
</span>
NDet Result(773): <span class="ansi33"
>(: sqrt (-> Number Number))
</span>
NDet Result(774): <span class="ansi33"
>(: abs (-> Number Number))
</span>
NDet Result(775): <span class="ansi33"
>(: trunc (-> Number Number))
</span>
NDet Result(776): <span class="ansi33"
>(: ceil (-> Number Number))
</span>
NDet Result(777): <span class="ansi33"
>(: floor (-> Number Number))
</span>
NDet Result(778): <span class="ansi33"
>(: round (-> Number Number))
</span>
NDet Result(779): <span class="ansi33"
>(: sin (-> Number Number))
</span>
NDet Result(780): <span class="ansi33"
>(: asin (-> Number Number))
</span>
NDet Result(781): <span class="ansi33"
>(: cos (-> Number Number))
</span>
NDet Result(782): <span class="ansi33"
>(: acos (-> Number Number))
</span>
NDet Result(783): <span class="ansi33"
>(: tan (-> Number Number))
</span>
NDet Result(784): <span class="ansi33"
>(: atan (-> Number Number))
</span>
NDet Result(785): <span class="ansi33"
>(is-fn-2 powf pow)
</span>
NDet Result(786): <span class="ansi33"
>(is-fn-2 pow pow)
</span>
NDet Result(787): <span class="ansi33"
>(is-fn-2 log log2)
</span>
NDet Result(788): <span class="ansi33"
>(is-fn-2 random-int random)
</span>
NDet Result(789): <span class="ansi33"
>(: powf (-> Number Number Number))
</span>
NDet Result(790): <span class="ansi33"
>(: pow (-> Number Number Number))
</span>
NDet Result(791): <span class="ansi33"
>(: log (-> Number Number Number))
</span>
NDet Result(792): <span class="ansi33"
>(: random-int (-> Number Number Number))
</span>
NDet Result(793): <span class="ansi33"
>(is-pred-1 isnan is_NaN)
</span>
NDet Result(794): <span class="ansi33"
>(is-pred-1 isinf is_Inf)
</span>
NDet Result(795): <span class="ansi33"
>(: isnan (-> Number Bool))
</span>
NDet Result(796): <span class="ansi33"
>(: isinf (-> Number Bool))
</span>
NDet Result(797): <span class="ansi33"
>(= (max-atom $10000)  
  (call-fn! max_list $10000))
</span>
NDet Result(798): <span class="ansi33"
>(= (size-atom $10000)  
  (call-fn! length $10000))
</span>
NDet Result(799): <span class="ansi33"
>(= (py-list $10000)  
  (call-fn! py_list $10000))
</span>
NDet Result(800): <span class="ansi33"
>(= (sqrt $10000)  
  (call-fn! sqrt $10000))
</span>
NDet Result(801): <span class="ansi33"
>(= (abs $10000)  
  (call-fn! abs $10000))
</span>
NDet Result(802): <span class="ansi33"
>(= (trunc $10000)  
  (call-fn! trunc $10000))
</span>
NDet Result(803): <span class="ansi33"
>(= (ceil $10000)  
  (call-fn! ceil $10000))
</span>
NDet Result(804): <span class="ansi33"
>(= (floor $10000)  
  (call-fn! floor $10000))
</span>
NDet Result(805): <span class="ansi33"
>(= (round $10000)  
  (call-fn! round $10000))
</span>
NDet Result(806): <span class="ansi33"
>(= (sin $10000)  
  (call-fn! sin $10000))
</span>
NDet Result(807): <span class="ansi33"
>(= (asin $10000)  
  (call-fn! asin $10000))
</span>
NDet Result(808): <span class="ansi33"
>(= (cos $10000)  
  (call-fn! cos $10000))
</span>
NDet Result(809): <span class="ansi33"
>(= (acos $10000)  
  (call-fn! acos $10000))
</span>
NDet Result(810): <span class="ansi33"
>(= (tan $10000)  
  (call-fn! tan $10000))
</span>
NDet Result(811): <span class="ansi33"
>(= (atan $10000)  
  (call-fn! atan $10000))
</span>
NDet Result(812): <span class="ansi33"
>(= (powf $10000 $10001)  
  (call-fn! pow $10000 $10001))
</span>
NDet Result(813): <span class="ansi33"
>(= (pow $10000 $10001)  
  (call-fn! pow $10000 $10001))
</span>
NDet Result(814): <span class="ansi33"
>(= (log $10000 $10001)  
  (call-fn! log2 $10000 $10001))
</span>
NDet Result(815): <span class="ansi33"
>(= (random-int $10000 $10001)  
  (call-fn! random $10000 $10001))
</span>
NDet Result(816): <span class="ansi33"
>(= (index-atom $10000 $10001)  
  (call-fn! nth0 $10001 $10000))
</span>
NDet Result(817): <span class="ansi33"
>(= (isnan $10000)  
  (call-p! is_NaN $10000))
</span>
NDet Result(818): <span class="ansi33"
>(= (isinf $10000)  
  (call-p! is_Inf $10000))
</span><span class="ansi38-013099040"
>!(assertEqual (match &self $1 $1) (get-atoms &self))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.00-LANG-CASE.13"
>;; HYPERON-METTALOG-SANITY.00-LANG-CASE.13</h3>

#(failed #( : user once ) #( : user #(if_or_else #(eval = $10000 497 &self (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003) #(call eval (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003)) ))


#(on_mettalog_error #(failed #( : user once ) #( : user #(if_or_else #(eval = $10000 497 &self (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003) #(call eval (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003)) )))

^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] call(user:once, user:if_or_else(eval(=, _1411028, 497, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334), call(eval, [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334)))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] once(user:if_or_else(eval(=, _1411028, 497, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334), call(eval, [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334)))
   <span class="ansi1 ansi32"
>Call: </span>(285) [user] if_or_else(eval(=, _1411028, 497, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334), call(eval, [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] eval(=, _1411028, 497, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334)
^  <span class="ansi1 ansi32"
>Call: </span>(287) [user] catch_metta_return(eval_args(=, _1411028, 497, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334), _1414334)
^  <span class="ansi1 ansi32"
>Call: </span>(289) [user] eval_args(=, _1411028, 497, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334)
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] var([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] setup_call_cleanup('$notrace'(_1432408, _1432410), once(user:self_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])), '$restore_trace'(_1432408, _1432410))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] sig_atomic(system:'$notrace'(_1432408, _1432410))
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] setup_call_cleanup('$notrace'(_1434320, _1434322), once(user:nonvar(_1414334)), '$restore_trace'(_1434320, _1434322))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] sig_atomic(system:'$notrace'(_1434320, _1434322))
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] setup_call_cleanup('$notrace'(_1436232, _1436234), once(user:nonvar(_1414334)), '$restore_trace'(_1436232, _1436234))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] sig_atomic(system:'$notrace'(_1436232, _1436234))
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] [['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(290) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] self_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] setup_call_cleanup('$notrace'(_1442772, _1442774), once(user:self_eval0([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])), '$restore_trace'(_1442772, _1442774))
^  <span class="ansi1 ansi32"
>Call: </span>(293) [system] sig_atomic(system:'$notrace'(_1442772, _1442774))
^  <span class="ansi1 ansi31"
>Fail: </span>(290) [user] self_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] eval_00(=, _1411028, 497, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334)
^  <span class="ansi1 ansi32"
>Call: </span>(291) [user] self_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Call: </span>(293) [system] setup_call_cleanup('$notrace'(_1447476, _1447478), once(user:self_eval0([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])), '$restore_trace'(_1447476, _1447478))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] sig_atomic(system:'$notrace'(_1447476, _1447478))
^  <span class="ansi1 ansi31"
>Fail: </span>(291) [user] self_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Call: </span>(291) [user] eval_01(=, _1411028, 497, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334)
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(292) [system] [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] if_t((497<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] 497<1
   <span class="ansi1 ansi31"
>Fail: </span>(294) [system] 497<1
^  <span class="ansi1 ansi32"
>Exit: </span>(292) [user] if_t((497<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(293) [system] setup_call_cleanup('$notrace'(_1456870, _1456872), once(user:(_1456846 is 497-1, copy_term([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1456860))), '$restore_trace'(_1456870, _1456872))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] sig_atomic(system:'$notrace'(_1456870, _1456872))
^  <span class="ansi1 ansi32"
>Exit: </span>(293) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(496 is 497-1, copy_term([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], [case, ['if-unify-or-empty', _1458792, _1458792], [['Empty', _1458822]]]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] trace_eval(eval_20(=, _1411028), e, 496, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1459770)
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] must_det_ll((notrace((flag(eval_num, _1460736, _1460736+1), _1460754 is _1460736 mod 500, _1460772 is 99-496 mod 100, _1460796=_1460798, option_else('trace-length', _1460810, 500), option_else('trace-depth', _1460818, 30))), quietly(if_t((nop(stop_rtrace), _1460754>_1460810), (set_debug(eval, false), _1460874 is _1460810+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1460874])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1460926)))))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] once(user:(notrace((flag(eval_num, _1460736, _1460736+1), _1460754 is _1460736 mod 500, _1460772 is 99-496 mod 100, _1460796=_1460798, option_else('trace-length', _1460810, 500), option_else('trace-depth', _1460818, 30))), quietly(if_t((nop(stop_rtrace), _1460754>_1460810), (set_debug(eval, false), _1460874 is _1460810+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1460874])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1460926)))))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [system] setup_call_cleanup('$notrace'(_1462796, _1462798), once(user:(flag(eval_num, _1460736, _1460736+1), _1460754 is _1460736 mod 500, _1460772 is 99-496 mod 100, _1460796=_1460798, option_else('trace-length', _1460810, 500), option_else('trace-depth', _1460818, 30))), '$restore_trace'(_1462796, _1462798))
^  <span class="ansi1 ansi32"
>Call: </span>(298) [system] sig_atomic(system:'$notrace'(_1462796, _1462798))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 4711, 4711+1), 211 is 4711 mod 500, 3 is 99-496 mod 100, _1460796=_1460796, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 211>500), (set_debug(eval, false), _1460874 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1460874])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 211>500), (set_debug(eval, false), _1460874 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1460874])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(296) [user] nop(notrace(no_repeats_var(_1460926)))
   <span class="ansi1 ansi32"
>Exit: </span>(296) [user] nop(notrace(no_repeats_var(_1460926)))
^  <span class="ansi1 ansi32"
>Exit: </span>(294) [system] once(user:(notrace((flag(eval_num, 4711, 4711+1), 211 is 4711 mod 500, 3 is 99-496 mod 100, _1460796=_1460796, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 211>500), (set_debug(eval, false), _1460874 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1460874])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1460926)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(293) [user] must_det_ll(user:(notrace((flag(eval_num, 4711, 4711+1), 211 is 4711 mod 500, 3 is 99-496 mod 100, _1460796=_1460796, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 211>500), (set_debug(eval, false), _1460874 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1460874])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1460926)))))
   <span class="ansi1 ansi32"
>Call: </span>(293) [occurs] occurs:sub_term(_1471480, e)
   <span class="ansi1 ansi32"
>Exit: </span>(293) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(293) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(294) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(293) [occurs] occurs:sub_term(_1471480, e)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] _1477970=e
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] if_trace((eval;e), (_1460796=1, indentq(3, 211, -->, [e, [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] setup_call_cleanup('$notrace'(_1480846, _1480848), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _1460796=1, indentq(3, 211, -->, [e, [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]]))), _1480804, fbug((_1480804-->if_trace((eval;e), (_1460796=1, indentq(3, 211, -->, [e, [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]])))))))), '$restore_trace'(_1480846, _1480848))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [system] sig_atomic(system:'$notrace'(_1480846, _1480848))
^  <span class="ansi1 ansi32"
>Exit: </span>(295) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _1460796=1, indentq(3, 211, -->, [e, [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]]))), _1480804, fbug((_1480804-->if_trace((eval;e), (_1460796=1, indentq(3, 211, -->, [e, [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(293) [user] if_trace((eval;e), (_1460796=1, indentq(3, 211, -->, [e, [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]])))
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] _1484690=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] _1486552=(\+ \+ (flag(eval_num, _1486572, _1486572+1), (retval(fail)\=@=retval(fail), nonvar(_1459770)->indentq(3, _1486572, <--, [e, _1459770]);indentq(3, _1486572, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] (\+ \+ (flag(eval_num, _1486572, _1486572+1), (retval(fail)\=@=retval(fail), nonvar(_1459770)->indentq(3, _1486572, <--, [e, _1459770]);indentq(3, _1486572, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _1486572, _1486572+1), (retval(fail)\=@=retval(fail), nonvar(_1459770)->indentq(3, _1486572, <--, [e, _1459770]);indentq(3, _1486572, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] call_cleanup(((call(eval_20(=, _1411028), 496, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1459770)*->nb_setarg(1, retval(fail), _1459770);fail, trace, call(eval_20(=, _1411028), 496, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1459770)), ignore(notrace((\+_1459770\=_1460926, nb_setarg(1, retval(fail), _1459770))))), ignore((_1460796==1->ignore(\+ \+ (flag(eval_num, _1486572, _1486572+1), (retval(fail)\=@=retval(fail), nonvar(_1459770)->indentq(3, _1486572, <--, [e, _1459770]);indentq(3, _1486572, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1486572, _1486572+1), (retval(fail)\=@=retval(fail), nonvar(_1459770)->indentq(3, _1486572, <--, [e, _1459770]);indentq(3, _1486572, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] eval_20(=, _1411028, 496, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1459770)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] atom([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] no_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] self_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_1493344, _1493346), once(user:self_eval0([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])), '$restore_trace'(_1493344, _1493346))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_1493344, _1493346))
^  <span class="ansi1 ansi31"
>Fail: </span>(297) [user] self_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] atomic(case)
   <span class="ansi1 ansi32"
>Exit: </span>(297) [system] atomic(case)
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] is_sl(case)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] number(case)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] [['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] callable(case)
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] callable(case)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] [['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] is_list([['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] is_list([['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] is_list(case)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] is_list([['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] is_list([['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] is_list([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] is_list([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] once(expand_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1513752))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] expand_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1513752)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] is_list([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
   <span class="ansi1 ansi32"
>Exit: </span>(298) [system] is_list([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] ground(case)
   <span class="ansi1 ansi32"
>Exit: </span>(298) [system] ground(case)
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] apply:maplist(expand_eval, [['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1519324)
   <span class="ansi1 ansi32"
>Call: </span>(299) [apply] apply:maplist_([['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1519324, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] expand_eval(['if-unify-or-empty', _1401296, _1401296], _1521204)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] is_list(['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] is_list(['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] apply:maplist(expand_eval, [_1401296, _1401296], _1525842)
   <span class="ansi1 ansi32"
>Call: </span>(302) [apply] apply:maplist_([_1401296, _1401296], _1525842, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] expand_eval(_1401296, _1527722)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list(_1401296)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _1401296=_1527722
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] _1401296=_1401296
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] expand_eval(_1401296, _1401296)
   <span class="ansi1 ansi32"
>Call: </span>(303) [apply] apply:maplist_([_1401296], _1527724, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] expand_eval(_1401296, _1533296)
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] is_list(_1401296)
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] _1401296=_1533296
   <span class="ansi1 ansi32"
>Exit: </span>(305) [system] _1401296=_1401296
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] expand_eval(_1401296, _1401296)
   <span class="ansi1 ansi32"
>Call: </span>(304) [apply] apply:maplist_([], _1533298, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [apply] apply:maplist_([_1401296], [_1401296], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [apply] apply:maplist_([_1401296, _1401296], [_1401296, _1401296], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [apply] apply:maplist(user:expand_eval, [_1401296, _1401296], [_1401296, _1401296])
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] expand_eval(['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(300) [apply] apply:maplist_([[['Empty', _1401314]]], _1521206, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] expand_eval([['Empty', _1401314]], _1544464)
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] is_list([['Empty', _1401314]])
   <span class="ansi1 ansi32"
>Exit: </span>(302) [system] is_list([['Empty', _1401314]])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] ground(['Empty', _1401314])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] apply:maplist(expand_eval, [], _1547248)
   <span class="ansi1 ansi32"
>Call: </span>(303) [apply] apply:maplist_([], _1547248, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [apply] apply:maplist_([], [], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [apply] apply:maplist(user:expand_eval, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] expand_eval([['Empty', _1401314]], [['Empty', _1401314]])
   <span class="ansi1 ansi32"
>Call: </span>(301) [apply] apply:maplist_([], _1544466, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [apply] apply:maplist_([[['Empty', _1401314]]], [[['Empty', _1401314]]], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [apply] apply:maplist_([['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], [['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [apply] apply:maplist(user:expand_eval, [['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], [['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] expand_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [system] once(user:expand_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]))
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]\==[case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] is_progn(case)
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] is_space_op(case)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] must_det_ll([]==[])
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] once(user:([]==[]))
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(298) [system] []==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [system] once(user:([]==[]))
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] must_det_ll(user:([]==[]))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] into_case_list([['Empty', _1401314]], _1570492)
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] is_list([['Empty', _1401314]])
   <span class="ansi1 ansi32"
>Exit: </span>(297) [system] is_list([['Empty', _1401314]])
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] into_case_list([['Empty', _1401314]], [['Empty', _1401314]])
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] into_case_keys(1, [['Empty', _1401314]], _1574198)
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] _1575150 is 1+1
   <span class="ansi1 ansi32"
>Exit: </span>(297) [system] 2 is 1+1
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] is_case(_1575140, ['Empty', _1401314], _1575142)
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] is_case('Empty', ['Empty', _1401314], _1401314)
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_1401314)))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_1579876, _1579878), once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_1401314))), _1579834, fbug((_1579834-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_1401314)))))))), '$restore_trace'(_1579876, _1579878))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_1579876, _1579878))
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_1401314))), _1579834, fbug((_1579834-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_1401314)))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_1401314)))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] into_case_keys(2, [], _1575136)
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] into_case_keys(2, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] into_case_keys(1, [['Empty', _1401314]], ['Empty'-_1401314])
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] eval_case(=, _1411028, 496, '&self', ['if-unify-or-empty', _1401296, _1401296], ['Empty'-_1401314], _1459770)
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _1401296, _1401296]))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_1588452, _1588454), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _1401296, _1401296]))), _1588410, fbug((_1588410-->if_trace(case, writeqln(case=['if-unify-or-empty', _1401296, _1401296]))))))), '$restore_trace'(_1588452, _1588454))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_1588452, _1588454))
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _1401296, _1401296]))), _1588410, fbug((_1588410-->if_trace(case, writeqln(case=['if-unify-or-empty', _1401296, _1401296]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _1401296, _1401296]))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] eval_args(=, _1592374, 496, '&self', ['if-unify-or-empty', _1401296, _1401296], _1592296)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] var(['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_1594178, _1594180), once(user:self_eval(['if-unify-or-empty', _1401296, _1401296])), '$restore_trace'(_1594178, _1594180))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_1594178, _1594180))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_1596090, _1596092), once(user:nonvar(_1592296)), '$restore_trace'(_1596090, _1596092))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_1596090, _1596092))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_1598002, _1598004), once(user:nonvar(_1592296)), '$restore_trace'(_1598002, _1598004))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_1598002, _1598004))
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] [_1401296, _1401296]==[]
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(298) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] self_eval(['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] setup_call_cleanup('$notrace'(_1604542, _1604544), once(user:self_eval0(['if-unify-or-empty', _1401296, _1401296])), '$restore_trace'(_1604542, _1604544))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] sig_atomic(system:'$notrace'(_1604542, _1604544))
^  <span class="ansi1 ansi31"
>Fail: </span>(298) [user] self_eval(['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] eval_00(=, _1607366, 496, '&self', ['if-unify-or-empty', _1401296, _1401296], _1592296)
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] self_eval(['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] setup_call_cleanup('$notrace'(_1609248, _1609250), once(user:self_eval0(['if-unify-or-empty', _1401296, _1401296])), '$restore_trace'(_1609248, _1609250))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] sig_atomic(system:'$notrace'(_1609248, _1609250))
^  <span class="ansi1 ansi31"
>Fail: </span>(299) [user] self_eval(['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] eval_01(=, _1607366, 496, '&self', ['if-unify-or-empty', _1401296, _1401296], _1592296)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] ['if-unify-or-empty', _1401296, _1401296]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] ['if-unify-or-empty', _1401296, _1401296]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] if_t((496<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] 496<1
   <span class="ansi1 ansi31"
>Fail: </span>(302) [system] 496<1
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] if_t((496<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] setup_call_cleanup('$notrace'(_1618642, _1618644), once(user:(_1618618 is 496-1, copy_term(['if-unify-or-empty', _1401296, _1401296], _1618632))), '$restore_trace'(_1618642, _1618644))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] sig_atomic(system:'$notrace'(_1618642, _1618644))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(495 is 496-1, copy_term(['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _1620552, _1620552]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] trace_eval(eval_20(=, _1607366), e, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1621506)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] must_det_ll((notrace((flag(eval_num, _1622472, _1622472+1), _1622490 is _1622472 mod 500, _1622508 is 99-495 mod 100, _1622532=_1622534, option_else('trace-length', _1622546, 500), option_else('trace-depth', _1622554, 30))), quietly(if_t((nop(stop_rtrace), _1622490>_1622546), (set_debug(eval, false), _1622610 is _1622546+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1622610])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1622662)))))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] once(user:(notrace((flag(eval_num, _1622472, _1622472+1), _1622490 is _1622472 mod 500, _1622508 is 99-495 mod 100, _1622532=_1622534, option_else('trace-length', _1622546, 500), option_else('trace-depth', _1622554, 30))), quietly(if_t((nop(stop_rtrace), _1622490>_1622546), (set_debug(eval, false), _1622610 is _1622546+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1622610])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1622662)))))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_1624532, _1624534), once(user:(flag(eval_num, _1622472, _1622472+1), _1622490 is _1622472 mod 500, _1622508 is 99-495 mod 100, _1622532=_1622534, option_else('trace-length', _1622546, 500), option_else('trace-depth', _1622554, 30))), '$restore_trace'(_1624532, _1624534))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_1624532, _1624534))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 4712, 4712+1), 212 is 4712 mod 500, 4 is 99-495 mod 100, _1622532=_1622532, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 212>500), (set_debug(eval, false), _1622610 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1622610])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 212>500), (set_debug(eval, false), _1622610 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1622610])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(304) [user] nop(notrace(no_repeats_var(_1622662)))
   <span class="ansi1 ansi32"
>Exit: </span>(304) [user] nop(notrace(no_repeats_var(_1622662)))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] once(user:(notrace((flag(eval_num, 4712, 4712+1), 212 is 4712 mod 500, 4 is 99-495 mod 100, _1622532=_1622532, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 212>500), (set_debug(eval, false), _1622610 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1622610])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1622662)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] must_det_ll(user:(notrace((flag(eval_num, 4712, 4712+1), 212 is 4712 mod 500, 4 is 99-495 mod 100, _1622532=_1622532, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 212>500), (set_debug(eval, false), _1622610 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1622610])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1622662)))))
   <span class="ansi1 ansi32"
>Call: </span>(301) [occurs] occurs:sub_term(_1633216, e)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(301) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(302) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(301) [occurs] occurs:sub_term(_1633216, e)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] _1639706=e
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] if_trace((eval;e), (_1622532=1, indentq(4, 212, -->, [e, ['if-unify-or-empty', _1401296, _1401296]])))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] setup_call_cleanup('$notrace'(_1642582, _1642584), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _1622532=1, indentq(4, 212, -->, [e, ['if-unify-or-empty', _1401296, _1401296]]))), _1642540, fbug((_1642540-->if_trace((eval;e), (_1622532=1, indentq(4, 212, -->, [e, ['if-unify-or-empty', _1401296, _1401296]])))))))), '$restore_trace'(_1642582, _1642584))
^  <span class="ansi1 ansi32"
>Call: </span>(304) [system] sig_atomic(system:'$notrace'(_1642582, _1642584))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _1622532=1, indentq(4, 212, -->, [e, ['if-unify-or-empty', _1401296, _1401296]]))), _1642540, fbug((_1642540-->if_trace((eval;e), (_1622532=1, indentq(4, 212, -->, [e, ['if-unify-or-empty', _1401296, _1401296]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] if_trace((eval;e), (_1622532=1, indentq(4, 212, -->, [e, ['if-unify-or-empty', _1401296, _1401296]])))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] _1646426=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] _1648288=(\+ \+ (flag(eval_num, _1648308, _1648308+1), (retval(fail)\=@=retval(fail), nonvar(_1621506)->indentq(4, _1648308, <--, [e, _1621506]);indentq(4, _1648308, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] (\+ \+ (flag(eval_num, _1648308, _1648308+1), (retval(fail)\=@=retval(fail), nonvar(_1621506)->indentq(4, _1648308, <--, [e, _1621506]);indentq(4, _1648308, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _1648308, _1648308+1), (retval(fail)\=@=retval(fail), nonvar(_1621506)->indentq(4, _1648308, <--, [e, _1621506]);indentq(4, _1648308, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] call_cleanup(((call(eval_20(=, _1607366), 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1621506)*->nb_setarg(1, retval(fail), _1621506);fail, trace, call(eval_20(=, _1607366), 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1621506)), ignore(notrace((\+_1621506\=_1622662, nb_setarg(1, retval(fail), _1621506))))), ignore((_1622532==1->ignore(\+ \+ (flag(eval_num, _1648308, _1648308+1), (retval(fail)\=@=retval(fail), nonvar(_1621506)->indentq(4, _1648308, <--, [e, _1621506]);indentq(4, _1648308, <--, [e, retval(fail)]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1648308, _1648308+1), (retval(fail)\=@=retval(fail), nonvar(_1621506)->indentq(4, _1648308, <--, [e, _1621506]);indentq(4, _1648308, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_20(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1621506)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] atom(['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] no_eval(['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] self_eval(['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] setup_call_cleanup('$notrace'(_1655080, _1655082), once(user:self_eval0(['if-unify-or-empty', _1401296, _1401296])), '$restore_trace'(_1655080, _1655082))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] sig_atomic(system:'$notrace'(_1655080, _1655082))
^  <span class="ansi1 ansi31"
>Fail: </span>(305) [user] self_eval(['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] atomic('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(305) [system] atomic('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] is_sl('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] number('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [_1401296, _1401296]==[]
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _1665306==eval
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [_1401296, _1401296]==[]
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list([_1401296, _1401296])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list([_1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list([_1401296, _1401296])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list([_1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list(['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list(['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] once(expand_eval(['if-unify-or-empty', _1401296, _1401296], _1676428))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] expand_eval(['if-unify-or-empty', _1401296, _1401296], _1676428)
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] is_list(['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Exit: </span>(306) [system] is_list(['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(306) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] apply:maplist(expand_eval, [_1401296, _1401296], _1682000)
   <span class="ansi1 ansi32"
>Call: </span>(307) [apply] apply:maplist_([_1401296, _1401296], _1682000, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] expand_eval(_1401296, _1683880)
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] is_list(_1401296)
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] _1401296=_1683880
   <span class="ansi1 ansi32"
>Exit: </span>(309) [system] _1401296=_1401296
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] expand_eval(_1401296, _1401296)
   <span class="ansi1 ansi32"
>Call: </span>(308) [apply] apply:maplist_([_1401296], _1683882, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] expand_eval(_1401296, _1689454)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list(_1401296)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _1401296=_1689454
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] _1401296=_1401296
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] expand_eval(_1401296, _1401296)
   <span class="ansi1 ansi32"
>Call: </span>(309) [apply] apply:maplist_([], _1689456, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(309) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(308) [apply] apply:maplist_([_1401296], [_1401296], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [apply] apply:maplist_([_1401296, _1401296], [_1401296, _1401296], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [apply] apply:maplist(user:expand_eval, [_1401296, _1401296], [_1401296, _1401296])
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [user] expand_eval(['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [system] once(user:expand_eval(['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _1401296, _1401296]))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] ['if-unify-or-empty', _1401296, _1401296]\==['if-unify-or-empty', _1401296, _1401296]
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] is_progn('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] is_space_op('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] arg(_1705332, v('catch!', 'throw!', 'number-of!', 'limit!', 'offset!', 'max-time!', 'findall!', 'setup-call-cleanup!', 'call-cleanup!', 'call-cleanup!', 'with-output-to!'), 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _1706190='if-unify-or-empty'
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] 'if-unify-or-empty'='if-unify-or-empty'
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _1708048)
^  <span class="ansi1 ansi31"
>Fail: </span>(304) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _1708048)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list(['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list(['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] apply:maplist(self_eval, ['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(305) [apply] apply:maplist_(['if-unify-or-empty', _1401296, _1401296], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] self_eval('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_1714566, _1714568), once(user:self_eval0('if-unify-or-empty')), '$restore_trace'(_1714566, _1714568))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_1714566, _1714568))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0('if-unify-or-empty')), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] self_eval('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(306) [apply] apply:maplist_([_1401296, _1401296], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] self_eval(_1401296)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_1720192, _1720194), once(user:self_eval0(_1401296)), '$restore_trace'(_1720192, _1720194))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_1720192, _1720194))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_1401296)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] self_eval(_1401296)
   <span class="ansi1 ansi32"
>Call: </span>(307) [apply] apply:maplist_([_1401296], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] self_eval(_1401296)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_1725818, _1725820), once(user:self_eval0(_1401296)), '$restore_trace'(_1725818, _1725820))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_1725818, _1725820))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_1401296)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] self_eval(_1401296)
   <span class="ansi1 ansi32"
>Call: </span>(308) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(308) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [apply] apply:maplist_([_1401296], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(306) [apply] apply:maplist_([_1401296, _1401296], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(305) [apply] apply:maplist_(['if-unify-or-empty', _1401296, _1401296], user:self_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [apply] apply:maplist(user:self_eval, ['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] ['if-unify-or-empty', _1401296, _1401296]=[_1735156|_1735158]
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] ['if-unify-or-empty', _1401296, _1401296]=['if-unify-or-empty', _1401296, _1401296]
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _1738864=do_more_defs(true)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] do_more_defs(true)=do_more_defs(true)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] clause(eval_21(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1621506), _1740740)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] 'if-unify-or-empty'==(/)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] 'if-unify-or-empty'== ===
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] 'if-unify-or-empty'== ====
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] eval_40(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460)
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] eval_selfless(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_selfless_0(['if-unify-or-empty', _1401296, _1401296], _1744460)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] is_assignment('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(308) [system] atom('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] eval_selfless_1(['if-unify-or-empty', _1401296, _1401296], _1744460)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] allow_clp
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] false_flag
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(310) [system] fail
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] false_flag
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] eval_selfless_2(['if-unify-or-empty', _1401296, _1401296], _1744460)
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] fake_notrace((ground(['if-unify-or-empty', _1401296, _1401296]), ['if-unify-or-empty', _1401296, _1401296]=[_1758364, _1758370, _1758376], atom(_1758364), catch_warn(current_op(_1758402, yfx, _1758364)), ['if-unify-or-empty', _1401296, _1401296]\=[_1758422], s2ps(['if-unify-or-empty', _1401296, _1401296], _1758430)))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] real_notrace(user:(ground(['if-unify-or-empty', _1401296, _1401296]), ['if-unify-or-empty', _1401296, _1401296]=[_1758364, _1758370, _1758376], atom(_1758364), catch_warn(current_op(_1758402, yfx, _1758364)), ['if-unify-or-empty', _1401296, _1401296]\=[_1758422], s2ps(['if-unify-or-empty', _1401296, _1401296], _1758430)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] setup_call_cleanup('$notrace'(_1760288, _1760290), once(user:(ground(['if-unify-or-empty', _1401296, _1401296]), ['if-unify-or-empty', _1401296, _1401296]=[_1758364, _1758370, _1758376], atom(_1758364), catch_warn(current_op(_1758402, yfx, _1758364)), ['if-unify-or-empty', _1401296, _1401296]\=[_1758422], s2ps(['if-unify-or-empty', _1401296, _1401296], _1758430))), '$restore_trace'(_1760288, _1760290))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(user:'$notrace'(_1760288, _1760290))
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] real_notrace(user:(ground(['if-unify-or-empty', _1401296, _1401296]), ['if-unify-or-empty', _1401296, _1401296]=[_1758364, _1758370, _1758376], atom(_1758364), catch_warn(current_op(_1758402, yfx, _1758364)), ['if-unify-or-empty', _1401296, _1401296]\=[_1758422], s2ps(['if-unify-or-empty', _1401296, _1401296], _1758430)))
^  <span class="ansi1 ansi31"
>Fail: </span>(308) [user] fake_notrace(user:(ground(['if-unify-or-empty', _1401296, _1401296]), ['if-unify-or-empty', _1401296, _1401296]=[_1758364, _1758370, _1758376], atom(_1758364), catch_warn(current_op(_1758402, yfx, _1758364)), ['if-unify-or-empty', _1401296, _1401296]\=[_1758422], s2ps(['if-unify-or-empty', _1401296, _1401296], _1758430)))
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] 'if-unify-or-empty'==(==)
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] 'if-unify-or-empty'==(==)
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] eval_41(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_adjust_args(=, _1607366, _1772332, _1744460, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1772334)
   <span class="ansi1 ansi32"
>Call: </span>(307) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _1607366, _1772332, _1744460, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1772334)), eval_adjust_args1(=, _1607366, _1772332, _1744460, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1772334))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_adjust_args2(=, _1607366, _1772332, _1744460, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1772334)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] apply:maplist(must_eval_args(=, _1778872, 495, '&self'), [_1401296, _1401296], _1778866)
   <span class="ansi1 ansi32"
>Call: </span>(311) [apply] apply:maplist_([_1401296, _1401296], _1778866, user:must_eval_args(=, _1778872, 495, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] must_eval_args(=, _1778872, 495, '&self', _1401296, _1780756)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] was_option_value(nodebug, _1790952)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] current_prolog_flag(nodebug, _1791882)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] current_prolog_flag(nodebug, _1791882)
   <span class="ansi1 ansi32"
>Call: </span>(318) [$syspreds] prolog_load_context(nodebug, _1793740)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [$syspreds] prolog_load_context(nodebug, _1793740)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nb_current(nodebug, _1795598)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] nb_current(nodebug, _1795598)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] was_option_value(nodebug, _1790952)
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_1801182, _1801184), once(user:option_value0(nodebug, true)), '$restore_trace'(_1801182, _1801184))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_1801182, _1801184))
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(314) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1819762)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1819762, _1820770)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_1824432, _1824434, _1824436), defined)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(317) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1824432, _1824434, _1824436))
   <span class="ansi1 ansi32"
>Call: </span>(318) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1824432, _1824434, _1824436))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] callable(debugging_logicmoo_setting(_1824432, _1824434, _1824436))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] callable(debugging_logicmoo_setting(_1824432, _1824434, _1824436))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1824432, _1824434, _1824436))
   <span class="ansi1 ansi32"
>Exit: </span>(317) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1824432, _1824434, _1824436))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_1824432, _1824434, _1824436), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _1819762, _1835560)
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(314) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval_args(=, _1778872, 495, '&self', _1401296, _1780756)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(_1401296)
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] var(_1401296)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] nonvar(_1780756)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_1845818, _1845820), once(user:self_eval(_1401296)), '$restore_trace'(_1845818, _1845820))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_1845818, _1845820))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_1401296)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] _1780756=_1401296
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] _1401296=_1401296
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] eval_args(=, _1778872, 495, '&self', _1401296, _1401296)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] must_eval_args(=, _1778872, 495, '&self', _1401296, _1401296)
   <span class="ansi1 ansi32"
>Call: </span>(312) [apply] apply:maplist_([_1401296], _1780758, user:must_eval_args(=, _1778872, 495, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] must_eval_args(=, _1778872, 495, '&self', _1401296, _1853378)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] was_option_value(nodebug, _1863574)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] current_prolog_flag(nodebug, _1864504)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] current_prolog_flag(nodebug, _1864504)
   <span class="ansi1 ansi32"
>Call: </span>(319) [$syspreds] prolog_load_context(nodebug, _1866362)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [$syspreds] prolog_load_context(nodebug, _1866362)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] nb_current(nodebug, _1868220)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] nb_current(nodebug, _1868220)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] was_option_value(nodebug, _1863574)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_1873804, _1873806), once(user:option_value0(nodebug, true)), '$restore_trace'(_1873804, _1873806))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_1873804, _1873806))
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(315) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1892384)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1892384, _1893392)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_1897054, _1897056, _1897058), defined)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(318) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1897054, _1897056, _1897058))
   <span class="ansi1 ansi32"
>Call: </span>(319) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1897054, _1897056, _1897058))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] callable(debugging_logicmoo_setting(_1897054, _1897056, _1897058))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] callable(debugging_logicmoo_setting(_1897054, _1897056, _1897058))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1897054, _1897056, _1897058))
   <span class="ansi1 ansi32"
>Exit: </span>(318) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1897054, _1897056, _1897058))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_1897054, _1897056, _1897058), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _1892384, _1908182)
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(315) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] eval_args(=, _1778872, 495, '&self', _1401296, _1853378)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] var(_1401296)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] var(_1401296)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nonvar(_1853378)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] setup_call_cleanup('$notrace'(_1918440, _1918442), once(user:self_eval(_1401296)), '$restore_trace'(_1918440, _1918442))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] sig_atomic(system:'$notrace'(_1918440, _1918442))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_1401296)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] _1853378=_1401296
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] _1401296=_1401296
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] eval_args(=, _1778872, 495, '&self', _1401296, _1401296)
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] must_eval_args(=, _1778872, 495, '&self', _1401296, _1401296)
   <span class="ansi1 ansi32"
>Call: </span>(313) [apply] apply:maplist_([], _1853380, user:must_eval_args(=, _1778872, 495, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(313) [apply] apply:maplist_([], [], user:must_eval_args(=, _1778872, 495, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(312) [apply] apply:maplist_([_1401296], [_1401296], user:must_eval_args(=, _1778872, 495, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(311) [apply] apply:maplist_([_1401296, _1401296], [_1401296, _1401296], user:must_eval_args(=, _1778872, 495, '&self'))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [apply] apply:maplist(user:must_eval_args(=, _1778872, 495, '&self'), [_1401296, _1401296], [_1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _1772332=_1744460
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] _1744460=_1744460
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_adjust_args2(=, _1607366, _1744460, _1744460, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _1607366, _1744460, _1744460, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _1401296, _1401296])), eval_adjust_args1(=, _1607366, _1744460, _1744460, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _1401296, _1401296]))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_adjust_args(=, _1607366, _1744460, _1744460, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] if_trace((e;args), (['if-unify-or-empty', _1401296, _1401296]\==['if-unify-or-empty', _1401296, _1401296]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _1401296, _1401296]->['if-unify-or-empty', _1401296, _1401296])));nop(indentq2(495, same(['if-unify-or-empty', _1401296, _1401296])))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_1935442, _1935444), once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _1401296, _1401296]\==['if-unify-or-empty', _1401296, _1401296]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _1401296, _1401296]->['if-unify-or-empty', _1401296, _1401296])));nop(indentq2(495, same(['if-unify-or-empty', _1401296, _1401296])))))), _1935400, fbug((_1935400-->if_trace((e;args), (['if-unify-or-empty', _1401296, _1401296]\==['if-unify-or-empty', _1401296, _1401296]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _1401296, _1401296]->['if-unify-or-empty', _1401296, _1401296])));nop(indentq2(495, same(['if-unify-or-empty', _1401296, _1401296])))))))))), '$restore_trace'(_1935442, _1935444))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_1935442, _1935444))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _1401296, _1401296]\==['if-unify-or-empty', _1401296, _1401296]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _1401296, _1401296]->['if-unify-or-empty', _1401296, _1401296])));nop(indentq2(495, same(['if-unify-or-empty', _1401296, _1401296])))))), _1935400, fbug((_1935400-->if_trace((e;args), (['if-unify-or-empty', _1401296, _1401296]\==['if-unify-or-empty', _1401296, _1401296]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _1401296, _1401296]->['if-unify-or-empty', _1401296, _1401296])));nop(indentq2(495, same(['if-unify-or-empty', _1401296, _1401296])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] if_trace((e;args), (['if-unify-or-empty', _1401296, _1401296]\==['if-unify-or-empty', _1401296, _1401296]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _1401296, _1401296]->['if-unify-or-empty', _1401296, _1401296])));nop(indentq2(495, same(['if-unify-or-empty', _1401296, _1401296])))))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_70(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460)
   <span class="ansi1 ansi32"
>Call: </span>(307) [user] if_or_else(eval_maybe_python(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460), if_or_else(eval_maybe_host_predicate(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460), if_or_else(eval_maybe_host_function(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460), if_or_else(eval_maybe_defn(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460), eval_maybe_subst(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460)))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] eval_maybe_python(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460)
   <span class="ansi1 ansi32"
>Call: </span>(309) [user] metta_atom('&self', ['registered-python-function', _1942186, _1942192, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] typed_list('&self', _1943196, _1943118)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(310) [user] typed_list('&self', _1945976, _1943118)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] metta_atom_in_file('&self', ['registered-python-function', _1942186, _1942192, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] metta_atom_in_file('&self', ['registered-python-function', _1942186, _1942192, 'if-unify-or-empty'], _1948766, _1948768)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] loaded_into_kb('&self', _1949624)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] loaded_into_kb('&self', '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] once(user:asserted_metta_pred(_1951490, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] asserted_metta_pred(_1951490, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(313) [user] asserted_metta_pred(_1951490, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] metta_atom_asserted('&self', ['registered-python-function', _1942186, _1942192, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] metta_atom_asserted_deduced('&self', ['registered-python-function', _1942186, _1942192, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] metta_atom('&corelib', ['registered-python-function', _1942186, _1942192, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] typed_list('&corelib', _1962674, _1962596)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(312) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(311) [user] typed_list('&corelib', _1965454, _1962596)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] metta_atom_in_file('&corelib', ['registered-python-function', _1942186, _1942192, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] metta_atom_in_file('&corelib', ['registered-python-function', _1942186, _1942192, 'if-unify-or-empty'], _1968244, _1968246)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] loaded_into_kb('&corelib', _1969102)
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] loaded_into_kb('&corelib', '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] once(user:asserted_metta_pred(_1970968, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] asserted_metta_pred(_1970968, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] asserted_metta_pred(_1970968, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] loaded_into_kb('&corelib', '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] once(user:asserted_metta_pred(_1974694, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] asserted_metta_pred(_1974694, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] asserted_metta_pred(_1974694, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
   <span class="ansi1 ansi32"
>Call: </span>(311) [user] metta_atom_asserted('&corelib', ['registered-python-function', _1942186, _1942192, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] metta_atom_asserted_deduced('&corelib', ['registered-python-function', _1942186, _1942192, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(308) [user] if_or_else(eval_maybe_host_predicate(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460), if_or_else(eval_maybe_host_function(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460), if_or_else(eval_maybe_defn(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460), eval_maybe_subst(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460))))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_maybe_host_predicate(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] once((is_system_pred('if-unify-or-empty'), length([_1401296, _1401296], _1986740), is_syspred('if-unify-or-empty', _1986740, _1986748)))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom_concat(_1990532, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom_concat(_1993312, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom_concat(_1996092, '-p', 'if-unify-or-empty')
^  <span class="ansi1 ansi31"
>Fail: </span>(312) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(309) [user] if_or_else(eval_maybe_host_function(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460), if_or_else(eval_maybe_defn(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460), eval_maybe_subst(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] eval_maybe_host_function(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom_concat(_2004412, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom_concat(_2007192, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom_concat(_2009972, '-p', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] if_or_else(eval_maybe_defn(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460), eval_maybe_subst(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] eval_maybe_defn(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] trace_eval(eval_defn_choose_candidates(=, _1607366), defn, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] must_det_ll((notrace((flag(eval_num, _2019180, _2019180+1), _2019198 is _2019180 mod 500, _2019216 is 99-495 mod 100, _2019240=_2019242, option_else('trace-length', _2019254, 500), option_else('trace-depth', _2019262, 30))), quietly(if_t((nop(stop_rtrace), _2019198>_2019254), (set_debug(eval, false), _2019318 is _2019254+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2019318])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2019370)))))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] once(user:(notrace((flag(eval_num, _2019180, _2019180+1), _2019198 is _2019180 mod 500, _2019216 is 99-495 mod 100, _2019240=_2019242, option_else('trace-length', _2019254, 500), option_else('trace-depth', _2019262, 30))), quietly(if_t((nop(stop_rtrace), _2019198>_2019254), (set_debug(eval, false), _2019318 is _2019254+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2019318])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2019370)))))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_2021240, _2021242), once(user:(flag(eval_num, _2019180, _2019180+1), _2019198 is _2019180 mod 500, _2019216 is 99-495 mod 100, _2019240=_2019242, option_else('trace-length', _2019254, 500), option_else('trace-depth', _2019262, 30))), '$restore_trace'(_2021240, _2021242))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_2021240, _2021242))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 4713, 4713+1), 213 is 4713 mod 500, 4 is 99-495 mod 100, _2019240=_2019240, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 213>500), (set_debug(eval, false), _2019318 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2019318])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 213>500), (set_debug(eval, false), _2019318 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2019318])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(316) [user] nop(notrace(no_repeats_var(_2019370)))
   <span class="ansi1 ansi32"
>Exit: </span>(316) [user] nop(notrace(no_repeats_var(_2019370)))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [system] once(user:(notrace((flag(eval_num, 4713, 4713+1), 213 is 4713 mod 500, 4 is 99-495 mod 100, _2019240=_2019240, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 213>500), (set_debug(eval, false), _2019318 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2019318])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2019370)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] must_det_ll(user:(notrace((flag(eval_num, 4713, 4713+1), 213 is 4713 mod 500, 4 is 99-495 mod 100, _2019240=_2019240, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 213>500), (set_debug(eval, false), _2019318 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2019318])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2019370)))))
   <span class="ansi1 ansi32"
>Call: </span>(313) [occurs] occurs:sub_term(_2029924, defn)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [occurs] occurs:sub_term(defn, defn)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] defn\=defn
   <span class="ansi1 ansi31"
>Fail: </span>(313) [system] defn\=defn
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(313) [occurs] occurs:sub_term(_2029924, defn)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _2036414=defn
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] defn=defn
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] if_trace((eval;defn), (_2019240=1, indentq(4, 213, -->, [defn, ['if-unify-or-empty', _1401296, _1401296]])))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_2039290, _2039292), once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _2019240=1, indentq(4, 213, -->, [defn, ['if-unify-or-empty', _1401296, _1401296]]))), _2039248, fbug((_2039248-->if_trace((eval;defn), (_2019240=1, indentq(4, 213, -->, [defn, ['if-unify-or-empty', _1401296, _1401296]])))))))), '$restore_trace'(_2039290, _2039292))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_2039290, _2039292))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _2019240=1, indentq(4, 213, -->, [defn, ['if-unify-or-empty', _1401296, _1401296]]))), _2039248, fbug((_2039248-->if_trace((eval;defn), (_2019240=1, indentq(4, 213, -->, [defn, ['if-unify-or-empty', _1401296, _1401296]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] if_trace((eval;defn), (_2019240=1, indentq(4, 213, -->, [defn, ['if-unify-or-empty', _1401296, _1401296]])))
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _2043134=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _2044996=(\+ \+ (flag(eval_num, _2045016, _2045016+1), (retval(fail)\=@=retval(fail), nonvar(_1744460)->indentq(4, _2045016, <--, [defn, _1744460]);indentq(4, _2045016, <--, [defn, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] (\+ \+ (flag(eval_num, _2045016, _2045016+1), (retval(fail)\=@=retval(fail), nonvar(_1744460)->indentq(4, _2045016, <--, [defn, _1744460]);indentq(4, _2045016, <--, [defn, retval(fail)]))))=(\+ \+ (flag(eval_num, _2045016, _2045016+1), (retval(fail)\=@=retval(fail), nonvar(_1744460)->indentq(4, _2045016, <--, [defn, _1744460]);indentq(4, _2045016, <--, [defn, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] call_cleanup(((call(eval_defn_choose_candidates(=, _1607366), 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460)*->nb_setarg(1, retval(fail), _1744460);fail, trace, call(eval_defn_choose_candidates(=, _1607366), 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460)), ignore(notrace((\+_1744460\=_2019370, nb_setarg(1, retval(fail), _1744460))))), ignore((_2019240==1->ignore(\+ \+ (flag(eval_num, _2045016, _2045016+1), (retval(fail)\=@=retval(fail), nonvar(_1744460)->indentq(4, _2045016, <--, [defn, _1744460]);indentq(4, _2045016, <--, [defn, retval(fail)]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _2045016, _2045016+1), (retval(fail)\=@=retval(fail), nonvar(_1744460)->indentq(4, _2045016, <--, [defn, _1744460]);indentq(4, _2045016, <--, [defn, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_defn_choose_candidates(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] findall((_2049006->_2049008), get_defn_expansions(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _2049006, _2049008), _2049026)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [$bags] findall((_2049006->_2049008), user:get_defn_expansions(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _2049006, _2049008), _2049026, [])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [$bags] cleanup_bag(findall_loop((_2049006->_2049008), user:get_defn_expansions(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _2049006, _2049008), _2049026, []), '$destroy_findall_bag')
   <span class="ansi1 ansi32"
>Call: </span>(319) [$bags] findall_loop((_2049006->_2049008), user:get_defn_expansions(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _2049006, _2049008), _2049026, [])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] get_defn_expansions(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _2049006, _2049008)
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] same_len_copy([_1401296, _1401296], _2053758)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] length([_1401296, _1401296], _2054688)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(_2054688)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] var(_2054688)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] []==[]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _2054688=2
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] 2=2
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] length([_1401296, _1401296], 2)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] length(_2053758, 2)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(2)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] integer(2)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] integer(2)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _2053758==[]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(_2053758)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] var(_2053758)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] length([_2068592, _2068598], 2)
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [user] same_len_copy([_1401296, _1401296], [_2068592, _2068598])
   <span class="ansi1 ansi32"
>Call: </span>(321) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _2068592, _2068598], _2049008)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] ignore((=)=(=))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] (=)=(=)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] (=)=(=)
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] ignore(user:((=)=(=)))
   <span class="ansi1 ansi32"
>Call: </span>(322) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _2068592, _2068598], _2049008]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _2068592, _2068598], _2049008]))
   <span class="ansi1 ansi32"
>Call: </span>(323) [user] metta_atom('&self', [=, ['if-unify-or-empty', _2068592, _2068598], _2049008])
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] typed_list('&self', _2077074, _2076996)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(325) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(324) [user] typed_list('&self', _2079854, _2076996)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _2068592, _2068598], _2049008])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _2068592, _2068598], _2049008], _2082644, _2082646)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] loaded_into_kb('&self', _2083502)
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] loaded_into_kb('&self', '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] once(user:asserted_metta_pred(_2085368, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] asserted_metta_pred(_2085368, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(327) [user] asserted_metta_pred(_2085368, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
   <span class="ansi1 ansi32"
>Call: </span>(324) [user] metta_atom_asserted('&self', [=, ['if-unify-or-empty', _2068592, _2068598], _2049008])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] metta_atom_asserted_deduced('&self', [=, ['if-unify-or-empty', _2068592, _2068598], _2049008])
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(324) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _2068592, _2068598], _2049008])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] typed_list('&corelib', _2096552, _2096474)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(326) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(325) [user] typed_list('&corelib', _2099332, _2096474)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _2068592, _2068598], _2049008])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _2068592, _2068598], _2049008], _2102122, _2102124)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] loaded_into_kb('&corelib', _2102980)
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] loaded_into_kb('&corelib', '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] once(user:asserted_metta_pred(_2104846, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] asserted_metta_pred(_2104846, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(328) [user] asserted_metta_pred(_2104846, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] loaded_into_kb('&corelib', '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] once(user:asserted_metta_pred(_2108572, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] asserted_metta_pred(_2108572, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(328) [user] asserted_metta_pred(_2108572, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
   <span class="ansi1 ansi32"
>Call: </span>(325) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _2068592, _2068598], _2049008])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] metta_atom_asserted_deduced('&corelib', [=, ['if-unify-or-empty', _2068592, _2068598], _2049008])
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] fail
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _2068592, _2068592], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(324) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _2068592, _2068592], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(323) [user] metta_atom('&self', [=, ['if-unify-or-empty', _2068592, _2068592], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _2068592, _2068592], unified]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _2068592, _2068592], unified]))
   <span class="ansi1 ansi32"
>Exit: </span>(321) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _2068592, _2068592], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] get_defn_expansions(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _2068592, _2068592], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _2068592, _2068598], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(324) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _2068592, _2068598], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(323) [user] metta_atom('&self', [=, ['if-unify-or-empty', _2068592, _2068598], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _2068592, _2068598], [empty]]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _2068592, _2068598], [empty]]))
   <span class="ansi1 ansi32"
>Exit: </span>(321) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _2068592, _2068598], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] get_defn_expansions(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _2068592, _2068598], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(319) [$bags] findall_loop((_2049006->_2049008), user:get_defn_expansions(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _2049006, _2049008), [(['if-unify-or-empty', _2128034, _2128034]->unified), (['if-unify-or-empty', _2127998, _2128004]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [$bags] cleanup_bag('$bags':findall_loop((_2049006->_2049008), user:get_defn_expansions(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _2049006, _2049008), [(['if-unify-or-empty', _2128034, _2128034]->unified), (['if-unify-or-empty', _2127998, _2128004]->[empty])], []), '$bags':'$destroy_findall_bag')
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [$bags] findall((_2049006->_2049008), user:get_defn_expansions(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _2049006, _2049008), [(['if-unify-or-empty', _2128034, _2128034]->unified), (['if-unify-or-empty', _2127998, _2128004]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [$bags] findall((_2049006->_2049008), user:get_defn_expansions(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _2049006, _2049008), [(['if-unify-or-empty', _2128034, _2128034]->unified), (['if-unify-or-empty', _2127998, _2128004]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_defn_bodies(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460, [(['if-unify-or-empty', _2128034, _2128034]->unified), (['if-unify-or-empty', _2127998, _2128004]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] if_trace(e, maplist(print_templates(495, '   '), [(['if-unify-or-empty', _2128034, _2128034]->unified), (['if-unify-or-empty', _2127998, _2128004]->[empty])]))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_2133738, _2133740), once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(495, '   '), [(['if-unify-or-empty', _2128034, _2128034]->unified), (['if-unify-or-empty', _2127998, _2128004]->[empty])]))), _2133696, fbug((_2133696-->if_trace(e, maplist(print_templates(495, '   '), [(['if-unify-or-empty', _2128034, _2128034]->unified), (['if-unify-or-empty', _2127998, _2128004]->[empty])]))))))), '$restore_trace'(_2133738, _2133740))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_2133738, _2133740))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(495, '   '), [(['if-unify-or-empty', _2128034, _2128034]->unified), (['if-unify-or-empty', _2127998, _2128004]->[empty])]))), _2133696, fbug((_2133696-->if_trace(e, maplist(print_templates(495, '   '), [(['if-unify-or-empty', _2128034, _2128034]->unified), (['if-unify-or-empty', _2127998, _2128004]->[empty])]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [user] if_trace(e, maplist(print_templates(495, '   '), [(['if-unify-or-empty', _2128034, _2128034]->unified), (['if-unify-or-empty', _2127998, _2128004]->[empty])]))
   <span class="ansi1 ansi32"
>Call: </span>(317) [user] if_or_else((member((_2137596->_2137598), [(['if-unify-or-empty', _2128034, _2128034]->unified), (['if-unify-or-empty', _2127998, _2128004]->[empty])]), copy_term((_2137596->_2137598), _2137610), eval_defn_success(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460, _2137596, _2137598, _2137610)), eval_defn_failure(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460))
   <span class="ansi1 ansi32"
>Call: </span>(319) [lists] lists:member((_2137596->_2137598), [(['if-unify-or-empty', _2128034, _2128034]->unified), (['if-unify-or-empty', _2127998, _2128004]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(320) [lists] lists:member_([(['if-unify-or-empty', _2127998, _2128004]->[empty])], (_2137596->_2137598), (['if-unify-or-empty', _2128034, _2128034]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [lists] lists:member_([(['if-unify-or-empty', _2127998, _2128004]->[empty])], (['if-unify-or-empty', _2128034, _2128034]->unified), (['if-unify-or-empty', _2128034, _2128034]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [lists] lists:member((['if-unify-or-empty', _2128034, _2128034]->unified), [(['if-unify-or-empty', _2128034, _2128034]->unified), (['if-unify-or-empty', _2127998, _2128004]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] copy_term((['if-unify-or-empty', _2128034, _2128034]->unified), _2137610)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] copy_term((['if-unify-or-empty', _2128034, _2128034]->unified), (['if-unify-or-empty', _2143232, _2143232]->unified))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_defn_success(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460, ['if-unify-or-empty', _2128034, _2128034], unified, (['if-unify-or-empty', _2143232, _2143232]->unified))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] ['if-unify-or-empty', _1401296, _1401296]=['if-unify-or-empty', _2128034, _2128034]
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] ['if-unify-or-empty', _1401296, _1401296]=['if-unify-or-empty', _1401296, _1401296]
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _1744460=unified
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] unified=unified
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] ['if-unify-or-empty', _1401296, _1401296]\=@=unified
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] ['if-unify-or-empty', _1401296, _1401296]\=@=unified
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _2143232, _2143232]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_2151688, _2151690), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _2143232, _2143232]->unified)))))), _2151646, fbug((_2151646-->if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _2143232, _2143232]->unified)))))))))), '$restore_trace'(_2151688, _2151690))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_2151688, _2151690))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _2143232, _2143232]->unified)))))), _2151646, fbug((_2151646-->if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _2143232, _2143232]->unified)))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _2143232, _2143232]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] light_eval(=, _1607366, 495, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] light_eval(=, _1607366, 495, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] eval_defn_success(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified, ['if-unify-or-empty', _1401296, _1401296], unified, (['if-unify-or-empty', _2143232, _2143232]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(317) [user] if_or_else((member((['if-unify-or-empty', _1401296, _1401296]->unified), [(['if-unify-or-empty', _1401296, _1401296]->unified), (['if-unify-or-empty', _2127998, _2128004]->[empty])]), copy_term((['if-unify-or-empty', _1401296, _1401296]->unified), (['if-unify-or-empty', _2143232, _2143232]->unified)), eval_defn_success(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified, ['if-unify-or-empty', _1401296, _1401296], unified, (['if-unify-or-empty', _2143232, _2143232]->unified))), eval_defn_failure(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] eval_defn_bodies(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified, [(['if-unify-or-empty', _1401296, _1401296]->unified), (['if-unify-or-empty', _2127998, _2128004]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] eval_defn_choose_candidates(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] ignore(notrace((\+unified\=_2019370, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_2163992, _2163994), once(user:(\+unified\=_2019370, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_2163992, _2163994))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_2163992, _2163994))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_2019370, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] ignore(user:notrace((\+unified\=_2019370, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _1607366), 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_defn_choose_candidates(=, _1607366), 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)), ignore(notrace((\+unified\=_2019370, nb_setarg(1, retval(unified), unified))))), user:ignore((_2019240==1->ignore(\+ \+ (flag(eval_num, _2045016, _2045016+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(4, _2045016, <--, [defn, unified]);indentq(4, _2045016, <--, [defn, retval(unified)]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _2045016, _2045016+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(4, _2045016, <--, [defn, unified]);indentq(4, _2045016, <--, [defn, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] trace_eval(eval_defn_choose_candidates(=, _1607366), defn, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] eval_maybe_defn(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else(eval_maybe_defn(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), eval_maybe_subst(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified))
   <span class="ansi1 ansi32"
>Exit: </span>(309) [user] if_or_else(eval_maybe_host_function(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), if_or_else(eval_maybe_defn(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), eval_maybe_subst(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)))
   <span class="ansi1 ansi32"
>Exit: </span>(308) [user] if_or_else(eval_maybe_host_predicate(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), if_or_else(eval_maybe_host_function(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), if_or_else(eval_maybe_defn(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), eval_maybe_subst(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified))))
   <span class="ansi1 ansi32"
>Exit: </span>(307) [user] if_or_else(eval_maybe_python(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), if_or_else(eval_maybe_host_predicate(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), if_or_else(eval_maybe_host_function(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), if_or_else(eval_maybe_defn(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), eval_maybe_subst(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_70(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] check_returnval(=, _1607366, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] check_returnval(=, _1607366, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [user] eval_41(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] eval_40(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] unified=_1621506
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] eval_20(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] ignore(notrace((\+unified\=_1622662, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_2186410, _2186412), once(user:(\+unified\=_1622662, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_2186410, _2186412))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_2186410, _2186412))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_1622662, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [system] ignore(user:notrace((\+unified\=_1622662, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] call_cleanup(user:((call(eval_20(=, _1607366), 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_20(=, _1607366), 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)), ignore(notrace((\+unified\=_1622662, nb_setarg(1, retval(unified), unified))))), user:ignore((_1622532==1->ignore(\+ \+ (flag(eval_num, _1648308, _1648308+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(4, _1648308, <--, [e, unified]);indentq(4, _1648308, <--, [e, retval(unified)]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1648308, _1648308+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(4, _1648308, <--, [e, unified]);indentq(4, _1648308, <--, [e, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] trace_eval(eval_20(=, _1607366), e, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] self_eval(unified)
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_2194852, _2194854), once(user:self_eval0(unified)), '$restore_trace'(_2194852, _2194854))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_2194852, _2194854))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(unified)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] self_eval(unified)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] _1592296=unified
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] eval_01(=, _1607366, 496, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [user] eval_00(=, _1607366, 496, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] eval_args(=, _1607366, 496, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_2204290, _2204292), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _2204248, fbug((_2204248-->if_trace(case, writeqln(switch=unified))))))), '$restore_trace'(_2204290, _2204292))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_2204290, _2204292))
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _2204248, fbug((_2204248-->if_trace(case, writeqln(switch=unified))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] select_case(496, '&self', unified, ['Empty'-_1401314], _2208134)
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] best_key(unified, ['Empty'-_1401314], _2208134)
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_2210010-_2208134, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member_([], _2210010-_2208134, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member_([], 'Empty'-_1401314, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [lists] lists:member('Empty'-_1401314, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] unified='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_2214664-_2208134, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member_([], _2214664-_2208134, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member_([], 'Empty'-_1401314, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [lists] lists:member('Empty'-_1401314, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] unified=='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_2219318-_2208134, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member_([], _2219318-_2208134, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member_([], 'Empty'-_1401314, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [lists] lists:member('Empty'-_1401314, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] unified=@='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_2223972-_2208134, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member_([], _2223972-_2208134, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member_([], 'Empty'-_1401314, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [lists] lists:member('Empty'-_1401314, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] unified='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] maybe_special_keys(496, '&self', ['Empty'-_1401314], _2228624)
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] eval_args(496, '&self', 'Empty', _2229570)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] eval_args(=, _2230586, 496, '&self', 'Empty', _2229570)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] var('Empty')
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_2232390, _2232392), once(user:self_eval('Empty')), '$restore_trace'(_2232390, _2232392))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_2232390, _2232392))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval('Empty')), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] _2229570='Empty'
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] 'Empty'='Empty'
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] eval_args(=, _2237204, 496, '&self', 'Empty', 'Empty')
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] eval_args(496, '&self', 'Empty', 'Empty')
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] 'Empty'\=@='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] maybe_special_keys(496, '&self', [], _2228624)
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] maybe_special_keys(496, '&self', [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [user] maybe_special_keys(496, '&self', ['Empty'-_1401314], [])
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] best_key(unified, [], _2208134)
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_2243678-_2208134, [])
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_2244612-_2208134, [])
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_2245546-_2208134, [])
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_2246480-_2208134, [])
   <span class="ansi1 ansi32"
>Call: </span>(298) [lists] lists:member(_2247414-_2208134, [])
   <span class="ansi1 ansi32"
>Call: </span>(297) [lists] lists:member(_2248348-_2248350, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(298) [lists] lists:member_([], _2248348-_2248350, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(298) [lists] lists:member_([], 'Empty'-_1401314, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(297) [lists] lists:member('Empty'-_1401314, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] 'Empty'=='%void%'
   <span class="ansi1 ansi32"
>Call: </span>(321) [lists] lists:member_([], (_2137596->_2137598), (['if-unify-or-empty', _2127998, _2128004]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(321) [lists] lists:member_([], (['if-unify-or-empty', _2127998, _2128004]->[empty]), (['if-unify-or-empty', _2127998, _2128004]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [lists] lists:member_([(['if-unify-or-empty', _2127998, _2128004]->[empty])], (['if-unify-or-empty', _2127998, _2128004]->[empty]), (['if-unify-or-empty', _2128034, _2128034]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [lists] lists:member((['if-unify-or-empty', _2127998, _2128004]->[empty]), [(['if-unify-or-empty', _2128034, _2128034]->unified), (['if-unify-or-empty', _2127998, _2128004]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] copy_term((['if-unify-or-empty', _2127998, _2128004]->[empty]), _2137610)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] copy_term((['if-unify-or-empty', _2127998, _2128004]->[empty]), (['if-unify-or-empty', _2257668, _2257674]->[empty]))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_defn_success(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], _1744460, ['if-unify-or-empty', _2127998, _2128004], [empty], (['if-unify-or-empty', _2257668, _2257674]->[empty]))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] ['if-unify-or-empty', _1401296, _1401296]=['if-unify-or-empty', _2127998, _2128004]
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] ['if-unify-or-empty', _1401296, _1401296]=['if-unify-or-empty', _1401296, _1401296]
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _1744460=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] [empty]=[empty]
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] ['if-unify-or-empty', _1401296, _1401296]\=@=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] ['if-unify-or-empty', _1401296, _1401296]\=@=[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _2257668, _2257674]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_2266124, _2266126), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _2257668, _2257674]->[empty])))))), _2266082, fbug((_2266082-->if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _2257668, _2257674]->[empty])))))))))), '$restore_trace'(_2266124, _2266126))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_2266124, _2266126))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _2257668, _2257674]->[empty])))))), _2266082, fbug((_2266082-->if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _2257668, _2257674]->[empty])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _2257668, _2257674]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] light_eval(=, _1607366, 495, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] light_eval(=, _1607366, 495, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] eval_defn_success(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty], ['if-unify-or-empty', _1401296, _1401296], [empty], (['if-unify-or-empty', _2257668, _2257674]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(317) [user] if_or_else((member((['if-unify-or-empty', _1401296, _1401296]->[empty]), [(['if-unify-or-empty', _2128034, _2128034]->unified), (['if-unify-or-empty', _1401296, _1401296]->[empty])]), copy_term((['if-unify-or-empty', _1401296, _1401296]->[empty]), (['if-unify-or-empty', _2257668, _2257674]->[empty])), eval_defn_success(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty], ['if-unify-or-empty', _1401296, _1401296], [empty], (['if-unify-or-empty', _2257668, _2257674]->[empty]))), eval_defn_failure(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] eval_defn_bodies(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty], [(['if-unify-or-empty', _2128034, _2128034]->unified), (['if-unify-or-empty', _1401296, _1401296]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] eval_defn_choose_candidates(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] ignore(notrace((\+[empty]\=_2019370, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_2278436, _2278438), once(user:(\+[empty]\=_2019370, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_2278436, _2278438))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_2278436, _2278438))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_2019370, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] ignore(user:notrace((\+[empty]\=_2019370, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] ignore((_2019240==1->ignore(\+ \+ (flag(eval_num, _2045016, _2045016+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _2045016, <--, [defn, [empty]]);indentq(4, _2045016, <--, [defn, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _2045016, _2045016+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _2045016, <--, [defn, [empty]]);indentq(4, _2045016, <--, [defn, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] _2019240==1
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] _2019240==1
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_2285012, _2285014), once(user:ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _2045016, _2045016+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _2045016, <--, [defn, [empty]]);indentq(4, _2045016, <--, [defn, retval([empty])])))))))), '$restore_trace'(_2285012, _2285014))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_2285012, _2285014))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _2045016, _2045016+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _2045016, <--, [defn, [empty]]);indentq(4, _2045016, <--, [defn, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] ignore(user:(_2019240==1->ignore(\+ \+ (flag(eval_num, _2045016, _2045016+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _2045016, <--, [defn, [empty]]);indentq(4, _2045016, <--, [defn, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _2045016, _2045016+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _2045016, <--, [defn, [empty]]);indentq(4, _2045016, <--, [defn, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _1607366), 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_defn_choose_candidates(=, _1607366), 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])), ignore(notrace((\+[empty]\=_2019370, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_2019240==1->ignore(\+ \+ (flag(eval_num, _2045016, _2045016+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _2045016, <--, [defn, [empty]]);indentq(4, _2045016, <--, [defn, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _2045016, _2045016+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _2045016, <--, [defn, [empty]]);indentq(4, _2045016, <--, [defn, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] trace_eval(eval_defn_choose_candidates(=, _1607366), defn, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] eval_maybe_defn(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else(eval_maybe_defn(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), eval_maybe_subst(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(309) [user] if_or_else(eval_maybe_host_function(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), if_or_else(eval_maybe_defn(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), eval_maybe_subst(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])))
   <span class="ansi1 ansi32"
>Exit: </span>(308) [user] if_or_else(eval_maybe_host_predicate(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), if_or_else(eval_maybe_host_function(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), if_or_else(eval_maybe_defn(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), eval_maybe_subst(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]))))
   <span class="ansi1 ansi32"
>Exit: </span>(307) [user] if_or_else(eval_maybe_python(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), if_or_else(eval_maybe_host_predicate(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), if_or_else(eval_maybe_host_function(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), if_or_else(eval_maybe_defn(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), eval_maybe_subst(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])))))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_70(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] check_returnval(=, _1607366, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] check_returnval(=, _1607366, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [user] eval_41(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] eval_40(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [empty]=_1621506
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] [empty]=[empty]
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] eval_20(=, _1607366, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] ignore(notrace((\+[empty]\=_1622662, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_2307604, _2307606), once(user:(\+[empty]\=_1622662, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_2307604, _2307606))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_2307604, _2307606))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_1622662, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [system] ignore(user:notrace((\+[empty]\=_1622662, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] ignore((_1622532==1->ignore(\+ \+ (flag(eval_num, _1648308, _1648308+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1648308, <--, [e, [empty]]);indentq(4, _1648308, <--, [e, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1648308, _1648308+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1648308, <--, [e, [empty]]);indentq(4, _1648308, <--, [e, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] _1622532==1
   <span class="ansi1 ansi31"
>Fail: </span>(305) [system] _1622532==1
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] setup_call_cleanup('$notrace'(_2314180, _2314182), once(user:ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1648308, _1648308+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1648308, <--, [e, [empty]]);indentq(4, _1648308, <--, [e, retval([empty])])))))))), '$restore_trace'(_2314180, _2314182))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] sig_atomic(system:'$notrace'(_2314180, _2314182))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1648308, _1648308+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1648308, <--, [e, [empty]]);indentq(4, _1648308, <--, [e, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [system] ignore(user:(_1622532==1->ignore(\+ \+ (flag(eval_num, _1648308, _1648308+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1648308, <--, [e, [empty]]);indentq(4, _1648308, <--, [e, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1648308, _1648308+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1648308, <--, [e, [empty]]);indentq(4, _1648308, <--, [e, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] call_cleanup(user:((call(eval_20(=, _1607366), 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_20(=, _1607366), 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])), ignore(notrace((\+[empty]\=_1622662, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_1622532==1->ignore(\+ \+ (flag(eval_num, _1648308, _1648308+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1648308, <--, [e, [empty]]);indentq(4, _1648308, <--, [e, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1648308, _1648308+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1648308, <--, [e, [empty]]);indentq(4, _1648308, <--, [e, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] trace_eval(eval_20(=, _1607366), e, 495, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_2322788, _2322790), once(user:self_eval0([empty])), '$restore_trace'(_2322788, _2322790))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_2322788, _2322790))
^  <span class="ansi1 ansi31"
>Fail: </span>(300) [user] self_eval([empty])
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] [empty]=@=['if-unify-or-empty', _1620552, _1620552]
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] eval_01(=, _1607366, 495, '&self', [empty], _2326540)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] [empty]\==[empty]
   <span class="ansi1 ansi32"
>Call: </span>(297) [lists] lists:member(_2328422-_2328424, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(298) [lists] lists:member_([], _2328422-_2328424, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(298) [lists] lists:member_([], 'Empty'-_1401314, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(297) [lists] lists:member('Empty'-_1401314, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi31"
>Fail: </span>(295) [user] eval_20(=, _1411028, 496, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1459770)
   <span class="ansi1 ansi32"
>Call: </span>(295) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(295) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] ignore((_1460796==1->ignore(\+ \+ (flag(eval_num, _1486572, _1486572+1), (retval(fail)\=@=retval(fail), nonvar(_1459770)->indentq(3, _1486572, <--, [e, _1459770]);indentq(3, _1486572, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1486572, _1486572+1), (retval(fail)\=@=retval(fail), nonvar(_1459770)->indentq(3, _1486572, <--, [e, _1459770]);indentq(3, _1486572, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] _1460796==1
   <span class="ansi1 ansi31"
>Fail: </span>(297) [system] _1460796==1
^  <span class="ansi1 ansi32"
>Call: </span>(298) [system] setup_call_cleanup('$notrace'(_2338650, _2338652), once(user:ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1486572, _1486572+1), (retval(fail)\=@=retval(fail), nonvar(_1459770)->indentq(3, _1486572, <--, [e, _1459770]);indentq(3, _1486572, <--, [e, retval(fail)])))))))), '$restore_trace'(_2338650, _2338652))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] sig_atomic(system:'$notrace'(_2338650, _2338652))
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1486572, _1486572+1), (retval(fail)\=@=retval(fail), nonvar(_1459770)->indentq(3, _1486572, <--, [e, _1459770]);indentq(3, _1486572, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(295) [system] ignore(user:(_1460796==1->ignore(\+ \+ (flag(eval_num, _1486572, _1486572+1), (retval(fail)\=@=retval(fail), nonvar(_1459770)->indentq(3, _1486572, <--, [e, _1459770]);indentq(3, _1486572, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1486572, _1486572+1), (retval(fail)\=@=retval(fail), nonvar(_1459770)->indentq(3, _1486572, <--, [e, _1459770]);indentq(3, _1486572, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(293) [system] call_cleanup(user:((call(eval_20(=, _1411028), 496, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1459770)*->nb_setarg(1, retval(fail), _1459770);fail, trace, call(eval_20(=, _1411028), 496, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1459770)), ignore(notrace((\+_1459770\=_1460926, nb_setarg(1, retval(fail), _1459770))))), user:ignore((_1460796==1->ignore(\+ \+ (flag(eval_num, _1486572, _1486572+1), (retval(fail)\=@=retval(fail), nonvar(_1459770)->indentq(3, _1486572, <--, [e, _1459770]);indentq(3, _1486572, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1486572, _1486572+1), (retval(fail)\=@=retval(fail), nonvar(_1459770)->indentq(3, _1486572, <--, [e, _1459770]);indentq(3, _1486572, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(292) [user] trace_eval(eval_20(=, _1411028), e, 496, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1459770)
^  <span class="ansi1 ansi31"
>Fail: </span>(289) [user] eval_args(=, _1411028, 497, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334)
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] call(eval, [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334)
   <span class="ansi1 ansi32"
>Call: </span>(287) [user] eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334)
^  <span class="ansi1 ansi32"
>Call: </span>(288) [user] current_self(_2347266)
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] nb_current(self_space, _2347266)
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(288) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(288) [user] eval('&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334)
   <span class="ansi1 ansi32"
>Call: </span>(289) [user] eval_H(500, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334)
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] fast_option_value(compile, save)
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] atom(compile)
   <span class="ansi1 ansi32"
>Exit: </span>(291) [system] atom(compile)
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] current_prolog_flag(compile, save)
   <span class="ansi1 ansi31"
>Fail: </span>(291) [system] current_prolog_flag(compile, save)
^  <span class="ansi1 ansi31"
>Fail: </span>(290) [user] fast_option_value(compile, save)
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] catch_metta_return(eval_args(=, _2360236, 500, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334), _1414334)
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] eval_args(=, _2360236, 500, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] var([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] setup_call_cleanup('$notrace'(_2363082, _2363084), once(user:self_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])), '$restore_trace'(_2363082, _2363084))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] sig_atomic(system:'$notrace'(_2363082, _2363084))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] setup_call_cleanup('$notrace'(_2364994, _2364996), once(user:nonvar(_1414334)), '$restore_trace'(_2364994, _2364996))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] sig_atomic(system:'$notrace'(_2364994, _2364996))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] setup_call_cleanup('$notrace'(_2366906, _2366908), once(user:nonvar(_1414334)), '$restore_trace'(_2366906, _2366908))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] sig_atomic(system:'$notrace'(_2366906, _2366908))
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] [['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] self_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] setup_call_cleanup('$notrace'(_2373446, _2373448), once(user:self_eval0([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])), '$restore_trace'(_2373446, _2373448))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [system] sig_atomic(system:'$notrace'(_2373446, _2373448))
^  <span class="ansi1 ansi31"
>Fail: </span>(293) [user] self_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] eval_00(=, _2360236, 500, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334)
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] self_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Call: </span>(296) [system] setup_call_cleanup('$notrace'(_2378150, _2378152), once(user:self_eval0([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])), '$restore_trace'(_2378150, _2378152))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [system] sig_atomic(system:'$notrace'(_2378150, _2378152))
^  <span class="ansi1 ansi31"
>Fail: </span>(294) [user] self_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] eval_01(=, _2360236, 500, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334)
   <span class="ansi1 ansi32"
>Call: </span>(295) [system] [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(295) [system] [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(297) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(295) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [system] setup_call_cleanup('$notrace'(_2387544, _2387546), once(user:(_2387520 is 500-1, copy_term([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _2387534))), '$restore_trace'(_2387544, _2387546))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [system] sig_atomic(system:'$notrace'(_2387544, _2387546))
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], [case, ['if-unify-or-empty', _2389466, _2389466], [['Empty', _2389496]]]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] trace_eval(eval_20(=, _2360236), e, 499, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _2390444)
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] must_det_ll((notrace((flag(eval_num, _2391410, _2391410+1), _2391428 is _2391410 mod 500, _2391446 is 99-499 mod 100, _2391470=_2391472, option_else('trace-length', _2391484, 500), option_else('trace-depth', _2391492, 30))), quietly(if_t((nop(stop_rtrace), _2391428>_2391484), (set_debug(eval, false), _2391548 is _2391484+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2391548])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2391600)))))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] once(user:(notrace((flag(eval_num, _2391410, _2391410+1), _2391428 is _2391410 mod 500, _2391446 is 99-499 mod 100, _2391470=_2391472, option_else('trace-length', _2391484, 500), option_else('trace-depth', _2391492, 30))), quietly(if_t((nop(stop_rtrace), _2391428>_2391484), (set_debug(eval, false), _2391548 is _2391484+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2391548])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2391600)))))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] setup_call_cleanup('$notrace'(_2393470, _2393472), once(user:(flag(eval_num, _2391410, _2391410+1), _2391428 is _2391410 mod 500, _2391446 is 99-499 mod 100, _2391470=_2391472, option_else('trace-length', _2391484, 500), option_else('trace-depth', _2391492, 30))), '$restore_trace'(_2393470, _2393472))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] sig_atomic(system:'$notrace'(_2393470, _2393472))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 4714, 4714+1), 214 is 4714 mod 500, 0 is 99-499 mod 100, _2391470=_2391470, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 214>500), (set_debug(eval, false), _2391548 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2391548])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 214>500), (set_debug(eval, false), _2391548 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2391548])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(299) [user] nop(notrace(no_repeats_var(_2391600)))
   <span class="ansi1 ansi32"
>Exit: </span>(299) [user] nop(notrace(no_repeats_var(_2391600)))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [system] once(user:(notrace((flag(eval_num, 4714, 4714+1), 214 is 4714 mod 500, 0 is 99-499 mod 100, _2391470=_2391470, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 214>500), (set_debug(eval, false), _2391548 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2391548])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2391600)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] must_det_ll(user:(notrace((flag(eval_num, 4714, 4714+1), 214 is 4714 mod 500, 0 is 99-499 mod 100, _2391470=_2391470, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 214>500), (set_debug(eval, false), _2391548 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2391548])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2391600)))))
   <span class="ansi1 ansi32"
>Call: </span>(296) [occurs] occurs:sub_term(_2402154, e)
   <span class="ansi1 ansi32"
>Exit: </span>(296) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(296) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(297) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(296) [occurs] occurs:sub_term(_2402154, e)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] _2408644=e
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] if_trace((eval;e), (_2391470=1, indentq(0, 214, -->, [e, [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(298) [system] setup_call_cleanup('$notrace'(_2411520, _2411522), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _2391470=1, indentq(0, 214, -->, [e, [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]]))), _2411478, fbug((_2411478-->if_trace((eval;e), (_2391470=1, indentq(0, 214, -->, [e, [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]])))))))), '$restore_trace'(_2411520, _2411522))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] sig_atomic(system:'$notrace'(_2411520, _2411522))
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _2391470=1, indentq(0, 214, -->, [e, [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]]))), _2411478, fbug((_2411478-->if_trace((eval;e), (_2391470=1, indentq(0, 214, -->, [e, [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] if_trace((eval;e), (_2391470=1, indentq(0, 214, -->, [e, [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]])))
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] _2415364=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] _2417226=(\+ \+ (flag(eval_num, _2417246, _2417246+1), (retval(fail)\=@=retval(fail), nonvar(_2390444)->indentq(0, _2417246, <--, [e, _2390444]);indentq(0, _2417246, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] (\+ \+ (flag(eval_num, _2417246, _2417246+1), (retval(fail)\=@=retval(fail), nonvar(_2390444)->indentq(0, _2417246, <--, [e, _2390444]);indentq(0, _2417246, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _2417246, _2417246+1), (retval(fail)\=@=retval(fail), nonvar(_2390444)->indentq(0, _2417246, <--, [e, _2390444]);indentq(0, _2417246, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] call_cleanup(((call(eval_20(=, _2360236), 499, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _2390444)*->nb_setarg(1, retval(fail), _2390444);fail, trace, call(eval_20(=, _2360236), 499, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _2390444)), ignore(notrace((\+_2390444\=_2391600, nb_setarg(1, retval(fail), _2390444))))), ignore((_2391470==1->ignore(\+ \+ (flag(eval_num, _2417246, _2417246+1), (retval(fail)\=@=retval(fail), nonvar(_2390444)->indentq(0, _2417246, <--, [e, _2390444]);indentq(0, _2417246, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _2417246, _2417246+1), (retval(fail)\=@=retval(fail), nonvar(_2390444)->indentq(0, _2417246, <--, [e, _2390444]);indentq(0, _2417246, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] eval_20(=, _2360236, 499, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _2390444)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] atom([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] no_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] self_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_2424018, _2424020), once(user:self_eval0([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])), '$restore_trace'(_2424018, _2424020))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_2424018, _2424020))
^  <span class="ansi1 ansi31"
>Fail: </span>(300) [user] self_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] atomic(case)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] atomic(case)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] is_sl(case)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] number(case)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] [['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] callable(case)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] callable(case)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] [['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] is_list([['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] is_list([['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] is_list(case)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] is_list([['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] is_list([['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] is_list([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] is_list([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] once(expand_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _2444426))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] expand_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _2444426)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] is_list([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] is_list([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] ground(case)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] ground(case)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] apply:maplist(expand_eval, [['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _2449998)
   <span class="ansi1 ansi32"
>Call: </span>(302) [apply] apply:maplist_([['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _2449998, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] expand_eval(['if-unify-or-empty', _1401296, _1401296], _2451878)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list(['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list(['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] apply:maplist(expand_eval, [_1401296, _1401296], _2456516)
   <span class="ansi1 ansi32"
>Call: </span>(305) [apply] apply:maplist_([_1401296, _1401296], _2456516, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] expand_eval(_1401296, _2458396)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list(_1401296)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _1401296=_2458396
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] _1401296=_1401296
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] expand_eval(_1401296, _1401296)
   <span class="ansi1 ansi32"
>Call: </span>(306) [apply] apply:maplist_([_1401296], _2458398, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] expand_eval(_1401296, _2463970)
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] is_list(_1401296)
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] _1401296=_2463970
   <span class="ansi1 ansi32"
>Exit: </span>(308) [system] _1401296=_1401296
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] expand_eval(_1401296, _1401296)
   <span class="ansi1 ansi32"
>Call: </span>(307) [apply] apply:maplist_([], _2463972, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(306) [apply] apply:maplist_([_1401296], [_1401296], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(305) [apply] apply:maplist_([_1401296, _1401296], [_1401296, _1401296], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [apply] apply:maplist(user:expand_eval, [_1401296, _1401296], [_1401296, _1401296])
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] expand_eval(['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(303) [apply] apply:maplist_([[['Empty', _1401314]]], _2451880, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] expand_eval([['Empty', _1401314]], _2475138)
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] is_list([['Empty', _1401314]])
   <span class="ansi1 ansi32"
>Exit: </span>(305) [system] is_list([['Empty', _1401314]])
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] ground(['Empty', _1401314])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] apply:maplist(expand_eval, [], _2477922)
   <span class="ansi1 ansi32"
>Call: </span>(306) [apply] apply:maplist_([], _2477922, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(306) [apply] apply:maplist_([], [], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [apply] apply:maplist(user:expand_eval, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] expand_eval([['Empty', _1401314]], [['Empty', _1401314]])
   <span class="ansi1 ansi32"
>Call: </span>(304) [apply] apply:maplist_([], _2475140, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [apply] apply:maplist_([[['Empty', _1401314]]], [[['Empty', _1401314]]], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [apply] apply:maplist_([['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], [['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [apply] apply:maplist(user:expand_eval, [['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], [['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] expand_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [system] once(user:expand_eval([case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]))
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]\==[case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]]
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] is_progn(case)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] is_space_op(case)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] must_det_ll([]==[])
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] once(user:([]==[]))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] []==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [system] once(user:([]==[]))
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] must_det_ll(user:([]==[]))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] into_case_list([['Empty', _1401314]], _2501166)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] is_list([['Empty', _1401314]])
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] is_list([['Empty', _1401314]])
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] into_case_list([['Empty', _1401314]], [['Empty', _1401314]])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] into_case_keys(1, [['Empty', _1401314]], _2504872)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] _2505824 is 1+1
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] 2 is 1+1
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] is_case(_2505814, ['Empty', _1401314], _2505816)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] is_case('Empty', ['Empty', _1401314], _1401314)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_1401314)))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_2510550, _2510552), once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_1401314))), _2510508, fbug((_2510508-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_1401314)))))))), '$restore_trace'(_2510550, _2510552))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_2510550, _2510552))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_1401314))), _2510508, fbug((_2510508-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_1401314)))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_1401314)))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] into_case_keys(2, [], _2505810)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] into_case_keys(2, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] into_case_keys(1, [['Empty', _1401314]], ['Empty'-_1401314])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] eval_case(=, _2360236, 499, '&self', ['if-unify-or-empty', _1401296, _1401296], ['Empty'-_1401314], _2390444)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _1401296, _1401296]))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_2519126, _2519128), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _1401296, _1401296]))), _2519084, fbug((_2519084-->if_trace(case, writeqln(case=['if-unify-or-empty', _1401296, _1401296]))))))), '$restore_trace'(_2519126, _2519128))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_2519126, _2519128))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _1401296, _1401296]))), _2519084, fbug((_2519084-->if_trace(case, writeqln(case=['if-unify-or-empty', _1401296, _1401296]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _1401296, _1401296]))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] eval_args(=, _2523048, 499, '&self', ['if-unify-or-empty', _1401296, _1401296], _2522970)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] var(['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_2524852, _2524854), once(user:self_eval(['if-unify-or-empty', _1401296, _1401296])), '$restore_trace'(_2524852, _2524854))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_2524852, _2524854))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_2526764, _2526766), once(user:nonvar(_2522970)), '$restore_trace'(_2526764, _2526766))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_2526764, _2526766))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_2528676, _2528678), once(user:nonvar(_2522970)), '$restore_trace'(_2528676, _2528678))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_2528676, _2528678))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] [_1401296, _1401296]==[]
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] self_eval(['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] setup_call_cleanup('$notrace'(_2535216, _2535218), once(user:self_eval0(['if-unify-or-empty', _1401296, _1401296])), '$restore_trace'(_2535216, _2535218))
^  <span class="ansi1 ansi32"
>Call: </span>(304) [system] sig_atomic(system:'$notrace'(_2535216, _2535218))
^  <span class="ansi1 ansi31"
>Fail: </span>(301) [user] self_eval(['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] eval_00(=, _2538040, 499, '&self', ['if-unify-or-empty', _1401296, _1401296], _2522970)
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] self_eval(['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(304) [system] setup_call_cleanup('$notrace'(_2539922, _2539924), once(user:self_eval0(['if-unify-or-empty', _1401296, _1401296])), '$restore_trace'(_2539922, _2539924))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] sig_atomic(system:'$notrace'(_2539922, _2539924))
^  <span class="ansi1 ansi31"
>Fail: </span>(302) [user] self_eval(['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] eval_01(=, _2538040, 499, '&self', ['if-unify-or-empty', _1401296, _1401296], _2522970)
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] ['if-unify-or-empty', _1401296, _1401296]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] ['if-unify-or-empty', _1401296, _1401296]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] if_t((499<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] 499<1
   <span class="ansi1 ansi31"
>Fail: </span>(305) [system] 499<1
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] if_t((499<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(304) [system] setup_call_cleanup('$notrace'(_2549316, _2549318), once(user:(_2549292 is 499-1, copy_term(['if-unify-or-empty', _1401296, _1401296], _2549306))), '$restore_trace'(_2549316, _2549318))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] sig_atomic(system:'$notrace'(_2549316, _2549318))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(498 is 499-1, copy_term(['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _2551226, _2551226]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] trace_eval(eval_20(=, _2538040), e, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2552180)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] must_det_ll((notrace((flag(eval_num, _2553146, _2553146+1), _2553164 is _2553146 mod 500, _2553182 is 99-498 mod 100, _2553206=_2553208, option_else('trace-length', _2553220, 500), option_else('trace-depth', _2553228, 30))), quietly(if_t((nop(stop_rtrace), _2553164>_2553220), (set_debug(eval, false), _2553284 is _2553220+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2553284])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2553336)))))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] once(user:(notrace((flag(eval_num, _2553146, _2553146+1), _2553164 is _2553146 mod 500, _2553182 is 99-498 mod 100, _2553206=_2553208, option_else('trace-length', _2553220, 500), option_else('trace-depth', _2553228, 30))), quietly(if_t((nop(stop_rtrace), _2553164>_2553220), (set_debug(eval, false), _2553284 is _2553220+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2553284])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2553336)))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_2555206, _2555208), once(user:(flag(eval_num, _2553146, _2553146+1), _2553164 is _2553146 mod 500, _2553182 is 99-498 mod 100, _2553206=_2553208, option_else('trace-length', _2553220, 500), option_else('trace-depth', _2553228, 30))), '$restore_trace'(_2555206, _2555208))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_2555206, _2555208))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 4715, 4715+1), 215 is 4715 mod 500, 1 is 99-498 mod 100, _2553206=_2553206, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 215>500), (set_debug(eval, false), _2553284 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2553284])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 215>500), (set_debug(eval, false), _2553284 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2553284])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(307) [user] nop(notrace(no_repeats_var(_2553336)))
   <span class="ansi1 ansi32"
>Exit: </span>(307) [user] nop(notrace(no_repeats_var(_2553336)))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] once(user:(notrace((flag(eval_num, 4715, 4715+1), 215 is 4715 mod 500, 1 is 99-498 mod 100, _2553206=_2553206, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 215>500), (set_debug(eval, false), _2553284 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2553284])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2553336)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] must_det_ll(user:(notrace((flag(eval_num, 4715, 4715+1), 215 is 4715 mod 500, 1 is 99-498 mod 100, _2553206=_2553206, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 215>500), (set_debug(eval, false), _2553284 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2553284])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2553336)))))
   <span class="ansi1 ansi32"
>Call: </span>(304) [occurs] occurs:sub_term(_2563890, e)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(304) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(305) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(304) [occurs] occurs:sub_term(_2563890, e)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _2570380=e
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] if_trace((eval;e), (_2553206=1, indentq(1, 215, -->, [e, ['if-unify-or-empty', _1401296, _1401296]])))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] setup_call_cleanup('$notrace'(_2573256, _2573258), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _2553206=1, indentq(1, 215, -->, [e, ['if-unify-or-empty', _1401296, _1401296]]))), _2573214, fbug((_2573214-->if_trace((eval;e), (_2553206=1, indentq(1, 215, -->, [e, ['if-unify-or-empty', _1401296, _1401296]])))))))), '$restore_trace'(_2573256, _2573258))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] sig_atomic(system:'$notrace'(_2573256, _2573258))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _2553206=1, indentq(1, 215, -->, [e, ['if-unify-or-empty', _1401296, _1401296]]))), _2573214, fbug((_2573214-->if_trace((eval;e), (_2553206=1, indentq(1, 215, -->, [e, ['if-unify-or-empty', _1401296, _1401296]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] if_trace((eval;e), (_2553206=1, indentq(1, 215, -->, [e, ['if-unify-or-empty', _1401296, _1401296]])))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _2577100=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _2578962=(\+ \+ (flag(eval_num, _2578982, _2578982+1), (retval(fail)\=@=retval(fail), nonvar(_2552180)->indentq(1, _2578982, <--, [e, _2552180]);indentq(1, _2578982, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] (\+ \+ (flag(eval_num, _2578982, _2578982+1), (retval(fail)\=@=retval(fail), nonvar(_2552180)->indentq(1, _2578982, <--, [e, _2552180]);indentq(1, _2578982, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _2578982, _2578982+1), (retval(fail)\=@=retval(fail), nonvar(_2552180)->indentq(1, _2578982, <--, [e, _2552180]);indentq(1, _2578982, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] call_cleanup(((call(eval_20(=, _2538040), 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2552180)*->nb_setarg(1, retval(fail), _2552180);fail, trace, call(eval_20(=, _2538040), 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2552180)), ignore(notrace((\+_2552180\=_2553336, nb_setarg(1, retval(fail), _2552180))))), ignore((_2553206==1->ignore(\+ \+ (flag(eval_num, _2578982, _2578982+1), (retval(fail)\=@=retval(fail), nonvar(_2552180)->indentq(1, _2578982, <--, [e, _2552180]);indentq(1, _2578982, <--, [e, retval(fail)]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _2578982, _2578982+1), (retval(fail)\=@=retval(fail), nonvar(_2552180)->indentq(1, _2578982, <--, [e, _2552180]);indentq(1, _2578982, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_20(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2552180)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] atom(['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] no_eval(['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] self_eval(['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_2585754, _2585756), once(user:self_eval0(['if-unify-or-empty', _1401296, _1401296])), '$restore_trace'(_2585754, _2585756))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_2585754, _2585756))
^  <span class="ansi1 ansi31"
>Fail: </span>(308) [user] self_eval(['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] atomic('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(308) [system] atomic('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] is_sl('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] number('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] [_1401296, _1401296]==[]
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _2595980==eval
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] [_1401296, _1401296]==[]
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list([_1401296, _1401296])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] is_list([_1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list([_1401296, _1401296])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] is_list([_1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list(['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] is_list(['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] once(expand_eval(['if-unify-or-empty', _1401296, _1401296], _2607102))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] expand_eval(['if-unify-or-empty', _1401296, _1401296], _2607102)
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] is_list(['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Exit: </span>(309) [system] is_list(['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(309) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] apply:maplist(expand_eval, [_1401296, _1401296], _2612674)
   <span class="ansi1 ansi32"
>Call: </span>(310) [apply] apply:maplist_([_1401296, _1401296], _2612674, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] expand_eval(_1401296, _2614554)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] is_list(_1401296)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] _1401296=_2614554
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] _1401296=_1401296
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] expand_eval(_1401296, _1401296)
   <span class="ansi1 ansi32"
>Call: </span>(311) [apply] apply:maplist_([_1401296], _2614556, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] expand_eval(_1401296, _2620128)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list(_1401296)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _1401296=_2620128
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] _1401296=_1401296
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] expand_eval(_1401296, _1401296)
   <span class="ansi1 ansi32"
>Call: </span>(312) [apply] apply:maplist_([], _2620130, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(312) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(311) [apply] apply:maplist_([_1401296], [_1401296], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [apply] apply:maplist_([_1401296, _1401296], [_1401296, _1401296], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [apply] apply:maplist(user:expand_eval, [_1401296, _1401296], [_1401296, _1401296])
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] expand_eval(['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [system] once(user:expand_eval(['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _1401296, _1401296]))
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] ['if-unify-or-empty', _1401296, _1401296]\==['if-unify-or-empty', _1401296, _1401296]
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] is_progn('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] is_space_op('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] arg(_2636006, v('catch!', 'throw!', 'number-of!', 'limit!', 'offset!', 'max-time!', 'findall!', 'setup-call-cleanup!', 'call-cleanup!', 'call-cleanup!', 'with-output-to!'), 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _2636864='if-unify-or-empty'
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] 'if-unify-or-empty'='if-unify-or-empty'
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _2638722)
^  <span class="ansi1 ansi31"
>Fail: </span>(307) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _2638722)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list(['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] is_list(['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] apply:maplist(self_eval, ['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(308) [apply] apply:maplist_(['if-unify-or-empty', _1401296, _1401296], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] self_eval('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] setup_call_cleanup('$notrace'(_2645240, _2645242), once(user:self_eval0('if-unify-or-empty')), '$restore_trace'(_2645240, _2645242))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] sig_atomic(system:'$notrace'(_2645240, _2645242))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0('if-unify-or-empty')), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] self_eval('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(309) [apply] apply:maplist_([_1401296, _1401296], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] self_eval(_1401296)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_2650866, _2650868), once(user:self_eval0(_1401296)), '$restore_trace'(_2650866, _2650868))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_2650866, _2650868))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_1401296)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] self_eval(_1401296)
   <span class="ansi1 ansi32"
>Call: </span>(310) [apply] apply:maplist_([_1401296], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] self_eval(_1401296)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] setup_call_cleanup('$notrace'(_2656492, _2656494), once(user:self_eval0(_1401296)), '$restore_trace'(_2656492, _2656494))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(system:'$notrace'(_2656492, _2656494))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_1401296)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] self_eval(_1401296)
   <span class="ansi1 ansi32"
>Call: </span>(311) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(311) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [apply] apply:maplist_([_1401296], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(309) [apply] apply:maplist_([_1401296, _1401296], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(308) [apply] apply:maplist_(['if-unify-or-empty', _1401296, _1401296], user:self_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [apply] apply:maplist(user:self_eval, ['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] ['if-unify-or-empty', _1401296, _1401296]=[_2665830|_2665832]
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] ['if-unify-or-empty', _1401296, _1401296]=['if-unify-or-empty', _1401296, _1401296]
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _2669538=do_more_defs(true)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] do_more_defs(true)=do_more_defs(true)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] clause(eval_21(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2552180), _2671414)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] 'if-unify-or-empty'==(/)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] 'if-unify-or-empty'== ===
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] 'if-unify-or-empty'== ====
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] eval_40(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] eval_selfless(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_selfless_0(['if-unify-or-empty', _1401296, _1401296], _2675134)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] is_assignment('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(311) [system] atom('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] eval_selfless_1(['if-unify-or-empty', _1401296, _1401296], _2675134)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] allow_clp
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] false_flag
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(313) [system] fail
^  <span class="ansi1 ansi31"
>Fail: </span>(312) [user] false_flag
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] eval_selfless_2(['if-unify-or-empty', _1401296, _1401296], _2675134)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] fake_notrace((ground(['if-unify-or-empty', _1401296, _1401296]), ['if-unify-or-empty', _1401296, _1401296]=[_2689038, _2689044, _2689050], atom(_2689038), catch_warn(current_op(_2689076, yfx, _2689038)), ['if-unify-or-empty', _1401296, _1401296]\=[_2689096], s2ps(['if-unify-or-empty', _1401296, _1401296], _2689104)))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] real_notrace(user:(ground(['if-unify-or-empty', _1401296, _1401296]), ['if-unify-or-empty', _1401296, _1401296]=[_2689038, _2689044, _2689050], atom(_2689038), catch_warn(current_op(_2689076, yfx, _2689038)), ['if-unify-or-empty', _1401296, _1401296]\=[_2689096], s2ps(['if-unify-or-empty', _1401296, _1401296], _2689104)))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] setup_call_cleanup('$notrace'(_2690962, _2690964), once(user:(ground(['if-unify-or-empty', _1401296, _1401296]), ['if-unify-or-empty', _1401296, _1401296]=[_2689038, _2689044, _2689050], atom(_2689038), catch_warn(current_op(_2689076, yfx, _2689038)), ['if-unify-or-empty', _1401296, _1401296]\=[_2689096], s2ps(['if-unify-or-empty', _1401296, _1401296], _2689104))), '$restore_trace'(_2690962, _2690964))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(user:'$notrace'(_2690962, _2690964))
^  <span class="ansi1 ansi31"
>Fail: </span>(312) [user] real_notrace(user:(ground(['if-unify-or-empty', _1401296, _1401296]), ['if-unify-or-empty', _1401296, _1401296]=[_2689038, _2689044, _2689050], atom(_2689038), catch_warn(current_op(_2689076, yfx, _2689038)), ['if-unify-or-empty', _1401296, _1401296]\=[_2689096], s2ps(['if-unify-or-empty', _1401296, _1401296], _2689104)))
^  <span class="ansi1 ansi31"
>Fail: </span>(311) [user] fake_notrace(user:(ground(['if-unify-or-empty', _1401296, _1401296]), ['if-unify-or-empty', _1401296, _1401296]=[_2689038, _2689044, _2689050], atom(_2689038), catch_warn(current_op(_2689076, yfx, _2689038)), ['if-unify-or-empty', _1401296, _1401296]\=[_2689096], s2ps(['if-unify-or-empty', _1401296, _1401296], _2689104)))
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] 'if-unify-or-empty'==(==)
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] 'if-unify-or-empty'==(==)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] eval_41(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_adjust_args(=, _2538040, _2703006, _2675134, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2703008)
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _2538040, _2703006, _2675134, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2703008)), eval_adjust_args1(=, _2538040, _2703006, _2675134, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2703008))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval_adjust_args2(=, _2538040, _2703006, _2675134, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2703008)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] apply:maplist(must_eval_args(=, _2709546, 498, '&self'), [_1401296, _1401296], _2709540)
   <span class="ansi1 ansi32"
>Call: </span>(314) [apply] apply:maplist_([_1401296, _1401296], _2709540, user:must_eval_args(=, _2709546, 498, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] must_eval_args(=, _2709546, 498, '&self', _1401296, _2711430)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] was_option_value(nodebug, _2721626)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] current_prolog_flag(nodebug, _2722556)
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] current_prolog_flag(nodebug, _2722556)
   <span class="ansi1 ansi32"
>Call: </span>(321) [$syspreds] prolog_load_context(nodebug, _2724414)
   <span class="ansi1 ansi31"
>Fail: </span>(321) [$syspreds] prolog_load_context(nodebug, _2724414)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] nb_current(nodebug, _2726272)
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] nb_current(nodebug, _2726272)
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [user] was_option_value(nodebug, _2721626)
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_2731856, _2731858), once(user:option_value0(nodebug, true)), '$restore_trace'(_2731856, _2731858))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_2731856, _2731858))
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(317) [prolog_debug] prolog_debug:debugging(metta(eval_args), _2750436)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [prolog_debug] prolog_debug:debugging(metta(eval_args), _2750436, _2751444)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_2755106, _2755108, _2755110), defined)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(320) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_2755106, _2755108, _2755110))
   <span class="ansi1 ansi32"
>Call: </span>(321) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_2755106, _2755108, _2755110))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] callable(debugging_logicmoo_setting(_2755106, _2755108, _2755110))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] callable(debugging_logicmoo_setting(_2755106, _2755108, _2755110))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(321) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_2755106, _2755108, _2755110))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_2755106, _2755108, _2755110))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_2755106, _2755108, _2755110), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _2750436, _2766234)
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(317) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_args(=, _2709546, 498, '&self', _1401296, _2711430)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] var(_1401296)
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] var(_1401296)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] nonvar(_2711430)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_2776492, _2776494), once(user:self_eval(_1401296)), '$restore_trace'(_2776492, _2776494))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_2776492, _2776494))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_1401296)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] _2711430=_1401296
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] _1401296=_1401296
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] eval_args(=, _2709546, 498, '&self', _1401296, _1401296)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] must_eval_args(=, _2709546, 498, '&self', _1401296, _1401296)
   <span class="ansi1 ansi32"
>Call: </span>(315) [apply] apply:maplist_([_1401296], _2711432, user:must_eval_args(=, _2709546, 498, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] must_eval_args(=, _2709546, 498, '&self', _1401296, _2784052)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] was_option_value(nodebug, _2794248)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] current_prolog_flag(nodebug, _2795178)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [system] current_prolog_flag(nodebug, _2795178)
   <span class="ansi1 ansi32"
>Call: </span>(322) [$syspreds] prolog_load_context(nodebug, _2797036)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [$syspreds] prolog_load_context(nodebug, _2797036)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] nb_current(nodebug, _2798894)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [system] nb_current(nodebug, _2798894)
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] was_option_value(nodebug, _2794248)
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_2804478, _2804480), once(user:option_value0(nodebug, true)), '$restore_trace'(_2804478, _2804480))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_2804478, _2804480))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(318) [prolog_debug] prolog_debug:debugging(metta(eval_args), _2823058)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [prolog_debug] prolog_debug:debugging(metta(eval_args), _2823058, _2824066)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_2827728, _2827730, _2827732), defined)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(321) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(321) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_2827728, _2827730, _2827732))
   <span class="ansi1 ansi32"
>Call: </span>(322) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_2827728, _2827730, _2827732))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] callable(debugging_logicmoo_setting(_2827728, _2827730, _2827732))
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] callable(debugging_logicmoo_setting(_2827728, _2827730, _2827732))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_2827728, _2827730, _2827732))
   <span class="ansi1 ansi32"
>Exit: </span>(321) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_2827728, _2827730, _2827732))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_2827728, _2827730, _2827732), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _2823058, _2838856)
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(318) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] eval_args(=, _2709546, 498, '&self', _1401296, _2784052)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] var(_1401296)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] var(_1401296)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nonvar(_2784052)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_2849114, _2849116), once(user:self_eval(_1401296)), '$restore_trace'(_2849114, _2849116))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_2849114, _2849116))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_1401296)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] _2784052=_1401296
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] _1401296=_1401296
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [user] eval_args(=, _2709546, 498, '&self', _1401296, _1401296)
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] must_eval_args(=, _2709546, 498, '&self', _1401296, _1401296)
   <span class="ansi1 ansi32"
>Call: </span>(316) [apply] apply:maplist_([], _2784054, user:must_eval_args(=, _2709546, 498, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(316) [apply] apply:maplist_([], [], user:must_eval_args(=, _2709546, 498, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(315) [apply] apply:maplist_([_1401296], [_1401296], user:must_eval_args(=, _2709546, 498, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(314) [apply] apply:maplist_([_1401296, _1401296], [_1401296, _1401296], user:must_eval_args(=, _2709546, 498, '&self'))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [apply] apply:maplist(user:must_eval_args(=, _2709546, 498, '&self'), [_1401296, _1401296], [_1401296, _1401296])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _2703006=_2675134
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] _2675134=_2675134
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] eval_adjust_args2(=, _2538040, _2675134, _2675134, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _1401296, _1401296])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _2538040, _2675134, _2675134, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _1401296, _1401296])), eval_adjust_args1(=, _2538040, _2675134, _2675134, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _1401296, _1401296]))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_adjust_args(=, _2538040, _2675134, _2675134, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] if_trace((e;args), (['if-unify-or-empty', _1401296, _1401296]\==['if-unify-or-empty', _1401296, _1401296]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _1401296, _1401296]->['if-unify-or-empty', _1401296, _1401296])));nop(indentq2(498, same(['if-unify-or-empty', _1401296, _1401296])))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] setup_call_cleanup('$notrace'(_2866116, _2866118), once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _1401296, _1401296]\==['if-unify-or-empty', _1401296, _1401296]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _1401296, _1401296]->['if-unify-or-empty', _1401296, _1401296])));nop(indentq2(498, same(['if-unify-or-empty', _1401296, _1401296])))))), _2866074, fbug((_2866074-->if_trace((e;args), (['if-unify-or-empty', _1401296, _1401296]\==['if-unify-or-empty', _1401296, _1401296]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _1401296, _1401296]->['if-unify-or-empty', _1401296, _1401296])));nop(indentq2(498, same(['if-unify-or-empty', _1401296, _1401296])))))))))), '$restore_trace'(_2866116, _2866118))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] sig_atomic(system:'$notrace'(_2866116, _2866118))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _1401296, _1401296]\==['if-unify-or-empty', _1401296, _1401296]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _1401296, _1401296]->['if-unify-or-empty', _1401296, _1401296])));nop(indentq2(498, same(['if-unify-or-empty', _1401296, _1401296])))))), _2866074, fbug((_2866074-->if_trace((e;args), (['if-unify-or-empty', _1401296, _1401296]\==['if-unify-or-empty', _1401296, _1401296]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _1401296, _1401296]->['if-unify-or-empty', _1401296, _1401296])));nop(indentq2(498, same(['if-unify-or-empty', _1401296, _1401296])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] if_trace((e;args), (['if-unify-or-empty', _1401296, _1401296]\==['if-unify-or-empty', _1401296, _1401296]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _1401296, _1401296]->['if-unify-or-empty', _1401296, _1401296])));nop(indentq2(498, same(['if-unify-or-empty', _1401296, _1401296])))))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_70(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134)
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] if_or_else(eval_maybe_python(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134), if_or_else(eval_maybe_host_predicate(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134), if_or_else(eval_maybe_host_function(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134), if_or_else(eval_maybe_defn(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134), eval_maybe_subst(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134)))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] eval_maybe_python(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134)
   <span class="ansi1 ansi32"
>Call: </span>(312) [user] metta_atom('&self', ['registered-python-function', _2872860, _2872866, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] typed_list('&self', _2873870, _2873792)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(313) [user] typed_list('&self', _2876650, _2873792)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] metta_atom_in_file('&self', ['registered-python-function', _2872860, _2872866, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] metta_atom_in_file('&self', ['registered-python-function', _2872860, _2872866, 'if-unify-or-empty'], _2879440, _2879442)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] loaded_into_kb('&self', _2880298)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] loaded_into_kb('&self', '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] once(user:asserted_metta_pred(_2882164, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] asserted_metta_pred(_2882164, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] asserted_metta_pred(_2882164, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] metta_atom_asserted('&self', ['registered-python-function', _2872860, _2872866, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] metta_atom_asserted_deduced('&self', ['registered-python-function', _2872860, _2872866, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] metta_atom('&corelib', ['registered-python-function', _2872860, _2872866, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] typed_list('&corelib', _2893348, _2893270)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] typed_list('&corelib', _2896128, _2893270)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] metta_atom_in_file('&corelib', ['registered-python-function', _2872860, _2872866, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] metta_atom_in_file('&corelib', ['registered-python-function', _2872860, _2872866, 'if-unify-or-empty'], _2898918, _2898920)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] loaded_into_kb('&corelib', _2899776)
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] loaded_into_kb('&corelib', '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] once(user:asserted_metta_pred(_2901642, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] asserted_metta_pred(_2901642, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] asserted_metta_pred(_2901642, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] loaded_into_kb('&corelib', '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] once(user:asserted_metta_pred(_2905368, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] asserted_metta_pred(_2905368, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] asserted_metta_pred(_2905368, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
   <span class="ansi1 ansi32"
>Call: </span>(314) [user] metta_atom_asserted('&corelib', ['registered-python-function', _2872860, _2872866, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] metta_atom_asserted_deduced('&corelib', ['registered-python-function', _2872860, _2872866, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(311) [user] if_or_else(eval_maybe_host_predicate(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134), if_or_else(eval_maybe_host_function(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134), if_or_else(eval_maybe_defn(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134), eval_maybe_subst(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134))))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval_maybe_host_predicate(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] once((is_system_pred('if-unify-or-empty'), length([_1401296, _1401296], _2917414), is_syspred('if-unify-or-empty', _2917414, _2917422)))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom_concat(_2921206, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom_concat(_2923986, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom_concat(_2926766, '-p', 'if-unify-or-empty')
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [user] if_or_else(eval_maybe_host_function(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134), if_or_else(eval_maybe_defn(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134), eval_maybe_subst(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134)))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval_maybe_host_function(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom_concat(_2935086, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom_concat(_2937866, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom_concat(_2940646, '-p', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] if_or_else(eval_maybe_defn(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134), eval_maybe_subst(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] eval_maybe_defn(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _1401296, _1401296])
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] trace_eval(eval_defn_choose_candidates(=, _2538040), defn, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] must_det_ll((notrace((flag(eval_num, _2949854, _2949854+1), _2949872 is _2949854 mod 500, _2949890 is 99-498 mod 100, _2949914=_2949916, option_else('trace-length', _2949928, 500), option_else('trace-depth', _2949936, 30))), quietly(if_t((nop(stop_rtrace), _2949872>_2949928), (set_debug(eval, false), _2949992 is _2949928+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2949992])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2950044)))))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] once(user:(notrace((flag(eval_num, _2949854, _2949854+1), _2949872 is _2949854 mod 500, _2949890 is 99-498 mod 100, _2949914=_2949916, option_else('trace-length', _2949928, 500), option_else('trace-depth', _2949936, 30))), quietly(if_t((nop(stop_rtrace), _2949872>_2949928), (set_debug(eval, false), _2949992 is _2949928+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2949992])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2950044)))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_2951914, _2951916), once(user:(flag(eval_num, _2949854, _2949854+1), _2949872 is _2949854 mod 500, _2949890 is 99-498 mod 100, _2949914=_2949916, option_else('trace-length', _2949928, 500), option_else('trace-depth', _2949936, 30))), '$restore_trace'(_2951914, _2951916))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_2951914, _2951916))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 4716, 4716+1), 216 is 4716 mod 500, 1 is 99-498 mod 100, _2949914=_2949914, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 216>500), (set_debug(eval, false), _2949992 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2949992])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 216>500), (set_debug(eval, false), _2949992 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2949992])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(319) [user] nop(notrace(no_repeats_var(_2950044)))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [user] nop(notrace(no_repeats_var(_2950044)))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [system] once(user:(notrace((flag(eval_num, 4716, 4716+1), 216 is 4716 mod 500, 1 is 99-498 mod 100, _2949914=_2949914, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 216>500), (set_debug(eval, false), _2949992 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2949992])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2950044)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] must_det_ll(user:(notrace((flag(eval_num, 4716, 4716+1), 216 is 4716 mod 500, 1 is 99-498 mod 100, _2949914=_2949914, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 216>500), (set_debug(eval, false), _2949992 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_2949992])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_2950044)))))
   <span class="ansi1 ansi32"
>Call: </span>(316) [occurs] occurs:sub_term(_2960598, defn)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [occurs] occurs:sub_term(defn, defn)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] defn\=defn
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] defn\=defn
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(316) [occurs] occurs:sub_term(_2960598, defn)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] _2967088=defn
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] defn=defn
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] if_trace((eval;defn), (_2949914=1, indentq(1, 216, -->, [defn, ['if-unify-or-empty', _1401296, _1401296]])))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_2969964, _2969966), once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _2949914=1, indentq(1, 216, -->, [defn, ['if-unify-or-empty', _1401296, _1401296]]))), _2969922, fbug((_2969922-->if_trace((eval;defn), (_2949914=1, indentq(1, 216, -->, [defn, ['if-unify-or-empty', _1401296, _1401296]])))))))), '$restore_trace'(_2969964, _2969966))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_2969964, _2969966))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _2949914=1, indentq(1, 216, -->, [defn, ['if-unify-or-empty', _1401296, _1401296]]))), _2969922, fbug((_2969922-->if_trace((eval;defn), (_2949914=1, indentq(1, 216, -->, [defn, ['if-unify-or-empty', _1401296, _1401296]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] if_trace((eval;defn), (_2949914=1, indentq(1, 216, -->, [defn, ['if-unify-or-empty', _1401296, _1401296]])))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] _2973808=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] _2975670=(\+ \+ (flag(eval_num, _2975690, _2975690+1), (retval(fail)\=@=retval(fail), nonvar(_2675134)->indentq(1, _2975690, <--, [defn, _2675134]);indentq(1, _2975690, <--, [defn, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] (\+ \+ (flag(eval_num, _2975690, _2975690+1), (retval(fail)\=@=retval(fail), nonvar(_2675134)->indentq(1, _2975690, <--, [defn, _2675134]);indentq(1, _2975690, <--, [defn, retval(fail)]))))=(\+ \+ (flag(eval_num, _2975690, _2975690+1), (retval(fail)\=@=retval(fail), nonvar(_2675134)->indentq(1, _2975690, <--, [defn, _2675134]);indentq(1, _2975690, <--, [defn, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] call_cleanup(((call(eval_defn_choose_candidates(=, _2538040), 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134)*->nb_setarg(1, retval(fail), _2675134);fail, trace, call(eval_defn_choose_candidates(=, _2538040), 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134)), ignore(notrace((\+_2675134\=_2950044, nb_setarg(1, retval(fail), _2675134))))), ignore((_2949914==1->ignore(\+ \+ (flag(eval_num, _2975690, _2975690+1), (retval(fail)\=@=retval(fail), nonvar(_2675134)->indentq(1, _2975690, <--, [defn, _2675134]);indentq(1, _2975690, <--, [defn, retval(fail)]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _2975690, _2975690+1), (retval(fail)\=@=retval(fail), nonvar(_2675134)->indentq(1, _2975690, <--, [defn, _2675134]);indentq(1, _2975690, <--, [defn, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] eval_defn_choose_candidates(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] findall((_2979680->_2979682), get_defn_expansions(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2979680, _2979682), _2979700)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [$bags] findall((_2979680->_2979682), user:get_defn_expansions(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2979680, _2979682), _2979700, [])
^  <span class="ansi1 ansi32"
>Call: </span>(321) [$bags] cleanup_bag(findall_loop((_2979680->_2979682), user:get_defn_expansions(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2979680, _2979682), _2979700, []), '$destroy_findall_bag')
   <span class="ansi1 ansi32"
>Call: </span>(322) [$bags] findall_loop((_2979680->_2979682), user:get_defn_expansions(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2979680, _2979682), _2979700, [])
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] get_defn_expansions(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2979680, _2979682)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] same_len_copy([_1401296, _1401296], _2984432)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] length([_1401296, _1401296], _2985362)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(_2985362)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] var(_2985362)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] []==[]
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _2985362=2
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] 2=2
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] length([_1401296, _1401296], 2)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] length(_2984432, 2)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(2)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] integer(2)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] integer(2)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _2984432==[]
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(_2984432)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] var(_2984432)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] length([_2999266, _2999272], 2)
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [user] same_len_copy([_1401296, _1401296], [_2999266, _2999272])
   <span class="ansi1 ansi32"
>Call: </span>(324) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _2999266, _2999272], _2979682)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] ignore((=)=(=))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] (=)=(=)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] (=)=(=)
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] ignore(user:((=)=(=)))
   <span class="ansi1 ansi32"
>Call: </span>(325) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _2999266, _2999272], _2979682]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _2999266, _2999272], _2979682]))
   <span class="ansi1 ansi32"
>Call: </span>(326) [user] metta_atom('&self', [=, ['if-unify-or-empty', _2999266, _2999272], _2979682])
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] typed_list('&self', _3007748, _3007670)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(328) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(327) [user] typed_list('&self', _3010528, _3007670)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _2999266, _2999272], _2979682])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _2999266, _2999272], _2979682], _3013318, _3013320)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] loaded_into_kb('&self', _3014176)
^  <span class="ansi1 ansi32"
>Exit: </span>(329) [user] loaded_into_kb('&self', '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] once(user:asserted_metta_pred(_3016042, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] asserted_metta_pred(_3016042, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(330) [user] asserted_metta_pred(_3016042, '/home/deb12user/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta')
   <span class="ansi1 ansi32"
>Call: </span>(327) [user] metta_atom_asserted('&self', [=, ['if-unify-or-empty', _2999266, _2999272], _2979682])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] metta_atom_asserted_deduced('&self', [=, ['if-unify-or-empty', _2999266, _2999272], _2979682])
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(327) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _2999266, _2999272], _2979682])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] typed_list('&corelib', _3027226, _3027148)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(329) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(328) [user] typed_list('&corelib', _3030006, _3027148)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _2999266, _2999272], _2979682])
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _2999266, _2999272], _2979682], _3032796, _3032798)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] loaded_into_kb('&corelib', _3033654)
^  <span class="ansi1 ansi32"
>Exit: </span>(330) [user] loaded_into_kb('&corelib', '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] once(user:asserted_metta_pred(_3035520, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] asserted_metta_pred(_3035520, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(331) [user] asserted_metta_pred(_3035520, '/home/deb12user/metta-wam/prolog/metta_lang/stdlib_mettalog.metta')
^  <span class="ansi1 ansi32"
>Exit: </span>(330) [user] loaded_into_kb('&corelib', '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] once(user:asserted_metta_pred(_3039246, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta'))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] asserted_metta_pred(_3039246, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
^  <span class="ansi1 ansi31"
>Fail: </span>(331) [user] asserted_metta_pred(_3039246, '/home/deb12user/metta-wam/prolog/metta_lang/corelib.metta')
   <span class="ansi1 ansi32"
>Call: </span>(328) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _2999266, _2999272], _2979682])
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] metta_atom_asserted_deduced('&corelib', [=, ['if-unify-or-empty', _2999266, _2999272], _2979682])
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] fail
   <span class="ansi1 ansi32"
>Exit: </span>(328) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _2999266, _2999266], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(327) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _2999266, _2999266], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(326) [user] metta_atom('&self', [=, ['if-unify-or-empty', _2999266, _2999266], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _2999266, _2999266], unified]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _2999266, _2999266], unified]))
   <span class="ansi1 ansi32"
>Exit: </span>(324) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _2999266, _2999266], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] get_defn_expansions(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _2999266, _2999266], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _2999266, _2999272], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(327) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _2999266, _2999272], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(326) [user] metta_atom('&self', [=, ['if-unify-or-empty', _2999266, _2999272], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _2999266, _2999272], [empty]]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _2999266, _2999272], [empty]]))
   <span class="ansi1 ansi32"
>Exit: </span>(324) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _2999266, _2999272], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] get_defn_expansions(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], ['if-unify-or-empty', _2999266, _2999272], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(322) [$bags] findall_loop((_2979680->_2979682), user:get_defn_expansions(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2979680, _2979682), [(['if-unify-or-empty', _3058708, _3058708]->unified), (['if-unify-or-empty', _3058672, _3058678]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [$bags] cleanup_bag('$bags':findall_loop((_2979680->_2979682), user:get_defn_expansions(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2979680, _2979682), [(['if-unify-or-empty', _3058708, _3058708]->unified), (['if-unify-or-empty', _3058672, _3058678]->[empty])], []), '$bags':'$destroy_findall_bag')
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [$bags] findall((_2979680->_2979682), user:get_defn_expansions(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2979680, _2979682), [(['if-unify-or-empty', _3058708, _3058708]->unified), (['if-unify-or-empty', _3058672, _3058678]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [$bags] findall((_2979680->_2979682), user:get_defn_expansions(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2979680, _2979682), [(['if-unify-or-empty', _3058708, _3058708]->unified), (['if-unify-or-empty', _3058672, _3058678]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_defn_bodies(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134, [(['if-unify-or-empty', _3058708, _3058708]->unified), (['if-unify-or-empty', _3058672, _3058678]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _3058708, _3058708]->unified), (['if-unify-or-empty', _3058672, _3058678]->[empty])]))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_3064412, _3064414), once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(498, '   '), [(['if-unify-or-empty', _3058708, _3058708]->unified), (['if-unify-or-empty', _3058672, _3058678]->[empty])]))), _3064370, fbug((_3064370-->if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _3058708, _3058708]->unified), (['if-unify-or-empty', _3058672, _3058678]->[empty])]))))))), '$restore_trace'(_3064412, _3064414))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_3064412, _3064414))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(498, '   '), [(['if-unify-or-empty', _3058708, _3058708]->unified), (['if-unify-or-empty', _3058672, _3058678]->[empty])]))), _3064370, fbug((_3064370-->if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _3058708, _3058708]->unified), (['if-unify-or-empty', _3058672, _3058678]->[empty])]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _3058708, _3058708]->unified), (['if-unify-or-empty', _3058672, _3058678]->[empty])]))
   <span class="ansi1 ansi32"
>Call: </span>(320) [user] if_or_else((member((_3068270->_3068272), [(['if-unify-or-empty', _3058708, _3058708]->unified), (['if-unify-or-empty', _3058672, _3058678]->[empty])]), copy_term((_3068270->_3068272), _3068284), eval_defn_success(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134, _3068270, _3068272, _3068284)), eval_defn_failure(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134))
   <span class="ansi1 ansi32"
>Call: </span>(322) [lists] lists:member((_3068270->_3068272), [(['if-unify-or-empty', _3058708, _3058708]->unified), (['if-unify-or-empty', _3058672, _3058678]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(323) [lists] lists:member_([(['if-unify-or-empty', _3058672, _3058678]->[empty])], (_3068270->_3068272), (['if-unify-or-empty', _3058708, _3058708]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(323) [lists] lists:member_([(['if-unify-or-empty', _3058672, _3058678]->[empty])], (['if-unify-or-empty', _3058708, _3058708]->unified), (['if-unify-or-empty', _3058708, _3058708]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [lists] lists:member((['if-unify-or-empty', _3058708, _3058708]->unified), [(['if-unify-or-empty', _3058708, _3058708]->unified), (['if-unify-or-empty', _3058672, _3058678]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] copy_term((['if-unify-or-empty', _3058708, _3058708]->unified), _3068284)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] copy_term((['if-unify-or-empty', _3058708, _3058708]->unified), (['if-unify-or-empty', _3073906, _3073906]->unified))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] eval_defn_success(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134, ['if-unify-or-empty', _3058708, _3058708], unified, (['if-unify-or-empty', _3073906, _3073906]->unified))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] ['if-unify-or-empty', _1401296, _1401296]=['if-unify-or-empty', _3058708, _3058708]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] ['if-unify-or-empty', _1401296, _1401296]=['if-unify-or-empty', _1401296, _1401296]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _2675134=unified
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] unified=unified
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] ['if-unify-or-empty', _1401296, _1401296]\=@=unified
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] ['if-unify-or-empty', _1401296, _1401296]\=@=unified
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _3073906, _3073906]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_3082362, _3082364), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _3073906, _3073906]->unified)))))), _3082320, fbug((_3082320-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _3073906, _3073906]->unified)))))))))), '$restore_trace'(_3082362, _3082364))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_3082362, _3082364))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _3073906, _3073906]->unified)))))), _3082320, fbug((_3082320-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _3073906, _3073906]->unified)))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _3073906, _3073906]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] light_eval(=, _2538040, 498, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] light_eval(=, _2538040, 498, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] eval_defn_success(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified, ['if-unify-or-empty', _1401296, _1401296], unified, (['if-unify-or-empty', _3073906, _3073906]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_or_else((member((['if-unify-or-empty', _1401296, _1401296]->unified), [(['if-unify-or-empty', _1401296, _1401296]->unified), (['if-unify-or-empty', _3058672, _3058678]->[empty])]), copy_term((['if-unify-or-empty', _1401296, _1401296]->unified), (['if-unify-or-empty', _3073906, _3073906]->unified)), eval_defn_success(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified, ['if-unify-or-empty', _1401296, _1401296], unified, (['if-unify-or-empty', _3073906, _3073906]->unified))), eval_defn_failure(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] eval_defn_bodies(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified, [(['if-unify-or-empty', _1401296, _1401296]->unified), (['if-unify-or-empty', _3058672, _3058678]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] eval_defn_choose_candidates(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] ignore(notrace((\+unified\=_2950044, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_3094666, _3094668), once(user:(\+unified\=_2950044, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_3094666, _3094668))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_3094666, _3094668))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_2950044, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] ignore(user:notrace((\+unified\=_2950044, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _2538040), 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_defn_choose_candidates(=, _2538040), 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)), ignore(notrace((\+unified\=_2950044, nb_setarg(1, retval(unified), unified))))), user:ignore((_2949914==1->ignore(\+ \+ (flag(eval_num, _2975690, _2975690+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _2975690, <--, [defn, unified]);indentq(1, _2975690, <--, [defn, retval(unified)]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _2975690, _2975690+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _2975690, <--, [defn, unified]);indentq(1, _2975690, <--, [defn, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] trace_eval(eval_defn_choose_candidates(=, _2538040), defn, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] eval_maybe_defn(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [user] if_or_else(eval_maybe_defn(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), eval_maybe_subst(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified))
   <span class="ansi1 ansi32"
>Exit: </span>(312) [user] if_or_else(eval_maybe_host_function(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), if_or_else(eval_maybe_defn(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), eval_maybe_subst(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)))
   <span class="ansi1 ansi32"
>Exit: </span>(311) [user] if_or_else(eval_maybe_host_predicate(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), if_or_else(eval_maybe_host_function(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), if_or_else(eval_maybe_defn(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), eval_maybe_subst(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified))))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else(eval_maybe_python(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), if_or_else(eval_maybe_host_predicate(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), if_or_else(eval_maybe_host_function(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), if_or_else(eval_maybe_defn(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified), eval_maybe_subst(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_70(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] check_returnval(=, _2538040, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] check_returnval(=, _2538040, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] eval_41(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] eval_40(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] unified=_2552180
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_20(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(306) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] ignore(notrace((\+unified\=_2553336, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_3117084, _3117086), once(user:(\+unified\=_2553336, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_3117084, _3117086))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_3117084, _3117086))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_2553336, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] ignore(user:notrace((\+unified\=_2553336, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [system] call_cleanup(user:((call(eval_20(=, _2538040), 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_20(=, _2538040), 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)), ignore(notrace((\+unified\=_2553336, nb_setarg(1, retval(unified), unified))))), user:ignore((_2553206==1->ignore(\+ \+ (flag(eval_num, _2578982, _2578982+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _2578982, <--, [e, unified]);indentq(1, _2578982, <--, [e, retval(unified)]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _2578982, _2578982+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _2578982, <--, [e, unified]);indentq(1, _2578982, <--, [e, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] trace_eval(eval_20(=, _2538040), e, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] self_eval(unified)
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_3125526, _3125528), once(user:self_eval0(unified)), '$restore_trace'(_3125526, _3125528))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_3125526, _3125528))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(unified)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] self_eval(unified)
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] _2522970=unified
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [user] eval_01(=, _2538040, 499, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] eval_00(=, _2538040, 499, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] eval_args(=, _2538040, 499, '&self', ['if-unify-or-empty', _1401296, _1401296], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_3134964, _3134966), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _3134922, fbug((_3134922-->if_trace(case, writeqln(switch=unified))))))), '$restore_trace'(_3134964, _3134966))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_3134964, _3134966))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _3134922, fbug((_3134922-->if_trace(case, writeqln(switch=unified))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] select_case(499, '&self', unified, ['Empty'-_1401314], _3138808)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] best_key(unified, ['Empty'-_1401314], _3138808)
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_3140684-_3138808, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(303) [lists] lists:member_([], _3140684-_3138808, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [lists] lists:member_([], 'Empty'-_1401314, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [lists] lists:member('Empty'-_1401314, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] unified='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_3145338-_3138808, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(303) [lists] lists:member_([], _3145338-_3138808, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [lists] lists:member_([], 'Empty'-_1401314, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [lists] lists:member('Empty'-_1401314, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] unified=='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_3149992-_3138808, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(303) [lists] lists:member_([], _3149992-_3138808, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [lists] lists:member_([], 'Empty'-_1401314, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [lists] lists:member('Empty'-_1401314, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] unified=@='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_3154646-_3138808, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(303) [lists] lists:member_([], _3154646-_3138808, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [lists] lists:member_([], 'Empty'-_1401314, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [lists] lists:member('Empty'-_1401314, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] unified='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] maybe_special_keys(499, '&self', ['Empty'-_1401314], _3159298)
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] eval_args(499, '&self', 'Empty', _3160244)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_args(=, _3161260, 499, '&self', 'Empty', _3160244)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] var('Empty')
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_3163064, _3163066), once(user:self_eval('Empty')), '$restore_trace'(_3163064, _3163066))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_3163064, _3163066))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval('Empty')), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _3160244='Empty'
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] 'Empty'='Empty'
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] eval_args(=, _3167878, 499, '&self', 'Empty', 'Empty')
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [user] eval_args(499, '&self', 'Empty', 'Empty')
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] 'Empty'\=@='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] maybe_special_keys(499, '&self', [], _3159298)
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [user] maybe_special_keys(499, '&self', [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] maybe_special_keys(499, '&self', ['Empty'-_1401314], [])
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] best_key(unified, [], _3138808)
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_3174352-_3138808, [])
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_3175286-_3138808, [])
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_3176220-_3138808, [])
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_3177154-_3138808, [])
   <span class="ansi1 ansi32"
>Call: </span>(301) [lists] lists:member(_3178088-_3138808, [])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member(_3179022-_3179024, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(301) [lists] lists:member_([], _3179022-_3179024, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [lists] lists:member_([], 'Empty'-_1401314, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member('Empty'-_1401314, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] 'Empty'=='%void%'
   <span class="ansi1 ansi32"
>Call: </span>(324) [lists] lists:member_([], (_3068270->_3068272), (['if-unify-or-empty', _3058672, _3058678]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(324) [lists] lists:member_([], (['if-unify-or-empty', _3058672, _3058678]->[empty]), (['if-unify-or-empty', _3058672, _3058678]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(323) [lists] lists:member_([(['if-unify-or-empty', _3058672, _3058678]->[empty])], (['if-unify-or-empty', _3058672, _3058678]->[empty]), (['if-unify-or-empty', _3058708, _3058708]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [lists] lists:member((['if-unify-or-empty', _3058672, _3058678]->[empty]), [(['if-unify-or-empty', _3058708, _3058708]->unified), (['if-unify-or-empty', _3058672, _3058678]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] copy_term((['if-unify-or-empty', _3058672, _3058678]->[empty]), _3068284)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] copy_term((['if-unify-or-empty', _3058672, _3058678]->[empty]), (['if-unify-or-empty', _3188342, _3188348]->[empty]))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] eval_defn_success(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], _2675134, ['if-unify-or-empty', _3058672, _3058678], [empty], (['if-unify-or-empty', _3188342, _3188348]->[empty]))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] ['if-unify-or-empty', _1401296, _1401296]=['if-unify-or-empty', _3058672, _3058678]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] ['if-unify-or-empty', _1401296, _1401296]=['if-unify-or-empty', _1401296, _1401296]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _2675134=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] [empty]=[empty]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] ['if-unify-or-empty', _1401296, _1401296]\=@=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] ['if-unify-or-empty', _1401296, _1401296]\=@=[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _3188342, _3188348]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_3196798, _3196800), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _3188342, _3188348]->[empty])))))), _3196756, fbug((_3196756-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _3188342, _3188348]->[empty])))))))))), '$restore_trace'(_3196798, _3196800))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_3196798, _3196800))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _3188342, _3188348]->[empty])))))), _3196756, fbug((_3196756-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _3188342, _3188348]->[empty])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _3188342, _3188348]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] light_eval(=, _2538040, 498, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] light_eval(=, _2538040, 498, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] eval_defn_success(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty], ['if-unify-or-empty', _1401296, _1401296], [empty], (['if-unify-or-empty', _3188342, _3188348]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_or_else((member((['if-unify-or-empty', _1401296, _1401296]->[empty]), [(['if-unify-or-empty', _3058708, _3058708]->unified), (['if-unify-or-empty', _1401296, _1401296]->[empty])]), copy_term((['if-unify-or-empty', _1401296, _1401296]->[empty]), (['if-unify-or-empty', _3188342, _3188348]->[empty])), eval_defn_success(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty], ['if-unify-or-empty', _1401296, _1401296], [empty], (['if-unify-or-empty', _3188342, _3188348]->[empty]))), eval_defn_failure(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] eval_defn_bodies(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty], [(['if-unify-or-empty', _3058708, _3058708]->unified), (['if-unify-or-empty', _1401296, _1401296]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] eval_defn_choose_candidates(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] ignore(notrace((\+[empty]\=_2950044, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_3209110, _3209112), once(user:(\+[empty]\=_2950044, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_3209110, _3209112))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_3209110, _3209112))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_2950044, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] ignore(user:notrace((\+[empty]\=_2950044, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] ignore((_2949914==1->ignore(\+ \+ (flag(eval_num, _2975690, _2975690+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _2975690, <--, [defn, [empty]]);indentq(1, _2975690, <--, [defn, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _2975690, _2975690+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _2975690, <--, [defn, [empty]]);indentq(1, _2975690, <--, [defn, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _2949914==1
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] _2949914==1
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_3215686, _3215688), once(user:ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _2975690, _2975690+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _2975690, <--, [defn, [empty]]);indentq(1, _2975690, <--, [defn, retval([empty])])))))))), '$restore_trace'(_3215686, _3215688))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_3215686, _3215688))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _2975690, _2975690+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _2975690, <--, [defn, [empty]]);indentq(1, _2975690, <--, [defn, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] ignore(user:(_2949914==1->ignore(\+ \+ (flag(eval_num, _2975690, _2975690+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _2975690, <--, [defn, [empty]]);indentq(1, _2975690, <--, [defn, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _2975690, _2975690+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _2975690, <--, [defn, [empty]]);indentq(1, _2975690, <--, [defn, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _2538040), 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_defn_choose_candidates(=, _2538040), 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])), ignore(notrace((\+[empty]\=_2950044, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_2949914==1->ignore(\+ \+ (flag(eval_num, _2975690, _2975690+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _2975690, <--, [defn, [empty]]);indentq(1, _2975690, <--, [defn, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _2975690, _2975690+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _2975690, <--, [defn, [empty]]);indentq(1, _2975690, <--, [defn, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] trace_eval(eval_defn_choose_candidates(=, _2538040), defn, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] eval_maybe_defn(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [user] if_or_else(eval_maybe_defn(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), eval_maybe_subst(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(312) [user] if_or_else(eval_maybe_host_function(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), if_or_else(eval_maybe_defn(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), eval_maybe_subst(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])))
   <span class="ansi1 ansi32"
>Exit: </span>(311) [user] if_or_else(eval_maybe_host_predicate(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), if_or_else(eval_maybe_host_function(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), if_or_else(eval_maybe_defn(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), eval_maybe_subst(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]))))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else(eval_maybe_python(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), if_or_else(eval_maybe_host_predicate(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), if_or_else(eval_maybe_host_function(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), if_or_else(eval_maybe_defn(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty]), eval_maybe_subst(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])))))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_70(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] check_returnval(=, _2538040, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] check_returnval(=, _2538040, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] eval_41(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] eval_40(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] [empty]=_2552180
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] [empty]=[empty]
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_20(=, _2538040, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(306) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] ignore(notrace((\+[empty]\=_2553336, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_3238278, _3238280), once(user:(\+[empty]\=_2553336, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_3238278, _3238280))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_3238278, _3238280))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_2553336, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] ignore(user:notrace((\+[empty]\=_2553336, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] ignore((_2553206==1->ignore(\+ \+ (flag(eval_num, _2578982, _2578982+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _2578982, <--, [e, [empty]]);indentq(1, _2578982, <--, [e, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _2578982, _2578982+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _2578982, <--, [e, [empty]]);indentq(1, _2578982, <--, [e, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] _2553206==1
   <span class="ansi1 ansi31"
>Fail: </span>(308) [system] _2553206==1
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_3244854, _3244856), once(user:ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _2578982, _2578982+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _2578982, <--, [e, [empty]]);indentq(1, _2578982, <--, [e, retval([empty])])))))))), '$restore_trace'(_3244854, _3244856))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_3244854, _3244856))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _2578982, _2578982+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _2578982, <--, [e, [empty]]);indentq(1, _2578982, <--, [e, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] ignore(user:(_2553206==1->ignore(\+ \+ (flag(eval_num, _2578982, _2578982+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _2578982, <--, [e, [empty]]);indentq(1, _2578982, <--, [e, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _2578982, _2578982+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _2578982, <--, [e, [empty]]);indentq(1, _2578982, <--, [e, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [system] call_cleanup(user:((call(eval_20(=, _2538040), 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_20(=, _2538040), 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])), ignore(notrace((\+[empty]\=_2553336, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_2553206==1->ignore(\+ \+ (flag(eval_num, _2578982, _2578982+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _2578982, <--, [e, [empty]]);indentq(1, _2578982, <--, [e, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _2578982, _2578982+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _2578982, <--, [e, [empty]]);indentq(1, _2578982, <--, [e, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] trace_eval(eval_20(=, _2538040), e, 498, '&self', ['if-unify-or-empty', _1401296, _1401296], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_3253462, _3253464), once(user:self_eval0([empty])), '$restore_trace'(_3253462, _3253464))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_3253462, _3253464))
^  <span class="ansi1 ansi31"
>Fail: </span>(303) [user] self_eval([empty])
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] [empty]=@=['if-unify-or-empty', _2551226, _2551226]
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_01(=, _2538040, 498, '&self', [empty], _3257214)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [empty]\==[empty]
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member(_3259096-_3259098, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(301) [lists] lists:member_([], _3259096-_3259098, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [lists] lists:member_([], 'Empty'-_1401314, 'Empty'-_1401314)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member('Empty'-_1401314, ['Empty'-_1401314])
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi31"
>Fail: </span>(298) [user] eval_20(=, _2360236, 499, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _2390444)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(298) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] ignore((_2391470==1->ignore(\+ \+ (flag(eval_num, _2417246, _2417246+1), (retval(fail)\=@=retval(fail), nonvar(_2390444)->indentq(0, _2417246, <--, [e, _2390444]);indentq(0, _2417246, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _2417246, _2417246+1), (retval(fail)\=@=retval(fail), nonvar(_2390444)->indentq(0, _2417246, <--, [e, _2390444]);indentq(0, _2417246, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] _2391470==1
   <span class="ansi1 ansi31"
>Fail: </span>(300) [system] _2391470==1
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] setup_call_cleanup('$notrace'(_3269324, _3269326), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _2417246, _2417246+1), (retval(fail)\=@=retval(fail), nonvar(_2390444)->indentq(0, _2417246, <--, [e, _2390444]);indentq(0, _2417246, <--, [e, retval(fail)])))))))), '$restore_trace'(_3269324, _3269326))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] sig_atomic(system:'$notrace'(_3269324, _3269326))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _2417246, _2417246+1), (retval(fail)\=@=retval(fail), nonvar(_2390444)->indentq(0, _2417246, <--, [e, _2390444]);indentq(0, _2417246, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [system] ignore(user:(_2391470==1->ignore(\+ \+ (flag(eval_num, _2417246, _2417246+1), (retval(fail)\=@=retval(fail), nonvar(_2390444)->indentq(0, _2417246, <--, [e, _2390444]);indentq(0, _2417246, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _2417246, _2417246+1), (retval(fail)\=@=retval(fail), nonvar(_2390444)->indentq(0, _2417246, <--, [e, _2390444]);indentq(0, _2417246, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(296) [system] call_cleanup(user:((call(eval_20(=, _2360236), 499, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _2390444)*->nb_setarg(1, retval(fail), _2390444);fail, trace, call(eval_20(=, _2360236), 499, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _2390444)), ignore(notrace((\+_2390444\=_2391600, nb_setarg(1, retval(fail), _2390444))))), user:ignore((_2391470==1->ignore(\+ \+ (flag(eval_num, _2417246, _2417246+1), (retval(fail)\=@=retval(fail), nonvar(_2390444)->indentq(0, _2417246, <--, [e, _2390444]);indentq(0, _2417246, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _2417246, _2417246+1), (retval(fail)\=@=retval(fail), nonvar(_2390444)->indentq(0, _2417246, <--, [e, _2390444]);indentq(0, _2417246, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(295) [user] trace_eval(eval_20(=, _2360236), e, 499, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _2390444)
^  <span class="ansi1 ansi31"
>Fail: </span>(292) [user] eval_args(=, _2360236, 500, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334)
^  <span class="ansi1 ansi31"
>Fail: </span>(283) [system] call(user:once, user:if_or_else(eval(=, _1411028, 497, '&self', [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334), call(eval, [case, ['if-unify-or-empty', _1401296, _1401296], [['Empty', _1401314]]], _1414334)))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(285) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(287) [system] setup_call_cleanup('$notrace'(_3279818, _3279820), once(rtrace:retract(t_l:tracer_reset(_3279808))), '$restore_trace'(_3279818, _3279820))
^  <span class="ansi1 ansi32"
>Call: </span>(288) [system] sig_atomic(system:'$notrace'(_3279818, _3279820))
^  <span class="ansi1 ansi32"
>Exit: </span>(287) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(287) [rtrace] tAt(false, 271, 271, false)

#(failed #( : user once ) #( : user #(if_or_else #(eval = $10000 497 &self (empty) $10001) #(call eval (empty) $10001)) ))


#(on_mettalog_error #(failed #( : user once ) #( : user #(if_or_else #(eval = $10000 497 &self (empty) $10001) #(call eval (empty) $10001)) )))

^  <span class="ansi1 ansi32"
>Call: </span>(282) [user] call(user:once, user:if_or_else(eval(=, _738602, 497, '&self', [empty], _738616), call(eval, [empty], _738616)))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] once(user:if_or_else(eval(=, _738602, 497, '&self', [empty], _738616), call(eval, [empty], _738616)))
   <span class="ansi1 ansi32"
>Call: </span>(284) [user] if_or_else(eval(=, _738602, 497, '&self', [empty], _738616), call(eval, [empty], _738616))
^  <span class="ansi1 ansi32"
>Call: </span>(285) [user] eval(=, _738602, 497, '&self', [empty], _738616)
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] catch_metta_return(eval_args(=, _738602, 497, '&self', [empty], _738616), _738616)
^  <span class="ansi1 ansi32"
>Call: </span>(288) [user] eval_args(=, _738602, 497, '&self', [empty], _738616)
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] var([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(290) [system] setup_call_cleanup('$notrace'(_746234, _746236), once(user:self_eval([empty])), '$restore_trace'(_746234, _746236))
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] sig_atomic(system:'$notrace'(_746234, _746236))
^  <span class="ansi1 ansi32"
>Call: </span>(290) [system] setup_call_cleanup('$notrace'(_748146, _748148), once(user:nonvar(_738616)), '$restore_trace'(_748146, _748148))
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] sig_atomic(system:'$notrace'(_748146, _748148))
^  <span class="ansi1 ansi32"
>Call: </span>(290) [system] setup_call_cleanup('$notrace'(_750058, _750060), once(user:nonvar(_738616)), '$restore_trace'(_750058, _750060))
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] sig_atomic(system:'$notrace'(_750058, _750060))
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] []==[]
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] number(empty)
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(289) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] setup_call_cleanup('$notrace'(_758450, _758452), once(user:self_eval0([empty])), '$restore_trace'(_758450, _758452))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] sig_atomic(system:'$notrace'(_758450, _758452))
^  <span class="ansi1 ansi31"
>Fail: </span>(289) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(289) [user] eval_00(=, _738602, 497, '&self', [empty], _738616)
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] setup_call_cleanup('$notrace'(_763154, _763156), once(user:self_eval0([empty])), '$restore_trace'(_763154, _763156))
^  <span class="ansi1 ansi32"
>Call: </span>(293) [system] sig_atomic(system:'$notrace'(_763154, _763156))
^  <span class="ansi1 ansi31"
>Fail: </span>(290) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] eval_01(=, _738602, 497, '&self', [empty], _738616)
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] [empty]\==[empty]
^  <span class="ansi1 ansi31"
>Fail: </span>(288) [user] eval_args(=, _738602, 497, '&self', [empty], _738616)
^  <span class="ansi1 ansi32"
>Call: </span>(285) [user] call(eval, [empty], _738616)
   <span class="ansi1 ansi32"
>Call: </span>(286) [user] eval([empty], _738616)
^  <span class="ansi1 ansi32"
>Call: </span>(287) [user] current_self(_770660)
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] nb_current(self_space, _770660)
   <span class="ansi1 ansi32"
>Exit: </span>(288) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(288) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(288) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(287) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(287) [user] eval('&self', [empty], _738616)
   <span class="ansi1 ansi32"
>Call: </span>(288) [user] eval_H(500, '&self', [empty], _738616)
^  <span class="ansi1 ansi32"
>Call: </span>(289) [user] fast_option_value(compile, save)
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] atom(compile)
   <span class="ansi1 ansi32"
>Exit: </span>(290) [system] atom(compile)
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] current_prolog_flag(compile, save)
   <span class="ansi1 ansi31"
>Fail: </span>(290) [system] current_prolog_flag(compile, save)
^  <span class="ansi1 ansi31"
>Fail: </span>(289) [user] fast_option_value(compile, save)
^  <span class="ansi1 ansi32"
>Call: </span>(289) [user] catch_metta_return(eval_args(=, _783630, 500, '&self', [empty], _738616), _738616)
^  <span class="ansi1 ansi32"
>Call: </span>(291) [user] eval_args(=, _783630, 500, '&self', [empty], _738616)
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] var([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(293) [system] setup_call_cleanup('$notrace'(_786476, _786478), once(user:self_eval([empty])), '$restore_trace'(_786476, _786478))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] sig_atomic(system:'$notrace'(_786476, _786478))
^  <span class="ansi1 ansi32"
>Call: </span>(293) [system] setup_call_cleanup('$notrace'(_788388, _788390), once(user:nonvar(_738616)), '$restore_trace'(_788388, _788390))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] sig_atomic(system:'$notrace'(_788388, _788390))
^  <span class="ansi1 ansi32"
>Call: </span>(293) [system] setup_call_cleanup('$notrace'(_790300, _790302), once(user:nonvar(_738616)), '$restore_trace'(_790300, _790302))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] sig_atomic(system:'$notrace'(_790300, _790302))
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(292) [system] []==[]
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] number(empty)
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(292) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] setup_call_cleanup('$notrace'(_798692, _798694), once(user:self_eval0([empty])), '$restore_trace'(_798692, _798694))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] sig_atomic(system:'$notrace'(_798692, _798694))
^  <span class="ansi1 ansi31"
>Fail: </span>(292) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] eval_00(=, _783630, 500, '&self', [empty], _738616)
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] setup_call_cleanup('$notrace'(_803396, _803398), once(user:self_eval0([empty])), '$restore_trace'(_803396, _803398))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [system] sig_atomic(system:'$notrace'(_803396, _803398))
^  <span class="ansi1 ansi31"
>Fail: </span>(293) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] eval_01(=, _783630, 500, '&self', [empty], _738616)
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] [empty]\==[empty]
^  <span class="ansi1 ansi31"
>Fail: </span>(291) [user] eval_args(=, _783630, 500, '&self', [empty], _738616)
^  <span class="ansi1 ansi31"
>Fail: </span>(282) [system] call(user:once, user:if_or_else(eval(=, _738602, 497, '&self', [empty], _738616), call(eval, [empty], _738616)))
^  <span class="ansi1 ansi32"
>Call: </span>(282) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(284) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(284) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(286) [system] setup_call_cleanup('$notrace'(_812780, _812782), once(rtrace:retract(t_l:tracer_reset(_812770))), '$restore_trace'(_812780, _812782))
^  <span class="ansi1 ansi32"
>Call: </span>(287) [system] sig_atomic(system:'$notrace'(_812780, _812782))
^  <span class="ansi1 ansi32"
>Exit: </span>(286) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [rtrace] tAt(false, 271, 271, false)
; 
; EVAL TEST
; took 0.852 secs. (852.23 milliseconds) 

!(assertEqual (match &self $1 $1) (get-atoms &self))


Script done on 2024-12-11 17:10:05-08:00 [COMMAND_EXIT_CODE="143"]

</pre>
</body>

</html>
\033[1;33mCompleted (EXITCODE=143) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat/' --timeout=40 --html --repl=false  --test "tests/baseline_compat/hyperon-mettalog_sanity/00_lang_case.metta" --halt=true\033[0m
