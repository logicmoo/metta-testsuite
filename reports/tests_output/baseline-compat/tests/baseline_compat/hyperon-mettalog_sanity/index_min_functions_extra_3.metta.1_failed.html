<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi36 { color: #00aaaa; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-12-03 11:20:48+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;           #(set_option_value compat false)

P;HTML|
;           #(set_option_value compatio false)

P;HTML|
;           #(set_option_value src_indents false)

P;HTML|
;         #(set_option_value devel false)

P;HTML|
;         #(set_option_value stack-max 500)

P;HTML|
;         #(set_option_value limit inf)

P;HTML|
;         #(set_option_value initial-result-count 10)

P;HTML|
;         #(set_option_value answer-format show)

P;HTML|
;         #(set_option_value repeats true)

P;HTML|
;         #(set_option_value time true)

P;HTML|
;         #(set_option_value synth-unit-tests false)

P;HTML|
;         #(set_option_value optimize true)

P;HTML|
;         #(set_option_value transpiler silent)

P;HTML|
;          #(set_debug transpiler false)

P;HTML|
;         #(set_option_value compile false)

P;HTML|
;         #(set_option_value tabling auto)

P;HTML|
;         #(set_option_value log false)

P;HTML|
;         #(set_option_value output ./)

P;HTML|
;         #(set_option_value exeout ./Sav.gitlab.MeTTaLog)

P;HTML|
;         #(set_option_value halt false)

P;HTML|
;         #(set_option_value trace-length 500)

P;HTML|
;         #(set_option_value trace-on-overtime 4.0)

P;HTML|
;          #(set_debug overtime 4.0)

P;HTML|
;         #(set_option_value trace-on-overflow 1000)

P;HTML|
;          #(set_debug overflow 1000)

P;HTML|
;         #(set_option_value trace-on-eval false)

P;HTML|
;          #(set_debug eval false)

P;HTML|
;         #(set_option_value trace-on-load silent)

P;HTML|
;          #(set_debug load silent)

P;HTML|
;          #(set_debug trace-on-load false)

P;HTML|
;         #(set_option_value trace-on-exec false)

P;HTML|
;          #(set_debug exec false)

P;HTML|
;         #(set_option_value trace-on-error non-type)

P;HTML|
;          #(set_debug error non-type)

P;HTML|
;         #(set_option_value trace-on-fail false)

P;HTML|
;          #(set_debug fail false)

P;HTML|
;         #(set_option_value trace-on-test true)

P;HTML|
;          #(set_debug test true)

P;HTML|
;         #(set_option_value repl-on-error true)

P;HTML|
;         #(set_option_value repl-on-fail false)

P;HTML|
;         #(set_option_value exit-on-fail false)

P;HTML|
;         #(set_option_value repl auto)

P;HTML|
;         #(set_option_value prolog false)

P;HTML|
;         #(set_option_value exec noskip)

P;HTML|
;         #(set_option_value maximum-result-count inf)

P;HTML|
;         #(set_option_value html false)

P;HTML|
;         #(set_option_value python true)

P;HTML|
;         #(set_option_value trace-on-test false)

P;HTML|
;         #(set_debug test false)

P;HTML|
;         #(set_option_value trace-on-fail false)

P;HTML|
;         #(set_debug fail false)

P;HTML|
;         #(set_option_value load show)

P;HTML|
;         #(set_option_value test false)
<span class="ansi32"
>
% 23,950 inferences, 0.005 CPU in 0.005 seconds (100% CPU, 4769501 Lips)
</span>P;HTML|
;          #(is_cmd_option prescan halt --halt=true true)
P;HTML|
;          #(set_option_value halt true)
P;HTML|
;          #(is_cmd_option prescan stdin --stdin=tty tty)
P;HTML|
;           #(set_option_value stdin tty)
P;HTML|
;          #(is_cmd_option prescan stdout --stdout=tty tty)
P;HTML|
;           #(set_option_value stdout tty)
P;HTML|
;          #(is_cmd_option prescan stderr --stderr=tty tty)
P;HTML|
;           #(set_option_value stderr tty)
P;HTML|
;          #(set_option_value compat false)
P;HTML|
;          #(set_option_value compatio false)
P;HTML|
;          #(set_option_value src_indents false)
P;HTML|
;          #(set_option_value devel false)
P;HTML|
;          #(set_option_value stack-max 500)
P;HTML|
;          #(set_option_value limit inf)
P;HTML|
;          #(set_option_value initial-result-count 10)
P;HTML|
;          #(set_option_value answer-format show)
P;HTML|
;          #(set_option_value repeats true)
P;HTML|
;          #(set_option_value time true)
P;HTML|
;          #(set_option_value synth-unit-tests false)
P;HTML|
;          #(set_option_value optimize true)
P;HTML|
;          #(set_option_value transpiler silent)
P;HTML|
;          #(set_debug transpiler false)
P;HTML|
;          #(set_option_value compile false)
P;HTML|
;          #(set_option_value tabling auto)
P;HTML|
;          #(set_option_value log false)
P;HTML|
;          #(set_option_value output ./)
P;HTML|
;          #(set_option_value exeout ./Sav.gitlab.MeTTaLog)
P;HTML|
;          #(set_option_value halt false)
P;HTML|
;          #(set_option_value trace-length 500)
P;HTML|
;          #(set_option_value trace-on-overtime 4.0)
P;HTML|
;          #(set_debug overtime 4.0)
P;HTML|
;          #(set_option_value trace-on-overflow 1000)
P;HTML|
;          #(set_debug overflow 1000)
P;HTML|
;          #(set_option_value trace-on-eval false)
P;HTML|
;          #(set_debug eval false)
P;HTML|
;          #(set_option_value trace-on-load silent)
P;HTML|
;          #(set_debug load silent)
P;HTML|
;          #(set_debug trace-on-load false)
P;HTML|
;          #(set_option_value trace-on-exec false)
P;HTML|
;          #(set_debug exec false)
P;HTML|
;          #(set_option_value trace-on-error non-type)
P;HTML|
;          #(set_debug error non-type)
P;HTML|
;          #(set_option_value trace-on-fail false)
P;HTML|
;          #(set_debug fail false)
P;HTML|
;          #(set_option_value trace-on-test true)
P;HTML|
;          #(set_debug test true)
P;HTML|
;          #(set_option_value repl-on-error true)
P;HTML|
;          #(set_option_value repl-on-fail false)
P;HTML|
;          #(set_option_value exit-on-fail false)
P;HTML|
;          #(set_option_value repl auto)
P;HTML|
;          #(set_option_value prolog false)
P;HTML|
;          #(set_option_value exec noskip)
P;HTML|
;          #(set_option_value maximum-result-count inf)
P;HTML|
;          #(set_option_value html false)
P;HTML|
;          #(set_option_value python true)
P;HTML|
;         #(set_option_value trace-on-test false)
P;HTML|
;          #(set_debug test false)
P;HTML|
;         #(set_option_value trace-on-fail false)
P;HTML|
;          #(set_debug fail false)
P;HTML|
;         #(set_option_value load show)
P;HTML|
;         #(set_option_value test true)
P;HTML|
;        #(is_cmd_option execute python --python=enable enable)
P;HTML|
;         #(set_option_value python enable)
P;HTML|
;        #(is_cmd_option execute timeout --timeout=40 40)
P;HTML|
;         #(set_option_value timeout 40)
P;HTML|
;         #(is_cmd_option execute output --output=./reports/tests_output/baseline-compat/ ./reports/tests_output/baseline-compat/)
P;HTML|
;         #(set_option_value output ./reports/tests_output/baseline-compat/)
P;HTML|
;         #(is_cmd_option execute html --html true)
P;HTML|
;          #(set_option_value html true)
P;HTML|
;         #(is_cmd_option execute test --test true)
P;HTML|
;          #(set_option_value test true)

; #( : user #(load_metta_file &self tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta) )
P;HTML|
;                       #(track_load_into_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta)
P;HTML|
;                                        #(load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta)
P;HTML|
;                                         #( = 1 "[()]" )
P;HTML|
;                                         #( = 2 "[()]" )
P;HTML|
;                                         #( = 3 "[(Error (assertEqualToResult (get-atoms GroundingSpace-0x55d913f927f8) ((mod-space! stdlib))) " )
P;HTML|
;                                         #( = 3 "Expected: [(mod-space! stdlib)]" )
P;HTML|
;                                         #( = 3 "Got: [GroundingSpace-top:stdlib]" )
P;HTML|
;                                         #( = 4 "Missed result: (mod-space! stdlib))]" )
P;HTML|
;                                         #( = 4 "0.03user 0.01system 0:00.04elapsed 100%CPU (0avgtext+0avgdata 26044maxresident)k" )
P;HTML|
;                                         #( = 4 "0inputs+0outputs (0major+3101minor)pagefaults 0swaps" )
P;HTML|
;                                        #(load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta)

;;; Test mod-space! operation to import a module into a new space
<span class="ansi38-013099040"
>!(bind! &new-space (new-space))

</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Add the stdlib module to the new space
<span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>!(add-atom &new-space (mod-space! stdlib))
</span>;; To unit test case:
<span class="ansi38-013099040"
>!(assertEqualToResult (add-atom &new-space (mod-space! stdlib)) (()))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.01"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.01</h3>
<span class="ansi38-255165000"
> (mod-space! stdlib)
</span>; 
; EVAL TEST
; took 0.001 secs. (1.00 milliseconds) 

!(assertEqualToResult (add-atom &new-space (mod-space! stdlib)) (()))

<span class="ansi36"
>#(loonit_success #(equal_enough_for_test (()) (())))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Get atoms from the new space, expecting to include stdlib module
<span class="ansi38-013099040"
>!(assertEqualToResult (get-atoms &new-space) ((mod-space! stdlib)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.02"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.02</h3>

#(failed #( : user once ) #( : user #(if_or_else #(eval = $10000 497 &self (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003) #(call eval (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003)) ))


#(on_mettalog_error #(failed #( : user once ) #( : user #(if_or_else #(eval = $10000 497 &self (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003) #(call eval (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003)) )))

^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] call(user:once, user:if_or_else(eval(=, _621376, 497, '&self', [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _624634), call(eval, [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _624634)))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] once(user:if_or_else(eval(=, _621376, 497, '&self', [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _624634), call(eval, [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _624634)))
   <span class="ansi1 ansi32"
>Call: </span>(285) [user] if_or_else(eval(=, _621376, 497, '&self', [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _624634), call(eval, [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _624634))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] eval(=, _621376, 497, '&self', [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _624634)
^  <span class="ansi1 ansi32"
>Call: </span>(287) [user] catch_metta_return(eval_args(=, _621376, 497, '&self', [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _624634), _624634)
^  <span class="ansi1 ansi32"
>Call: </span>(289) [user] eval_args(=, _621376, 497, '&self', [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _624634)
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] var([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] setup_call_cleanup('$notrace'(_643500, _643502), once(user:self_eval([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])), '$restore_trace'(_643500, _643502))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] sig_atomic(system:'$notrace'(_643500, _643502))
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] setup_call_cleanup('$notrace'(_645588, _645590), once(user:nonvar(_624634)), '$restore_trace'(_645588, _645590))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] sig_atomic(system:'$notrace'(_645588, _645590))
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] setup_call_cleanup('$notrace'(_647676, _647678), once(user:nonvar(_624634)), '$restore_trace'(_647676, _647678))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] sig_atomic(system:'$notrace'(_647676, _647678))
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] [['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(290) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] self_eval([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] setup_call_cleanup('$notrace'(_654832, _654834), once(user:self_eval0([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])), '$restore_trace'(_654832, _654834))
^  <span class="ansi1 ansi32"
>Call: </span>(293) [system] sig_atomic(system:'$notrace'(_654832, _654834))
^  <span class="ansi1 ansi31"
>Fail: </span>(290) [user] self_eval([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] eval_00(=, _621376, 497, '&self', [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _624634)
^  <span class="ansi1 ansi32"
>Call: </span>(291) [user] self_eval([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])
^  <span class="ansi1 ansi32"
>Call: </span>(293) [system] setup_call_cleanup('$notrace'(_659976, _659978), once(user:self_eval0([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])), '$restore_trace'(_659976, _659978))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] sig_atomic(system:'$notrace'(_659976, _659978))
^  <span class="ansi1 ansi31"
>Fail: </span>(291) [user] self_eval([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])
^  <span class="ansi1 ansi32"
>Call: </span>(291) [user] eval_01(=, _621376, 497, '&self', [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _624634)
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(292) [system] [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] if_t((497<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] 497<1
   <span class="ansi1 ansi31"
>Fail: </span>(294) [system] 497<1
^  <span class="ansi1 ansi32"
>Exit: </span>(292) [user] if_t((497<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(293) [system] setup_call_cleanup('$notrace'(_670250, _670252), once(user:(_670226 is 497-1, copy_term([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _670240))), '$restore_trace'(_670250, _670252))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] sig_atomic(system:'$notrace'(_670250, _670252))
^  <span class="ansi1 ansi32"
>Exit: </span>(293) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(496 is 497-1, copy_term([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], [case, ['if-unify-or-empty', _672348, _672348], [['Empty', _672378]]]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] trace_eval(eval_20(=, _621376), e, 496, '&self', [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _673414)
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] must_det_ll((notrace((flag(eval_num, _674468, _674468+1), _674486 is _674468 mod 500, _674504 is 99-496 mod 100, _674528=_674530, option_else('trace-length', _674542, 500), option_else('trace-depth', _674550, 30))), quietly(if_t((nop(stop_rtrace), _674486>_674542), (set_debug(eval, false), _674606 is _674542+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_674606])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_674658)))))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] once(user:(notrace((flag(eval_num, _674468, _674468+1), _674486 is _674468 mod 500, _674504 is 99-496 mod 100, _674528=_674530, option_else('trace-length', _674542, 500), option_else('trace-depth', _674550, 30))), quietly(if_t((nop(stop_rtrace), _674486>_674542), (set_debug(eval, false), _674606 is _674542+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_674606])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_674658)))))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [system] setup_call_cleanup('$notrace'(_676704, _676706), once(user:(flag(eval_num, _674468, _674468+1), _674486 is _674468 mod 500, _674504 is 99-496 mod 100, _674528=_674530, option_else('trace-length', _674542, 500), option_else('trace-depth', _674550, 30))), '$restore_trace'(_676704, _676706))
^  <span class="ansi1 ansi32"
>Call: </span>(298) [system] sig_atomic(system:'$notrace'(_676704, _676706))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 576, 576+1), 76 is 576 mod 500, 3 is 99-496 mod 100, _674528=_674528, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 76>500), (set_debug(eval, false), _674606 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_674606])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 76>500), (set_debug(eval, false), _674606 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_674606])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(296) [user] nop(notrace(no_repeats_var(_674658)))
   <span class="ansi1 ansi32"
>Exit: </span>(296) [user] nop(notrace(no_repeats_var(_674658)))
^  <span class="ansi1 ansi32"
>Exit: </span>(294) [system] once(user:(notrace((flag(eval_num, 576, 576+1), 76 is 576 mod 500, 3 is 99-496 mod 100, _674528=_674528, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 76>500), (set_debug(eval, false), _674606 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_674606])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_674658)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(293) [user] must_det_ll(user:(notrace((flag(eval_num, 576, 576+1), 76 is 576 mod 500, 3 is 99-496 mod 100, _674528=_674528, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 76>500), (set_debug(eval, false), _674606 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_674606])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_674658)))))
   <span class="ansi1 ansi32"
>Call: </span>(293) [occurs] occurs:sub_term(_686356, e)
   <span class="ansi1 ansi32"
>Exit: </span>(293) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(293) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(294) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(293) [occurs] occurs:sub_term(_686356, e)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] _693462=e
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] if_trace((eval;e), (_674528=1, indentq(3, 76, -->, [e, [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] setup_call_cleanup('$notrace'(_696602, _696604), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _674528=1, indentq(3, 76, -->, [e, [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]]]))), _696560, fbug((_696560-->if_trace((eval;e), (_674528=1, indentq(3, 76, -->, [e, [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]]])))))))), '$restore_trace'(_696602, _696604))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [system] sig_atomic(system:'$notrace'(_696602, _696604))
^  <span class="ansi1 ansi32"
>Exit: </span>(295) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _674528=1, indentq(3, 76, -->, [e, [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]]]))), _696560, fbug((_696560-->if_trace((eval;e), (_674528=1, indentq(3, 76, -->, [e, [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(293) [user] if_trace((eval;e), (_674528=1, indentq(3, 76, -->, [e, [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]]])))
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] _700798=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] _702836=(\+ \+ (flag(eval_num, _702856, _702856+1), (retval(fail)\=@=retval(fail), nonvar(_673414)->indentq(3, _702856, <--, [e, _673414]);indentq(3, _702856, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] (\+ \+ (flag(eval_num, _702856, _702856+1), (retval(fail)\=@=retval(fail), nonvar(_673414)->indentq(3, _702856, <--, [e, _673414]);indentq(3, _702856, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _702856, _702856+1), (retval(fail)\=@=retval(fail), nonvar(_673414)->indentq(3, _702856, <--, [e, _673414]);indentq(3, _702856, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] call_cleanup(((call(eval_20(=, _621376), 496, '&self', [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _673414)*->nb_setarg(1, retval(fail), _673414);fail, trace, call(eval_20(=, _621376), 496, '&self', [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _673414)), ignore(notrace((\+_673414\=_674658, nb_setarg(1, retval(fail), _673414))))), ignore((_674528==1->ignore(\+ \+ (flag(eval_num, _702856, _702856+1), (retval(fail)\=@=retval(fail), nonvar(_673414)->indentq(3, _702856, <--, [e, _673414]);indentq(3, _702856, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _702856, _702856+1), (retval(fail)\=@=retval(fail), nonvar(_673414)->indentq(3, _702856, <--, [e, _673414]);indentq(3, _702856, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] eval_20(=, _621376, 496, '&self', [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _673414)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] atom([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] no_eval([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] self_eval([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_710244, _710246), once(user:self_eval0([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])), '$restore_trace'(_710244, _710246))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_710244, _710246))
^  <span class="ansi1 ansi31"
>Fail: </span>(297) [user] self_eval([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] atomic(case)
   <span class="ansi1 ansi32"
>Exit: </span>(297) [system] atomic(case)
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] is_sl(case)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] number(case)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] [['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] callable(case)
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] callable(case)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] [['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] is_list([['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] is_list([['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] is_list(case)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] is_list([['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] is_list([['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] is_list([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] is_list([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] once(expand_eval([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _732588))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] expand_eval([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _732588)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] is_list([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])
   <span class="ansi1 ansi32"
>Exit: </span>(298) [system] is_list([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] ground(case)
   <span class="ansi1 ansi32"
>Exit: </span>(298) [system] ground(case)
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] apply:maplist(expand_eval, [['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _738688)
   <span class="ansi1 ansi32"
>Call: </span>(299) [apply] apply:maplist_([['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], _738688, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] expand_eval(['if-unify-or-empty', _611692, _611692], _740744)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] is_list(['if-unify-or-empty', _611692, _611692])
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] is_list(['if-unify-or-empty', _611692, _611692])
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] apply:maplist(expand_eval, [_611692, _611692], _745822)
   <span class="ansi1 ansi32"
>Call: </span>(302) [apply] apply:maplist_([_611692, _611692], _745822, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] expand_eval(_611692, _747878)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list(_611692)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _611692=_747878
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] _611692=_611692
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] expand_eval(_611692, _611692)
   <span class="ansi1 ansi32"
>Call: </span>(303) [apply] apply:maplist_([_611692], _747880, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] expand_eval(_611692, _753980)
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] is_list(_611692)
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] _611692=_753980
   <span class="ansi1 ansi32"
>Exit: </span>(305) [system] _611692=_611692
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] expand_eval(_611692, _611692)
   <span class="ansi1 ansi32"
>Call: </span>(304) [apply] apply:maplist_([], _753982, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [apply] apply:maplist_([_611692], [_611692], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [apply] apply:maplist_([_611692, _611692], [_611692, _611692], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [apply] apply:maplist(user:expand_eval, [_611692, _611692], [_611692, _611692])
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] expand_eval(['if-unify-or-empty', _611692, _611692], ['if-unify-or-empty', _611692, _611692])
   <span class="ansi1 ansi32"
>Call: </span>(300) [apply] apply:maplist_([[['Empty', _611710]]], _740746, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] expand_eval([['Empty', _611710]], _766204)
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] is_list([['Empty', _611710]])
   <span class="ansi1 ansi32"
>Exit: </span>(302) [system] is_list([['Empty', _611710]])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] ground(['Empty', _611710])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] apply:maplist(expand_eval, [], _769252)
   <span class="ansi1 ansi32"
>Call: </span>(303) [apply] apply:maplist_([], _769252, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [apply] apply:maplist_([], [], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [apply] apply:maplist(user:expand_eval, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] expand_eval([['Empty', _611710]], [['Empty', _611710]])
   <span class="ansi1 ansi32"
>Call: </span>(301) [apply] apply:maplist_([], _766206, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [apply] apply:maplist_([[['Empty', _611710]]], [[['Empty', _611710]]], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [apply] apply:maplist_([['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], [['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [apply] apply:maplist(user:expand_eval, [['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], [['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] expand_eval([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [system] once(user:expand_eval([case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]], [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]]))
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] [case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]]\==[case, ['if-unify-or-empty', _611692, _611692], [['Empty', _611710]]]
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] is_progn(case)
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] is_space_op(case)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] must_det_ll([]==[])
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] once(user:([]==[]))
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(298) [system] []==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [system] once(user:([]==[]))
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] must_det_ll(user:([]==[]))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] into_case_list([['Empty', _611710]], _794696)
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] is_list([['Empty', _611710]])
   <span class="ansi1 ansi32"
>Exit: </span>(297) [system] is_list([['Empty', _611710]])
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] into_case_list([['Empty', _611710]], [['Empty', _611710]])
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] into_case_keys(1, [['Empty', _611710]], _798754)
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] _799794 is 1+1
   <span class="ansi1 ansi32"
>Exit: </span>(297) [system] 2 is 1+1
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] is_case(_799784, ['Empty', _611710], _799786)
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] is_case('Empty', ['Empty', _611710], _611710)
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_611710)))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_804960, _804962), once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_611710))), _804918, fbug((_804918-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_611710)))))))), '$restore_trace'(_804960, _804962))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_804960, _804962))
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_611710))), _804918, fbug((_804918-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_611710)))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_611710)))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] into_case_keys(2, [], _799780)
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] into_case_keys(2, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] into_case_keys(1, [['Empty', _611710]], ['Empty'-_611710])
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] eval_case(=, _621376, 496, '&self', ['if-unify-or-empty', _611692, _611692], ['Empty'-_611710], _673414)
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _611692, _611692]))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_814328, _814330), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _611692, _611692]))), _814286, fbug((_814286-->if_trace(case, writeqln(case=['if-unify-or-empty', _611692, _611692]))))))), '$restore_trace'(_814328, _814330))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_814328, _814330))
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _611692, _611692]))), _814286, fbug((_814286-->if_trace(case, writeqln(case=['if-unify-or-empty', _611692, _611692]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _611692, _611692]))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] eval_args(=, _818650, 496, '&self', ['if-unify-or-empty', _611692, _611692], _818524)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] var(['if-unify-or-empty', _611692, _611692])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_820582, _820584), once(user:self_eval(['if-unify-or-empty', _611692, _611692])), '$restore_trace'(_820582, _820584))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_820582, _820584))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_822670, _822672), once(user:nonvar(_818524)), '$restore_trace'(_822670, _822672))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_822670, _822672))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_824758, _824760), once(user:nonvar(_818524)), '$restore_trace'(_824758, _824760))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_824758, _824760))
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] [_611692, _611692]==[]
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(298) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] self_eval(['if-unify-or-empty', _611692, _611692])
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] setup_call_cleanup('$notrace'(_831914, _831916), once(user:self_eval0(['if-unify-or-empty', _611692, _611692])), '$restore_trace'(_831914, _831916))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] sig_atomic(system:'$notrace'(_831914, _831916))
^  <span class="ansi1 ansi31"
>Fail: </span>(298) [user] self_eval(['if-unify-or-empty', _611692, _611692])
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] eval_00(=, _835002, 496, '&self', ['if-unify-or-empty', _611692, _611692], _818524)
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] self_eval(['if-unify-or-empty', _611692, _611692])
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] setup_call_cleanup('$notrace'(_837060, _837062), once(user:self_eval0(['if-unify-or-empty', _611692, _611692])), '$restore_trace'(_837060, _837062))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] sig_atomic(system:'$notrace'(_837060, _837062))
^  <span class="ansi1 ansi31"
>Fail: </span>(299) [user] self_eval(['if-unify-or-empty', _611692, _611692])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] eval_01(=, _835002, 496, '&self', ['if-unify-or-empty', _611692, _611692], _818524)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] ['if-unify-or-empty', _611692, _611692]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] ['if-unify-or-empty', _611692, _611692]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] if_t((496<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] 496<1
   <span class="ansi1 ansi31"
>Fail: </span>(302) [system] 496<1
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] if_t((496<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] setup_call_cleanup('$notrace'(_847334, _847336), once(user:(_847310 is 496-1, copy_term(['if-unify-or-empty', _611692, _611692], _847324))), '$restore_trace'(_847334, _847336))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] sig_atomic(system:'$notrace'(_847334, _847336))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(495 is 496-1, copy_term(['if-unify-or-empty', _611692, _611692], ['if-unify-or-empty', _849420, _849420]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] trace_eval(eval_20(=, _835002), e, 495, '&self', ['if-unify-or-empty', _611692, _611692], _850462)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] must_det_ll((notrace((flag(eval_num, _851516, _851516+1), _851534 is _851516 mod 500, _851552 is 99-495 mod 100, _851576=_851578, option_else('trace-length', _851590, 500), option_else('trace-depth', _851598, 30))), quietly(if_t((nop(stop_rtrace), _851534>_851590), (set_debug(eval, false), _851654 is _851590+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_851654])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_851706)))))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] once(user:(notrace((flag(eval_num, _851516, _851516+1), _851534 is _851516 mod 500, _851552 is 99-495 mod 100, _851576=_851578, option_else('trace-length', _851590, 500), option_else('trace-depth', _851598, 30))), quietly(if_t((nop(stop_rtrace), _851534>_851590), (set_debug(eval, false), _851654 is _851590+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_851654])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_851706)))))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_853752, _853754), once(user:(flag(eval_num, _851516, _851516+1), _851534 is _851516 mod 500, _851552 is 99-495 mod 100, _851576=_851578, option_else('trace-length', _851590, 500), option_else('trace-depth', _851598, 30))), '$restore_trace'(_853752, _853754))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_853752, _853754))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 577, 577+1), 77 is 577 mod 500, 4 is 99-495 mod 100, _851576=_851576, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 77>500), (set_debug(eval, false), _851654 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_851654])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 77>500), (set_debug(eval, false), _851654 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_851654])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(304) [user] nop(notrace(no_repeats_var(_851706)))
   <span class="ansi1 ansi32"
>Exit: </span>(304) [user] nop(notrace(no_repeats_var(_851706)))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] once(user:(notrace((flag(eval_num, 577, 577+1), 77 is 577 mod 500, 4 is 99-495 mod 100, _851576=_851576, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 77>500), (set_debug(eval, false), _851654 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_851654])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_851706)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] must_det_ll(user:(notrace((flag(eval_num, 577, 577+1), 77 is 577 mod 500, 4 is 99-495 mod 100, _851576=_851576, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 77>500), (set_debug(eval, false), _851654 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_851654])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_851706)))))
   <span class="ansi1 ansi32"
>Call: </span>(301) [occurs] occurs:sub_term(_863404, e)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(301) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(302) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(301) [occurs] occurs:sub_term(_863404, e)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] _870510=e
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] if_trace((eval;e), (_851576=1, indentq(4, 77, -->, [e, ['if-unify-or-empty', _611692, _611692]])))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] setup_call_cleanup('$notrace'(_873650, _873652), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _851576=1, indentq(4, 77, -->, [e, ['if-unify-or-empty', _611692, _611692]]))), _873608, fbug((_873608-->if_trace((eval;e), (_851576=1, indentq(4, 77, -->, [e, ['if-unify-or-empty', _611692, _611692]])))))))), '$restore_trace'(_873650, _873652))
^  <span class="ansi1 ansi32"
>Call: </span>(304) [system] sig_atomic(system:'$notrace'(_873650, _873652))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _851576=1, indentq(4, 77, -->, [e, ['if-unify-or-empty', _611692, _611692]]))), _873608, fbug((_873608-->if_trace((eval;e), (_851576=1, indentq(4, 77, -->, [e, ['if-unify-or-empty', _611692, _611692]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] if_trace((eval;e), (_851576=1, indentq(4, 77, -->, [e, ['if-unify-or-empty', _611692, _611692]])))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] _877846=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] _879884=(\+ \+ (flag(eval_num, _879904, _879904+1), (retval(fail)\=@=retval(fail), nonvar(_850462)->indentq(4, _879904, <--, [e, _850462]);indentq(4, _879904, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] (\+ \+ (flag(eval_num, _879904, _879904+1), (retval(fail)\=@=retval(fail), nonvar(_850462)->indentq(4, _879904, <--, [e, _850462]);indentq(4, _879904, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _879904, _879904+1), (retval(fail)\=@=retval(fail), nonvar(_850462)->indentq(4, _879904, <--, [e, _850462]);indentq(4, _879904, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] call_cleanup(((call(eval_20(=, _835002), 495, '&self', ['if-unify-or-empty', _611692, _611692], _850462)*->nb_setarg(1, retval(fail), _850462);fail, trace, call(eval_20(=, _835002), 495, '&self', ['if-unify-or-empty', _611692, _611692], _850462)), ignore(notrace((\+_850462\=_851706, nb_setarg(1, retval(fail), _850462))))), ignore((_851576==1->ignore(\+ \+ (flag(eval_num, _879904, _879904+1), (retval(fail)\=@=retval(fail), nonvar(_850462)->indentq(4, _879904, <--, [e, _850462]);indentq(4, _879904, <--, [e, retval(fail)]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _879904, _879904+1), (retval(fail)\=@=retval(fail), nonvar(_850462)->indentq(4, _879904, <--, [e, _850462]);indentq(4, _879904, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_20(=, _835002, 495, '&self', ['if-unify-or-empty', _611692, _611692], _850462)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] atom(['if-unify-or-empty', _611692, _611692])
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] no_eval(['if-unify-or-empty', _611692, _611692])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] self_eval(['if-unify-or-empty', _611692, _611692])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] setup_call_cleanup('$notrace'(_887292, _887294), once(user:self_eval0(['if-unify-or-empty', _611692, _611692])), '$restore_trace'(_887292, _887294))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] sig_atomic(system:'$notrace'(_887292, _887294))
^  <span class="ansi1 ansi31"
>Fail: </span>(305) [user] self_eval(['if-unify-or-empty', _611692, _611692])
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] atomic('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(305) [system] atomic('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] is_sl('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] number('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [_611692, _611692]==[]
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _898486==eval
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [_611692, _611692]==[]
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list([_611692, _611692])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list([_611692, _611692])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list([_611692, _611692])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list([_611692, _611692])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list(['if-unify-or-empty', _611692, _611692])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list(['if-unify-or-empty', _611692, _611692])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] once(expand_eval(['if-unify-or-empty', _611692, _611692], _910664))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] expand_eval(['if-unify-or-empty', _611692, _611692], _910664)
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] is_list(['if-unify-or-empty', _611692, _611692])
   <span class="ansi1 ansi32"
>Exit: </span>(306) [system] is_list(['if-unify-or-empty', _611692, _611692])
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(306) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] apply:maplist(expand_eval, [_611692, _611692], _916764)
   <span class="ansi1 ansi32"
>Call: </span>(307) [apply] apply:maplist_([_611692, _611692], _916764, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] expand_eval(_611692, _918820)
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] is_list(_611692)
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] _611692=_918820
   <span class="ansi1 ansi32"
>Exit: </span>(309) [system] _611692=_611692
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] expand_eval(_611692, _611692)
   <span class="ansi1 ansi32"
>Call: </span>(308) [apply] apply:maplist_([_611692], _918822, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] expand_eval(_611692, _924922)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list(_611692)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _611692=_924922
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] _611692=_611692
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] expand_eval(_611692, _611692)
   <span class="ansi1 ansi32"
>Call: </span>(309) [apply] apply:maplist_([], _924924, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(309) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(308) [apply] apply:maplist_([_611692], [_611692], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [apply] apply:maplist_([_611692, _611692], [_611692, _611692], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [apply] apply:maplist(user:expand_eval, [_611692, _611692], [_611692, _611692])
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [user] expand_eval(['if-unify-or-empty', _611692, _611692], ['if-unify-or-empty', _611692, _611692])
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [system] once(user:expand_eval(['if-unify-or-empty', _611692, _611692], ['if-unify-or-empty', _611692, _611692]))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] ['if-unify-or-empty', _611692, _611692]\==['if-unify-or-empty', _611692, _611692]
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] is_progn('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] is_space_op('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] arg(_942344, v('catch!', 'throw!', 'number-of!', 'limit!', 'offset!', 'max-time!', 'findall!', 'setup-call-cleanup!', 'call-cleanup!', 'call-cleanup!', 'with-output-to!'), 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _943242='if-unify-or-empty'
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] 'if-unify-or-empty'='if-unify-or-empty'
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _945276)
^  <span class="ansi1 ansi31"
>Fail: </span>(304) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _945276)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list(['if-unify-or-empty', _611692, _611692])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list(['if-unify-or-empty', _611692, _611692])
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] apply:maplist(self_eval, ['if-unify-or-empty', _611692, _611692])
   <span class="ansi1 ansi32"
>Call: </span>(305) [apply] apply:maplist_(['if-unify-or-empty', _611692, _611692], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] self_eval('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_952410, _952412), once(user:self_eval0('if-unify-or-empty')), '$restore_trace'(_952410, _952412))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_952410, _952412))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0('if-unify-or-empty')), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] self_eval('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(306) [apply] apply:maplist_([_611692, _611692], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] self_eval(_611692)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_958564, _958566), once(user:self_eval0(_611692)), '$restore_trace'(_958564, _958566))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_958564, _958566))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_611692)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] self_eval(_611692)
   <span class="ansi1 ansi32"
>Call: </span>(307) [apply] apply:maplist_([_611692], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] self_eval(_611692)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_964718, _964720), once(user:self_eval0(_611692)), '$restore_trace'(_964718, _964720))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_964718, _964720))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_611692)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] self_eval(_611692)
   <span class="ansi1 ansi32"
>Call: </span>(308) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(308) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [apply] apply:maplist_([_611692], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(306) [apply] apply:maplist_([_611692, _611692], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(305) [apply] apply:maplist_(['if-unify-or-empty', _611692, _611692], user:self_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [apply] apply:maplist(user:self_eval, ['if-unify-or-empty', _611692, _611692])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] ['if-unify-or-empty', _611692, _611692]=[_974936|_974938]
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] ['if-unify-or-empty', _611692, _611692]=['if-unify-or-empty', _611692, _611692]
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _978996=do_more_defs(true)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] do_more_defs(true)=do_more_defs(true)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] clause(eval_21(=, _835002, 495, '&self', ['if-unify-or-empty', _611692, _611692], _850462), _981048)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] 'if-unify-or-empty'==(/)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] 'if-unify-or-empty'== ===
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] 'if-unify-or-empty'== ====
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] eval_40(=, _835002, 495, '&self', ['if-unify-or-empty', _611692, _611692], _985120)
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] eval_selfless(=, _835002, 495, '&self', ['if-unify-or-empty', _611692, _611692], _985120)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_selfless_0(['if-unify-or-empty', _611692, _611692], _985120)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] is_assignment('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(308) [system] atom('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] eval_selfless_1(['if-unify-or-empty', _611692, _611692], _985120)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] allow_clp
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] false_flag
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(310) [system] fail
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] false_flag
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] eval_selfless_2(['if-unify-or-empty', _611692, _611692], _985120)
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] fake_notrace((ground(['if-unify-or-empty', _611692, _611692]), ['if-unify-or-empty', _611692, _611692]=[_1000344, _1000350, _1000356], atom(_1000344), catch_warn(current_op(_1000382, yfx, _1000344)), ['if-unify-or-empty', _611692, _611692]\=[_1000402], s2ps(['if-unify-or-empty', _611692, _611692], _1000410)))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] real_notrace(user:(ground(['if-unify-or-empty', _611692, _611692]), ['if-unify-or-empty', _611692, _611692]=[_1000344, _1000350, _1000356], atom(_1000344), catch_warn(current_op(_1000382, yfx, _1000344)), ['if-unify-or-empty', _611692, _611692]\=[_1000402], s2ps(['if-unify-or-empty', _611692, _611692], _1000410)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] setup_call_cleanup('$notrace'(_1002444, _1002446), once(user:(ground(['if-unify-or-empty', _611692, _611692]), ['if-unify-or-empty', _611692, _611692]=[_1000344, _1000350, _1000356], atom(_1000344), catch_warn(current_op(_1000382, yfx, _1000344)), ['if-unify-or-empty', _611692, _611692]\=[_1000402], s2ps(['if-unify-or-empty', _611692, _611692], _1000410))), '$restore_trace'(_1002444, _1002446))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(user:'$notrace'(_1002444, _1002446))
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] real_notrace(user:(ground(['if-unify-or-empty', _611692, _611692]), ['if-unify-or-empty', _611692, _611692]=[_1000344, _1000350, _1000356], atom(_1000344), catch_warn(current_op(_1000382, yfx, _1000344)), ['if-unify-or-empty', _611692, _611692]\=[_1000402], s2ps(['if-unify-or-empty', _611692, _611692], _1000410)))
^  <span class="ansi1 ansi31"
>Fail: </span>(308) [user] fake_notrace(user:(ground(['if-unify-or-empty', _611692, _611692]), ['if-unify-or-empty', _611692, _611692]=[_1000344, _1000350, _1000356], atom(_1000344), catch_warn(current_op(_1000382, yfx, _1000344)), ['if-unify-or-empty', _611692, _611692]\=[_1000402], s2ps(['if-unify-or-empty', _611692, _611692], _1000410)))
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] 'if-unify-or-empty'==(==)
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] 'if-unify-or-empty'==(==)
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] eval_41(=, _835002, 495, '&self', ['if-unify-or-empty', _611692, _611692], _985120)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_adjust_args(=, _835002, _1015632, _985120, 495, '&self', ['if-unify-or-empty', _611692, _611692], _1015634)
   <span class="ansi1 ansi32"
>Call: </span>(307) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _835002, _1015632, _985120, 495, '&self', ['if-unify-or-empty', _611692, _611692], _1015634)), eval_adjust_args1(=, _835002, _1015632, _985120, 495, '&self', ['if-unify-or-empty', _611692, _611692], _1015634))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_adjust_args2(=, _835002, _1015632, _985120, 495, '&self', ['if-unify-or-empty', _611692, _611692], _1015634)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] apply:maplist(must_eval_args(=, _1022788, 495, '&self'), [_611692, _611692], _1022782)
   <span class="ansi1 ansi32"
>Call: </span>(311) [apply] apply:maplist_([_611692, _611692], _1022782, user:must_eval_args(=, _1022788, 495, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] must_eval_args(=, _1022788, 495, '&self', _611692, _1024848)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] was_option_value(nodebug, _1036012)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] current_prolog_flag(nodebug, _1037030)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] current_prolog_flag(nodebug, _1037030)
   <span class="ansi1 ansi32"
>Call: </span>(318) [$syspreds] prolog_load_context(nodebug, _1039064)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [$syspreds] prolog_load_context(nodebug, _1039064)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nb_current(nodebug, _1041098)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] nb_current(nodebug, _1041098)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] was_option_value(nodebug, _1036012)
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_1047210, _1047212), once(user:option_value0(nodebug, true)), '$restore_trace'(_1047210, _1047212))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_8728, _8730))
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(314) [prolog_debug] prolog_debug:debugging(metta(eval_args), _27946)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [prolog_debug] prolog_debug:debugging(metta(eval_args), _27946, _29090)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_33056, _33058, _33060), defined)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(317) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_33056, _33058, _33060))
   <span class="ansi1 ansi32"
>Call: </span>(318) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_33056, _33058, _33060))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] callable(debugging_logicmoo_setting(_33056, _33058, _33060))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] callable(debugging_logicmoo_setting(_33056, _33058, _33060))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_33056, _33058, _33060))
   <span class="ansi1 ansi32"
>Exit: </span>(317) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_33056, _33058, _33060))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_33056, _33058, _33060), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _27946, _45240)
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(314) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval_args(=, _8696, 495, '&self', _6624, _8710)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(_6624)
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] var(_6624)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] nonvar(_8710)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_56466, _56468), once(user:self_eval(_6624)), '$restore_trace'(_56466, _56468))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_56466, _56468))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_6624)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] _8710=_6624
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] _6624=_6624
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] eval_args(=, _8696, 495, '&self', _6624, _6624)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] must_eval_args(=, _8696, 495, '&self', _6624, _6624)
   <span class="ansi1 ansi32"
>Call: </span>(312) [apply] apply:maplist_([_6624], _8712, user:must_eval_args(=, _8696, 495, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] must_eval_args(=, _8696, 495, '&self', _6624, _64730)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] was_option_value(nodebug, _75894)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] current_prolog_flag(nodebug, _76912)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] current_prolog_flag(nodebug, _76912)
   <span class="ansi1 ansi32"
>Call: </span>(319) [$syspreds] prolog_load_context(nodebug, _78946)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [$syspreds] prolog_load_context(nodebug, _78946)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] nb_current(nodebug, _80980)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] nb_current(nodebug, _80980)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] was_option_value(nodebug, _75894)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_87092, _87094), once(user:option_value0(nodebug, true)), '$restore_trace'(_87092, _87094))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_87092, _87094))
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(315) [prolog_debug] prolog_debug:debugging(metta(eval_args), _107432)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [prolog_debug] prolog_debug:debugging(metta(eval_args), _107432, _108576)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_112542, _112544, _112546), defined)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(318) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_112542, _112544, _112546))
   <span class="ansi1 ansi32"
>Call: </span>(319) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_112542, _112544, _112546))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] callable(debugging_logicmoo_setting(_112542, _112544, _112546))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] callable(debugging_logicmoo_setting(_112542, _112544, _112546))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_112542, _112544, _112546))
   <span class="ansi1 ansi32"
>Exit: </span>(318) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_112542, _112544, _112546))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_112542, _112544, _112546), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _107432, _124726)
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(315) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] eval_args(=, _8696, 495, '&self', _6624, _64730)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] var(_6624)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] var(_6624)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nonvar(_64730)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] setup_call_cleanup('$notrace'(_135952, _135954), once(user:self_eval(_6624)), '$restore_trace'(_135952, _135954))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] sig_atomic(system:'$notrace'(_135952, _135954))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_6624)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] _64730=_6624
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] _6624=_6624
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] eval_args(=, _8696, 495, '&self', _6624, _6624)
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] must_eval_args(=, _8696, 495, '&self', _6624, _6624)
   <span class="ansi1 ansi32"
>Call: </span>(313) [apply] apply:maplist_([], _64732, user:must_eval_args(=, _8696, 495, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(313) [apply] apply:maplist_([], [], user:must_eval_args(=, _8696, 495, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(312) [apply] apply:maplist_([_6624], [_6624], user:must_eval_args(=, _8696, 495, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(311) [apply] apply:maplist_([_6624, _6624], [_6624, _6624], user:must_eval_args(=, _8696, 495, '&self'))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [apply] apply:maplist(user:must_eval_args(=, _8696, 495, '&self'), [_6624, _6624], [_6624, _6624])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _8640=_8638
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] _8638=_8638
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_adjust_args2(=, _8308, _8638, _8638, 495, '&self', ['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _8308, _8638, _8638, 495, '&self', ['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _6624, _6624])), eval_adjust_args1(=, _8308, _8638, _8638, 495, '&self', ['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _6624, _6624]))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_adjust_args(=, _8308, _8638, _8638, 495, '&self', ['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] if_trace((e;args), (['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _6624, _6624]->['if-unify-or-empty', _6624, _6624])));nop(indentq2(495, same(['if-unify-or-empty', _6624, _6624])))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_154538, _154540), once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _6624, _6624]->['if-unify-or-empty', _6624, _6624])));nop(indentq2(495, same(['if-unify-or-empty', _6624, _6624])))))), _154496, fbug((_154496-->if_trace((e;args), (['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _6624, _6624]->['if-unify-or-empty', _6624, _6624])));nop(indentq2(495, same(['if-unify-or-empty', _6624, _6624])))))))))), '$restore_trace'(_154538, _154540))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_154538, _154540))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _6624, _6624]->['if-unify-or-empty', _6624, _6624])));nop(indentq2(495, same(['if-unify-or-empty', _6624, _6624])))))), _154496, fbug((_154496-->if_trace((e;args), (['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _6624, _6624]->['if-unify-or-empty', _6624, _6624])));nop(indentq2(495, same(['if-unify-or-empty', _6624, _6624])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] if_trace((e;args), (['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _6624, _6624]->['if-unify-or-empty', _6624, _6624])));nop(indentq2(495, same(['if-unify-or-empty', _6624, _6624])))))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_70(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638)
   <span class="ansi1 ansi32"
>Call: </span>(307) [user] if_or_else(eval_maybe_python(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638), if_or_else(eval_maybe_host_predicate(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638), if_or_else(eval_maybe_host_function(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638), if_or_else(eval_maybe_defn(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638), eval_maybe_subst(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638)))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] eval_maybe_python(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638)
   <span class="ansi1 ansi32"
>Call: </span>(309) [user] metta_atom('&self', ['registered-python-function', _161898, _161904, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] typed_list('&self', _163044, _162918)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(310) [user] typed_list('&self', _166088, _162918)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] metta_atom_in_file('&self', ['registered-python-function', _161898, _161904, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] metta_atom_in_file('&self', ['registered-python-function', _161898, _161904, 'if-unify-or-empty'], _169142, _169144)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] loaded_into_kb('&self', _170040)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] loaded_into_kb('&self', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] once(user:asserted_metta_pred(_193056, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] asserted_metta_pred(_193056, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(313) [user] asserted_metta_pred(_193056, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] metta_atom_asserted('&self', ['registered-python-function', _161898, _161904, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] metta_atom_asserted_deduced('&self', ['registered-python-function', _161898, _161904, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] metta_atom('&corelib', ['registered-python-function', _161898, _161904, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] typed_list('&corelib', _217122, _216996)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(312) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(311) [user] typed_list('&corelib', _220166, _216996)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] metta_atom_in_file('&corelib', ['registered-python-function', _161898, _161904, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] metta_atom_in_file('&corelib', ['registered-python-function', _161898, _161904, 'if-unify-or-empty'], _223220, _223222)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] loaded_into_kb('&corelib', _224118)
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] once(user:asserted_metta_pred(_230062, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] asserted_metta_pred(_230062, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] asserted_metta_pred(_230062, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] once(user:asserted_metta_pred(_249744, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] asserted_metta_pred(_249744, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] asserted_metta_pred(_249744, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(311) [user] metta_atom_asserted('&corelib', ['registered-python-function', _161898, _161904, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] metta_atom_asserted_deduced('&corelib', ['registered-python-function', _161898, _161904, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(308) [user] if_or_else(eval_maybe_host_predicate(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638), if_or_else(eval_maybe_host_function(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638), if_or_else(eval_maybe_defn(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638), eval_maybe_subst(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638))))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_maybe_host_predicate(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] once((is_system_pred('if-unify-or-empty'), length([_6624, _6624], _274628), is_syspred('if-unify-or-empty', _274628, _274636)))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom_concat(_278820, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom_concat(_281864, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom_concat(_284908, '-p', 'if-unify-or-empty')
^  <span class="ansi1 ansi31"
>Fail: </span>(312) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(309) [user] if_or_else(eval_maybe_host_function(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638), if_or_else(eval_maybe_defn(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638), eval_maybe_subst(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] eval_maybe_host_function(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom_concat(_294020, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom_concat(_297064, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom_concat(_300108, '-p', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] if_or_else(eval_maybe_defn(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638), eval_maybe_subst(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] eval_maybe_defn(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] trace_eval(eval_defn_choose_candidates(=, _8308), defn, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] must_det_ll((notrace((flag(eval_num, _310148, _310148+1), _310166 is _310148 mod 500, _310184 is 99-495 mod 100, _310208=_310210, option_else('trace-length', _310222, 500), option_else('trace-depth', _310230, 30))), quietly(if_t((nop(stop_rtrace), _310166>_310222), (set_debug(eval, false), _310286 is _310222+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_310286])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_310338)))))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] once(user:(notrace((flag(eval_num, _310148, _310148+1), _310166 is _310148 mod 500, _310184 is 99-495 mod 100, _310208=_310210, option_else('trace-length', _310222, 500), option_else('trace-depth', _310230, 30))), quietly(if_t((nop(stop_rtrace), _310166>_310222), (set_debug(eval, false), _310286 is _310222+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_310286])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_310338)))))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_312384, _312386), once(user:(flag(eval_num, _310148, _310148+1), _310166 is _310148 mod 500, _310184 is 99-495 mod 100, _310208=_310210, option_else('trace-length', _310222, 500), option_else('trace-depth', _310230, 30))), '$restore_trace'(_312384, _312386))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_312384, _312386))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 578, 578+1), 78 is 578 mod 500, 4 is 99-495 mod 100, _310208=_310208, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _310286 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_310286])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _310286 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_310286])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(316) [user] nop(notrace(no_repeats_var(_310338)))
   <span class="ansi1 ansi32"
>Exit: </span>(316) [user] nop(notrace(no_repeats_var(_310338)))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [system] once(user:(notrace((flag(eval_num, 578, 578+1), 78 is 578 mod 500, 4 is 99-495 mod 100, _310208=_310208, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _310286 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_310286])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_310338)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] must_det_ll(user:(notrace((flag(eval_num, 578, 578+1), 78 is 578 mod 500, 4 is 99-495 mod 100, _310208=_310208, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _310286 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_310286])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_310338)))))
   <span class="ansi1 ansi32"
>Call: </span>(313) [occurs] occurs:sub_term(_322036, defn)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [occurs] occurs:sub_term(defn, defn)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] defn\=defn
   <span class="ansi1 ansi31"
>Fail: </span>(313) [system] defn\=defn
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(313) [occurs] occurs:sub_term(_322036, defn)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _329142=defn
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] defn=defn
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] if_trace((eval;defn), (_310208=1, indentq(4, 78, -->, [defn, ['if-unify-or-empty', _6624, _6624]])))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_332282, _332284), once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _310208=1, indentq(4, 78, -->, [defn, ['if-unify-or-empty', _6624, _6624]]))), _332240, fbug((_332240-->if_trace((eval;defn), (_310208=1, indentq(4, 78, -->, [defn, ['if-unify-or-empty', _6624, _6624]])))))))), '$restore_trace'(_332282, _332284))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_332282, _332284))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _310208=1, indentq(4, 78, -->, [defn, ['if-unify-or-empty', _6624, _6624]]))), _332240, fbug((_332240-->if_trace((eval;defn), (_310208=1, indentq(4, 78, -->, [defn, ['if-unify-or-empty', _6624, _6624]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] if_trace((eval;defn), (_310208=1, indentq(4, 78, -->, [defn, ['if-unify-or-empty', _6624, _6624]])))
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _336478=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _338516=(\+ \+ (flag(eval_num, _338536, _338536+1), (retval(fail)\=@=retval(fail), nonvar(_8638)->indentq(4, _338536, <--, [defn, _8638]);indentq(4, _338536, <--, [defn, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] (\+ \+ (flag(eval_num, _338536, _338536+1), (retval(fail)\=@=retval(fail), nonvar(_8638)->indentq(4, _338536, <--, [defn, _8638]);indentq(4, _338536, <--, [defn, retval(fail)]))))=(\+ \+ (flag(eval_num, _338536, _338536+1), (retval(fail)\=@=retval(fail), nonvar(_8638)->indentq(4, _338536, <--, [defn, _8638]);indentq(4, _338536, <--, [defn, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] call_cleanup(((call(eval_defn_choose_candidates(=, _8308), 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638)*->nb_setarg(1, retval(fail), _8638);fail, trace, call(eval_defn_choose_candidates(=, _8308), 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638)), ignore(notrace((\+_8638\=_310338, nb_setarg(1, retval(fail), _8638))))), ignore((_310208==1->ignore(\+ \+ (flag(eval_num, _338536, _338536+1), (retval(fail)\=@=retval(fail), nonvar(_8638)->indentq(4, _338536, <--, [defn, _8638]);indentq(4, _338536, <--, [defn, retval(fail)]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _338536, _338536+1), (retval(fail)\=@=retval(fail), nonvar(_8638)->indentq(4, _338536, <--, [defn, _8638]);indentq(4, _338536, <--, [defn, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_defn_choose_candidates(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] findall((_342878->_342880), get_defn_expansions(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _342878, _342880), _342898)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [$bags] findall((_342878->_342880), user:get_defn_expansions(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _342878, _342880), _342898, [])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [$bags] cleanup_bag(findall_loop((_342878->_342880), user:get_defn_expansions(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _342878, _342880), _342898, []), '$destroy_findall_bag')
   <span class="ansi1 ansi32"
>Call: </span>(319) [$bags] findall_loop((_342878->_342880), user:get_defn_expansions(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _342878, _342880), _342898, [])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] get_defn_expansions(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _342878, _342880)
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] same_len_copy([_6624, _6624], _348070)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] length([_6624, _6624], _349088)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(_349088)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] var(_349088)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] []==[]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _349088=2
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] 2=2
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] length([_6624, _6624], 2)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] length(_348070, 2)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(2)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] integer(2)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] integer(2)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _348070==[]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(_348070)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] var(_348070)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] length([_364312, _364318], 2)
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [user] same_len_copy([_6624, _6624], [_364312, _364318])
   <span class="ansi1 ansi32"
>Call: </span>(321) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _364312, _364318], _342880)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] ignore((=)=(=))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] (=)=(=)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] (=)=(=)
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] ignore(user:((=)=(=)))
   <span class="ansi1 ansi32"
>Call: </span>(322) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _364312, _364318], _342880]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _364312, _364318], _342880]))
   <span class="ansi1 ansi32"
>Call: </span>(323) [user] metta_atom('&self', [=, ['if-unify-or-empty', _364312, _364318], _342880])
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] typed_list('&self', _373634, _373508)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(325) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(324) [user] typed_list('&self', _376678, _373508)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _364312, _364318], _342880])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _364312, _364318], _342880], _379732, _379734)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] loaded_into_kb('&self', _380630)
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] loaded_into_kb('&self', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] once(user:asserted_metta_pred(_386598, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] asserted_metta_pred(_386598, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(327) [user] asserted_metta_pred(_386598, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(324) [user] metta_atom_asserted('&self', [=, ['if-unify-or-empty', _364312, _364318], _342880])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] metta_atom_asserted_deduced('&self', [=, ['if-unify-or-empty', _364312, _364318], _342880])
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(324) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _364312, _364318], _342880])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] typed_list('&corelib', _410664, _410538)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(326) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(325) [user] typed_list('&corelib', _413708, _410538)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _364312, _364318], _342880])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _364312, _364318], _342880], _416762, _416764)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] loaded_into_kb('&corelib', _417660)
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] once(user:asserted_metta_pred(_423604, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] asserted_metta_pred(_423604, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(328) [user] asserted_metta_pred(_423604, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] once(user:asserted_metta_pred(_443286, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] asserted_metta_pred(_443286, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(328) [user] asserted_metta_pred(_443286, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(325) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _364312, _364318], _342880])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] metta_atom_asserted_deduced('&corelib', [=, ['if-unify-or-empty', _364312, _364318], _342880])
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] fail
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _364312, _364312], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(324) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _364312, _364312], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(323) [user] metta_atom('&self', [=, ['if-unify-or-empty', _364312, _364312], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _364312, _364312], unified]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _364312, _364312], unified]))
   <span class="ansi1 ansi32"
>Exit: </span>(321) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _364312, _364312], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] get_defn_expansions(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _364312, _364312], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _364312, _364318], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(324) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _364312, _364318], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(323) [user] metta_atom('&self', [=, ['if-unify-or-empty', _364312, _364318], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _364312, _364318], [empty]]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _364312, _364318], [empty]]))
   <span class="ansi1 ansi32"
>Exit: </span>(321) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _364312, _364318], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] get_defn_expansions(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _364312, _364318], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(319) [$bags] findall_loop((_342878->_342880), user:get_defn_expansions(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _342878, _342880), [(['if-unify-or-empty', _476290, _476290]->unified), (['if-unify-or-empty', _476254, _476260]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [$bags] cleanup_bag('$bags':findall_loop((_342878->_342880), user:get_defn_expansions(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _342878, _342880), [(['if-unify-or-empty', _476290, _476290]->unified), (['if-unify-or-empty', _476254, _476260]->[empty])], []), '$bags':'$destroy_findall_bag')
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [$bags] findall((_342878->_342880), user:get_defn_expansions(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _342878, _342880), [(['if-unify-or-empty', _476290, _476290]->unified), (['if-unify-or-empty', _476254, _476260]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [$bags] findall((_342878->_342880), user:get_defn_expansions(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _342878, _342880), [(['if-unify-or-empty', _476290, _476290]->unified), (['if-unify-or-empty', _476254, _476260]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_defn_bodies(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638, [(['if-unify-or-empty', _476290, _476290]->unified), (['if-unify-or-empty', _476254, _476260]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] if_trace(e, maplist(print_templates(495, '   '), [(['if-unify-or-empty', _476290, _476290]->unified), (['if-unify-or-empty', _476254, _476260]->[empty])]))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_482522, _482524), once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(495, '   '), [(['if-unify-or-empty', _476290, _476290]->unified), (['if-unify-or-empty', _476254, _476260]->[empty])]))), _482480, fbug((_482480-->if_trace(e, maplist(print_templates(495, '   '), [(['if-unify-or-empty', _476290, _476290]->unified), (['if-unify-or-empty', _476254, _476260]->[empty])]))))))), '$restore_trace'(_482522, _482524))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_482522, _482524))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(495, '   '), [(['if-unify-or-empty', _476290, _476290]->unified), (['if-unify-or-empty', _476254, _476260]->[empty])]))), _482480, fbug((_482480-->if_trace(e, maplist(print_templates(495, '   '), [(['if-unify-or-empty', _476290, _476290]->unified), (['if-unify-or-empty', _476254, _476260]->[empty])]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [user] if_trace(e, maplist(print_templates(495, '   '), [(['if-unify-or-empty', _476290, _476290]->unified), (['if-unify-or-empty', _476254, _476260]->[empty])]))
   <span class="ansi1 ansi32"
>Call: </span>(317) [user] if_or_else((member((_486732->_486734), [(['if-unify-or-empty', _476290, _476290]->unified), (['if-unify-or-empty', _476254, _476260]->[empty])]), copy_term((_486732->_486734), _486746), eval_defn_success(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638, _486732, _486734, _486746)), eval_defn_failure(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638))
   <span class="ansi1 ansi32"
>Call: </span>(319) [lists] lists:member((_486732->_486734), [(['if-unify-or-empty', _476290, _476290]->unified), (['if-unify-or-empty', _476254, _476260]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(320) [lists] lists:member_([(['if-unify-or-empty', _476254, _476260]->[empty])], (_486732->_486734), (['if-unify-or-empty', _476290, _476290]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [lists] lists:member_([(['if-unify-or-empty', _476254, _476260]->[empty])], (['if-unify-or-empty', _476290, _476290]->unified), (['if-unify-or-empty', _476290, _476290]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [lists] lists:member((['if-unify-or-empty', _476290, _476290]->unified), [(['if-unify-or-empty', _476290, _476290]->unified), (['if-unify-or-empty', _476254, _476260]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] copy_term((['if-unify-or-empty', _476290, _476290]->unified), _486746)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] copy_term((['if-unify-or-empty', _476290, _476290]->unified), (['if-unify-or-empty', _492896, _492896]->unified))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_defn_success(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638, ['if-unify-or-empty', _476290, _476290], unified, (['if-unify-or-empty', _492896, _492896]->unified))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] ['if-unify-or-empty', _6624, _6624]=['if-unify-or-empty', _476290, _476290]
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] ['if-unify-or-empty', _6624, _6624]=['if-unify-or-empty', _6624, _6624]
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _8638=unified
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] unified=unified
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] ['if-unify-or-empty', _6624, _6624]\=@=unified
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] ['if-unify-or-empty', _6624, _6624]\=@=unified
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _492896, _492896]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_502144, _502146), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _492896, _492896]->unified)))))), _502102, fbug((_502102-->if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _492896, _492896]->unified)))))))))), '$restore_trace'(_502144, _502146))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_502144, _502146))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _492896, _492896]->unified)))))), _502102, fbug((_502102-->if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _492896, _492896]->unified)))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _492896, _492896]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] light_eval(=, _8308, 495, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] light_eval(=, _8308, 495, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] eval_defn_success(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified, ['if-unify-or-empty', _6624, _6624], unified, (['if-unify-or-empty', _492896, _492896]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(317) [user] if_or_else((member((['if-unify-or-empty', _6624, _6624]->unified), [(['if-unify-or-empty', _6624, _6624]->unified), (['if-unify-or-empty', _476254, _476260]->[empty])]), copy_term((['if-unify-or-empty', _6624, _6624]->unified), (['if-unify-or-empty', _492896, _492896]->unified)), eval_defn_success(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified, ['if-unify-or-empty', _6624, _6624], unified, (['if-unify-or-empty', _492896, _492896]->unified))), eval_defn_failure(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] eval_defn_bodies(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified, [(['if-unify-or-empty', _6624, _6624]->unified), (['if-unify-or-empty', _476254, _476260]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] eval_defn_choose_candidates(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] ignore(notrace((\+unified\=_310338, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_515592, _515594), once(user:(\+unified\=_310338, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_515592, _515594))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_515592, _515594))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_310338, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] ignore(user:notrace((\+unified\=_310338, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _8308), 495, '&self', ['if-unify-or-empty', _6624, _6624], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_defn_choose_candidates(=, _8308), 495, '&self', ['if-unify-or-empty', _6624, _6624], unified)), ignore(notrace((\+unified\=_310338, nb_setarg(1, retval(unified), unified))))), user:ignore((_310208==1->ignore(\+ \+ (flag(eval_num, _338536, _338536+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(4, _338536, <--, [defn, unified]);indentq(4, _338536, <--, [defn, retval(unified)]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _338536, _338536+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(4, _338536, <--, [defn, unified]);indentq(4, _338536, <--, [defn, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] trace_eval(eval_defn_choose_candidates(=, _8308), defn, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] eval_maybe_defn(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else(eval_maybe_defn(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified), eval_maybe_subst(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified))
   <span class="ansi1 ansi32"
>Exit: </span>(309) [user] if_or_else(eval_maybe_host_function(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified), if_or_else(eval_maybe_defn(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified), eval_maybe_subst(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified)))
   <span class="ansi1 ansi32"
>Exit: </span>(308) [user] if_or_else(eval_maybe_host_predicate(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified), if_or_else(eval_maybe_host_function(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified), if_or_else(eval_maybe_defn(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified), eval_maybe_subst(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified))))
   <span class="ansi1 ansi32"
>Exit: </span>(307) [user] if_or_else(eval_maybe_python(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified), if_or_else(eval_maybe_host_predicate(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified), if_or_else(eval_maybe_host_function(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified), if_or_else(eval_maybe_defn(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified), eval_maybe_subst(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_70(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] check_returnval(=, _8308, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] check_returnval(=, _8308, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [user] eval_41(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] eval_40(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] unified=_8338
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] eval_20(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified)
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] ignore(notrace((\+unified\=_8354, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_540122, _540124), once(user:(\+unified\=_8354, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_540122, _540124))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_540122, _540124))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_8354, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [system] ignore(user:notrace((\+unified\=_8354, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] call_cleanup(user:((call(eval_20(=, _8308), 495, '&self', ['if-unify-or-empty', _6624, _6624], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_20(=, _8308), 495, '&self', ['if-unify-or-empty', _6624, _6624], unified)), ignore(notrace((\+unified\=_8354, nb_setarg(1, retval(unified), unified))))), user:ignore((_8346==1->ignore(\+ \+ (flag(eval_num, _8384, _8384+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(4, _8384, <--, [e, unified]);indentq(4, _8384, <--, [e, retval(unified)]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8384, _8384+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(4, _8384, <--, [e, unified]);indentq(4, _8384, <--, [e, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] trace_eval(eval_20(=, _8308), e, 495, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] self_eval(unified)
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_549356, _549358), once(user:self_eval0(unified)), '$restore_trace'(_549356, _549358))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_549356, _549358))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(unified)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] self_eval(unified)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] _8306=unified
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] eval_01(=, _8308, 496, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [user] eval_00(=, _8308, 496, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] eval_args(=, _8308, 496, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_559674, _559676), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _559632, fbug((_559632-->if_trace(case, writeqln(switch=unified))))))), '$restore_trace'(_559674, _559676))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_559674, _559676))
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _559632, fbug((_559632-->if_trace(case, writeqln(switch=unified))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] select_case(496, '&self', unified, ['Empty'-_6642], _563870)
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] best_key(unified, ['Empty'-_6642], _563870)
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_565922-_563870, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member_([], _565922-_563870, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member_([], 'Empty'-_6642, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [lists] lists:member('Empty'-_6642, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] unified='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_571016-_563870, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member_([], _571016-_563870, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member_([], 'Empty'-_6642, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [lists] lists:member('Empty'-_6642, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] unified=='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_576110-_563870, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member_([], _576110-_563870, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member_([], 'Empty'-_6642, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [lists] lists:member('Empty'-_6642, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] unified=@='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_581204-_563870, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member_([], _581204-_563870, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member_([], 'Empty'-_6642, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [lists] lists:member('Empty'-_6642, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] unified='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] maybe_special_keys(496, '&self', ['Empty'-_6642], _586296)
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] eval_args(496, '&self', 'Empty', _587330)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] eval_args(=, _588482, 496, '&self', 'Empty', _587330)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] var('Empty')
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_590414, _590416), once(user:self_eval('Empty')), '$restore_trace'(_590414, _590416))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_590414, _590416))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval('Empty')), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] _587330='Empty'
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] 'Empty'='Empty'
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] eval_args(=, _595716, 496, '&self', 'Empty', 'Empty')
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] eval_args(496, '&self', 'Empty', 'Empty')
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] 'Empty'\=@='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] maybe_special_keys(496, '&self', [], _586296)
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] maybe_special_keys(496, '&self', [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [user] maybe_special_keys(496, '&self', ['Empty'-_6642], [])
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] best_key(unified, [], _563870)
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_602758-_563870, [])
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_603780-_563870, [])
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_604802-_563870, [])
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_605824-_563870, [])
   <span class="ansi1 ansi32"
>Call: </span>(298) [lists] lists:member(_606846-_563870, [])
   <span class="ansi1 ansi32"
>Call: </span>(297) [lists] lists:member(_607868-_607870, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(298) [lists] lists:member_([], _607868-_607870, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(298) [lists] lists:member_([], 'Empty'-_6642, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(297) [lists] lists:member('Empty'-_6642, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] 'Empty'=='%void%'
   <span class="ansi1 ansi32"
>Call: </span>(321) [lists] lists:member_([], (_486732->_486734), (['if-unify-or-empty', _476254, _476260]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(321) [lists] lists:member_([], (['if-unify-or-empty', _476254, _476260]->[empty]), (['if-unify-or-empty', _476254, _476260]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [lists] lists:member_([(['if-unify-or-empty', _476254, _476260]->[empty])], (['if-unify-or-empty', _476254, _476260]->[empty]), (['if-unify-or-empty', _476290, _476290]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [lists] lists:member((['if-unify-or-empty', _476254, _476260]->[empty]), [(['if-unify-or-empty', _476290, _476290]->unified), (['if-unify-or-empty', _476254, _476260]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] copy_term((['if-unify-or-empty', _476254, _476260]->[empty]), _486746)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] copy_term((['if-unify-or-empty', _476254, _476260]->[empty]), (['if-unify-or-empty', _618068, _618074]->[empty]))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_defn_success(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], _8638, ['if-unify-or-empty', _476254, _476260], [empty], (['if-unify-or-empty', _618068, _618074]->[empty]))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] ['if-unify-or-empty', _6624, _6624]=['if-unify-or-empty', _476254, _476260]
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] ['if-unify-or-empty', _6624, _6624]=['if-unify-or-empty', _6624, _6624]
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _8638=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] [empty]=[empty]
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] ['if-unify-or-empty', _6624, _6624]\=@=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] ['if-unify-or-empty', _6624, _6624]\=@=[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _618068, _618074]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_627316, _627318), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _618068, _618074]->[empty])))))), _627274, fbug((_627274-->if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _618068, _618074]->[empty])))))))))), '$restore_trace'(_627316, _627318))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_627316, _627318))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _618068, _618074]->[empty])))))), _627274, fbug((_627274-->if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _618068, _618074]->[empty])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _618068, _618074]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] light_eval(=, _8308, 495, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] light_eval(=, _8308, 495, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] eval_defn_success(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty], ['if-unify-or-empty', _6624, _6624], [empty], (['if-unify-or-empty', _618068, _618074]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(317) [user] if_or_else((member((['if-unify-or-empty', _6624, _6624]->[empty]), [(['if-unify-or-empty', _476290, _476290]->unified), (['if-unify-or-empty', _6624, _6624]->[empty])]), copy_term((['if-unify-or-empty', _6624, _6624]->[empty]), (['if-unify-or-empty', _618068, _618074]->[empty])), eval_defn_success(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty], ['if-unify-or-empty', _6624, _6624], [empty], (['if-unify-or-empty', _618068, _618074]->[empty]))), eval_defn_failure(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty]))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] eval_defn_bodies(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty], [(['if-unify-or-empty', _476290, _476290]->unified), (['if-unify-or-empty', _6624, _6624]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] eval_defn_choose_candidates(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] ignore(notrace((\+[empty]\=_310338, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_640772, _640774), once(user:(\+[empty]\=_310338, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_640772, _640774))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_640772, _640774))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_310338, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] ignore(user:notrace((\+[empty]\=_310338, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] ignore((_310208==1->ignore(\+ \+ (flag(eval_num, _338536, _338536+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _338536, <--, [defn, [empty]]);indentq(4, _338536, <--, [defn, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _338536, _338536+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _338536, <--, [defn, [empty]]);indentq(4, _338536, <--, [defn, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] _310208==1
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] _310208==1
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_647964, _647966), once(user:ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _338536, _338536+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _338536, <--, [defn, [empty]]);indentq(4, _338536, <--, [defn, retval([empty])])))))))), '$restore_trace'(_647964, _647966))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_647964, _647966))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _338536, _338536+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _338536, <--, [defn, [empty]]);indentq(4, _338536, <--, [defn, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] ignore(user:(_310208==1->ignore(\+ \+ (flag(eval_num, _338536, _338536+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _338536, <--, [defn, [empty]]);indentq(4, _338536, <--, [defn, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _338536, _338536+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _338536, <--, [defn, [empty]]);indentq(4, _338536, <--, [defn, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _8308), 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_defn_choose_candidates(=, _8308), 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty])), ignore(notrace((\+[empty]\=_310338, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_310208==1->ignore(\+ \+ (flag(eval_num, _338536, _338536+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _338536, <--, [defn, [empty]]);indentq(4, _338536, <--, [defn, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _338536, _338536+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _338536, <--, [defn, [empty]]);indentq(4, _338536, <--, [defn, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] trace_eval(eval_defn_choose_candidates(=, _8308), defn, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] eval_maybe_defn(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else(eval_maybe_defn(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), eval_maybe_subst(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(309) [user] if_or_else(eval_maybe_host_function(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), if_or_else(eval_maybe_defn(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), eval_maybe_subst(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty])))
   <span class="ansi1 ansi32"
>Exit: </span>(308) [user] if_or_else(eval_maybe_host_predicate(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), if_or_else(eval_maybe_host_function(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), if_or_else(eval_maybe_defn(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), eval_maybe_subst(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty]))))
   <span class="ansi1 ansi32"
>Exit: </span>(307) [user] if_or_else(eval_maybe_python(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), if_or_else(eval_maybe_host_predicate(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), if_or_else(eval_maybe_host_function(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), if_or_else(eval_maybe_defn(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), eval_maybe_subst(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty])))))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_70(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] check_returnval(=, _8308, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] check_returnval(=, _8308, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [user] eval_41(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] eval_40(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [empty]=_8338
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] [empty]=[empty]
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] eval_20(=, _8308, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] ignore(notrace((\+[empty]\=_8354, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_672668, _672670), once(user:(\+[empty]\=_8354, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_672668, _672670))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_672668, _672670))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_8354, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [system] ignore(user:notrace((\+[empty]\=_8354, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] ignore((_8346==1->ignore(\+ \+ (flag(eval_num, _8384, _8384+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _8384, <--, [e, [empty]]);indentq(4, _8384, <--, [e, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8384, _8384+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _8384, <--, [e, [empty]]);indentq(4, _8384, <--, [e, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] _8346==1
   <span class="ansi1 ansi31"
>Fail: </span>(305) [system] _8346==1
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] setup_call_cleanup('$notrace'(_679860, _679862), once(user:ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8384, _8384+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _8384, <--, [e, [empty]]);indentq(4, _8384, <--, [e, retval([empty])])))))))), '$restore_trace'(_679860, _679862))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] sig_atomic(system:'$notrace'(_679860, _679862))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8384, _8384+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _8384, <--, [e, [empty]]);indentq(4, _8384, <--, [e, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [system] ignore(user:(_8346==1->ignore(\+ \+ (flag(eval_num, _8384, _8384+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _8384, <--, [e, [empty]]);indentq(4, _8384, <--, [e, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8384, _8384+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _8384, <--, [e, [empty]]);indentq(4, _8384, <--, [e, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] call_cleanup(user:((call(eval_20(=, _8308), 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_20(=, _8308), 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty])), ignore(notrace((\+[empty]\=_8354, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_8346==1->ignore(\+ \+ (flag(eval_num, _8384, _8384+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _8384, <--, [e, [empty]]);indentq(4, _8384, <--, [e, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8384, _8384+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _8384, <--, [e, [empty]]);indentq(4, _8384, <--, [e, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] trace_eval(eval_20(=, _8308), e, 495, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_689260, _689262), once(user:self_eval0([empty])), '$restore_trace'(_689260, _689262))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_689260, _689262))
^  <span class="ansi1 ansi31"
>Fail: </span>(300) [user] self_eval([empty])
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] [empty]=@=['if-unify-or-empty', _8322, _8322]
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] eval_01(=, _8308, 495, '&self', [empty], _693364)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] [empty]\==[empty]
   <span class="ansi1 ansi32"
>Call: </span>(297) [lists] lists:member(_695422-_695424, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(298) [lists] lists:member_([], _695422-_695424, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(298) [lists] lists:member_([], 'Empty'-_6642, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(297) [lists] lists:member('Empty'-_6642, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi31"
>Fail: </span>(295) [user] eval_20(=, _7326, 496, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7988)
   <span class="ansi1 ansi32"
>Call: </span>(295) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(295) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] ignore((_7996==1->ignore(\+ \+ (flag(eval_num, _8034, _8034+1), (retval(fail)\=@=retval(fail), nonvar(_7988)->indentq(3, _8034, <--, [e, _7988]);indentq(3, _8034, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8034, _8034+1), (retval(fail)\=@=retval(fail), nonvar(_7988)->indentq(3, _8034, <--, [e, _7988]);indentq(3, _8034, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] _7996==1
   <span class="ansi1 ansi31"
>Fail: </span>(297) [system] _7996==1
^  <span class="ansi1 ansi32"
>Call: </span>(298) [system] setup_call_cleanup('$notrace'(_706618, _706620), once(user:ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8034, _8034+1), (retval(fail)\=@=retval(fail), nonvar(_7988)->indentq(3, _8034, <--, [e, _7988]);indentq(3, _8034, <--, [e, retval(fail)])))))))), '$restore_trace'(_706618, _706620))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] sig_atomic(system:'$notrace'(_706618, _706620))
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8034, _8034+1), (retval(fail)\=@=retval(fail), nonvar(_7988)->indentq(3, _8034, <--, [e, _7988]);indentq(3, _8034, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(295) [system] ignore(user:(_7996==1->ignore(\+ \+ (flag(eval_num, _8034, _8034+1), (retval(fail)\=@=retval(fail), nonvar(_7988)->indentq(3, _8034, <--, [e, _7988]);indentq(3, _8034, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8034, _8034+1), (retval(fail)\=@=retval(fail), nonvar(_7988)->indentq(3, _8034, <--, [e, _7988]);indentq(3, _8034, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(293) [system] call_cleanup(user:((call(eval_20(=, _7326), 496, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7988)*->nb_setarg(1, retval(fail), _7988);fail, trace, call(eval_20(=, _7326), 496, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7988)), ignore(notrace((\+_7988\=_8004, nb_setarg(1, retval(fail), _7988))))), user:ignore((_7996==1->ignore(\+ \+ (flag(eval_num, _8034, _8034+1), (retval(fail)\=@=retval(fail), nonvar(_7988)->indentq(3, _8034, <--, [e, _7988]);indentq(3, _8034, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8034, _8034+1), (retval(fail)\=@=retval(fail), nonvar(_7988)->indentq(3, _8034, <--, [e, _7988]);indentq(3, _8034, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(292) [user] trace_eval(eval_20(=, _7326), e, 496, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7988)
^  <span class="ansi1 ansi31"
>Fail: </span>(289) [user] eval_args(=, _7326, 497, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7346)
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] call(eval, [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7346)
   <span class="ansi1 ansi32"
>Call: </span>(287) [user] eval([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7346)
^  <span class="ansi1 ansi32"
>Call: </span>(288) [user] current_self(_716026)
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] nb_current(self_space, _716026)
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(288) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(288) [user] eval('&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7346)
   <span class="ansi1 ansi32"
>Call: </span>(289) [user] eval_H(500, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7346)
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] fast_option_value(compile, save)
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] atom(compile)
   <span class="ansi1 ansi32"
>Exit: </span>(291) [system] atom(compile)
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] current_prolog_flag(compile, save)
   <span class="ansi1 ansi31"
>Fail: </span>(291) [system] current_prolog_flag(compile, save)
^  <span class="ansi1 ansi31"
>Fail: </span>(290) [user] fast_option_value(compile, save)
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] catch_metta_return(eval_args(=, _730228, 500, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7346), _7346)
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] eval_args(=, _730228, 500, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7346)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] var([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] setup_call_cleanup('$notrace'(_733338, _733340), once(user:self_eval([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])), '$restore_trace'(_733338, _733340))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] sig_atomic(system:'$notrace'(_733338, _733340))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] setup_call_cleanup('$notrace'(_735426, _735428), once(user:nonvar(_7346)), '$restore_trace'(_735426, _735428))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] sig_atomic(system:'$notrace'(_735426, _735428))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] setup_call_cleanup('$notrace'(_737514, _737516), once(user:nonvar(_7346)), '$restore_trace'(_737514, _737516))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] sig_atomic(system:'$notrace'(_737514, _737516))
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] [['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] self_eval([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] setup_call_cleanup('$notrace'(_744670, _744672), once(user:self_eval0([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])), '$restore_trace'(_744670, _744672))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [system] sig_atomic(system:'$notrace'(_744670, _744672))
^  <span class="ansi1 ansi31"
>Fail: </span>(293) [user] self_eval([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] eval_00(=, _730228, 500, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7346)
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] self_eval([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])
^  <span class="ansi1 ansi32"
>Call: </span>(296) [system] setup_call_cleanup('$notrace'(_749814, _749816), once(user:self_eval0([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])), '$restore_trace'(_749814, _749816))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [system] sig_atomic(system:'$notrace'(_749814, _749816))
^  <span class="ansi1 ansi31"
>Fail: </span>(294) [user] self_eval([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] eval_01(=, _730228, 500, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7346)
   <span class="ansi1 ansi32"
>Call: </span>(295) [system] [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(295) [system] [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(297) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(295) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [system] setup_call_cleanup('$notrace'(_760088, _760090), once(user:(_760064 is 500-1, copy_term([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _760078))), '$restore_trace'(_760088, _760090))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [system] sig_atomic(system:'$notrace'(_760088, _760090))
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], [case, ['if-unify-or-empty', _762186, _762186], [['Empty', _762216]]]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] trace_eval(eval_20(=, _730228), e, 499, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _763252)
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] must_det_ll((notrace((flag(eval_num, _764306, _764306+1), _764324 is _764306 mod 500, _764342 is 99-499 mod 100, _764366=_764368, option_else('trace-length', _764380, 500), option_else('trace-depth', _764388, 30))), quietly(if_t((nop(stop_rtrace), _764324>_764380), (set_debug(eval, false), _764444 is _764380+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_764444])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_764496)))))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] once(user:(notrace((flag(eval_num, _764306, _764306+1), _764324 is _764306 mod 500, _764342 is 99-499 mod 100, _764366=_764368, option_else('trace-length', _764380, 500), option_else('trace-depth', _764388, 30))), quietly(if_t((nop(stop_rtrace), _764324>_764380), (set_debug(eval, false), _764444 is _764380+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_764444])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_764496)))))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] setup_call_cleanup('$notrace'(_766542, _766544), once(user:(flag(eval_num, _764306, _764306+1), _764324 is _764306 mod 500, _764342 is 99-499 mod 100, _764366=_764368, option_else('trace-length', _764380, 500), option_else('trace-depth', _764388, 30))), '$restore_trace'(_766542, _766544))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] sig_atomic(system:'$notrace'(_766542, _766544))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 579, 579+1), 79 is 579 mod 500, 0 is 99-499 mod 100, _764366=_764366, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _764444 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_764444])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _764444 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_764444])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(299) [user] nop(notrace(no_repeats_var(_764496)))
   <span class="ansi1 ansi32"
>Exit: </span>(299) [user] nop(notrace(no_repeats_var(_764496)))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [system] once(user:(notrace((flag(eval_num, 579, 579+1), 79 is 579 mod 500, 0 is 99-499 mod 100, _764366=_764366, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _764444 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_764444])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_764496)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] must_det_ll(user:(notrace((flag(eval_num, 579, 579+1), 79 is 579 mod 500, 0 is 99-499 mod 100, _764366=_764366, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _764444 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_764444])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_764496)))))
   <span class="ansi1 ansi32"
>Call: </span>(296) [occurs] occurs:sub_term(_776194, e)
   <span class="ansi1 ansi32"
>Exit: </span>(296) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(296) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(297) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(296) [occurs] occurs:sub_term(_776194, e)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] _783300=e
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] if_trace((eval;e), (_764366=1, indentq(0, 79, -->, [e, [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(298) [system] setup_call_cleanup('$notrace'(_786440, _786442), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _764366=1, indentq(0, 79, -->, [e, [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]]]))), _786398, fbug((_786398-->if_trace((eval;e), (_764366=1, indentq(0, 79, -->, [e, [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]]])))))))), '$restore_trace'(_786440, _786442))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] sig_atomic(system:'$notrace'(_786440, _786442))
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _764366=1, indentq(0, 79, -->, [e, [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]]]))), _786398, fbug((_786398-->if_trace((eval;e), (_764366=1, indentq(0, 79, -->, [e, [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] if_trace((eval;e), (_764366=1, indentq(0, 79, -->, [e, [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]]])))
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] _790636=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] _792674=(\+ \+ (flag(eval_num, _792694, _792694+1), (retval(fail)\=@=retval(fail), nonvar(_763252)->indentq(0, _792694, <--, [e, _763252]);indentq(0, _792694, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] (\+ \+ (flag(eval_num, _792694, _792694+1), (retval(fail)\=@=retval(fail), nonvar(_763252)->indentq(0, _792694, <--, [e, _763252]);indentq(0, _792694, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _792694, _792694+1), (retval(fail)\=@=retval(fail), nonvar(_763252)->indentq(0, _792694, <--, [e, _763252]);indentq(0, _792694, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] call_cleanup(((call(eval_20(=, _730228), 499, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _763252)*->nb_setarg(1, retval(fail), _763252);fail, trace, call(eval_20(=, _730228), 499, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _763252)), ignore(notrace((\+_763252\=_764496, nb_setarg(1, retval(fail), _763252))))), ignore((_764366==1->ignore(\+ \+ (flag(eval_num, _792694, _792694+1), (retval(fail)\=@=retval(fail), nonvar(_763252)->indentq(0, _792694, <--, [e, _763252]);indentq(0, _792694, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _792694, _792694+1), (retval(fail)\=@=retval(fail), nonvar(_763252)->indentq(0, _792694, <--, [e, _763252]);indentq(0, _792694, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] eval_20(=, _730228, 499, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _763252)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] atom([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] no_eval([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] self_eval([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_800082, _800084), once(user:self_eval0([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])), '$restore_trace'(_800082, _800084))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_800082, _800084))
^  <span class="ansi1 ansi31"
>Fail: </span>(300) [user] self_eval([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] atomic(case)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] atomic(case)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] is_sl(case)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] number(case)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] [['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] callable(case)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] callable(case)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] [['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] is_list([['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] is_list([['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] is_list(case)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] is_list([['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] is_list([['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] is_list([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] is_list([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] once(expand_eval([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _822426))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] expand_eval([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _822426)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] is_list([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] is_list([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] ground(case)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] ground(case)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] apply:maplist(expand_eval, [['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _828526)
   <span class="ansi1 ansi32"
>Call: </span>(302) [apply] apply:maplist_([['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _828526, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] expand_eval(['if-unify-or-empty', _6624, _6624], _830582)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list(['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list(['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] apply:maplist(expand_eval, [_6624, _6624], _835660)
   <span class="ansi1 ansi32"
>Call: </span>(305) [apply] apply:maplist_([_6624, _6624], _835660, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] expand_eval(_6624, _837716)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list(_6624)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _6624=_837716
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] _6624=_6624
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] expand_eval(_6624, _6624)
   <span class="ansi1 ansi32"
>Call: </span>(306) [apply] apply:maplist_([_6624], _837718, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] expand_eval(_6624, _843818)
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] is_list(_6624)
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] _6624=_843818
   <span class="ansi1 ansi32"
>Exit: </span>(308) [system] _6624=_6624
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] expand_eval(_6624, _6624)
   <span class="ansi1 ansi32"
>Call: </span>(307) [apply] apply:maplist_([], _843820, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(306) [apply] apply:maplist_([_6624], [_6624], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(305) [apply] apply:maplist_([_6624, _6624], [_6624, _6624], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [apply] apply:maplist(user:expand_eval, [_6624, _6624], [_6624, _6624])
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] expand_eval(['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Call: </span>(303) [apply] apply:maplist_([[['Empty', _6642]]], _830584, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] expand_eval([['Empty', _6642]], _856042)
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] is_list([['Empty', _6642]])
   <span class="ansi1 ansi32"
>Exit: </span>(305) [system] is_list([['Empty', _6642]])
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] ground(['Empty', _6642])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] apply:maplist(expand_eval, [], _859090)
   <span class="ansi1 ansi32"
>Call: </span>(306) [apply] apply:maplist_([], _859090, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(306) [apply] apply:maplist_([], [], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [apply] apply:maplist(user:expand_eval, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] expand_eval([['Empty', _6642]], [['Empty', _6642]])
   <span class="ansi1 ansi32"
>Call: </span>(304) [apply] apply:maplist_([], _856044, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [apply] apply:maplist_([[['Empty', _6642]]], [[['Empty', _6642]]], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [apply] apply:maplist_([['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], [['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [apply] apply:maplist(user:expand_eval, [['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], [['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] expand_eval([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [system] once(user:expand_eval([case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]]))
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]]\==[case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]]
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] is_progn(case)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] is_space_op(case)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] must_det_ll([]==[])
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] once(user:([]==[]))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] []==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [system] once(user:([]==[]))
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] must_det_ll(user:([]==[]))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] into_case_list([['Empty', _6642]], _884534)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] is_list([['Empty', _6642]])
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] is_list([['Empty', _6642]])
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] into_case_list([['Empty', _6642]], [['Empty', _6642]])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] into_case_keys(1, [['Empty', _6642]], _888592)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] _889632 is 1+1
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] 2 is 1+1
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] is_case(_889622, ['Empty', _6642], _889624)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] is_case('Empty', ['Empty', _6642], _6642)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_6642)))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_894798, _894800), once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_6642))), _894756, fbug((_894756-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_6642)))))))), '$restore_trace'(_894798, _894800))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_894798, _894800))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_6642))), _894756, fbug((_894756-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_6642)))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_6642)))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] into_case_keys(2, [], _889618)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] into_case_keys(2, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] into_case_keys(1, [['Empty', _6642]], ['Empty'-_6642])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] eval_case(=, _730228, 499, '&self', ['if-unify-or-empty', _6624, _6624], ['Empty'-_6642], _763252)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _6624, _6624]))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_904166, _904168), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _6624, _6624]))), _904124, fbug((_904124-->if_trace(case, writeqln(case=['if-unify-or-empty', _6624, _6624]))))))), '$restore_trace'(_904166, _904168))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_904166, _904168))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _6624, _6624]))), _904124, fbug((_904124-->if_trace(case, writeqln(case=['if-unify-or-empty', _6624, _6624]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _6624, _6624]))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] eval_args(=, _908488, 499, '&self', ['if-unify-or-empty', _6624, _6624], _908362)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] var(['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_910420, _910422), once(user:self_eval(['if-unify-or-empty', _6624, _6624])), '$restore_trace'(_910420, _910422))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_910420, _910422))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_912508, _912510), once(user:nonvar(_908362)), '$restore_trace'(_912508, _912510))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_912508, _912510))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_914596, _914598), once(user:nonvar(_908362)), '$restore_trace'(_914596, _914598))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_914596, _914598))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] [_6624, _6624]==[]
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] self_eval(['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] setup_call_cleanup('$notrace'(_921752, _921754), once(user:self_eval0(['if-unify-or-empty', _6624, _6624])), '$restore_trace'(_921752, _921754))
^  <span class="ansi1 ansi32"
>Call: </span>(304) [system] sig_atomic(system:'$notrace'(_921752, _921754))
^  <span class="ansi1 ansi31"
>Fail: </span>(301) [user] self_eval(['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] eval_00(=, _924840, 499, '&self', ['if-unify-or-empty', _6624, _6624], _908362)
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] self_eval(['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(304) [system] setup_call_cleanup('$notrace'(_926898, _926900), once(user:self_eval0(['if-unify-or-empty', _6624, _6624])), '$restore_trace'(_926898, _926900))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] sig_atomic(system:'$notrace'(_926898, _926900))
^  <span class="ansi1 ansi31"
>Fail: </span>(302) [user] self_eval(['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] eval_01(=, _924840, 499, '&self', ['if-unify-or-empty', _6624, _6624], _908362)
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] ['if-unify-or-empty', _6624, _6624]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] ['if-unify-or-empty', _6624, _6624]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] if_t((499<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] 499<1
   <span class="ansi1 ansi31"
>Fail: </span>(305) [system] 499<1
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] if_t((499<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(304) [system] setup_call_cleanup('$notrace'(_937172, _937174), once(user:(_937148 is 499-1, copy_term(['if-unify-or-empty', _6624, _6624], _937162))), '$restore_trace'(_937172, _937174))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] sig_atomic(system:'$notrace'(_937172, _937174))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(498 is 499-1, copy_term(['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _939258, _939258]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] trace_eval(eval_20(=, _924840), e, 498, '&self', ['if-unify-or-empty', _6624, _6624], _940300)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] must_det_ll((notrace((flag(eval_num, _941354, _941354+1), _941372 is _941354 mod 500, _941390 is 99-498 mod 100, _941414=_941416, option_else('trace-length', _941428, 500), option_else('trace-depth', _941436, 30))), quietly(if_t((nop(stop_rtrace), _941372>_941428), (set_debug(eval, false), _941492 is _941428+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_941492])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_941544)))))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] once(user:(notrace((flag(eval_num, _941354, _941354+1), _941372 is _941354 mod 500, _941390 is 99-498 mod 100, _941414=_941416, option_else('trace-length', _941428, 500), option_else('trace-depth', _941436, 30))), quietly(if_t((nop(stop_rtrace), _941372>_941428), (set_debug(eval, false), _941492 is _941428+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_941492])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_941544)))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_943590, _943592), once(user:(flag(eval_num, _941354, _941354+1), _941372 is _941354 mod 500, _941390 is 99-498 mod 100, _941414=_941416, option_else('trace-length', _941428, 500), option_else('trace-depth', _941436, 30))), '$restore_trace'(_943590, _943592))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_943590, _943592))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 580, 580+1), 80 is 580 mod 500, 1 is 99-498 mod 100, _941414=_941414, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 80>500), (set_debug(eval, false), _941492 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_941492])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 80>500), (set_debug(eval, false), _941492 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_941492])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(307) [user] nop(notrace(no_repeats_var(_941544)))
   <span class="ansi1 ansi32"
>Exit: </span>(307) [user] nop(notrace(no_repeats_var(_941544)))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] once(user:(notrace((flag(eval_num, 580, 580+1), 80 is 580 mod 500, 1 is 99-498 mod 100, _941414=_941414, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 80>500), (set_debug(eval, false), _941492 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_941492])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_941544)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] must_det_ll(user:(notrace((flag(eval_num, 580, 580+1), 80 is 580 mod 500, 1 is 99-498 mod 100, _941414=_941414, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 80>500), (set_debug(eval, false), _941492 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_941492])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_941544)))))
   <span class="ansi1 ansi32"
>Call: </span>(304) [occurs] occurs:sub_term(_953242, e)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(304) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(305) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(304) [occurs] occurs:sub_term(_953242, e)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _960348=e
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] if_trace((eval;e), (_941414=1, indentq(1, 80, -->, [e, ['if-unify-or-empty', _6624, _6624]])))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] setup_call_cleanup('$notrace'(_963488, _963490), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _941414=1, indentq(1, 80, -->, [e, ['if-unify-or-empty', _6624, _6624]]))), _963446, fbug((_963446-->if_trace((eval;e), (_941414=1, indentq(1, 80, -->, [e, ['if-unify-or-empty', _6624, _6624]])))))))), '$restore_trace'(_963488, _963490))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] sig_atomic(system:'$notrace'(_963488, _963490))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _941414=1, indentq(1, 80, -->, [e, ['if-unify-or-empty', _6624, _6624]]))), _963446, fbug((_963446-->if_trace((eval;e), (_941414=1, indentq(1, 80, -->, [e, ['if-unify-or-empty', _6624, _6624]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] if_trace((eval;e), (_941414=1, indentq(1, 80, -->, [e, ['if-unify-or-empty', _6624, _6624]])))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _967684=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _969722=(\+ \+ (flag(eval_num, _969742, _969742+1), (retval(fail)\=@=retval(fail), nonvar(_940300)->indentq(1, _969742, <--, [e, _940300]);indentq(1, _969742, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] (\+ \+ (flag(eval_num, _969742, _969742+1), (retval(fail)\=@=retval(fail), nonvar(_940300)->indentq(1, _969742, <--, [e, _940300]);indentq(1, _969742, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _969742, _969742+1), (retval(fail)\=@=retval(fail), nonvar(_940300)->indentq(1, _969742, <--, [e, _940300]);indentq(1, _969742, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] call_cleanup(((call(eval_20(=, _924840), 498, '&self', ['if-unify-or-empty', _6624, _6624], _940300)*->nb_setarg(1, retval(fail), _940300);fail, trace, call(eval_20(=, _924840), 498, '&self', ['if-unify-or-empty', _6624, _6624], _940300)), ignore(notrace((\+_940300\=_941544, nb_setarg(1, retval(fail), _940300))))), ignore((_941414==1->ignore(\+ \+ (flag(eval_num, _969742, _969742+1), (retval(fail)\=@=retval(fail), nonvar(_940300)->indentq(1, _969742, <--, [e, _940300]);indentq(1, _969742, <--, [e, retval(fail)]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _969742, _969742+1), (retval(fail)\=@=retval(fail), nonvar(_940300)->indentq(1, _969742, <--, [e, _940300]);indentq(1, _969742, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_20(=, _924840, 498, '&self', ['if-unify-or-empty', _6624, _6624], _940300)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] atom(['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] no_eval(['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] self_eval(['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_977130, _977132), once(user:self_eval0(['if-unify-or-empty', _6624, _6624])), '$restore_trace'(_977130, _977132))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_977130, _977132))
^  <span class="ansi1 ansi31"
>Fail: </span>(308) [user] self_eval(['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] atomic('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(308) [system] atomic('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] is_sl('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] number('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] [_6624, _6624]==[]
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _988324==eval
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] [_6624, _6624]==[]
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list([_6624, _6624])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] is_list([_6624, _6624])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list([_6624, _6624])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] is_list([_6624, _6624])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list(['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] is_list(['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] once(expand_eval(['if-unify-or-empty', _6624, _6624], _1000502))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] expand_eval(['if-unify-or-empty', _6624, _6624], _1000502)
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] is_list(['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Exit: </span>(309) [system] is_list(['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(309) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] apply:maplist(expand_eval, [_6624, _6624], _1006602)
   <span class="ansi1 ansi32"
>Call: </span>(310) [apply] apply:maplist_([_6624, _6624], _1006602, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] expand_eval(_6624, _1008658)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] is_list(_6624)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] _6624=_1008658
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] _6624=_6624
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] expand_eval(_6624, _6624)
   <span class="ansi1 ansi32"
>Call: </span>(311) [apply] apply:maplist_([_6624], _1008660, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] expand_eval(_6624, _1014760)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list(_6624)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _6624=_1014760
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] _6624=_6624
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] expand_eval(_6624, _6624)
   <span class="ansi1 ansi32"
>Call: </span>(312) [apply] apply:maplist_([], _1014762, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(312) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(311) [apply] apply:maplist_([_6624], [_6624], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [apply] apply:maplist_([_6624, _6624], [_6624, _6624], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [apply] apply:maplist(user:expand_eval, [_6624, _6624], [_6624, _6624])
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] expand_eval(['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [system] once(user:expand_eval(['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _6624, _6624]))
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] ['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] is_progn('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] is_space_op('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] arg(_1032182, v('catch!', 'throw!', 'number-of!', 'limit!', 'offset!', 'max-time!', 'findall!', 'setup-call-cleanup!', 'call-cleanup!', 'call-cleanup!', 'with-output-to!'), 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _1033080='if-unify-or-empty'
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] 'if-unify-or-empty'='if-unify-or-empty'
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _1035114)
^  <span class="ansi1 ansi31"
>Fail: </span>(307) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _1035114)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list(['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] is_list(['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] apply:maplist(self_eval, ['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Call: </span>(308) [apply] apply:maplist_(['if-unify-or-empty', _6624, _6624], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] self_eval('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] setup_call_cleanup('$notrace'(_1042248, _1042250), once(user:self_eval0('if-unify-or-empty')), '$restore_trace'(_1042248, _1042250))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] sig_atomic(system:'$notrace'(_1042248, _1042250))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0('if-unify-or-empty')), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] self_eval('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(309) [apply] apply:maplist_([_6624, _6624], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] self_eval(_6624)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_8666, _8668), once(user:self_eval0(_6624)), '$restore_trace'(_8666, _8668))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_8666, _8668))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_6624)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] self_eval(_6624)
   <span class="ansi1 ansi32"
>Call: </span>(310) [apply] apply:maplist_([_6624], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] self_eval(_6624)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] setup_call_cleanup('$notrace'(_14774, _14776), once(user:self_eval0(_6624)), '$restore_trace'(_14774, _14776))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(system:'$notrace'(_14774, _14776))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_6624)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] self_eval(_6624)
   <span class="ansi1 ansi32"
>Call: </span>(311) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(311) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [apply] apply:maplist_([_6624], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(309) [apply] apply:maplist_([_6624, _6624], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(308) [apply] apply:maplist_(['if-unify-or-empty', _6624, _6624], user:self_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [apply] apply:maplist(user:self_eval, ['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] ['if-unify-or-empty', _6624, _6624]=[_24992|_24994]
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] ['if-unify-or-empty', _6624, _6624]=['if-unify-or-empty', _6624, _6624]
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _29052=do_more_defs(true)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] do_more_defs(true)=do_more_defs(true)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] clause(eval_21(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _8346), _31104)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] 'if-unify-or-empty'==(/)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] 'if-unify-or-empty'== ===
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] 'if-unify-or-empty'== ====
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] eval_40(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] eval_selfless(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_selfless_0(['if-unify-or-empty', _6624, _6624], _35176)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] is_assignment('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(311) [system] atom('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] eval_selfless_1(['if-unify-or-empty', _6624, _6624], _35176)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] allow_clp
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] false_flag
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(313) [system] fail
^  <span class="ansi1 ansi31"
>Fail: </span>(312) [user] false_flag
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] eval_selfless_2(['if-unify-or-empty', _6624, _6624], _35176)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] fake_notrace((ground(['if-unify-or-empty', _6624, _6624]), ['if-unify-or-empty', _6624, _6624]=[_50400, _50406, _50412], atom(_50400), catch_warn(current_op(_50438, yfx, _50400)), ['if-unify-or-empty', _6624, _6624]\=[_50458], s2ps(['if-unify-or-empty', _6624, _6624], _50466)))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] real_notrace(user:(ground(['if-unify-or-empty', _6624, _6624]), ['if-unify-or-empty', _6624, _6624]=[_50400, _50406, _50412], atom(_50400), catch_warn(current_op(_50438, yfx, _50400)), ['if-unify-or-empty', _6624, _6624]\=[_50458], s2ps(['if-unify-or-empty', _6624, _6624], _50466)))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] setup_call_cleanup('$notrace'(_52500, _52502), once(user:(ground(['if-unify-or-empty', _6624, _6624]), ['if-unify-or-empty', _6624, _6624]=[_50400, _50406, _50412], atom(_50400), catch_warn(current_op(_50438, yfx, _50400)), ['if-unify-or-empty', _6624, _6624]\=[_50458], s2ps(['if-unify-or-empty', _6624, _6624], _50466))), '$restore_trace'(_52500, _52502))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(user:'$notrace'(_52500, _52502))
^  <span class="ansi1 ansi31"
>Fail: </span>(312) [user] real_notrace(user:(ground(['if-unify-or-empty', _6624, _6624]), ['if-unify-or-empty', _6624, _6624]=[_50400, _50406, _50412], atom(_50400), catch_warn(current_op(_50438, yfx, _50400)), ['if-unify-or-empty', _6624, _6624]\=[_50458], s2ps(['if-unify-or-empty', _6624, _6624], _50466)))
^  <span class="ansi1 ansi31"
>Fail: </span>(311) [user] fake_notrace(user:(ground(['if-unify-or-empty', _6624, _6624]), ['if-unify-or-empty', _6624, _6624]=[_50400, _50406, _50412], atom(_50400), catch_warn(current_op(_50438, yfx, _50400)), ['if-unify-or-empty', _6624, _6624]\=[_50458], s2ps(['if-unify-or-empty', _6624, _6624], _50466)))
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] 'if-unify-or-empty'==(==)
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] 'if-unify-or-empty'==(==)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] eval_41(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_adjust_args(=, _8316, _65688, _35176, 498, '&self', ['if-unify-or-empty', _6624, _6624], _65690)
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _8316, _65688, _35176, 498, '&self', ['if-unify-or-empty', _6624, _6624], _65690)), eval_adjust_args1(=, _8316, _65688, _35176, 498, '&self', ['if-unify-or-empty', _6624, _6624], _65690))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval_adjust_args2(=, _8316, _65688, _35176, 498, '&self', ['if-unify-or-empty', _6624, _6624], _65690)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] apply:maplist(must_eval_args(=, _72844, 498, '&self'), [_6624, _6624], _72838)
   <span class="ansi1 ansi32"
>Call: </span>(314) [apply] apply:maplist_([_6624, _6624], _72838, user:must_eval_args(=, _72844, 498, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] must_eval_args(=, _72844, 498, '&self', _6624, _74904)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] was_option_value(nodebug, _86068)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] current_prolog_flag(nodebug, _87086)
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] current_prolog_flag(nodebug, _87086)
   <span class="ansi1 ansi32"
>Call: </span>(321) [$syspreds] prolog_load_context(nodebug, _89120)
   <span class="ansi1 ansi31"
>Fail: </span>(321) [$syspreds] prolog_load_context(nodebug, _89120)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] nb_current(nodebug, _91154)
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] nb_current(nodebug, _91154)
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [user] was_option_value(nodebug, _86068)
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_97266, _97268), once(user:option_value0(nodebug, true)), '$restore_trace'(_97266, _97268))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_97266, _97268))
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(317) [prolog_debug] prolog_debug:debugging(metta(eval_args), _117606)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [prolog_debug] prolog_debug:debugging(metta(eval_args), _117606, _118750)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_122716, _122718, _122720), defined)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(320) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_122716, _122718, _122720))
   <span class="ansi1 ansi32"
>Call: </span>(321) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_122716, _122718, _122720))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] callable(debugging_logicmoo_setting(_122716, _122718, _122720))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] callable(debugging_logicmoo_setting(_122716, _122718, _122720))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(321) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_122716, _122718, _122720))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_122716, _122718, _122720))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_122716, _122718, _122720), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _117606, _134900)
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(317) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_args(=, _72844, 498, '&self', _6624, _74904)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] var(_6624)
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] var(_6624)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] nonvar(_74904)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_146126, _146128), once(user:self_eval(_6624)), '$restore_trace'(_146126, _146128))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_146126, _146128))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_6624)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] _74904=_6624
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] _6624=_6624
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] eval_args(=, _72844, 498, '&self', _6624, _6624)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] must_eval_args(=, _72844, 498, '&self', _6624, _6624)
   <span class="ansi1 ansi32"
>Call: </span>(315) [apply] apply:maplist_([_6624], _74906, user:must_eval_args(=, _72844, 498, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] must_eval_args(=, _72844, 498, '&self', _6624, _154390)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] was_option_value(nodebug, _165554)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] current_prolog_flag(nodebug, _166572)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [system] current_prolog_flag(nodebug, _166572)
   <span class="ansi1 ansi32"
>Call: </span>(322) [$syspreds] prolog_load_context(nodebug, _168606)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [$syspreds] prolog_load_context(nodebug, _168606)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] nb_current(nodebug, _170640)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [system] nb_current(nodebug, _170640)
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] was_option_value(nodebug, _165554)
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_176752, _176754), once(user:option_value0(nodebug, true)), '$restore_trace'(_176752, _176754))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_176752, _176754))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(318) [prolog_debug] prolog_debug:debugging(metta(eval_args), _197092)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [prolog_debug] prolog_debug:debugging(metta(eval_args), _197092, _198236)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_202202, _202204, _202206), defined)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(321) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(321) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_202202, _202204, _202206))
   <span class="ansi1 ansi32"
>Call: </span>(322) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_202202, _202204, _202206))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] callable(debugging_logicmoo_setting(_202202, _202204, _202206))
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] callable(debugging_logicmoo_setting(_202202, _202204, _202206))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_202202, _202204, _202206))
   <span class="ansi1 ansi32"
>Exit: </span>(321) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_202202, _202204, _202206))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_202202, _202204, _202206), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _197092, _214386)
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(318) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] eval_args(=, _72844, 498, '&self', _6624, _154390)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] var(_6624)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] var(_6624)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nonvar(_154390)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_225612, _225614), once(user:self_eval(_6624)), '$restore_trace'(_225612, _225614))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_225612, _225614))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_6624)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] _154390=_6624
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] _6624=_6624
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [user] eval_args(=, _72844, 498, '&self', _6624, _6624)
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] must_eval_args(=, _72844, 498, '&self', _6624, _6624)
   <span class="ansi1 ansi32"
>Call: </span>(316) [apply] apply:maplist_([], _154392, user:must_eval_args(=, _72844, 498, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(316) [apply] apply:maplist_([], [], user:must_eval_args(=, _72844, 498, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(315) [apply] apply:maplist_([_6624], [_6624], user:must_eval_args(=, _72844, 498, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(314) [apply] apply:maplist_([_6624, _6624], [_6624, _6624], user:must_eval_args(=, _72844, 498, '&self'))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [apply] apply:maplist(user:must_eval_args(=, _72844, 498, '&self'), [_6624, _6624], [_6624, _6624])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _65688=_35176
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] _35176=_35176
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] eval_adjust_args2(=, _8316, _35176, _35176, 498, '&self', ['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _8316, _35176, _35176, 498, '&self', ['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _6624, _6624])), eval_adjust_args1(=, _8316, _35176, _35176, 498, '&self', ['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _6624, _6624]))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_adjust_args(=, _8316, _35176, _35176, 498, '&self', ['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] if_trace((e;args), (['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _6624, _6624]->['if-unify-or-empty', _6624, _6624])));nop(indentq2(498, same(['if-unify-or-empty', _6624, _6624])))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] setup_call_cleanup('$notrace'(_244198, _244200), once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _6624, _6624]->['if-unify-or-empty', _6624, _6624])));nop(indentq2(498, same(['if-unify-or-empty', _6624, _6624])))))), _244156, fbug((_244156-->if_trace((e;args), (['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _6624, _6624]->['if-unify-or-empty', _6624, _6624])));nop(indentq2(498, same(['if-unify-or-empty', _6624, _6624])))))))))), '$restore_trace'(_244198, _244200))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] sig_atomic(system:'$notrace'(_244198, _244200))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _6624, _6624]->['if-unify-or-empty', _6624, _6624])));nop(indentq2(498, same(['if-unify-or-empty', _6624, _6624])))))), _244156, fbug((_244156-->if_trace((e;args), (['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _6624, _6624]->['if-unify-or-empty', _6624, _6624])));nop(indentq2(498, same(['if-unify-or-empty', _6624, _6624])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] if_trace((e;args), (['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _6624, _6624]->['if-unify-or-empty', _6624, _6624])));nop(indentq2(498, same(['if-unify-or-empty', _6624, _6624])))))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_70(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176)
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] if_or_else(eval_maybe_python(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176), if_or_else(eval_maybe_host_predicate(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176), if_or_else(eval_maybe_host_function(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176), if_or_else(eval_maybe_defn(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176), eval_maybe_subst(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176)))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] eval_maybe_python(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176)
   <span class="ansi1 ansi32"
>Call: </span>(312) [user] metta_atom('&self', ['registered-python-function', _251558, _251564, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] typed_list('&self', _252704, _252578)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(313) [user] typed_list('&self', _255748, _252578)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] metta_atom_in_file('&self', ['registered-python-function', _251558, _251564, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] metta_atom_in_file('&self', ['registered-python-function', _251558, _251564, 'if-unify-or-empty'], _258802, _258804)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] loaded_into_kb('&self', _259700)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] loaded_into_kb('&self', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] once(user:asserted_metta_pred(_265668, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] asserted_metta_pred(_265668, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] asserted_metta_pred(_265668, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] metta_atom_asserted('&self', ['registered-python-function', _251558, _251564, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] metta_atom_asserted_deduced('&self', ['registered-python-function', _251558, _251564, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] metta_atom('&corelib', ['registered-python-function', _251558, _251564, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] typed_list('&corelib', _289734, _289608)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] typed_list('&corelib', _292778, _289608)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] metta_atom_in_file('&corelib', ['registered-python-function', _251558, _251564, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] metta_atom_in_file('&corelib', ['registered-python-function', _251558, _251564, 'if-unify-or-empty'], _295832, _295834)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] loaded_into_kb('&corelib', _296730)
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] once(user:asserted_metta_pred(_302674, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] asserted_metta_pred(_302674, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] asserted_metta_pred(_302674, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] once(user:asserted_metta_pred(_322356, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] asserted_metta_pred(_322356, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] asserted_metta_pred(_322356, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(314) [user] metta_atom_asserted('&corelib', ['registered-python-function', _251558, _251564, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] metta_atom_asserted_deduced('&corelib', ['registered-python-function', _251558, _251564, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(311) [user] if_or_else(eval_maybe_host_predicate(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176), if_or_else(eval_maybe_host_function(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176), if_or_else(eval_maybe_defn(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176), eval_maybe_subst(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176))))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval_maybe_host_predicate(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] once((is_system_pred('if-unify-or-empty'), length([_6624, _6624], _347240), is_syspred('if-unify-or-empty', _347240, _347248)))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom_concat(_351432, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom_concat(_354476, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom_concat(_357520, '-p', 'if-unify-or-empty')
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [user] if_or_else(eval_maybe_host_function(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176), if_or_else(eval_maybe_defn(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176), eval_maybe_subst(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176)))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval_maybe_host_function(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom_concat(_366632, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom_concat(_369676, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom_concat(_372720, '-p', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] if_or_else(eval_maybe_defn(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176), eval_maybe_subst(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] eval_maybe_defn(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] trace_eval(eval_defn_choose_candidates(=, _8316), defn, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] must_det_ll((notrace((flag(eval_num, _382760, _382760+1), _382778 is _382760 mod 500, _382796 is 99-498 mod 100, _382820=_382822, option_else('trace-length', _382834, 500), option_else('trace-depth', _382842, 30))), quietly(if_t((nop(stop_rtrace), _382778>_382834), (set_debug(eval, false), _382898 is _382834+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_382898])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_382950)))))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] once(user:(notrace((flag(eval_num, _382760, _382760+1), _382778 is _382760 mod 500, _382796 is 99-498 mod 100, _382820=_382822, option_else('trace-length', _382834, 500), option_else('trace-depth', _382842, 30))), quietly(if_t((nop(stop_rtrace), _382778>_382834), (set_debug(eval, false), _382898 is _382834+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_382898])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_382950)))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_384996, _384998), once(user:(flag(eval_num, _382760, _382760+1), _382778 is _382760 mod 500, _382796 is 99-498 mod 100, _382820=_382822, option_else('trace-length', _382834, 500), option_else('trace-depth', _382842, 30))), '$restore_trace'(_384996, _384998))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_384996, _384998))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 581, 581+1), 81 is 581 mod 500, 1 is 99-498 mod 100, _382820=_382820, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 81>500), (set_debug(eval, false), _382898 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_382898])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 81>500), (set_debug(eval, false), _382898 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_382898])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(319) [user] nop(notrace(no_repeats_var(_382950)))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [user] nop(notrace(no_repeats_var(_382950)))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [system] once(user:(notrace((flag(eval_num, 581, 581+1), 81 is 581 mod 500, 1 is 99-498 mod 100, _382820=_382820, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 81>500), (set_debug(eval, false), _382898 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_382898])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_382950)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] must_det_ll(user:(notrace((flag(eval_num, 581, 581+1), 81 is 581 mod 500, 1 is 99-498 mod 100, _382820=_382820, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 81>500), (set_debug(eval, false), _382898 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_382898])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_382950)))))
   <span class="ansi1 ansi32"
>Call: </span>(316) [occurs] occurs:sub_term(_394648, defn)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [occurs] occurs:sub_term(defn, defn)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] defn\=defn
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] defn\=defn
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(316) [occurs] occurs:sub_term(_394648, defn)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] _401754=defn
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] defn=defn
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] if_trace((eval;defn), (_382820=1, indentq(1, 81, -->, [defn, ['if-unify-or-empty', _6624, _6624]])))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_404894, _404896), once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _382820=1, indentq(1, 81, -->, [defn, ['if-unify-or-empty', _6624, _6624]]))), _404852, fbug((_404852-->if_trace((eval;defn), (_382820=1, indentq(1, 81, -->, [defn, ['if-unify-or-empty', _6624, _6624]])))))))), '$restore_trace'(_404894, _404896))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_404894, _404896))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _382820=1, indentq(1, 81, -->, [defn, ['if-unify-or-empty', _6624, _6624]]))), _404852, fbug((_404852-->if_trace((eval;defn), (_382820=1, indentq(1, 81, -->, [defn, ['if-unify-or-empty', _6624, _6624]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] if_trace((eval;defn), (_382820=1, indentq(1, 81, -->, [defn, ['if-unify-or-empty', _6624, _6624]])))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] _409090=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] _411128=(\+ \+ (flag(eval_num, _411148, _411148+1), (retval(fail)\=@=retval(fail), nonvar(_35176)->indentq(1, _411148, <--, [defn, _35176]);indentq(1, _411148, <--, [defn, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] (\+ \+ (flag(eval_num, _411148, _411148+1), (retval(fail)\=@=retval(fail), nonvar(_35176)->indentq(1, _411148, <--, [defn, _35176]);indentq(1, _411148, <--, [defn, retval(fail)]))))=(\+ \+ (flag(eval_num, _411148, _411148+1), (retval(fail)\=@=retval(fail), nonvar(_35176)->indentq(1, _411148, <--, [defn, _35176]);indentq(1, _411148, <--, [defn, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] call_cleanup(((call(eval_defn_choose_candidates(=, _8316), 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176)*->nb_setarg(1, retval(fail), _35176);fail, trace, call(eval_defn_choose_candidates(=, _8316), 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176)), ignore(notrace((\+_35176\=_382950, nb_setarg(1, retval(fail), _35176))))), ignore((_382820==1->ignore(\+ \+ (flag(eval_num, _411148, _411148+1), (retval(fail)\=@=retval(fail), nonvar(_35176)->indentq(1, _411148, <--, [defn, _35176]);indentq(1, _411148, <--, [defn, retval(fail)]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _411148, _411148+1), (retval(fail)\=@=retval(fail), nonvar(_35176)->indentq(1, _411148, <--, [defn, _35176]);indentq(1, _411148, <--, [defn, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] eval_defn_choose_candidates(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] findall((_415490->_415492), get_defn_expansions(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _415490, _415492), _415510)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [$bags] findall((_415490->_415492), user:get_defn_expansions(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _415490, _415492), _415510, [])
^  <span class="ansi1 ansi32"
>Call: </span>(321) [$bags] cleanup_bag(findall_loop((_415490->_415492), user:get_defn_expansions(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _415490, _415492), _415510, []), '$destroy_findall_bag')
   <span class="ansi1 ansi32"
>Call: </span>(322) [$bags] findall_loop((_415490->_415492), user:get_defn_expansions(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _415490, _415492), _415510, [])
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] get_defn_expansions(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _415490, _415492)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] same_len_copy([_6624, _6624], _420682)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] length([_6624, _6624], _421700)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(_421700)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] var(_421700)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] []==[]
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _421700=2
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] 2=2
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] length([_6624, _6624], 2)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] length(_420682, 2)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(2)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] integer(2)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] integer(2)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _420682==[]
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(_420682)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] var(_420682)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] length([_436924, _436930], 2)
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [user] same_len_copy([_6624, _6624], [_436924, _436930])
   <span class="ansi1 ansi32"
>Call: </span>(324) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _436924, _436930], _415492)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] ignore((=)=(=))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] (=)=(=)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] (=)=(=)
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] ignore(user:((=)=(=)))
   <span class="ansi1 ansi32"
>Call: </span>(325) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _436924, _436930], _415492]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _436924, _436930], _415492]))
   <span class="ansi1 ansi32"
>Call: </span>(326) [user] metta_atom('&self', [=, ['if-unify-or-empty', _436924, _436930], _415492])
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] typed_list('&self', _446246, _446120)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(328) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(327) [user] typed_list('&self', _449290, _446120)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _436924, _436930], _415492])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _436924, _436930], _415492], _452344, _452346)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] loaded_into_kb('&self', _453242)
^  <span class="ansi1 ansi32"
>Exit: </span>(329) [user] loaded_into_kb('&self', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] once(user:asserted_metta_pred(_459210, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] asserted_metta_pred(_459210, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(330) [user] asserted_metta_pred(_459210, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(327) [user] metta_atom_asserted('&self', [=, ['if-unify-or-empty', _436924, _436930], _415492])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] metta_atom_asserted_deduced('&self', [=, ['if-unify-or-empty', _436924, _436930], _415492])
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(327) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _436924, _436930], _415492])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] typed_list('&corelib', _483276, _483150)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(329) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(328) [user] typed_list('&corelib', _486320, _483150)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _436924, _436930], _415492])
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _436924, _436930], _415492], _489374, _489376)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] loaded_into_kb('&corelib', _490272)
^  <span class="ansi1 ansi32"
>Exit: </span>(330) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] once(user:asserted_metta_pred(_496216, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] asserted_metta_pred(_496216, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(331) [user] asserted_metta_pred(_496216, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Exit: </span>(330) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] once(user:asserted_metta_pred(_515898, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] asserted_metta_pred(_515898, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(331) [user] asserted_metta_pred(_515898, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(328) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _436924, _436930], _415492])
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] metta_atom_asserted_deduced('&corelib', [=, ['if-unify-or-empty', _436924, _436930], _415492])
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] fail
   <span class="ansi1 ansi32"
>Exit: </span>(328) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _436924, _436924], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(327) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _436924, _436924], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(326) [user] metta_atom('&self', [=, ['if-unify-or-empty', _436924, _436924], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _436924, _436924], unified]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _436924, _436924], unified]))
   <span class="ansi1 ansi32"
>Exit: </span>(324) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _436924, _436924], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] get_defn_expansions(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _436924, _436924], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _436924, _436930], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(327) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _436924, _436930], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(326) [user] metta_atom('&self', [=, ['if-unify-or-empty', _436924, _436930], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _436924, _436930], [empty]]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _436924, _436930], [empty]]))
   <span class="ansi1 ansi32"
>Exit: </span>(324) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _436924, _436930], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] get_defn_expansions(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _436924, _436930], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(322) [$bags] findall_loop((_415490->_415492), user:get_defn_expansions(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _415490, _415492), [(['if-unify-or-empty', _548902, _548902]->unified), (['if-unify-or-empty', _548866, _548872]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [$bags] cleanup_bag('$bags':findall_loop((_415490->_415492), user:get_defn_expansions(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _415490, _415492), [(['if-unify-or-empty', _548902, _548902]->unified), (['if-unify-or-empty', _548866, _548872]->[empty])], []), '$bags':'$destroy_findall_bag')
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [$bags] findall((_415490->_415492), user:get_defn_expansions(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _415490, _415492), [(['if-unify-or-empty', _548902, _548902]->unified), (['if-unify-or-empty', _548866, _548872]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [$bags] findall((_415490->_415492), user:get_defn_expansions(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _415490, _415492), [(['if-unify-or-empty', _548902, _548902]->unified), (['if-unify-or-empty', _548866, _548872]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_defn_bodies(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176, [(['if-unify-or-empty', _548902, _548902]->unified), (['if-unify-or-empty', _548866, _548872]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _548902, _548902]->unified), (['if-unify-or-empty', _548866, _548872]->[empty])]))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_555134, _555136), once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(498, '   '), [(['if-unify-or-empty', _548902, _548902]->unified), (['if-unify-or-empty', _548866, _548872]->[empty])]))), _555092, fbug((_555092-->if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _548902, _548902]->unified), (['if-unify-or-empty', _548866, _548872]->[empty])]))))))), '$restore_trace'(_555134, _555136))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_555134, _555136))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(498, '   '), [(['if-unify-or-empty', _548902, _548902]->unified), (['if-unify-or-empty', _548866, _548872]->[empty])]))), _555092, fbug((_555092-->if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _548902, _548902]->unified), (['if-unify-or-empty', _548866, _548872]->[empty])]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _548902, _548902]->unified), (['if-unify-or-empty', _548866, _548872]->[empty])]))
   <span class="ansi1 ansi32"
>Call: </span>(320) [user] if_or_else((member((_559344->_559346), [(['if-unify-or-empty', _548902, _548902]->unified), (['if-unify-or-empty', _548866, _548872]->[empty])]), copy_term((_559344->_559346), _559358), eval_defn_success(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176, _559344, _559346, _559358)), eval_defn_failure(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176))
   <span class="ansi1 ansi32"
>Call: </span>(322) [lists] lists:member((_559344->_559346), [(['if-unify-or-empty', _548902, _548902]->unified), (['if-unify-or-empty', _548866, _548872]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(323) [lists] lists:member_([(['if-unify-or-empty', _548866, _548872]->[empty])], (_559344->_559346), (['if-unify-or-empty', _548902, _548902]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(323) [lists] lists:member_([(['if-unify-or-empty', _548866, _548872]->[empty])], (['if-unify-or-empty', _548902, _548902]->unified), (['if-unify-or-empty', _548902, _548902]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [lists] lists:member((['if-unify-or-empty', _548902, _548902]->unified), [(['if-unify-or-empty', _548902, _548902]->unified), (['if-unify-or-empty', _548866, _548872]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] copy_term((['if-unify-or-empty', _548902, _548902]->unified), _559358)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] copy_term((['if-unify-or-empty', _548902, _548902]->unified), (['if-unify-or-empty', _565508, _565508]->unified))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] eval_defn_success(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176, ['if-unify-or-empty', _548902, _548902], unified, (['if-unify-or-empty', _565508, _565508]->unified))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] ['if-unify-or-empty', _6624, _6624]=['if-unify-or-empty', _548902, _548902]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] ['if-unify-or-empty', _6624, _6624]=['if-unify-or-empty', _6624, _6624]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _35176=unified
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] unified=unified
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] ['if-unify-or-empty', _6624, _6624]\=@=unified
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] ['if-unify-or-empty', _6624, _6624]\=@=unified
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _565508, _565508]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_574756, _574758), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _565508, _565508]->unified)))))), _574714, fbug((_574714-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _565508, _565508]->unified)))))))))), '$restore_trace'(_574756, _574758))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_574756, _574758))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _565508, _565508]->unified)))))), _574714, fbug((_574714-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _565508, _565508]->unified)))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _565508, _565508]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] light_eval(=, _8316, 498, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] light_eval(=, _8316, 498, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] eval_defn_success(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified, ['if-unify-or-empty', _6624, _6624], unified, (['if-unify-or-empty', _565508, _565508]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_or_else((member((['if-unify-or-empty', _6624, _6624]->unified), [(['if-unify-or-empty', _6624, _6624]->unified), (['if-unify-or-empty', _548866, _548872]->[empty])]), copy_term((['if-unify-or-empty', _6624, _6624]->unified), (['if-unify-or-empty', _565508, _565508]->unified)), eval_defn_success(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified, ['if-unify-or-empty', _6624, _6624], unified, (['if-unify-or-empty', _565508, _565508]->unified))), eval_defn_failure(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] eval_defn_bodies(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified, [(['if-unify-or-empty', _6624, _6624]->unified), (['if-unify-or-empty', _548866, _548872]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] eval_defn_choose_candidates(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] ignore(notrace((\+unified\=_382950, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_588204, _588206), once(user:(\+unified\=_382950, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_588204, _588206))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_588204, _588206))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_382950, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] ignore(user:notrace((\+unified\=_382950, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _8316), 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_defn_choose_candidates(=, _8316), 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)), ignore(notrace((\+unified\=_382950, nb_setarg(1, retval(unified), unified))))), user:ignore((_382820==1->ignore(\+ \+ (flag(eval_num, _411148, _411148+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _411148, <--, [defn, unified]);indentq(1, _411148, <--, [defn, retval(unified)]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _411148, _411148+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _411148, <--, [defn, unified]);indentq(1, _411148, <--, [defn, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] trace_eval(eval_defn_choose_candidates(=, _8316), defn, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] eval_maybe_defn(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [user] if_or_else(eval_maybe_defn(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), eval_maybe_subst(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified))
   <span class="ansi1 ansi32"
>Exit: </span>(312) [user] if_or_else(eval_maybe_host_function(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), if_or_else(eval_maybe_defn(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), eval_maybe_subst(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)))
   <span class="ansi1 ansi32"
>Exit: </span>(311) [user] if_or_else(eval_maybe_host_predicate(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), if_or_else(eval_maybe_host_function(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), if_or_else(eval_maybe_defn(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), eval_maybe_subst(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified))))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else(eval_maybe_python(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), if_or_else(eval_maybe_host_predicate(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), if_or_else(eval_maybe_host_function(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), if_or_else(eval_maybe_defn(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), eval_maybe_subst(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_70(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] check_returnval(=, _8316, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] check_returnval(=, _8316, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] eval_41(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] eval_40(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] unified=_8346
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_20(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(306) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] ignore(notrace((\+unified\=_8362, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_612734, _612736), once(user:(\+unified\=_8362, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_612734, _612736))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_612734, _612736))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_8362, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] ignore(user:notrace((\+unified\=_8362, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [system] call_cleanup(user:((call(eval_20(=, _8316), 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_20(=, _8316), 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)), ignore(notrace((\+unified\=_8362, nb_setarg(1, retval(unified), unified))))), user:ignore((_8354==1->ignore(\+ \+ (flag(eval_num, _8392, _8392+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _8392, <--, [e, unified]);indentq(1, _8392, <--, [e, retval(unified)]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8392, _8392+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _8392, <--, [e, unified]);indentq(1, _8392, <--, [e, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] trace_eval(eval_20(=, _8316), e, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] self_eval(unified)
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_621968, _621970), once(user:self_eval0(unified)), '$restore_trace'(_621968, _621970))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_621968, _621970))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(unified)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] self_eval(unified)
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] _8314=unified
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [user] eval_01(=, _8316, 499, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] eval_00(=, _8316, 499, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] eval_args(=, _8316, 499, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_632286, _632288), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _632244, fbug((_632244-->if_trace(case, writeqln(switch=unified))))))), '$restore_trace'(_632286, _632288))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_632286, _632288))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _632244, fbug((_632244-->if_trace(case, writeqln(switch=unified))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] select_case(499, '&self', unified, ['Empty'-_6642], _636482)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] best_key(unified, ['Empty'-_6642], _636482)
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_638534-_636482, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(303) [lists] lists:member_([], _638534-_636482, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [lists] lists:member_([], 'Empty'-_6642, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [lists] lists:member('Empty'-_6642, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] unified='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_643628-_636482, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(303) [lists] lists:member_([], _643628-_636482, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [lists] lists:member_([], 'Empty'-_6642, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [lists] lists:member('Empty'-_6642, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] unified=='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_648722-_636482, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(303) [lists] lists:member_([], _648722-_636482, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [lists] lists:member_([], 'Empty'-_6642, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [lists] lists:member('Empty'-_6642, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] unified=@='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_653816-_636482, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(303) [lists] lists:member_([], _653816-_636482, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [lists] lists:member_([], 'Empty'-_6642, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [lists] lists:member('Empty'-_6642, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] unified='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] maybe_special_keys(499, '&self', ['Empty'-_6642], _658908)
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] eval_args(499, '&self', 'Empty', _659942)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_args(=, _661094, 499, '&self', 'Empty', _659942)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] var('Empty')
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_663026, _663028), once(user:self_eval('Empty')), '$restore_trace'(_663026, _663028))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_663026, _663028))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval('Empty')), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _659942='Empty'
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] 'Empty'='Empty'
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] eval_args(=, _668328, 499, '&self', 'Empty', 'Empty')
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [user] eval_args(499, '&self', 'Empty', 'Empty')
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] 'Empty'\=@='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] maybe_special_keys(499, '&self', [], _658908)
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [user] maybe_special_keys(499, '&self', [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] maybe_special_keys(499, '&self', ['Empty'-_6642], [])
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] best_key(unified, [], _636482)
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_675370-_636482, [])
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_676392-_636482, [])
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_677414-_636482, [])
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_678436-_636482, [])
   <span class="ansi1 ansi32"
>Call: </span>(301) [lists] lists:member(_679458-_636482, [])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member(_680480-_680482, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(301) [lists] lists:member_([], _680480-_680482, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [lists] lists:member_([], 'Empty'-_6642, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member('Empty'-_6642, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] 'Empty'=='%void%'
   <span class="ansi1 ansi32"
>Call: </span>(324) [lists] lists:member_([], (_559344->_559346), (['if-unify-or-empty', _548866, _548872]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(324) [lists] lists:member_([], (['if-unify-or-empty', _548866, _548872]->[empty]), (['if-unify-or-empty', _548866, _548872]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(323) [lists] lists:member_([(['if-unify-or-empty', _548866, _548872]->[empty])], (['if-unify-or-empty', _548866, _548872]->[empty]), (['if-unify-or-empty', _548902, _548902]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [lists] lists:member((['if-unify-or-empty', _548866, _548872]->[empty]), [(['if-unify-or-empty', _548902, _548902]->unified), (['if-unify-or-empty', _548866, _548872]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] copy_term((['if-unify-or-empty', _548866, _548872]->[empty]), _559358)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] copy_term((['if-unify-or-empty', _548866, _548872]->[empty]), (['if-unify-or-empty', _690680, _690686]->[empty]))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] eval_defn_success(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], _35176, ['if-unify-or-empty', _548866, _548872], [empty], (['if-unify-or-empty', _690680, _690686]->[empty]))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] ['if-unify-or-empty', _6624, _6624]=['if-unify-or-empty', _548866, _548872]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] ['if-unify-or-empty', _6624, _6624]=['if-unify-or-empty', _6624, _6624]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _35176=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] [empty]=[empty]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] ['if-unify-or-empty', _6624, _6624]\=@=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] ['if-unify-or-empty', _6624, _6624]\=@=[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _690680, _690686]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_699928, _699930), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _690680, _690686]->[empty])))))), _699886, fbug((_699886-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _690680, _690686]->[empty])))))))))), '$restore_trace'(_699928, _699930))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_699928, _699930))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _690680, _690686]->[empty])))))), _699886, fbug((_699886-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _690680, _690686]->[empty])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _690680, _690686]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] light_eval(=, _8316, 498, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] light_eval(=, _8316, 498, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] eval_defn_success(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty], ['if-unify-or-empty', _6624, _6624], [empty], (['if-unify-or-empty', _690680, _690686]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_or_else((member((['if-unify-or-empty', _6624, _6624]->[empty]), [(['if-unify-or-empty', _548902, _548902]->unified), (['if-unify-or-empty', _6624, _6624]->[empty])]), copy_term((['if-unify-or-empty', _6624, _6624]->[empty]), (['if-unify-or-empty', _690680, _690686]->[empty])), eval_defn_success(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty], ['if-unify-or-empty', _6624, _6624], [empty], (['if-unify-or-empty', _690680, _690686]->[empty]))), eval_defn_failure(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] eval_defn_bodies(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty], [(['if-unify-or-empty', _548902, _548902]->unified), (['if-unify-or-empty', _6624, _6624]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] eval_defn_choose_candidates(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] ignore(notrace((\+[empty]\=_382950, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_713384, _713386), once(user:(\+[empty]\=_382950, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_713384, _713386))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_713384, _713386))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_382950, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] ignore(user:notrace((\+[empty]\=_382950, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] ignore((_382820==1->ignore(\+ \+ (flag(eval_num, _411148, _411148+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _411148, <--, [defn, [empty]]);indentq(1, _411148, <--, [defn, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _411148, _411148+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _411148, <--, [defn, [empty]]);indentq(1, _411148, <--, [defn, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _382820==1
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] _382820==1
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_720576, _720578), once(user:ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _411148, _411148+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _411148, <--, [defn, [empty]]);indentq(1, _411148, <--, [defn, retval([empty])])))))))), '$restore_trace'(_720576, _720578))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_720576, _720578))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _411148, _411148+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _411148, <--, [defn, [empty]]);indentq(1, _411148, <--, [defn, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] ignore(user:(_382820==1->ignore(\+ \+ (flag(eval_num, _411148, _411148+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _411148, <--, [defn, [empty]]);indentq(1, _411148, <--, [defn, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _411148, _411148+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _411148, <--, [defn, [empty]]);indentq(1, _411148, <--, [defn, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _8316), 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_defn_choose_candidates(=, _8316), 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])), ignore(notrace((\+[empty]\=_382950, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_382820==1->ignore(\+ \+ (flag(eval_num, _411148, _411148+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _411148, <--, [defn, [empty]]);indentq(1, _411148, <--, [defn, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _411148, _411148+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _411148, <--, [defn, [empty]]);indentq(1, _411148, <--, [defn, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] trace_eval(eval_defn_choose_candidates(=, _8316), defn, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] eval_maybe_defn(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [user] if_or_else(eval_maybe_defn(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), eval_maybe_subst(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(312) [user] if_or_else(eval_maybe_host_function(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), if_or_else(eval_maybe_defn(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), eval_maybe_subst(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])))
   <span class="ansi1 ansi32"
>Exit: </span>(311) [user] if_or_else(eval_maybe_host_predicate(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), if_or_else(eval_maybe_host_function(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), if_or_else(eval_maybe_defn(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), eval_maybe_subst(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]))))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else(eval_maybe_python(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), if_or_else(eval_maybe_host_predicate(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), if_or_else(eval_maybe_host_function(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), if_or_else(eval_maybe_defn(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), eval_maybe_subst(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])))))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_70(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] check_returnval(=, _8316, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] check_returnval(=, _8316, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] eval_41(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] eval_40(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] [empty]=_8346
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] [empty]=[empty]
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_20(=, _8316, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(306) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] ignore(notrace((\+[empty]\=_8362, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_745280, _745282), once(user:(\+[empty]\=_8362, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_745280, _745282))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_745280, _745282))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_8362, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] ignore(user:notrace((\+[empty]\=_8362, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] ignore((_8354==1->ignore(\+ \+ (flag(eval_num, _8392, _8392+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _8392, <--, [e, [empty]]);indentq(1, _8392, <--, [e, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8392, _8392+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _8392, <--, [e, [empty]]);indentq(1, _8392, <--, [e, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] _8354==1
   <span class="ansi1 ansi31"
>Fail: </span>(308) [system] _8354==1
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_752472, _752474), once(user:ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8392, _8392+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _8392, <--, [e, [empty]]);indentq(1, _8392, <--, [e, retval([empty])])))))))), '$restore_trace'(_752472, _752474))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_752472, _752474))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8392, _8392+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _8392, <--, [e, [empty]]);indentq(1, _8392, <--, [e, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] ignore(user:(_8354==1->ignore(\+ \+ (flag(eval_num, _8392, _8392+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _8392, <--, [e, [empty]]);indentq(1, _8392, <--, [e, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8392, _8392+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _8392, <--, [e, [empty]]);indentq(1, _8392, <--, [e, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [system] call_cleanup(user:((call(eval_20(=, _8316), 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_20(=, _8316), 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])), ignore(notrace((\+[empty]\=_8362, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_8354==1->ignore(\+ \+ (flag(eval_num, _8392, _8392+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _8392, <--, [e, [empty]]);indentq(1, _8392, <--, [e, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8392, _8392+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _8392, <--, [e, [empty]]);indentq(1, _8392, <--, [e, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] trace_eval(eval_20(=, _8316), e, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_761872, _761874), once(user:self_eval0([empty])), '$restore_trace'(_761872, _761874))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_761872, _761874))
^  <span class="ansi1 ansi31"
>Fail: </span>(303) [user] self_eval([empty])
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] [empty]=@=['if-unify-or-empty', _8330, _8330]
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_01(=, _8316, 498, '&self', [empty], _765976)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [empty]\==[empty]
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member(_768034-_768036, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(301) [lists] lists:member_([], _768034-_768036, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [lists] lists:member_([], 'Empty'-_6642, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member('Empty'-_6642, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi31"
>Fail: </span>(298) [user] eval_20(=, _7894, 499, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7996)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(298) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] ignore((_8004==1->ignore(\+ \+ (flag(eval_num, _8042, _8042+1), (retval(fail)\=@=retval(fail), nonvar(_7996)->indentq(0, _8042, <--, [e, _7996]);indentq(0, _8042, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8042, _8042+1), (retval(fail)\=@=retval(fail), nonvar(_7996)->indentq(0, _8042, <--, [e, _7996]);indentq(0, _8042, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] _8004==1
   <span class="ansi1 ansi31"
>Fail: </span>(300) [system] _8004==1
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] setup_call_cleanup('$notrace'(_779230, _779232), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8042, _8042+1), (retval(fail)\=@=retval(fail), nonvar(_7996)->indentq(0, _8042, <--, [e, _7996]);indentq(0, _8042, <--, [e, retval(fail)])))))))), '$restore_trace'(_779230, _779232))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] sig_atomic(system:'$notrace'(_779230, _779232))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8042, _8042+1), (retval(fail)\=@=retval(fail), nonvar(_7996)->indentq(0, _8042, <--, [e, _7996]);indentq(0, _8042, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [system] ignore(user:(_8004==1->ignore(\+ \+ (flag(eval_num, _8042, _8042+1), (retval(fail)\=@=retval(fail), nonvar(_7996)->indentq(0, _8042, <--, [e, _7996]);indentq(0, _8042, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8042, _8042+1), (retval(fail)\=@=retval(fail), nonvar(_7996)->indentq(0, _8042, <--, [e, _7996]);indentq(0, _8042, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(296) [system] call_cleanup(user:((call(eval_20(=, _7894), 499, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7996)*->nb_setarg(1, retval(fail), _7996);fail, trace, call(eval_20(=, _7894), 499, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7996)), ignore(notrace((\+_7996\=_8012, nb_setarg(1, retval(fail), _7996))))), user:ignore((_8004==1->ignore(\+ \+ (flag(eval_num, _8042, _8042+1), (retval(fail)\=@=retval(fail), nonvar(_7996)->indentq(0, _8042, <--, [e, _7996]);indentq(0, _8042, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8042, _8042+1), (retval(fail)\=@=retval(fail), nonvar(_7996)->indentq(0, _8042, <--, [e, _7996]);indentq(0, _8042, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(295) [user] trace_eval(eval_20(=, _7894), e, 499, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7996)
^  <span class="ansi1 ansi31"
>Fail: </span>(292) [user] eval_args(=, _7894, 500, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7346)
^  <span class="ansi1 ansi31"
>Fail: </span>(283) [system] call(user:once, user:if_or_else(eval(=, _7326, 497, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7346), call(eval, [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7346)))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(285) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(287) [system] setup_call_cleanup('$notrace'(_790692, _790694), once(rtrace:retract(t_l:tracer_reset(_790682))), '$restore_trace'(_790692, _790694))
^  <span class="ansi1 ansi32"
>Call: </span>(288) [system] sig_atomic(system:'$notrace'(_790692, _790694))
^  <span class="ansi1 ansi32"
>Exit: </span>(287) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(287) [rtrace] tAt(false, 271, 271, false)
; 
; EVAL TEST
; took 0.600 secs. (599.77 milliseconds) 

!(assertEqualToResult (get-atoms &new-space) ((mod-space! stdlib)))

<span class="ansi31"
>#(loonit_failureR #(equal_enough_for_test ((mod-space! stdlib) (@doc Any (@desc "The universal type; any value belongs to this type.")) (: Any Type) (@doc Atom (@desc "Type representing any atom.")) (: Atom Type) (@doc LazyEvaluatable (@desc "A type of Atom/Value that hyperon does not implicitly evaluate")) (: LazyEvaluatable Type) (:> Atom LazyEvaluatable) (@doc Bool (@desc "Boolean type of True or False.")) (: Bool Type) (@doc LazyBool (@desc "A LazyEvaluatable that when evaluated returns True or False.")) (: LazyBool Type) (:> LazyBool LazyEvaluatable) (@doc Expression (@desc "Type representing an S-Expression, which is a combination of atoms.")) (: Expression Type) (:> Expression LazyEvaluatable) (@doc Number (@desc "Numeric type, including integers and floating-point numbers.")) (: Number Type) (@doc hyperon::space::DynSpace (@desc "Dynamic space type, representing an Atomspace.")) (: hyperon::space::DynSpace Type) (@doc ReturnType (@desc "Type representing a function's return value.")) (: ReturnType Type) (@doc Symbol (@desc "Type representing a symbol or identifier.")) (: Symbol Type) (@doc StateMonad (@desc "Type representing a state monad, used for encapsulating stateful computations.")) (: StateMonad Type) (@doc Type (@desc "Type representing a type.")) (: Type Type) (@doc True (@desc "Boolean value representing truth.")) (: True Bool) (@doc False (@desc "Boolean value representing falsehood.")) (: False Bool) (@doc %Undefined% (@desc "Special type representing an undefined value or type.")) (: %Undefined% Type) (@doc Variable (@desc "Type representing a variable in the language.")) (: Variable Type) (@doc : (@desc "Type declarion operator")) (@doc <: (@desc "Super Type declarion operator")) (: : %Undefined%) (: if-empty (-> Atom Atom Atom Atom)) (: if-non-empty-expression (-> Atom Atom Atom Atom)) (: if-not-reducible (-> Atom Atom Atom Atom)) (: return (-> Atom ReturnType)) (: switch (-> %Undefined% Expression Atom)) (: unify (-> Atom Atom Atom Atom %Undefined%)) (: get-type (-> Atom Type)) (: get-type0 (-> Atom Atom)) (: get-ftype (-> Atom Atom)) (: pragma! (-> Atom Atom (->))) (: = (-> Atom Atom %Undefined%)) (: match (-> hyperon::space::DynSpace Atom Atom %Undefined%)) (: case (-> Expression Atom Atom)) (: combine (-> $10000 $10000 $10000)) (: import! (-> hyperon::space::DynSpace Atom (->))) (: If (-> Bool Atom Atom Atom)) (: If (-> Bool Atom Atom)) (= (If True $10001)  $10001) (= (If False $10002)  
  (let $10003 0 
    (let $10003 1 $10003))) (= (If $10004 $10005 $10006)  
  (if $10004 $10005 $10006)) (iz predicate-arity MeTTaLog) (@doc predicate-arity (@desc "Specifies the arity (number of arguments) for a given predicate, allowing it to be queriable in the system's match framework. This is particularly useful for enabling built-in functions, such as `size-atom`, to be used as predicates in declarative contexts and run in reverse to compute inputs based on outputs.\n\nFor example:\n  ; Enable the built-in function `size-atom` that takes an atom and returns the size\n    as a predicate with arity 2\n  (add-atom &dyn-space (predicate-arity size-atom 2))\n\n  ; Now `size-atom` can be used as a predicate in pattern matching\n  (match &dyn-space '(size-atom (a b c) $size) \n         (The abc tuple was len $size))\n  ; This pattern will resolve `Size = 3` and execute the action.\n\nAdditionally, by running `size-atom` in reverse, you can compute a new atom based on a desired size:\n  (match &dyn-space '(size-atom $new-atom 4) \n         (The new atom is $new-atom))\n  ; This resolves `$new-atom` to a tuple of size 4, such as ($1 $2 $3 $4).\n\nThis reverse functionality is made possible because predicates can describe relationships, allowing you to infer inputs from outputs.") (@params ((@param "Predicate symbol" "The name of the predicate whose arity is being defined."))) (@return "The number of arguments required for the predicate.")) (: predicate-arity (-> Symbol Number)) (predicate-arity predicate-arity 2) (function-arity predicate-arity 1) (@doc function-arity (@desc "Defines the arity of a function, allowing predicates or built-in facts to also behave as callable functions. This enables procedural-style execution where the last argument of the predicate becomes the function's return value, and the system internally resolves the function using a `match` query. \n\nFor example:\n  ; Declare the built-in predicate `max` with arity 2\n  (predicate-arity max 2)\n\n  ; Enable `max` as a function\n  (add-atom &dyn-space (function-arity max 2))\n\n  ; Define the rules for `max`\n  (add-atom &dyn-space (max $X $Y $X) (<= $X $Y))\n  (add-atom &dyn-space (max $X $Y $Y) (> $X $Y))\n\n  ; Using `max` declaratively as a predicate\n  (match &dyn-space (max (5 10) $max)\n         (The maximum is $max))\n  ; This resolves `$max = 10`.\n\n  ; Using `max` procedurally as a function\n  (max 5 10)\n  ; Returns: 10.\n\n  ; Reverse execution with `max`\n  (max $pair 10)\n  ; Returns: a pair such as (8 10) or (10 5) where the maximum is 10.\n\n  This dual behavior allows predicates to act as functions, bridging procedural and declarative paradigms. By defining `function-arity`, the function automatically resolves using the logic of the associated predicate.") (@params ((@param "Function symbol" "The name of the function or predicate to enable as a callable function."))) (@return "The number of arguments expected by the function.")) (: function-arity (-> Symbol Number)) (predicate-arity function-arity 2) (function-arity function-arity 1) (iz If MeTTa) (@doc If (@desc "Conditional function that evaluates and returns one of the provided atoms based on a boolean condition.") (@params ((@param "Boolean condition") (@param "Atom to return if condition is True") (@param "Atom to return if condition is False (optional)"))) (@return "Either the second or third argument depending on the condition")) (predicate-arity : 2) (= (: $10007 P1)  
  (predicate-arity $10007 1)) (iz SrcPredicate MeTTa) (@doc SrcPredicate (@desc "Type representing a source predicate.")) (: SrcPredicate Type) (iz SrcFunction MeTTa) (@doc SrcFunction (@desc "Type representing a source function.")) (: SrcFunction Type) (iz MeTTaResult MeTTa) (@doc MeTTaResult (@desc "Type representing the result of a MeTTa evaluation.")) (: MeTTaResult Type) (iz NotReducible MeTTaResult) (@doc NotReducible (@desc "Result indicating that an atom cannot be reduced further.")) (: NotReducible MeTTaResult) (iz ValueAtom MeTTa) (@doc ValueAtom (@desc "Type representing a value atom.")) (:> ValueAtom Atom) (iz ForeignObject MeTTa) (@doc ForeignObject (@desc "Type representing a foreign object, such as a Python object.")) (: ForeignObject Type) (:> ValueAtom Grounded) (:> ForeignObject ValueAtom) (iz PyObject MeTTa) (@doc PyObject (@desc "Type representing a Python object.")) (:> PyObject ForeignObject) (:> hyperon::space::DynSpace Grounded) (iz py-list MeTTa) (@doc py-list (@desc "Converts a MeTTa Expression into a Python list and returns it as a PyObject.") (@params ((@param (@desc "A MeTTa List that will be converted into a Python list")))) (@return (@desc "A Python list object that represents the given MeTTa Expression as a PyObject"))) (: py-list (-> Expression PyObject)) (iz py-chain MeTTa) (@doc py-chain (@desc "Chains together a list of Python objects contained in a MeTTa Expression, applying the Python vertical bar | OR operation jointly to all elements.") (@params ((@param (@desc "A MeTTa list of atoms, each embedding a Python object.")))) (@return (@desc "A MeTTa atom which embeds the result of applying the Python OR | operator to all elements of the list."))) (: py-chain (-> Expression PyObject)) (iz py-eval MeTTaLog) (@doc py-eval (@desc "Evaluates a Python expression from a string and returns the result as a PyObject.") (@params ((@param (@desc "A string representing a Python expression that will be evaluated")))) (@return (@desc "The result of evaluating the Python expression as a PyObject"))) (: py-eval (-> String PyObject)) (iz py-exec! MeTTaLog) (@doc py-exec! (@desc "Executes some Python sourcecode from a string !(py-exec! \"import torch\") -> True.  !(py-exec! \"import torche\") -> False. ") (@params ((@param (@type String) (@desc "A string representing a Python sourcecode that will be executed")))) (@return (@desc "The True|False results of executing the Python expression"))) (: py-exec! (-> String Bool)) (iz = MeTTa) (@doc = (@desc "A symbol used to define reduction rules for expressions.") (@params ((@param "Pattern to be matched against expression to be reduced") (@param "Result of reduction or transformation of the first pattern"))) (@return "Not reduced itself unless custom equalities over equalities are added")) (: = (-> $10008 $10008 Atom)) (: = (-> Atom Atom Atom)) (iz ErrorType MeTTa) (@doc ErrorType (@desc "Type of the atom which contains error")) (: ErrorType Type) (iz Error MeTTa) (@doc Error (@desc "Error constructor") (@params ((@param "Atom which contains error") (@param "Error message, can be one of the reserved symbols: BadType, IncorrectNumberOfArguments"))) (@return "Instance of the error atom")) (: Error (-> Atom Atom ErrorType)) (iz return MinimalMeTTa) (@doc return (@desc "Returns value from the (function ...) expression") (@params ((@param "Value to be returned"))) (@return "Passed argument")) (: return (-> $10009 $10009)) (iz function MinimalMeTTa) (@doc function (@desc "Evaluates the argument until it becomes (return <result>). Then (function (return <result>)) is reduced to the <result>.") (@params ((@param "Atom to be evaluated"))) (@return "Result of atom's evaluation")) (: function (-> Atom Atom)) (iz eval MinimalMeTTa) (@doc eval (@desc "Evaluates input Atom, performs one step of the evaluation. Empty results (Empty, ()) are removed from the result set. If no results are produced for a non-grounded function, eval returns NotReducible.") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function"))) (@return "Result of evaluation")) (: eval (-> Atom Atom)) (@doc evalc (@desc "Evaluates input atom, makes one step of the evaluation") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function") (@param "Space to evaluate atom in its context"))) (@return "Result of evaluation")) (: evalc (-> Atom Grounded Atom)) (iz chain MinimalMeTTa) (@doc chain (@desc "Evaluates first argument Atom, binds it to the Variable (second argument) and then evaluates third argument Template with Variable substituted in. When evaluation of the first Atom brings more than a single result, chain returns one instance of the Template expression for each result. The first argument Atom is only evaluated if it is part of the Minimal MeTTa specification; evaluation of non-Minimal MeTTa atoms can be controlled by wrapping in a call to eval (for one evaluation step) or metta (for full evaluation).") (@params ((@param "Atom to be evaluated") (@param "Variable") (@param "Template which will be evaluated at the end with Variable substituted"))) (@return "Result of evaluating third input argument")) (: chain (-> Atom Variable Atom Atom)) (iz unify MeTTa) (@doc unify (@desc "Like Match but allows any sort of container for the first argument. (Match only allows MeTTa spaces.)") (@params ((@param "The collection or space to match") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when found or fourth one otherwise")) (: unify (-> Atom Atom Atom Atom Atom)) (iz if-unify MinimalMeTTaHelper) (@doc if-unify (@desc "Matches two first terms and returns third argument if they are matched and fourth argument otherwise") (@params ((@param "First term to unify with") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when first two atoms are unifiable or fourth one otherwise")) (: if-unify (-> Atom Atom Atom Atom %Undefined%)) (ALT= $10010 $10010) (iz if-unify-or-empty MinimalMeTTaHelper) (@doc if-unify-or-empty (@desc "Attempts to unify two atoms and returns a result. Returns Empty if they cannot be unified.") (@params ((@param "First atom") (@param "Second atom"))) (@return "Unification result or Empty")) (: if-unify-or-empty (-> Atom Atom Atom)) (= (if-unify-or-empty $10011 $10011)  unified) (= (if-unify-or-empty $10012 $10013)  
  (empty)) (iz cons-atom MinimalMeTTa) (@doc cons-atom (@desc "Constructs an expression using two arguments") (@params ((@param "Head of an expression") (@param "Tail of an expression"))) (@return "New expression consisting of the two input arguments")) (: cons-atom (-> Atom Expression Expression)) (iz decons-atom MinimalMeTTa) (@doc decons-atom (@desc "Works as a reverse to cons-atom function. It gets Expression as an input and returns it split into head and tail, e.g. (decons-atom (Cons X Nil)) -> (Cons (X Nil))") (@params ((@param "Expression to be Deconsed"))) (@return "Deconsed expression")) (: decons-atom (-> Expression Expression)) (iz min-atom MeTTa) (@doc min-atom (@desc "Returns atom with minimum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Minimum value in the expression. Error if expression contains non-numeric value or is empty.")) (: min-atom (-> Expression Number)) (= (min-atom $10014)  
  (call-fn! min_list $10014)) (iz max-atom MeTTa) (@doc max-atom (@desc "Returns atom with maximum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Maximum value in the expression. Error if expression contains non-numeric value or is empty.")) (: max-atom (-> Expression Number)) (is-fn-1 max-atom max_list) (iz size-atom MeTTa) (@doc size-atom (@desc "Returns the size of an expression (first argument).") (@params ((@param "Expression to measure the size of"))) (@return "Size of the expression")) (: size-atom (-> Expression Integer)) (is-fn-1 size-atom length) (iz index-atom MeTTa) (@doc index-atom (@desc "Returns atom from an expression (first argument) using index (second argument) or error if index is out of bounds.") (@params ((@param "Expression") (@param "Index"))) (@return "Atom at the specified index in the expression. Error if index is out of bounds.")) (: index-atom (-> Expression Number Atom)) (is-fn-21 index-atom nth0) (iz powi MeTTa) (@doc powi (@desc "Takes base (first argument) and power (second argument) and returns the result of raising the base to the power.") (@params ((@param "Base. Could be a float.") (@param "Power. Must be an integer."))) (@return "Result of base raised to the power")) (= (powi $10015 $10016)  
  (call-fn! pow $10015 $10016)) (==> (is-op-1 $10017 $10018) (is-fn-1 $10017 $10018))) ((mod-space! stdlib))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((mod-space! stdlib) (@doc Any (@desc "The universal type; any value belongs to this type.")) (: Any Type) (@doc Atom (@desc "Type representing any atom.")) (: Atom Type) (@doc LazyEvaluatable (@desc "A type of Atom/Value that hyperon does not implicitly evaluate")) (: LazyEvaluatable Type) (:> Atom LazyEvaluatable) (@doc Bool (@desc "Boolean type of True or False.")) (: Bool Type) (@doc LazyBool (@desc "A LazyEvaluatable that when evaluated returns True or False.")) (: LazyBool Type) (:> LazyBool LazyEvaluatable) (@doc Expression (@desc "Type representing an S-Expression, which is a combination of atoms.")) (: Expression Type) (:> Expression LazyEvaluatable) (@doc Number (@desc "Numeric type, including integers and floating-point numbers.")) (: Number Type) (@doc hyperon::space::DynSpace (@desc "Dynamic space type, representing an Atomspace.")) (: hyperon::space::DynSpace Type) (@doc ReturnType (@desc "Type representing a function's return value.")) (: ReturnType Type) (@doc Symbol (@desc "Type representing a symbol or identifier.")) (: Symbol Type) (@doc StateMonad (@desc "Type representing a state monad, used for encapsulating stateful computations.")) (: StateMonad Type) (@doc Type (@desc "Type representing a type.")) (: Type Type) (@doc True (@desc "Boolean value representing truth.")) (: True Bool) (@doc False (@desc "Boolean value representing falsehood.")) (: False Bool) (@doc %Undefined% (@desc "Special type representing an undefined value or type.")) (: %Undefined% Type) (@doc Variable (@desc "Type representing a variable in the language.")) (: Variable Type) (@doc : (@desc "Type declarion operator")) (@doc <: (@desc "Super Type declarion operator")) (: : %Undefined%) (: if-empty (-> Atom Atom Atom Atom)) (: if-non-empty-expression (-> Atom Atom Atom Atom)) (: if-not-reducible (-> Atom Atom Atom Atom)) (: return (-> Atom ReturnType)) (: switch (-> %Undefined% Expression Atom)) (: unify (-> Atom Atom Atom Atom %Undefined%)) (: get-type (-> Atom Type)) (: get-type0 (-> Atom Atom)) (: get-ftype (-> Atom Atom)) (: pragma! (-> Atom Atom (->))) (: = (-> Atom Atom %Undefined%)) (: match (-> hyperon::space::DynSpace Atom Atom %Undefined%)) (: case (-> Expression Atom Atom)) (: combine (-> $10000 $10000 $10000)) (: import! (-> hyperon::space::DynSpace Atom (->))) (: If (-> Bool Atom Atom Atom)) (: If (-> Bool Atom Atom)) (= (If True $10001)  $10001) (= (If False $10002)  
  (let $10003 0 
    (let $10003 1 $10003))) (= (If $10004 $10005 $10006)  
  (if $10004 $10005 $10006)) (iz predicate-arity MeTTaLog) (@doc predicate-arity (@desc "Specifies the arity (number of arguments) for a given predicate, allowing it to be queriable in the system's match framework. This is particularly useful for enabling built-in functions, such as `size-atom`, to be used as predicates in declarative contexts and run in reverse to compute inputs based on outputs.\n\nFor example:\n  ; Enable the built-in function `size-atom` that takes an atom and returns the size\n    as a predicate with arity 2\n  (add-atom &dyn-space (predicate-arity size-atom 2))\n\n  ; Now `size-atom` can be used as a predicate in pattern matching\n  (match &dyn-space '(size-atom (a b c) $size) \n         (The abc tuple was len $size))\n  ; This pattern will resolve `Size = 3` and execute the action.\n\nAdditionally, by running `size-atom` in reverse, you can compute a new atom based on a desired size:\n  (match &dyn-space '(size-atom $new-atom 4) \n         (The new atom is $new-atom))\n  ; This resolves `$new-atom` to a tuple of size 4, such as ($1 $2 $3 $4).\n\nThis reverse functionality is made possible because predicates can describe relationships, allowing you to infer inputs from outputs.") (@params ((@param "Predicate symbol" "The name of the predicate whose arity is being defined."))) (@return "The number of arguments required for the predicate.")) (: predicate-arity (-> Symbol Number)) (predicate-arity predicate-arity 2) (function-arity predicate-arity 1) (@doc function-arity (@desc "Defines the arity of a function, allowing predicates or built-in facts to also behave as callable functions. This enables procedural-style execution where the last argument of the predicate becomes the function's return value, and the system internally resolves the function using a `match` query. \n\nFor example:\n  ; Declare the built-in predicate `max` with arity 2\n  (predicate-arity max 2)\n\n  ; Enable `max` as a function\n  (add-atom &dyn-space (function-arity max 2))\n\n  ; Define the rules for `max`\n  (add-atom &dyn-space (max $X $Y $X) (<= $X $Y))\n  (add-atom &dyn-space (max $X $Y $Y) (> $X $Y))\n\n  ; Using `max` declaratively as a predicate\n  (match &dyn-space (max (5 10) $max)\n         (The maximum is $max))\n  ; This resolves `$max = 10`.\n\n  ; Using `max` procedurally as a function\n  (max 5 10)\n  ; Returns: 10.\n\n  ; Reverse execution with `max`\n  (max $pair 10)\n  ; Returns: a pair such as (8 10) or (10 5) where the maximum is 10.\n\n  This dual behavior allows predicates to act as functions, bridging procedural and declarative paradigms. By defining `function-arity`, the function automatically resolves using the logic of the associated predicate.") (@params ((@param "Function symbol" "The name of the function or predicate to enable as a callable function."))) (@return "The number of arguments expected by the function.")) (: function-arity (-> Symbol Number)) (predicate-arity function-arity 2) (function-arity function-arity 1) (iz If MeTTa) (@doc If (@desc "Conditional function that evaluates and returns one of the provided atoms based on a boolean condition.") (@params ((@param "Boolean condition") (@param "Atom to return if condition is True") (@param "Atom to return if condition is False (optional)"))) (@return "Either the second or third argument depending on the condition")) (predicate-arity : 2) (= (: $10007 P1)  
  (predicate-arity $10007 1)) (iz SrcPredicate MeTTa) (@doc SrcPredicate (@desc "Type representing a source predicate.")) (: SrcPredicate Type) (iz SrcFunction MeTTa) (@doc SrcFunction (@desc "Type representing a source function.")) (: SrcFunction Type) (iz MeTTaResult MeTTa) (@doc MeTTaResult (@desc "Type representing the result of a MeTTa evaluation.")) (: MeTTaResult Type) (iz NotReducible MeTTaResult) (@doc NotReducible (@desc "Result indicating that an atom cannot be reduced further.")) (: NotReducible MeTTaResult) (iz ValueAtom MeTTa) (@doc ValueAtom (@desc "Type representing a value atom.")) (:> ValueAtom Atom) (iz ForeignObject MeTTa) (@doc ForeignObject (@desc "Type representing a foreign object, such as a Python object.")) (: ForeignObject Type) (:> ValueAtom Grounded) (:> ForeignObject ValueAtom) (iz PyObject MeTTa) (@doc PyObject (@desc "Type representing a Python object.")) (:> PyObject ForeignObject) (:> hyperon::space::DynSpace Grounded) (iz py-list MeTTa) (@doc py-list (@desc "Converts a MeTTa Expression into a Python list and returns it as a PyObject.") (@params ((@param (@desc "A MeTTa List that will be converted into a Python list")))) (@return (@desc "A Python list object that represents the given MeTTa Expression as a PyObject"))) (: py-list (-> Expression PyObject)) (iz py-chain MeTTa) (@doc py-chain (@desc "Chains together a list of Python objects contained in a MeTTa Expression, applying the Python vertical bar | OR operation jointly to all elements.") (@params ((@param (@desc "A MeTTa list of atoms, each embedding a Python object.")))) (@return (@desc "A MeTTa atom which embeds the result of applying the Python OR | operator to all elements of the list."))) (: py-chain (-> Expression PyObject)) (iz py-eval MeTTaLog) (@doc py-eval (@desc "Evaluates a Python expression from a string and returns the result as a PyObject.") (@params ((@param (@desc "A string representing a Python expression that will be evaluated")))) (@return (@desc "The result of evaluating the Python expression as a PyObject"))) (: py-eval (-> String PyObject)) (iz py-exec! MeTTaLog) (@doc py-exec! (@desc "Executes some Python sourcecode from a string !(py-exec! \"import torch\") -> True.  !(py-exec! \"import torche\") -> False. ") (@params ((@param (@type String) (@desc "A string representing a Python sourcecode that will be executed")))) (@return (@desc "The True|False results of executing the Python expression"))) (: py-exec! (-> String Bool)) (iz = MeTTa) (@doc = (@desc "A symbol used to define reduction rules for expressions.") (@params ((@param "Pattern to be matched against expression to be reduced") (@param "Result of reduction or transformation of the first pattern"))) (@return "Not reduced itself unless custom equalities over equalities are added")) (: = (-> $10008 $10008 Atom)) (: = (-> Atom Atom Atom)) (iz ErrorType MeTTa) (@doc ErrorType (@desc "Type of the atom which contains error")) (: ErrorType Type) (iz Error MeTTa) (@doc Error (@desc "Error constructor") (@params ((@param "Atom which contains error") (@param "Error message, can be one of the reserved symbols: BadType, IncorrectNumberOfArguments"))) (@return "Instance of the error atom")) (: Error (-> Atom Atom ErrorType)) (iz return MinimalMeTTa) (@doc return (@desc "Returns value from the (function ...) expression") (@params ((@param "Value to be returned"))) (@return "Passed argument")) (: return (-> $10009 $10009)) (iz function MinimalMeTTa) (@doc function (@desc "Evaluates the argument until it becomes (return <result>). Then (function (return <result>)) is reduced to the <result>.") (@params ((@param "Atom to be evaluated"))) (@return "Result of atom's evaluation")) (: function (-> Atom Atom)) (iz eval MinimalMeTTa) (@doc eval (@desc "Evaluates input Atom, performs one step of the evaluation. Empty results (Empty, ()) are removed from the result set. If no results are produced for a non-grounded function, eval returns NotReducible.") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function"))) (@return "Result of evaluation")) (: eval (-> Atom Atom)) (@doc evalc (@desc "Evaluates input atom, makes one step of the evaluation") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function") (@param "Space to evaluate atom in its context"))) (@return "Result of evaluation")) (: evalc (-> Atom Grounded Atom)) (iz chain MinimalMeTTa) (@doc chain (@desc "Evaluates first argument Atom, binds it to the Variable (second argument) and then evaluates third argument Template with Variable substituted in. When evaluation of the first Atom brings more than a single result, chain returns one instance of the Template expression for each result. The first argument Atom is only evaluated if it is part of the Minimal MeTTa specification; evaluation of non-Minimal MeTTa atoms can be controlled by wrapping in a call to eval (for one evaluation step) or metta (for full evaluation).") (@params ((@param "Atom to be evaluated") (@param "Variable") (@param "Template which will be evaluated at the end with Variable substituted"))) (@return "Result of evaluating third input argument")) (: chain (-> Atom Variable Atom Atom)) (iz unify MeTTa) (@doc unify (@desc "Like Match but allows any sort of container for the first argument. (Match only allows MeTTa spaces.)") (@params ((@param "The collection or space to match") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when found or fourth one otherwise")) (: unify (-> Atom Atom Atom Atom Atom)) (iz if-unify MinimalMeTTaHelper) (@doc if-unify (@desc "Matches two first terms and returns third argument if they are matched and fourth argument otherwise") (@params ((@param "First term to unify with") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when first two atoms are unifiable or fourth one otherwise")) (: if-unify (-> Atom Atom Atom Atom %Undefined%)) (ALT= $10010 $10010) (iz if-unify-or-empty MinimalMeTTaHelper) (@doc if-unify-or-empty (@desc "Attempts to unify two atoms and returns a result. Returns Empty if they cannot be unified.") (@params ((@param "First atom") (@param "Second atom"))) (@return "Unification result or Empty")) (: if-unify-or-empty (-> Atom Atom Atom)) (= (if-unify-or-empty $10011 $10011)  unified) (= (if-unify-or-empty $10012 $10013)  
  (empty)) (iz cons-atom MinimalMeTTa) (@doc cons-atom (@desc "Constructs an expression using two arguments") (@params ((@param "Head of an expression") (@param "Tail of an expression"))) (@return "New expression consisting of the two input arguments")) (: cons-atom (-> Atom Expression Expression)) (iz decons-atom MinimalMeTTa) (@doc decons-atom (@desc "Works as a reverse to cons-atom function. It gets Expression as an input and returns it split into head and tail, e.g. (decons-atom (Cons X Nil)) -> (Cons (X Nil))") (@params ((@param "Expression to be Deconsed"))) (@return "Deconsed expression")) (: decons-atom (-> Expression Expression)) (iz min-atom MeTTa) (@doc min-atom (@desc "Returns atom with minimum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Minimum value in the expression. Error if expression contains non-numeric value or is empty.")) (: min-atom (-> Expression Number)) (= (min-atom $10014)  
  (call-fn! min_list $10014)) (iz max-atom MeTTa) (@doc max-atom (@desc "Returns atom with maximum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Maximum value in the expression. Error if expression contains non-numeric value or is empty.")) (: max-atom (-> Expression Number)) (is-fn-1 max-atom max_list) (iz size-atom MeTTa) (@doc size-atom (@desc "Returns the size of an expression (first argument).") (@params ((@param "Expression to measure the size of"))) (@return "Size of the expression")) (: size-atom (-> Expression Integer)) (is-fn-1 size-atom length) (iz index-atom MeTTa) (@doc index-atom (@desc "Returns atom from an expression (first argument) using index (second argument) or error if index is out of bounds.") (@params ((@param "Expression") (@param "Index"))) (@return "Atom at the specified index in the expression. Error if index is out of bounds.")) (: index-atom (-> Expression Number Atom)) (is-fn-21 index-atom nth0) (iz powi MeTTa) (@doc powi (@desc "Takes base (first argument) and power (second argument) and returns the result of raising the base to the power.") (@params ((@param "Base. Could be a float.") (@param "Power. Must be an integer."))) (@return "Result of base raised to the power")) (= (powi $10015 $10016)  
  (call-fn! pow $10015 $10016)) (==> (is-op-1 $10017 $10018) (is-fn-1 $10017 $10018)))) #(expected ((mod-space! stdlib)))))
</span>;;; Test removing duplicated atom
;;; Create a new space
<span class="ansi38-013099040"
>!(bind! &space (new-space))

</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Add 'a' multiple times to the space
<span class="ansi38-013099040"
>!(add-atom &space a)

</span><span class="ansi38-255165000"
> a
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &space a)

</span><span class="ansi38-255165000"
> a
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &space a)

</span><span class="ansi38-255165000"
> a
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Remove 'a' once, expecting 'a' to remain twice
<span class="ansi38-013099040"
>!(remove-atom &space a)

</span><span class="ansi38-255165000"
> a
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Get atoms from space, expecting two 'a's
<span class="ansi38-013099040"
>!(assertEqualToResult (get-atoms &space) ((a a)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.03"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.03</h3>

#(failed #( : user once ) #( : user #(if_or_else #(eval = $10000 497 &self (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003) #(call eval (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003)) ))


#(on_mettalog_error #(failed #( : user once ) #( : user #(if_or_else #(eval = $10000 497 &self (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003) #(call eval (case (if-unify-or-empty $10001 $10001) (( $10002))) $10003)) )))

^  <span class="ansi1 ansi32"
>Call: </span>(283) [user] call(user:once, user:if_or_else(eval(=, _821682, 497, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940), call(eval, [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940)))
^  <span class="ansi1 ansi32"
>Call: </span>(284) [user] once(user:if_or_else(eval(=, _821682, 497, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940), call(eval, [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940)))
   <span class="ansi1 ansi32"
>Call: </span>(285) [user] if_or_else(eval(=, _821682, 497, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940), call(eval, [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940))
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] eval(=, _821682, 497, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940)
^  <span class="ansi1 ansi32"
>Call: </span>(287) [user] catch_metta_return(eval_args(=, _821682, 497, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940), _824940)
^  <span class="ansi1 ansi32"
>Call: </span>(289) [user] eval_args(=, _821682, 497, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940)
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] var([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] setup_call_cleanup('$notrace'(_843806, _843808), once(user:self_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])), '$restore_trace'(_843806, _843808))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] sig_atomic(system:'$notrace'(_843806, _843808))
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] setup_call_cleanup('$notrace'(_845894, _845896), once(user:nonvar(_824940)), '$restore_trace'(_845894, _845896))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] sig_atomic(system:'$notrace'(_845894, _845896))
^  <span class="ansi1 ansi32"
>Call: </span>(291) [system] setup_call_cleanup('$notrace'(_847982, _847984), once(user:nonvar(_824940)), '$restore_trace'(_847982, _847984))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] sig_atomic(system:'$notrace'(_847982, _847984))
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] [['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(290) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(290) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] self_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Call: </span>(292) [system] setup_call_cleanup('$notrace'(_855138, _855140), once(user:self_eval0([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])), '$restore_trace'(_855138, _855140))
^  <span class="ansi1 ansi32"
>Call: </span>(293) [system] sig_atomic(system:'$notrace'(_855138, _855140))
^  <span class="ansi1 ansi31"
>Fail: </span>(290) [user] self_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] eval_00(=, _821682, 497, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940)
^  <span class="ansi1 ansi32"
>Call: </span>(291) [user] self_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Call: </span>(293) [system] setup_call_cleanup('$notrace'(_860282, _860284), once(user:self_eval0([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])), '$restore_trace'(_860282, _860284))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] sig_atomic(system:'$notrace'(_860282, _860284))
^  <span class="ansi1 ansi31"
>Fail: </span>(291) [user] self_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Call: </span>(291) [user] eval_01(=, _821682, 497, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940)
   <span class="ansi1 ansi32"
>Call: </span>(292) [system] [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(292) [system] [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] if_t((497<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] 497<1
   <span class="ansi1 ansi31"
>Fail: </span>(294) [system] 497<1
^  <span class="ansi1 ansi32"
>Exit: </span>(292) [user] if_t((497<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(293) [system] setup_call_cleanup('$notrace'(_870556, _870558), once(user:(_870532 is 497-1, copy_term([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _870546))), '$restore_trace'(_870556, _870558))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] sig_atomic(system:'$notrace'(_870556, _870558))
^  <span class="ansi1 ansi32"
>Exit: </span>(293) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(496 is 497-1, copy_term([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], [case, ['if-unify-or-empty', _872654, _872654], [['Empty', _872684]]]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] trace_eval(eval_20(=, _821682), e, 496, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _873720)
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] must_det_ll((notrace((flag(eval_num, _874774, _874774+1), _874792 is _874774 mod 500, _874810 is 99-496 mod 100, _874834=_874836, option_else('trace-length', _874848, 500), option_else('trace-depth', _874856, 30))), quietly(if_t((nop(stop_rtrace), _874792>_874848), (set_debug(eval, false), _874912 is _874848+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_874912])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_874964)))))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] once(user:(notrace((flag(eval_num, _874774, _874774+1), _874792 is _874774 mod 500, _874810 is 99-496 mod 100, _874834=_874836, option_else('trace-length', _874848, 500), option_else('trace-depth', _874856, 30))), quietly(if_t((nop(stop_rtrace), _874792>_874848), (set_debug(eval, false), _874912 is _874848+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_874912])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_874964)))))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [system] setup_call_cleanup('$notrace'(_877010, _877012), once(user:(flag(eval_num, _874774, _874774+1), _874792 is _874774 mod 500, _874810 is 99-496 mod 100, _874834=_874836, option_else('trace-length', _874848, 500), option_else('trace-depth', _874856, 30))), '$restore_trace'(_877010, _877012))
^  <span class="ansi1 ansi32"
>Call: </span>(298) [system] sig_atomic(system:'$notrace'(_877010, _877012))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 574, 574+1), 74 is 574 mod 500, 3 is 99-496 mod 100, _874834=_874834, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 74>500), (set_debug(eval, false), _874912 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_874912])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 74>500), (set_debug(eval, false), _874912 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_874912])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(296) [user] nop(notrace(no_repeats_var(_874964)))
   <span class="ansi1 ansi32"
>Exit: </span>(296) [user] nop(notrace(no_repeats_var(_874964)))
^  <span class="ansi1 ansi32"
>Exit: </span>(294) [system] once(user:(notrace((flag(eval_num, 574, 574+1), 74 is 574 mod 500, 3 is 99-496 mod 100, _874834=_874834, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 74>500), (set_debug(eval, false), _874912 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_874912])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_874964)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(293) [user] must_det_ll(user:(notrace((flag(eval_num, 574, 574+1), 74 is 574 mod 500, 3 is 99-496 mod 100, _874834=_874834, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 74>500), (set_debug(eval, false), _874912 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_874912])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_874964)))))
   <span class="ansi1 ansi32"
>Call: </span>(293) [occurs] occurs:sub_term(_886662, e)
   <span class="ansi1 ansi32"
>Exit: </span>(293) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(293) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(294) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(294) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(293) [occurs] occurs:sub_term(_886662, e)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] _893768=e
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] if_trace((eval;e), (_874834=1, indentq(3, 74, -->, [e, [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] setup_call_cleanup('$notrace'(_896908, _896910), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _874834=1, indentq(3, 74, -->, [e, [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]]))), _896866, fbug((_896866-->if_trace((eval;e), (_874834=1, indentq(3, 74, -->, [e, [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]])))))))), '$restore_trace'(_896908, _896910))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [system] sig_atomic(system:'$notrace'(_896908, _896910))
^  <span class="ansi1 ansi32"
>Exit: </span>(295) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _874834=1, indentq(3, 74, -->, [e, [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]]))), _896866, fbug((_896866-->if_trace((eval;e), (_874834=1, indentq(3, 74, -->, [e, [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(293) [user] if_trace((eval;e), (_874834=1, indentq(3, 74, -->, [e, [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]])))
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] _901104=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] _903142=(\+ \+ (flag(eval_num, _903162, _903162+1), (retval(fail)\=@=retval(fail), nonvar(_873720)->indentq(3, _903162, <--, [e, _873720]);indentq(3, _903162, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] (\+ \+ (flag(eval_num, _903162, _903162+1), (retval(fail)\=@=retval(fail), nonvar(_873720)->indentq(3, _903162, <--, [e, _873720]);indentq(3, _903162, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _903162, _903162+1), (retval(fail)\=@=retval(fail), nonvar(_873720)->indentq(3, _903162, <--, [e, _873720]);indentq(3, _903162, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] call_cleanup(((call(eval_20(=, _821682), 496, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _873720)*->nb_setarg(1, retval(fail), _873720);fail, trace, call(eval_20(=, _821682), 496, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _873720)), ignore(notrace((\+_873720\=_874964, nb_setarg(1, retval(fail), _873720))))), ignore((_874834==1->ignore(\+ \+ (flag(eval_num, _903162, _903162+1), (retval(fail)\=@=retval(fail), nonvar(_873720)->indentq(3, _903162, <--, [e, _873720]);indentq(3, _903162, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _903162, _903162+1), (retval(fail)\=@=retval(fail), nonvar(_873720)->indentq(3, _903162, <--, [e, _873720]);indentq(3, _903162, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] eval_20(=, _821682, 496, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _873720)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] atom([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] no_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] self_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_910550, _910552), once(user:self_eval0([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])), '$restore_trace'(_910550, _910552))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_910550, _910552))
^  <span class="ansi1 ansi31"
>Fail: </span>(297) [user] self_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] atomic(case)
   <span class="ansi1 ansi32"
>Exit: </span>(297) [system] atomic(case)
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] is_sl(case)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] number(case)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] [['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] callable(case)
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] callable(case)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] [['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] is_list([['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] is_list([['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] is_list(case)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] is_list([['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] is_list([['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] is_list([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] is_list([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] once(expand_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _932894))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] expand_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _932894)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] is_list([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
   <span class="ansi1 ansi32"
>Exit: </span>(298) [system] is_list([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] ground(case)
   <span class="ansi1 ansi32"
>Exit: </span>(298) [system] ground(case)
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] apply:maplist(expand_eval, [['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _938994)
   <span class="ansi1 ansi32"
>Call: </span>(299) [apply] apply:maplist_([['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _938994, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] expand_eval(['if-unify-or-empty', _811998, _811998], _941050)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] is_list(['if-unify-or-empty', _811998, _811998])
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] is_list(['if-unify-or-empty', _811998, _811998])
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] apply:maplist(expand_eval, [_811998, _811998], _946128)
   <span class="ansi1 ansi32"
>Call: </span>(302) [apply] apply:maplist_([_811998, _811998], _946128, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] expand_eval(_811998, _948184)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list(_811998)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _811998=_948184
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] _811998=_811998
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] expand_eval(_811998, _811998)
   <span class="ansi1 ansi32"
>Call: </span>(303) [apply] apply:maplist_([_811998], _948186, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] expand_eval(_811998, _954286)
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] is_list(_811998)
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] _811998=_954286
   <span class="ansi1 ansi32"
>Exit: </span>(305) [system] _811998=_811998
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] expand_eval(_811998, _811998)
   <span class="ansi1 ansi32"
>Call: </span>(304) [apply] apply:maplist_([], _954288, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [apply] apply:maplist_([_811998], [_811998], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [apply] apply:maplist_([_811998, _811998], [_811998, _811998], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [apply] apply:maplist(user:expand_eval, [_811998, _811998], [_811998, _811998])
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] expand_eval(['if-unify-or-empty', _811998, _811998], ['if-unify-or-empty', _811998, _811998])
   <span class="ansi1 ansi32"
>Call: </span>(300) [apply] apply:maplist_([[['Empty', _812016]]], _941052, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] expand_eval([['Empty', _812016]], _966510)
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] is_list([['Empty', _812016]])
   <span class="ansi1 ansi32"
>Exit: </span>(302) [system] is_list([['Empty', _812016]])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] ground(['Empty', _812016])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] apply:maplist(expand_eval, [], _969558)
   <span class="ansi1 ansi32"
>Call: </span>(303) [apply] apply:maplist_([], _969558, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [apply] apply:maplist_([], [], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [apply] apply:maplist(user:expand_eval, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] expand_eval([['Empty', _812016]], [['Empty', _812016]])
   <span class="ansi1 ansi32"
>Call: </span>(301) [apply] apply:maplist_([], _966512, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [apply] apply:maplist_([[['Empty', _812016]]], [[['Empty', _812016]]], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [apply] apply:maplist_([['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], [['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [apply] apply:maplist(user:expand_eval, [['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], [['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] expand_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [system] once(user:expand_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]))
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]\==[case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] is_progn(case)
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] is_space_op(case)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] must_det_ll([]==[])
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] once(user:([]==[]))
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(298) [system] []==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [system] once(user:([]==[]))
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] must_det_ll(user:([]==[]))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] into_case_list([['Empty', _812016]], _995002)
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] is_list([['Empty', _812016]])
   <span class="ansi1 ansi32"
>Exit: </span>(297) [system] is_list([['Empty', _812016]])
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] into_case_list([['Empty', _812016]], [['Empty', _812016]])
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] into_case_keys(1, [['Empty', _812016]], _999060)
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] _1000100 is 1+1
   <span class="ansi1 ansi32"
>Exit: </span>(297) [system] 2 is 1+1
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] is_case(_1000090, ['Empty', _812016], _1000092)
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] is_case('Empty', ['Empty', _812016], _812016)
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_812016)))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_1005266, _1005268), once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_812016))), _1005224, fbug((_1005224-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_812016)))))))), '$restore_trace'(_1005266, _1005268))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_1005266, _1005268))
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_812016))), _1005224, fbug((_1005224-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_812016)))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_812016)))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] into_case_keys(2, [], _1000086)
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] into_case_keys(2, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] into_case_keys(1, [['Empty', _812016]], ['Empty'-_812016])
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] eval_case(=, _821682, 496, '&self', ['if-unify-or-empty', _811998, _811998], ['Empty'-_812016], _873720)
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _811998, _811998]))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_1014634, _1014636), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _811998, _811998]))), _1014592, fbug((_1014592-->if_trace(case, writeqln(case=['if-unify-or-empty', _811998, _811998]))))))), '$restore_trace'(_1014634, _1014636))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_1014634, _1014636))
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _811998, _811998]))), _1014592, fbug((_1014592-->if_trace(case, writeqln(case=['if-unify-or-empty', _811998, _811998]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _811998, _811998]))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] eval_args(=, _1018956, 496, '&self', ['if-unify-or-empty', _811998, _811998], _1018830)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] var(['if-unify-or-empty', _811998, _811998])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_1020888, _1020890), once(user:self_eval(['if-unify-or-empty', _811998, _811998])), '$restore_trace'(_1020888, _1020890))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_1020888, _1020890))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_1022976, _1022978), once(user:nonvar(_1018830)), '$restore_trace'(_1022976, _1022978))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_1022976, _1022978))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_1025064, _1025066), once(user:nonvar(_1018830)), '$restore_trace'(_1025064, _1025066))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_1025064, _1025066))
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] [_811998, _811998]==[]
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(298) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] self_eval(['if-unify-or-empty', _811998, _811998])
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] setup_call_cleanup('$notrace'(_1032220, _1032222), once(user:self_eval0(['if-unify-or-empty', _811998, _811998])), '$restore_trace'(_1032220, _1032222))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] sig_atomic(system:'$notrace'(_1032220, _1032222))
^  <span class="ansi1 ansi31"
>Fail: </span>(298) [user] self_eval(['if-unify-or-empty', _811998, _811998])
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] eval_00(=, _1035308, 496, '&self', ['if-unify-or-empty', _811998, _811998], _1018830)
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] self_eval(['if-unify-or-empty', _811998, _811998])
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] setup_call_cleanup('$notrace'(_1037366, _1037368), once(user:self_eval0(['if-unify-or-empty', _811998, _811998])), '$restore_trace'(_1037366, _1037368))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] sig_atomic(system:'$notrace'(_1037366, _1037368))
^  <span class="ansi1 ansi31"
>Fail: </span>(299) [user] self_eval(['if-unify-or-empty', _811998, _811998])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] eval_01(=, _1035308, 496, '&self', ['if-unify-or-empty', _811998, _811998], _1018830)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] ['if-unify-or-empty', _811998, _811998]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] ['if-unify-or-empty', _811998, _811998]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] if_t((496<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] 496<1
   <span class="ansi1 ansi31"
>Fail: </span>(302) [system] 496<1
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] if_t((496<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] setup_call_cleanup('$notrace'(_1047640, _1047642), once(user:(_1047616 is 496-1, copy_term(['if-unify-or-empty', _811998, _811998], _1047630))), '$restore_trace'(_1047640, _1047642))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] sig_atomic(system:'$notrace'(_1047640, _1047642))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(495 is 496-1, copy_term(['if-unify-or-empty', _811998, _811998], ['if-unify-or-empty', _1049726, _1049726]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] trace_eval(eval_20(=, _1035308), e, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1050768)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] must_det_ll((notrace((flag(eval_num, _1051822, _1051822+1), _1051840 is _1051822 mod 500, _1051858 is 99-495 mod 100, _1051882=_1051884, option_else('trace-length', _1051896, 500), option_else('trace-depth', _1051904, 30))), quietly(if_t((nop(stop_rtrace), _1051840>_1051896), (set_debug(eval, false), _1051960 is _1051896+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1051960])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1052012)))))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] once(user:(notrace((flag(eval_num, _1051822, _1051822+1), _1051840 is _1051822 mod 500, _1051858 is 99-495 mod 100, _1051882=_1051884, option_else('trace-length', _1051896, 500), option_else('trace-depth', _1051904, 30))), quietly(if_t((nop(stop_rtrace), _1051840>_1051896), (set_debug(eval, false), _1051960 is _1051896+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1051960])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1052012)))))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_1054058, _1054060), once(user:(flag(eval_num, _1051822, _1051822+1), _1051840 is _1051822 mod 500, _1051858 is 99-495 mod 100, _1051882=_1051884, option_else('trace-length', _1051896, 500), option_else('trace-depth', _1051904, 30))), '$restore_trace'(_1054058, _1054060))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_1054058, _1054060))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 575, 575+1), 75 is 575 mod 500, 4 is 99-495 mod 100, _1051882=_1051882, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 75>500), (set_debug(eval, false), _1051960 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1051960])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 75>500), (set_debug(eval, false), _1051960 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1051960])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(304) [user] nop(notrace(no_repeats_var(_1052012)))
   <span class="ansi1 ansi32"
>Exit: </span>(304) [user] nop(notrace(no_repeats_var(_1052012)))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] once(user:(notrace((flag(eval_num, 575, 575+1), 75 is 575 mod 500, 4 is 99-495 mod 100, _1051882=_1051882, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 75>500), (set_debug(eval, false), _1051960 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1051960])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1052012)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] must_det_ll(user:(notrace((flag(eval_num, 575, 575+1), 75 is 575 mod 500, 4 is 99-495 mod 100, _1051882=_1051882, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 75>500), (set_debug(eval, false), _1051960 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1051960])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1052012)))))
   <span class="ansi1 ansi32"
>Call: </span>(301) [occurs] occurs:sub_term(_1063710, e)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(301) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(302) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(301) [occurs] occurs:sub_term(_1063710, e)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] _1070816=e
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] if_trace((eval;e), (_1051882=1, indentq(4, 75, -->, [e, ['if-unify-or-empty', _811998, _811998]])))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] setup_call_cleanup('$notrace'(_1073956, _1073958), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _1051882=1, indentq(4, 75, -->, [e, ['if-unify-or-empty', _811998, _811998]]))), _1073914, fbug((_1073914-->if_trace((eval;e), (_1051882=1, indentq(4, 75, -->, [e, ['if-unify-or-empty', _811998, _811998]])))))))), '$restore_trace'(_1073956, _1073958))
^  <span class="ansi1 ansi32"
>Call: </span>(304) [system] sig_atomic(system:'$notrace'(_1073956, _1073958))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _1051882=1, indentq(4, 75, -->, [e, ['if-unify-or-empty', _811998, _811998]]))), _1073914, fbug((_1073914-->if_trace((eval;e), (_1051882=1, indentq(4, 75, -->, [e, ['if-unify-or-empty', _811998, _811998]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] if_trace((eval;e), (_1051882=1, indentq(4, 75, -->, [e, ['if-unify-or-empty', _811998, _811998]])))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] _1078152=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] _1080190=(\+ \+ (flag(eval_num, _1080210, _1080210+1), (retval(fail)\=@=retval(fail), nonvar(_1050768)->indentq(4, _1080210, <--, [e, _1050768]);indentq(4, _1080210, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] (\+ \+ (flag(eval_num, _1080210, _1080210+1), (retval(fail)\=@=retval(fail), nonvar(_1050768)->indentq(4, _1080210, <--, [e, _1050768]);indentq(4, _1080210, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _1080210, _1080210+1), (retval(fail)\=@=retval(fail), nonvar(_1050768)->indentq(4, _1080210, <--, [e, _1050768]);indentq(4, _1080210, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] call_cleanup(((call(eval_20(=, _1035308), 495, '&self', ['if-unify-or-empty', _811998, _811998], _1050768)*->nb_setarg(1, retval(fail), _1050768);fail, trace, call(eval_20(=, _1035308), 495, '&self', ['if-unify-or-empty', _811998, _811998], _1050768)), ignore(notrace((\+_1050768\=_1052012, nb_setarg(1, retval(fail), _1050768))))), ignore((_1051882==1->ignore(\+ \+ (flag(eval_num, _1080210, _1080210+1), (retval(fail)\=@=retval(fail), nonvar(_1050768)->indentq(4, _1080210, <--, [e, _1050768]);indentq(4, _1080210, <--, [e, retval(fail)]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1080210, _1080210+1), (retval(fail)\=@=retval(fail), nonvar(_1050768)->indentq(4, _1080210, <--, [e, _1050768]);indentq(4, _1080210, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_20(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1050768)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] atom(['if-unify-or-empty', _811998, _811998])
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] no_eval(['if-unify-or-empty', _811998, _811998])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] self_eval(['if-unify-or-empty', _811998, _811998])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] setup_call_cleanup('$notrace'(_1087598, _1087600), once(user:self_eval0(['if-unify-or-empty', _811998, _811998])), '$restore_trace'(_1087598, _1087600))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] sig_atomic(system:'$notrace'(_1087598, _1087600))
^  <span class="ansi1 ansi31"
>Fail: </span>(305) [user] self_eval(['if-unify-or-empty', _811998, _811998])
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] atomic('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(305) [system] atomic('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] is_sl('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] number('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [_811998, _811998]==[]
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _1098792==eval
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [_811998, _811998]==[]
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list([_811998, _811998])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list([_811998, _811998])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list([_811998, _811998])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list([_811998, _811998])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list(['if-unify-or-empty', _811998, _811998])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list(['if-unify-or-empty', _811998, _811998])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] once(expand_eval(['if-unify-or-empty', _811998, _811998], _1110970))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] expand_eval(['if-unify-or-empty', _811998, _811998], _1110970)
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] is_list(['if-unify-or-empty', _811998, _811998])
   <span class="ansi1 ansi32"
>Exit: </span>(306) [system] is_list(['if-unify-or-empty', _811998, _811998])
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(306) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] apply:maplist(expand_eval, [_811998, _811998], _1117070)
   <span class="ansi1 ansi32"
>Call: </span>(307) [apply] apply:maplist_([_811998, _811998], _1117070, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] expand_eval(_811998, _1119126)
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] is_list(_811998)
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] _811998=_1119126
   <span class="ansi1 ansi32"
>Exit: </span>(309) [system] _811998=_811998
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] expand_eval(_811998, _811998)
   <span class="ansi1 ansi32"
>Call: </span>(308) [apply] apply:maplist_([_811998], _1119128, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] expand_eval(_811998, _1125228)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list(_811998)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _811998=_1125228
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] _811998=_811998
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] expand_eval(_811998, _811998)
   <span class="ansi1 ansi32"
>Call: </span>(309) [apply] apply:maplist_([], _1125230, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(309) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(308) [apply] apply:maplist_([_811998], [_811998], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [apply] apply:maplist_([_811998, _811998], [_811998, _811998], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [apply] apply:maplist(user:expand_eval, [_811998, _811998], [_811998, _811998])
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [user] expand_eval(['if-unify-or-empty', _811998, _811998], ['if-unify-or-empty', _811998, _811998])
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [system] once(user:expand_eval(['if-unify-or-empty', _811998, _811998], ['if-unify-or-empty', _811998, _811998]))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] ['if-unify-or-empty', _811998, _811998]\==['if-unify-or-empty', _811998, _811998]
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] is_progn('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] is_space_op('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] arg(_1142650, v('catch!', 'throw!', 'number-of!', 'limit!', 'offset!', 'max-time!', 'findall!', 'setup-call-cleanup!', 'call-cleanup!', 'call-cleanup!', 'with-output-to!'), 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _1143548='if-unify-or-empty'
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] 'if-unify-or-empty'='if-unify-or-empty'
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _1145582)
^  <span class="ansi1 ansi31"
>Fail: </span>(304) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _1145582)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list(['if-unify-or-empty', _811998, _811998])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list(['if-unify-or-empty', _811998, _811998])
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] apply:maplist(self_eval, ['if-unify-or-empty', _811998, _811998])
   <span class="ansi1 ansi32"
>Call: </span>(305) [apply] apply:maplist_(['if-unify-or-empty', _811998, _811998], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] self_eval('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_1152716, _1152718), once(user:self_eval0('if-unify-or-empty')), '$restore_trace'(_1152716, _1152718))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_1152716, _1152718))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0('if-unify-or-empty')), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] self_eval('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(306) [apply] apply:maplist_([_811998, _811998], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] self_eval(_811998)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_1158870, _1158872), once(user:self_eval0(_811998)), '$restore_trace'(_1158870, _1158872))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_1158870, _1158872))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_811998)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] self_eval(_811998)
   <span class="ansi1 ansi32"
>Call: </span>(307) [apply] apply:maplist_([_811998], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] self_eval(_811998)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_1165024, _1165026), once(user:self_eval0(_811998)), '$restore_trace'(_1165024, _1165026))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_1165024, _1165026))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_811998)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] self_eval(_811998)
   <span class="ansi1 ansi32"
>Call: </span>(308) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(308) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [apply] apply:maplist_([_811998], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(306) [apply] apply:maplist_([_811998, _811998], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(305) [apply] apply:maplist_(['if-unify-or-empty', _811998, _811998], user:self_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [apply] apply:maplist(user:self_eval, ['if-unify-or-empty', _811998, _811998])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] ['if-unify-or-empty', _811998, _811998]=[_1175242|_1175244]
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] ['if-unify-or-empty', _811998, _811998]=['if-unify-or-empty', _811998, _811998]
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _1179302=do_more_defs(true)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] do_more_defs(true)=do_more_defs(true)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] clause(eval_21(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1050768), _1181354)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] 'if-unify-or-empty'==(/)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] 'if-unify-or-empty'== ===
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] 'if-unify-or-empty'== ====
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] eval_40(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426)
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] eval_selfless(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_selfless_0(['if-unify-or-empty', _811998, _811998], _1185426)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] is_assignment('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(308) [system] atom('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] eval_selfless_1(['if-unify-or-empty', _811998, _811998], _1185426)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] allow_clp
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] false_flag
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(310) [system] fail
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] false_flag
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] eval_selfless_2(['if-unify-or-empty', _811998, _811998], _1185426)
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] fake_notrace((ground(['if-unify-or-empty', _811998, _811998]), ['if-unify-or-empty', _811998, _811998]=[_1200650, _1200656, _1200662], atom(_1200650), catch_warn(current_op(_1200688, yfx, _1200650)), ['if-unify-or-empty', _811998, _811998]\=[_1200708], s2ps(['if-unify-or-empty', _811998, _811998], _1200716)))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] real_notrace(user:(ground(['if-unify-or-empty', _811998, _811998]), ['if-unify-or-empty', _811998, _811998]=[_1200650, _1200656, _1200662], atom(_1200650), catch_warn(current_op(_1200688, yfx, _1200650)), ['if-unify-or-empty', _811998, _811998]\=[_1200708], s2ps(['if-unify-or-empty', _811998, _811998], _1200716)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] setup_call_cleanup('$notrace'(_1202750, _1202752), once(user:(ground(['if-unify-or-empty', _811998, _811998]), ['if-unify-or-empty', _811998, _811998]=[_1200650, _1200656, _1200662], atom(_1200650), catch_warn(current_op(_1200688, yfx, _1200650)), ['if-unify-or-empty', _811998, _811998]\=[_1200708], s2ps(['if-unify-or-empty', _811998, _811998], _1200716))), '$restore_trace'(_1202750, _1202752))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(user:'$notrace'(_1202750, _1202752))
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] real_notrace(user:(ground(['if-unify-or-empty', _811998, _811998]), ['if-unify-or-empty', _811998, _811998]=[_1200650, _1200656, _1200662], atom(_1200650), catch_warn(current_op(_1200688, yfx, _1200650)), ['if-unify-or-empty', _811998, _811998]\=[_1200708], s2ps(['if-unify-or-empty', _811998, _811998], _1200716)))
^  <span class="ansi1 ansi31"
>Fail: </span>(308) [user] fake_notrace(user:(ground(['if-unify-or-empty', _811998, _811998]), ['if-unify-or-empty', _811998, _811998]=[_1200650, _1200656, _1200662], atom(_1200650), catch_warn(current_op(_1200688, yfx, _1200650)), ['if-unify-or-empty', _811998, _811998]\=[_1200708], s2ps(['if-unify-or-empty', _811998, _811998], _1200716)))
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] 'if-unify-or-empty'==(==)
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] 'if-unify-or-empty'==(==)
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] eval_41(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_adjust_args(=, _1035308, _1215938, _1185426, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1215940)
   <span class="ansi1 ansi32"
>Call: </span>(307) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _1035308, _1215938, _1185426, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1215940)), eval_adjust_args1(=, _1035308, _1215938, _1185426, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1215940))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_adjust_args2(=, _1035308, _1215938, _1185426, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1215940)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] apply:maplist(must_eval_args(=, _1223094, 495, '&self'), [_811998, _811998], _1223088)
   <span class="ansi1 ansi32"
>Call: </span>(311) [apply] apply:maplist_([_811998, _811998], _1223088, user:must_eval_args(=, _1223094, 495, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] must_eval_args(=, _1223094, 495, '&self', _811998, _1225154)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] was_option_value(nodebug, _1236318)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] current_prolog_flag(nodebug, _1237336)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] current_prolog_flag(nodebug, _1237336)
   <span class="ansi1 ansi32"
>Call: </span>(318) [$syspreds] prolog_load_context(nodebug, _1239370)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [$syspreds] prolog_load_context(nodebug, _1239370)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nb_current(nodebug, _1241404)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] nb_current(nodebug, _1241404)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] was_option_value(nodebug, _1236318)
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_1247516, _1247518), once(user:option_value0(nodebug, true)), '$restore_trace'(_1247516, _1247518))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_1247516, _1247518))
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(314) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1267856)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1267856, _1269000)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_1272966, _1272968, _1272970), defined)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(317) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1272966, _1272968, _1272970))
   <span class="ansi1 ansi32"
>Call: </span>(318) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1272966, _1272968, _1272970))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] callable(debugging_logicmoo_setting(_1272966, _1272968, _1272970))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] callable(debugging_logicmoo_setting(_1272966, _1272968, _1272970))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1272966, _1272968, _1272970))
   <span class="ansi1 ansi32"
>Exit: </span>(317) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1272966, _1272968, _1272970))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_1272966, _1272968, _1272970), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _1267856, _1285150)
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(314) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval_args(=, _1223094, 495, '&self', _811998, _1225154)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(_811998)
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] var(_811998)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] nonvar(_1225154)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_1296376, _1296378), once(user:self_eval(_811998)), '$restore_trace'(_1296376, _1296378))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_1296376, _1296378))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_811998)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] _1225154=_811998
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] _811998=_811998
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] eval_args(=, _1223094, 495, '&self', _811998, _811998)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] must_eval_args(=, _1223094, 495, '&self', _811998, _811998)
   <span class="ansi1 ansi32"
>Call: </span>(312) [apply] apply:maplist_([_811998], _1225156, user:must_eval_args(=, _1223094, 495, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] must_eval_args(=, _1223094, 495, '&self', _811998, _1304640)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] was_option_value(nodebug, _1315804)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] current_prolog_flag(nodebug, _1316822)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] current_prolog_flag(nodebug, _1316822)
   <span class="ansi1 ansi32"
>Call: </span>(319) [$syspreds] prolog_load_context(nodebug, _1318856)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [$syspreds] prolog_load_context(nodebug, _1318856)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] nb_current(nodebug, _1320890)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] nb_current(nodebug, _1320890)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] was_option_value(nodebug, _1315804)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_1327002, _1327004), once(user:option_value0(nodebug, true)), '$restore_trace'(_1327002, _1327004))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_1327002, _1327004))
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(315) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1347342)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [prolog_debug] prolog_debug:debugging(metta(eval_args), _1347342, _1348486)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_1352452, _1352454, _1352456), defined)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(318) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1352452, _1352454, _1352456))
   <span class="ansi1 ansi32"
>Call: </span>(319) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1352452, _1352454, _1352456))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] callable(debugging_logicmoo_setting(_1352452, _1352454, _1352456))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] callable(debugging_logicmoo_setting(_1352452, _1352454, _1352456))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_1352452, _1352454, _1352456))
   <span class="ansi1 ansi32"
>Exit: </span>(318) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_1352452, _1352454, _1352456))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_1352452, _1352454, _1352456), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _1347342, _1364636)
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(315) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] eval_args(=, _1223094, 495, '&self', _811998, _1304640)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] var(_811998)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] var(_811998)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nonvar(_1304640)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] setup_call_cleanup('$notrace'(_1375862, _1375864), once(user:self_eval(_811998)), '$restore_trace'(_1375862, _1375864))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] sig_atomic(system:'$notrace'(_1375862, _1375864))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_811998)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] _1304640=_811998
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] _811998=_811998
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] eval_args(=, _1223094, 495, '&self', _811998, _811998)
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] must_eval_args(=, _1223094, 495, '&self', _811998, _811998)
   <span class="ansi1 ansi32"
>Call: </span>(313) [apply] apply:maplist_([], _1304642, user:must_eval_args(=, _1223094, 495, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(313) [apply] apply:maplist_([], [], user:must_eval_args(=, _1223094, 495, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(312) [apply] apply:maplist_([_811998], [_811998], user:must_eval_args(=, _1223094, 495, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(311) [apply] apply:maplist_([_811998, _811998], [_811998, _811998], user:must_eval_args(=, _1223094, 495, '&self'))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [apply] apply:maplist(user:must_eval_args(=, _1223094, 495, '&self'), [_811998, _811998], [_811998, _811998])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _1215938=_1185426
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] _1185426=_1185426
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_adjust_args2(=, _1035308, _1185426, _1185426, 495, '&self', ['if-unify-or-empty', _811998, _811998], ['if-unify-or-empty', _811998, _811998])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _1035308, _1185426, _1185426, 495, '&self', ['if-unify-or-empty', _811998, _811998], ['if-unify-or-empty', _811998, _811998])), eval_adjust_args1(=, _1035308, _1185426, _1185426, 495, '&self', ['if-unify-or-empty', _811998, _811998], ['if-unify-or-empty', _811998, _811998]))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_adjust_args(=, _1035308, _1185426, _1185426, 495, '&self', ['if-unify-or-empty', _811998, _811998], ['if-unify-or-empty', _811998, _811998])
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] if_trace((e;args), (['if-unify-or-empty', _811998, _811998]\==['if-unify-or-empty', _811998, _811998]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _811998, _811998]->['if-unify-or-empty', _811998, _811998])));nop(indentq2(495, same(['if-unify-or-empty', _811998, _811998])))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_1394448, _1394450), once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _811998, _811998]\==['if-unify-or-empty', _811998, _811998]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _811998, _811998]->['if-unify-or-empty', _811998, _811998])));nop(indentq2(495, same(['if-unify-or-empty', _811998, _811998])))))), _1394406, fbug((_1394406-->if_trace((e;args), (['if-unify-or-empty', _811998, _811998]\==['if-unify-or-empty', _811998, _811998]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _811998, _811998]->['if-unify-or-empty', _811998, _811998])));nop(indentq2(495, same(['if-unify-or-empty', _811998, _811998])))))))))), '$restore_trace'(_1394448, _1394450))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_1394448, _1394450))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _811998, _811998]\==['if-unify-or-empty', _811998, _811998]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _811998, _811998]->['if-unify-or-empty', _811998, _811998])));nop(indentq2(495, same(['if-unify-or-empty', _811998, _811998])))))), _1394406, fbug((_1394406-->if_trace((e;args), (['if-unify-or-empty', _811998, _811998]\==['if-unify-or-empty', _811998, _811998]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _811998, _811998]->['if-unify-or-empty', _811998, _811998])));nop(indentq2(495, same(['if-unify-or-empty', _811998, _811998])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] if_trace((e;args), (['if-unify-or-empty', _811998, _811998]\==['if-unify-or-empty', _811998, _811998]->color_g_mesg('#773733', indentq2(495, (['if-unify-or-empty', _811998, _811998]->['if-unify-or-empty', _811998, _811998])));nop(indentq2(495, same(['if-unify-or-empty', _811998, _811998])))))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_70(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426)
   <span class="ansi1 ansi32"
>Call: </span>(307) [user] if_or_else(eval_maybe_python(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426), if_or_else(eval_maybe_host_predicate(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426), if_or_else(eval_maybe_host_function(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426), if_or_else(eval_maybe_defn(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426), eval_maybe_subst(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426)))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] eval_maybe_python(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426)
   <span class="ansi1 ansi32"
>Call: </span>(309) [user] metta_atom('&self', ['registered-python-function', _1401808, _1401814, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] typed_list('&self', _1402954, _1402828)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(310) [user] typed_list('&self', _1405998, _1402828)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] metta_atom_in_file('&self', ['registered-python-function', _1401808, _1401814, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] metta_atom_in_file('&self', ['registered-python-function', _1401808, _1401814, 'if-unify-or-empty'], _1409052, _1409054)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] loaded_into_kb('&self', _1409950)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] loaded_into_kb('&self', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] once(user:asserted_metta_pred(_1415918, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] asserted_metta_pred(_1415918, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(313) [user] asserted_metta_pred(_1415918, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] metta_atom_asserted('&self', ['registered-python-function', _1401808, _1401814, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] metta_atom_asserted_deduced('&self', ['registered-python-function', _1401808, _1401814, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] metta_atom('&corelib', ['registered-python-function', _1401808, _1401814, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] typed_list('&corelib', _1439984, _1439858)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(312) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(311) [user] typed_list('&corelib', _1443028, _1439858)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] metta_atom_in_file('&corelib', ['registered-python-function', _1401808, _1401814, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] metta_atom_in_file('&corelib', ['registered-python-function', _1401808, _1401814, 'if-unify-or-empty'], _1446082, _1446084)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] loaded_into_kb('&corelib', _1446980)
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] once(user:asserted_metta_pred(_1452924, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] asserted_metta_pred(_1452924, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] asserted_metta_pred(_1452924, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] once(user:asserted_metta_pred(_1472606, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] asserted_metta_pred(_1472606, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] asserted_metta_pred(_1472606, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(311) [user] metta_atom_asserted('&corelib', ['registered-python-function', _1401808, _1401814, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] metta_atom_asserted_deduced('&corelib', ['registered-python-function', _1401808, _1401814, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(308) [user] if_or_else(eval_maybe_host_predicate(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426), if_or_else(eval_maybe_host_function(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426), if_or_else(eval_maybe_defn(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426), eval_maybe_subst(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426))))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_maybe_host_predicate(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] once((is_system_pred('if-unify-or-empty'), length([_811998, _811998], _1497490), is_syspred('if-unify-or-empty', _1497490, _1497498)))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom_concat(_1501682, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom_concat(_1504726, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom_concat(_1507770, '-p', 'if-unify-or-empty')
^  <span class="ansi1 ansi31"
>Fail: </span>(312) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(309) [user] if_or_else(eval_maybe_host_function(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426), if_or_else(eval_maybe_defn(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426), eval_maybe_subst(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] eval_maybe_host_function(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom_concat(_1516882, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom_concat(_1519926, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] atom_concat(_1522970, '-p', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] if_or_else(eval_maybe_defn(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426), eval_maybe_subst(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] eval_maybe_defn(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _811998, _811998])
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _811998, _811998])
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] trace_eval(eval_defn_choose_candidates(=, _1035308), defn, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] must_det_ll((notrace((flag(eval_num, _1533010, _1533010+1), _1533028 is _1533010 mod 500, _1533046 is 99-495 mod 100, _1533070=_1533072, option_else('trace-length', _1533084, 500), option_else('trace-depth', _1533092, 30))), quietly(if_t((nop(stop_rtrace), _1533028>_1533084), (set_debug(eval, false), _1533148 is _1533084+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1533148])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1533200)))))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] once(user:(notrace((flag(eval_num, _1533010, _1533010+1), _1533028 is _1533010 mod 500, _1533046 is 99-495 mod 100, _1533070=_1533072, option_else('trace-length', _1533084, 500), option_else('trace-depth', _1533092, 30))), quietly(if_t((nop(stop_rtrace), _1533028>_1533084), (set_debug(eval, false), _1533148 is _1533084+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1533148])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1533200)))))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_1535246, _1535248), once(user:(flag(eval_num, _1533010, _1533010+1), _1533028 is _1533010 mod 500, _1533046 is 99-495 mod 100, _1533070=_1533072, option_else('trace-length', _1533084, 500), option_else('trace-depth', _1533092, 30))), '$restore_trace'(_1535246, _1535248))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_1535246, _1535248))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 576, 576+1), 76 is 576 mod 500, 4 is 99-495 mod 100, _1533070=_1533070, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 76>500), (set_debug(eval, false), _1533148 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1533148])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 76>500), (set_debug(eval, false), _1533148 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1533148])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(316) [user] nop(notrace(no_repeats_var(_1533200)))
   <span class="ansi1 ansi32"
>Exit: </span>(316) [user] nop(notrace(no_repeats_var(_1533200)))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [system] once(user:(notrace((flag(eval_num, 576, 576+1), 76 is 576 mod 500, 4 is 99-495 mod 100, _1533070=_1533070, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 76>500), (set_debug(eval, false), _1533148 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1533148])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1533200)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] must_det_ll(user:(notrace((flag(eval_num, 576, 576+1), 76 is 576 mod 500, 4 is 99-495 mod 100, _1533070=_1533070, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 76>500), (set_debug(eval, false), _1533148 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1533148])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1533200)))))
   <span class="ansi1 ansi32"
>Call: </span>(313) [occurs] occurs:sub_term(_1544898, defn)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [occurs] occurs:sub_term(defn, defn)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] defn\=defn
   <span class="ansi1 ansi31"
>Fail: </span>(313) [system] defn\=defn
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(313) [occurs] occurs:sub_term(_1544898, defn)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _1552004=defn
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] defn=defn
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] if_trace((eval;defn), (_1533070=1, indentq(4, 76, -->, [defn, ['if-unify-or-empty', _811998, _811998]])))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_1555144, _1555146), once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _1533070=1, indentq(4, 76, -->, [defn, ['if-unify-or-empty', _811998, _811998]]))), _1555102, fbug((_1555102-->if_trace((eval;defn), (_1533070=1, indentq(4, 76, -->, [defn, ['if-unify-or-empty', _811998, _811998]])))))))), '$restore_trace'(_1555144, _1555146))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_1555144, _1555146))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _1533070=1, indentq(4, 76, -->, [defn, ['if-unify-or-empty', _811998, _811998]]))), _1555102, fbug((_1555102-->if_trace((eval;defn), (_1533070=1, indentq(4, 76, -->, [defn, ['if-unify-or-empty', _811998, _811998]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] if_trace((eval;defn), (_1533070=1, indentq(4, 76, -->, [defn, ['if-unify-or-empty', _811998, _811998]])))
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _1559340=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _1561378=(\+ \+ (flag(eval_num, _1561398, _1561398+1), (retval(fail)\=@=retval(fail), nonvar(_1185426)->indentq(4, _1561398, <--, [defn, _1185426]);indentq(4, _1561398, <--, [defn, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] (\+ \+ (flag(eval_num, _1561398, _1561398+1), (retval(fail)\=@=retval(fail), nonvar(_1185426)->indentq(4, _1561398, <--, [defn, _1185426]);indentq(4, _1561398, <--, [defn, retval(fail)]))))=(\+ \+ (flag(eval_num, _1561398, _1561398+1), (retval(fail)\=@=retval(fail), nonvar(_1185426)->indentq(4, _1561398, <--, [defn, _1185426]);indentq(4, _1561398, <--, [defn, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] call_cleanup(((call(eval_defn_choose_candidates(=, _1035308), 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426)*->nb_setarg(1, retval(fail), _1185426);fail, trace, call(eval_defn_choose_candidates(=, _1035308), 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426)), ignore(notrace((\+_1185426\=_1533200, nb_setarg(1, retval(fail), _1185426))))), ignore((_1533070==1->ignore(\+ \+ (flag(eval_num, _1561398, _1561398+1), (retval(fail)\=@=retval(fail), nonvar(_1185426)->indentq(4, _1561398, <--, [defn, _1185426]);indentq(4, _1561398, <--, [defn, retval(fail)]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1561398, _1561398+1), (retval(fail)\=@=retval(fail), nonvar(_1185426)->indentq(4, _1561398, <--, [defn, _1185426]);indentq(4, _1561398, <--, [defn, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_defn_choose_candidates(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] findall((_1565740->_1565742), get_defn_expansions(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1565740, _1565742), _1565760)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [$bags] findall((_1565740->_1565742), user:get_defn_expansions(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1565740, _1565742), _1565760, [])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [$bags] cleanup_bag(findall_loop((_1565740->_1565742), user:get_defn_expansions(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1565740, _1565742), _1565760, []), '$destroy_findall_bag')
   <span class="ansi1 ansi32"
>Call: </span>(319) [$bags] findall_loop((_1565740->_1565742), user:get_defn_expansions(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1565740, _1565742), _1565760, [])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] get_defn_expansions(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1565740, _1565742)
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] same_len_copy([_811998, _811998], _1570932)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] length([_811998, _811998], _1571950)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(_1571950)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] var(_1571950)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] []==[]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _1571950=2
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] 2=2
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] length([_811998, _811998], 2)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] length(_1570932, 2)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(2)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] integer(2)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] integer(2)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _1570932==[]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(_1570932)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] var(_1570932)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] length([_1587174, _1587180], 2)
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [user] same_len_copy([_811998, _811998], [_1587174, _1587180])
   <span class="ansi1 ansi32"
>Call: </span>(321) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _1587174, _1587180], _1565742)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] ignore((=)=(=))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] (=)=(=)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] (=)=(=)
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] ignore(user:((=)=(=)))
   <span class="ansi1 ansi32"
>Call: </span>(322) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _1587174, _1587180], _1565742]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _1587174, _1587180], _1565742]))
   <span class="ansi1 ansi32"
>Call: </span>(323) [user] metta_atom('&self', [=, ['if-unify-or-empty', _1587174, _1587180], _1565742])
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] typed_list('&self', _1596496, _1596370)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(325) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(324) [user] typed_list('&self', _1599540, _1596370)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _1587174, _1587180], _1565742])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _1587174, _1587180], _1565742], _1602594, _1602596)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] loaded_into_kb('&self', _1603492)
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] loaded_into_kb('&self', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] once(user:asserted_metta_pred(_1609460, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] asserted_metta_pred(_1609460, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(327) [user] asserted_metta_pred(_1609460, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(324) [user] metta_atom_asserted('&self', [=, ['if-unify-or-empty', _1587174, _1587180], _1565742])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] metta_atom_asserted_deduced('&self', [=, ['if-unify-or-empty', _1587174, _1587180], _1565742])
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(324) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _1587174, _1587180], _1565742])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] typed_list('&corelib', _1633526, _1633400)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(326) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(325) [user] typed_list('&corelib', _1636570, _1633400)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _1587174, _1587180], _1565742])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _1587174, _1587180], _1565742], _1639624, _1639626)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] loaded_into_kb('&corelib', _1640522)
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] once(user:asserted_metta_pred(_1646466, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] asserted_metta_pred(_1646466, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(328) [user] asserted_metta_pred(_1646466, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] once(user:asserted_metta_pred(_1666148, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] asserted_metta_pred(_1666148, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(328) [user] asserted_metta_pred(_1666148, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(325) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _1587174, _1587180], _1565742])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] metta_atom_asserted_deduced('&corelib', [=, ['if-unify-or-empty', _1587174, _1587180], _1565742])
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] fail
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _1587174, _1587174], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(324) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _1587174, _1587174], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(323) [user] metta_atom('&self', [=, ['if-unify-or-empty', _1587174, _1587174], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _1587174, _1587174], unified]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _1587174, _1587174], unified]))
   <span class="ansi1 ansi32"
>Exit: </span>(321) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _1587174, _1587174], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] get_defn_expansions(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], ['if-unify-or-empty', _1587174, _1587174], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _1587174, _1587180], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(324) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _1587174, _1587180], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(323) [user] metta_atom('&self', [=, ['if-unify-or-empty', _1587174, _1587180], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _1587174, _1587180], [empty]]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _1587174, _1587180], [empty]]))
   <span class="ansi1 ansi32"
>Exit: </span>(321) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _1587174, _1587180], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] get_defn_expansions(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], ['if-unify-or-empty', _1587174, _1587180], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(319) [$bags] findall_loop((_1565740->_1565742), user:get_defn_expansions(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1565740, _1565742), [(['if-unify-or-empty', _1699152, _1699152]->unified), (['if-unify-or-empty', _1699116, _1699122]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [$bags] cleanup_bag('$bags':findall_loop((_1565740->_1565742), user:get_defn_expansions(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1565740, _1565742), [(['if-unify-or-empty', _1699152, _1699152]->unified), (['if-unify-or-empty', _1699116, _1699122]->[empty])], []), '$bags':'$destroy_findall_bag')
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [$bags] findall((_1565740->_1565742), user:get_defn_expansions(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1565740, _1565742), [(['if-unify-or-empty', _1699152, _1699152]->unified), (['if-unify-or-empty', _1699116, _1699122]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [$bags] findall((_1565740->_1565742), user:get_defn_expansions(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1565740, _1565742), [(['if-unify-or-empty', _1699152, _1699152]->unified), (['if-unify-or-empty', _1699116, _1699122]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_defn_bodies(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426, [(['if-unify-or-empty', _1699152, _1699152]->unified), (['if-unify-or-empty', _1699116, _1699122]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] if_trace(e, maplist(print_templates(495, '   '), [(['if-unify-or-empty', _1699152, _1699152]->unified), (['if-unify-or-empty', _1699116, _1699122]->[empty])]))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_1705384, _1705386), once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(495, '   '), [(['if-unify-or-empty', _1699152, _1699152]->unified), (['if-unify-or-empty', _1699116, _1699122]->[empty])]))), _1705342, fbug((_1705342-->if_trace(e, maplist(print_templates(495, '   '), [(['if-unify-or-empty', _1699152, _1699152]->unified), (['if-unify-or-empty', _1699116, _1699122]->[empty])]))))))), '$restore_trace'(_1705384, _1705386))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_1705384, _1705386))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(495, '   '), [(['if-unify-or-empty', _1699152, _1699152]->unified), (['if-unify-or-empty', _1699116, _1699122]->[empty])]))), _1705342, fbug((_1705342-->if_trace(e, maplist(print_templates(495, '   '), [(['if-unify-or-empty', _1699152, _1699152]->unified), (['if-unify-or-empty', _1699116, _1699122]->[empty])]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [user] if_trace(e, maplist(print_templates(495, '   '), [(['if-unify-or-empty', _1699152, _1699152]->unified), (['if-unify-or-empty', _1699116, _1699122]->[empty])]))
   <span class="ansi1 ansi32"
>Call: </span>(317) [user] if_or_else((member((_1709594->_1709596), [(['if-unify-or-empty', _1699152, _1699152]->unified), (['if-unify-or-empty', _1699116, _1699122]->[empty])]), copy_term((_1709594->_1709596), _1709608), eval_defn_success(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426, _1709594, _1709596, _1709608)), eval_defn_failure(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426))
   <span class="ansi1 ansi32"
>Call: </span>(319) [lists] lists:member((_1709594->_1709596), [(['if-unify-or-empty', _1699152, _1699152]->unified), (['if-unify-or-empty', _1699116, _1699122]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(320) [lists] lists:member_([(['if-unify-or-empty', _1699116, _1699122]->[empty])], (_1709594->_1709596), (['if-unify-or-empty', _1699152, _1699152]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [lists] lists:member_([(['if-unify-or-empty', _1699116, _1699122]->[empty])], (['if-unify-or-empty', _1699152, _1699152]->unified), (['if-unify-or-empty', _1699152, _1699152]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [lists] lists:member((['if-unify-or-empty', _1699152, _1699152]->unified), [(['if-unify-or-empty', _1699152, _1699152]->unified), (['if-unify-or-empty', _1699116, _1699122]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] copy_term((['if-unify-or-empty', _1699152, _1699152]->unified), _1709608)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] copy_term((['if-unify-or-empty', _1699152, _1699152]->unified), (['if-unify-or-empty', _1715758, _1715758]->unified))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_defn_success(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426, ['if-unify-or-empty', _1699152, _1699152], unified, (['if-unify-or-empty', _1715758, _1715758]->unified))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] ['if-unify-or-empty', _811998, _811998]=['if-unify-or-empty', _1699152, _1699152]
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] ['if-unify-or-empty', _811998, _811998]=['if-unify-or-empty', _811998, _811998]
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _1185426=unified
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] unified=unified
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] ['if-unify-or-empty', _811998, _811998]\=@=unified
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] ['if-unify-or-empty', _811998, _811998]\=@=unified
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1715758, _1715758]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_1725006, _1725008), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1715758, _1715758]->unified)))))), _1724964, fbug((_1724964-->if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1715758, _1715758]->unified)))))))))), '$restore_trace'(_1725006, _1725008))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_1725006, _1725008))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1715758, _1715758]->unified)))))), _1724964, fbug((_1724964-->if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1715758, _1715758]->unified)))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1715758, _1715758]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] light_eval(=, _1035308, 495, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] light_eval(=, _1035308, 495, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] eval_defn_success(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified, ['if-unify-or-empty', _811998, _811998], unified, (['if-unify-or-empty', _1715758, _1715758]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(317) [user] if_or_else((member((['if-unify-or-empty', _811998, _811998]->unified), [(['if-unify-or-empty', _811998, _811998]->unified), (['if-unify-or-empty', _1699116, _1699122]->[empty])]), copy_term((['if-unify-or-empty', _811998, _811998]->unified), (['if-unify-or-empty', _1715758, _1715758]->unified)), eval_defn_success(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified, ['if-unify-or-empty', _811998, _811998], unified, (['if-unify-or-empty', _1715758, _1715758]->unified))), eval_defn_failure(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] eval_defn_bodies(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified, [(['if-unify-or-empty', _811998, _811998]->unified), (['if-unify-or-empty', _1699116, _1699122]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] eval_defn_choose_candidates(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] ignore(notrace((\+unified\=_1533200, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_1738454, _1738456), once(user:(\+unified\=_1533200, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_1738454, _1738456))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_1738454, _1738456))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_1533200, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] ignore(user:notrace((\+unified\=_1533200, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _1035308), 495, '&self', ['if-unify-or-empty', _811998, _811998], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_defn_choose_candidates(=, _1035308), 495, '&self', ['if-unify-or-empty', _811998, _811998], unified)), ignore(notrace((\+unified\=_1533200, nb_setarg(1, retval(unified), unified))))), user:ignore((_1533070==1->ignore(\+ \+ (flag(eval_num, _1561398, _1561398+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(4, _1561398, <--, [defn, unified]);indentq(4, _1561398, <--, [defn, retval(unified)]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1561398, _1561398+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(4, _1561398, <--, [defn, unified]);indentq(4, _1561398, <--, [defn, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] trace_eval(eval_defn_choose_candidates(=, _1035308), defn, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] eval_maybe_defn(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else(eval_maybe_defn(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified), eval_maybe_subst(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified))
   <span class="ansi1 ansi32"
>Exit: </span>(309) [user] if_or_else(eval_maybe_host_function(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified), if_or_else(eval_maybe_defn(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified), eval_maybe_subst(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified)))
   <span class="ansi1 ansi32"
>Exit: </span>(308) [user] if_or_else(eval_maybe_host_predicate(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified), if_or_else(eval_maybe_host_function(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified), if_or_else(eval_maybe_defn(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified), eval_maybe_subst(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified))))
   <span class="ansi1 ansi32"
>Exit: </span>(307) [user] if_or_else(eval_maybe_python(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified), if_or_else(eval_maybe_host_predicate(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified), if_or_else(eval_maybe_host_function(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified), if_or_else(eval_maybe_defn(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified), eval_maybe_subst(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_70(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] check_returnval(=, _1035308, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] check_returnval(=, _1035308, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [user] eval_41(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] eval_40(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] unified=_1050768
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] eval_20(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified)
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] ignore(notrace((\+unified\=_1052012, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_1762984, _1762986), once(user:(\+unified\=_1052012, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_1762984, _1762986))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_1762984, _1762986))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_1052012, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [system] ignore(user:notrace((\+unified\=_1052012, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] call_cleanup(user:((call(eval_20(=, _1035308), 495, '&self', ['if-unify-or-empty', _811998, _811998], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_20(=, _1035308), 495, '&self', ['if-unify-or-empty', _811998, _811998], unified)), ignore(notrace((\+unified\=_1052012, nb_setarg(1, retval(unified), unified))))), user:ignore((_1051882==1->ignore(\+ \+ (flag(eval_num, _1080210, _1080210+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(4, _1080210, <--, [e, unified]);indentq(4, _1080210, <--, [e, retval(unified)]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1080210, _1080210+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(4, _1080210, <--, [e, unified]);indentq(4, _1080210, <--, [e, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] trace_eval(eval_20(=, _1035308), e, 495, '&self', ['if-unify-or-empty', _811998, _811998], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] self_eval(unified)
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_1772218, _1772220), once(user:self_eval0(unified)), '$restore_trace'(_1772218, _1772220))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_1772218, _1772220))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(unified)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] self_eval(unified)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] _1018830=unified
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] eval_01(=, _1035308, 496, '&self', ['if-unify-or-empty', _811998, _811998], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [user] eval_00(=, _1035308, 496, '&self', ['if-unify-or-empty', _811998, _811998], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] eval_args(=, _1035308, 496, '&self', ['if-unify-or-empty', _811998, _811998], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] setup_call_cleanup('$notrace'(_1782536, _1782538), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _1782494, fbug((_1782494-->if_trace(case, writeqln(switch=unified))))))), '$restore_trace'(_1782536, _1782538))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] sig_atomic(system:'$notrace'(_1782536, _1782538))
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _1782494, fbug((_1782494-->if_trace(case, writeqln(switch=unified))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] select_case(496, '&self', unified, ['Empty'-_812016], _1786732)
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] best_key(unified, ['Empty'-_812016], _1786732)
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_1788784-_1786732, ['Empty'-_812016])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member_([], _1788784-_1786732, 'Empty'-_812016)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member_([], 'Empty'-_812016, 'Empty'-_812016)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [lists] lists:member('Empty'-_812016, ['Empty'-_812016])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] unified='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_1793878-_1786732, ['Empty'-_812016])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member_([], _1793878-_1786732, 'Empty'-_812016)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member_([], 'Empty'-_812016, 'Empty'-_812016)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [lists] lists:member('Empty'-_812016, ['Empty'-_812016])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] unified=='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_1798972-_1786732, ['Empty'-_812016])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member_([], _1798972-_1786732, 'Empty'-_812016)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member_([], 'Empty'-_812016, 'Empty'-_812016)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [lists] lists:member('Empty'-_812016, ['Empty'-_812016])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] unified=@='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_1804066-_1786732, ['Empty'-_812016])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member_([], _1804066-_1786732, 'Empty'-_812016)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member_([], 'Empty'-_812016, 'Empty'-_812016)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [lists] lists:member('Empty'-_812016, ['Empty'-_812016])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] unified='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] maybe_special_keys(496, '&self', ['Empty'-_812016], _1809158)
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] eval_args(496, '&self', 'Empty', _1810192)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] eval_args(=, _1811344, 496, '&self', 'Empty', _1810192)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] var('Empty')
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_1813276, _1813278), once(user:self_eval('Empty')), '$restore_trace'(_1813276, _1813278))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_1813276, _1813278))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval('Empty')), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] _1810192='Empty'
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] 'Empty'='Empty'
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] eval_args(=, _1818578, 496, '&self', 'Empty', 'Empty')
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] eval_args(496, '&self', 'Empty', 'Empty')
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] 'Empty'\=@='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] maybe_special_keys(496, '&self', [], _1809158)
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] maybe_special_keys(496, '&self', [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [user] maybe_special_keys(496, '&self', ['Empty'-_812016], [])
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] best_key(unified, [], _1786732)
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_1825620-_1786732, [])
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_1826642-_1786732, [])
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_1827664-_1786732, [])
   <span class="ansi1 ansi32"
>Call: </span>(299) [lists] lists:member(_1828686-_1786732, [])
   <span class="ansi1 ansi32"
>Call: </span>(298) [lists] lists:member(_1829708-_1786732, [])
   <span class="ansi1 ansi32"
>Call: </span>(297) [lists] lists:member(_1830730-_1830732, ['Empty'-_812016])
   <span class="ansi1 ansi32"
>Call: </span>(298) [lists] lists:member_([], _1830730-_1830732, 'Empty'-_812016)
   <span class="ansi1 ansi32"
>Exit: </span>(298) [lists] lists:member_([], 'Empty'-_812016, 'Empty'-_812016)
   <span class="ansi1 ansi32"
>Exit: </span>(297) [lists] lists:member('Empty'-_812016, ['Empty'-_812016])
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] 'Empty'=='%void%'
   <span class="ansi1 ansi32"
>Call: </span>(321) [lists] lists:member_([], (_1709594->_1709596), (['if-unify-or-empty', _1699116, _1699122]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(321) [lists] lists:member_([], (['if-unify-or-empty', _1699116, _1699122]->[empty]), (['if-unify-or-empty', _1699116, _1699122]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [lists] lists:member_([(['if-unify-or-empty', _1699116, _1699122]->[empty])], (['if-unify-or-empty', _1699116, _1699122]->[empty]), (['if-unify-or-empty', _1699152, _1699152]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [lists] lists:member((['if-unify-or-empty', _1699116, _1699122]->[empty]), [(['if-unify-or-empty', _1699152, _1699152]->unified), (['if-unify-or-empty', _1699116, _1699122]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] copy_term((['if-unify-or-empty', _1699116, _1699122]->[empty]), _1709608)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] copy_term((['if-unify-or-empty', _1699116, _1699122]->[empty]), (['if-unify-or-empty', _1840930, _1840936]->[empty]))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_defn_success(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], _1185426, ['if-unify-or-empty', _1699116, _1699122], [empty], (['if-unify-or-empty', _1840930, _1840936]->[empty]))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] ['if-unify-or-empty', _811998, _811998]=['if-unify-or-empty', _1699116, _1699122]
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] ['if-unify-or-empty', _811998, _811998]=['if-unify-or-empty', _811998, _811998]
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _1185426=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] [empty]=[empty]
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] ['if-unify-or-empty', _811998, _811998]\=@=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] ['if-unify-or-empty', _811998, _811998]\=@=[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1840930, _1840936]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_1850178, _1850180), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1840930, _1840936]->[empty])))))), _1850136, fbug((_1850136-->if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1840930, _1840936]->[empty])))))))))), '$restore_trace'(_1850178, _1850180))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_1850178, _1850180))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1840930, _1840936]->[empty])))))), _1850136, fbug((_1850136-->if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1840930, _1840936]->[empty])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_trace(e, color_g_mesg('#773700', indentq2(495, defs_used((['if-unify-or-empty', _1840930, _1840936]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] light_eval(=, _1035308, 495, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] light_eval(=, _1035308, 495, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] eval_defn_success(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty], ['if-unify-or-empty', _811998, _811998], [empty], (['if-unify-or-empty', _1840930, _1840936]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(317) [user] if_or_else((member((['if-unify-or-empty', _811998, _811998]->[empty]), [(['if-unify-or-empty', _1699152, _1699152]->unified), (['if-unify-or-empty', _811998, _811998]->[empty])]), copy_term((['if-unify-or-empty', _811998, _811998]->[empty]), (['if-unify-or-empty', _1840930, _1840936]->[empty])), eval_defn_success(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty], ['if-unify-or-empty', _811998, _811998], [empty], (['if-unify-or-empty', _1840930, _1840936]->[empty]))), eval_defn_failure(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty]))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] eval_defn_bodies(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty], [(['if-unify-or-empty', _1699152, _1699152]->unified), (['if-unify-or-empty', _811998, _811998]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] eval_defn_choose_candidates(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] ignore(notrace((\+[empty]\=_1533200, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_1863634, _1863636), once(user:(\+[empty]\=_1533200, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_1863634, _1863636))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_1863634, _1863636))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_1533200, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] ignore(user:notrace((\+[empty]\=_1533200, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] ignore((_1533070==1->ignore(\+ \+ (flag(eval_num, _1561398, _1561398+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1561398, <--, [defn, [empty]]);indentq(4, _1561398, <--, [defn, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1561398, _1561398+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1561398, <--, [defn, [empty]]);indentq(4, _1561398, <--, [defn, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] _1533070==1
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] _1533070==1
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_1870826, _1870828), once(user:ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1561398, _1561398+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1561398, <--, [defn, [empty]]);indentq(4, _1561398, <--, [defn, retval([empty])])))))))), '$restore_trace'(_1870826, _1870828))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_1870826, _1870828))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1561398, _1561398+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1561398, <--, [defn, [empty]]);indentq(4, _1561398, <--, [defn, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] ignore(user:(_1533070==1->ignore(\+ \+ (flag(eval_num, _1561398, _1561398+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1561398, <--, [defn, [empty]]);indentq(4, _1561398, <--, [defn, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1561398, _1561398+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1561398, <--, [defn, [empty]]);indentq(4, _1561398, <--, [defn, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _1035308), 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_defn_choose_candidates(=, _1035308), 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty])), ignore(notrace((\+[empty]\=_1533200, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_1533070==1->ignore(\+ \+ (flag(eval_num, _1561398, _1561398+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1561398, <--, [defn, [empty]]);indentq(4, _1561398, <--, [defn, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _1561398, _1561398+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1561398, <--, [defn, [empty]]);indentq(4, _1561398, <--, [defn, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] trace_eval(eval_defn_choose_candidates(=, _1035308), defn, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] eval_maybe_defn(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else(eval_maybe_defn(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty]), eval_maybe_subst(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(309) [user] if_or_else(eval_maybe_host_function(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty]), if_or_else(eval_maybe_defn(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty]), eval_maybe_subst(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty])))
   <span class="ansi1 ansi32"
>Exit: </span>(308) [user] if_or_else(eval_maybe_host_predicate(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty]), if_or_else(eval_maybe_host_function(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty]), if_or_else(eval_maybe_defn(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty]), eval_maybe_subst(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty]))))
   <span class="ansi1 ansi32"
>Exit: </span>(307) [user] if_or_else(eval_maybe_python(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty]), if_or_else(eval_maybe_host_predicate(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty]), if_or_else(eval_maybe_host_function(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty]), if_or_else(eval_maybe_defn(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty]), eval_maybe_subst(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty])))))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_70(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] check_returnval(=, _1035308, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] check_returnval(=, _1035308, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [user] eval_41(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] eval_40(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [empty]=_1050768
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] [empty]=[empty]
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] eval_20(=, _1035308, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] ignore(notrace((\+[empty]\=_1052012, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_1895530, _1895532), once(user:(\+[empty]\=_1052012, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_1895530, _1895532))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_1895530, _1895532))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_1052012, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [system] ignore(user:notrace((\+[empty]\=_1052012, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] ignore((_1051882==1->ignore(\+ \+ (flag(eval_num, _1080210, _1080210+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1080210, <--, [e, [empty]]);indentq(4, _1080210, <--, [e, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1080210, _1080210+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1080210, <--, [e, [empty]]);indentq(4, _1080210, <--, [e, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] _1051882==1
   <span class="ansi1 ansi31"
>Fail: </span>(305) [system] _1051882==1
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] setup_call_cleanup('$notrace'(_1902722, _1902724), once(user:ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1080210, _1080210+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1080210, <--, [e, [empty]]);indentq(4, _1080210, <--, [e, retval([empty])])))))))), '$restore_trace'(_1902722, _1902724))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] sig_atomic(system:'$notrace'(_1902722, _1902724))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1080210, _1080210+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1080210, <--, [e, [empty]]);indentq(4, _1080210, <--, [e, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [system] ignore(user:(_1051882==1->ignore(\+ \+ (flag(eval_num, _1080210, _1080210+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1080210, <--, [e, [empty]]);indentq(4, _1080210, <--, [e, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1080210, _1080210+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1080210, <--, [e, [empty]]);indentq(4, _1080210, <--, [e, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] call_cleanup(user:((call(eval_20(=, _1035308), 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_20(=, _1035308), 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty])), ignore(notrace((\+[empty]\=_1052012, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_1051882==1->ignore(\+ \+ (flag(eval_num, _1080210, _1080210+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1080210, <--, [e, [empty]]);indentq(4, _1080210, <--, [e, retval([empty])]))));notrace(ignore(if_t(4<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _1080210, _1080210+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(4, _1080210, <--, [e, [empty]]);indentq(4, _1080210, <--, [e, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] trace_eval(eval_20(=, _1035308), e, 495, '&self', ['if-unify-or-empty', _811998, _811998], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_1912122, _1912124), once(user:self_eval0([empty])), '$restore_trace'(_1912122, _1912124))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_1912122, _1912124))
^  <span class="ansi1 ansi31"
>Fail: </span>(300) [user] self_eval([empty])
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] [empty]=@=['if-unify-or-empty', _1049726, _1049726]
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] eval_01(=, _1035308, 495, '&self', [empty], _1916226)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] [empty]\==[empty]
   <span class="ansi1 ansi32"
>Call: </span>(297) [lists] lists:member(_1918284-_1918286, ['Empty'-_812016])
   <span class="ansi1 ansi32"
>Call: </span>(298) [lists] lists:member_([], _1918284-_1918286, 'Empty'-_812016)
   <span class="ansi1 ansi32"
>Exit: </span>(298) [lists] lists:member_([], 'Empty'-_812016, 'Empty'-_812016)
   <span class="ansi1 ansi32"
>Exit: </span>(297) [lists] lists:member('Empty'-_812016, ['Empty'-_812016])
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi31"
>Fail: </span>(295) [user] eval_20(=, _821682, 496, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _873720)
   <span class="ansi1 ansi32"
>Call: </span>(295) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(295) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] ignore((_874834==1->ignore(\+ \+ (flag(eval_num, _903162, _903162+1), (retval(fail)\=@=retval(fail), nonvar(_873720)->indentq(3, _903162, <--, [e, _873720]);indentq(3, _903162, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _903162, _903162+1), (retval(fail)\=@=retval(fail), nonvar(_873720)->indentq(3, _903162, <--, [e, _873720]);indentq(3, _903162, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] _874834==1
   <span class="ansi1 ansi31"
>Fail: </span>(297) [system] _874834==1
^  <span class="ansi1 ansi32"
>Call: </span>(298) [system] setup_call_cleanup('$notrace'(_1929480, _1929482), once(user:ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _903162, _903162+1), (retval(fail)\=@=retval(fail), nonvar(_873720)->indentq(3, _903162, <--, [e, _873720]);indentq(3, _903162, <--, [e, retval(fail)])))))))), '$restore_trace'(_1929480, _1929482))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] sig_atomic(system:'$notrace'(_1929480, _1929482))
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _903162, _903162+1), (retval(fail)\=@=retval(fail), nonvar(_873720)->indentq(3, _903162, <--, [e, _873720]);indentq(3, _903162, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(295) [system] ignore(user:(_874834==1->ignore(\+ \+ (flag(eval_num, _903162, _903162+1), (retval(fail)\=@=retval(fail), nonvar(_873720)->indentq(3, _903162, <--, [e, _873720]);indentq(3, _903162, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _903162, _903162+1), (retval(fail)\=@=retval(fail), nonvar(_873720)->indentq(3, _903162, <--, [e, _873720]);indentq(3, _903162, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(293) [system] call_cleanup(user:((call(eval_20(=, _821682), 496, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _873720)*->nb_setarg(1, retval(fail), _873720);fail, trace, call(eval_20(=, _821682), 496, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _873720)), ignore(notrace((\+_873720\=_874964, nb_setarg(1, retval(fail), _873720))))), user:ignore((_874834==1->ignore(\+ \+ (flag(eval_num, _903162, _903162+1), (retval(fail)\=@=retval(fail), nonvar(_873720)->indentq(3, _903162, <--, [e, _873720]);indentq(3, _903162, <--, [e, retval(fail)]))));notrace(ignore(if_t(3<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _903162, _903162+1), (retval(fail)\=@=retval(fail), nonvar(_873720)->indentq(3, _903162, <--, [e, _873720]);indentq(3, _903162, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(292) [user] trace_eval(eval_20(=, _821682), e, 496, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _873720)
^  <span class="ansi1 ansi31"
>Fail: </span>(289) [user] eval_args(=, _821682, 497, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940)
^  <span class="ansi1 ansi32"
>Call: </span>(286) [user] call(eval, [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940)
   <span class="ansi1 ansi32"
>Call: </span>(287) [user] eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940)
^  <span class="ansi1 ansi32"
>Call: </span>(288) [user] current_self(_1938888)
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] nb_current(self_space, _1938888)
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(289) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(289) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(288) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(288) [user] eval('&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940)
   <span class="ansi1 ansi32"
>Call: </span>(289) [user] eval_H(500, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940)
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] fast_option_value(compile, save)
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] atom(compile)
   <span class="ansi1 ansi32"
>Exit: </span>(291) [system] atom(compile)
   <span class="ansi1 ansi32"
>Call: </span>(291) [system] current_prolog_flag(compile, save)
   <span class="ansi1 ansi31"
>Fail: </span>(291) [system] current_prolog_flag(compile, save)
^  <span class="ansi1 ansi31"
>Fail: </span>(290) [user] fast_option_value(compile, save)
^  <span class="ansi1 ansi32"
>Call: </span>(290) [user] catch_metta_return(eval_args(=, _1953090, 500, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940), _824940)
^  <span class="ansi1 ansi32"
>Call: </span>(292) [user] eval_args(=, _1953090, 500, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] var([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] setup_call_cleanup('$notrace'(_1956200, _1956202), once(user:self_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])), '$restore_trace'(_1956200, _1956202))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] sig_atomic(system:'$notrace'(_1956200, _1956202))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] setup_call_cleanup('$notrace'(_1958288, _1958290), once(user:nonvar(_824940)), '$restore_trace'(_1958288, _1958290))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] sig_atomic(system:'$notrace'(_1958288, _1958290))
^  <span class="ansi1 ansi32"
>Call: </span>(294) [system] setup_call_cleanup('$notrace'(_1960376, _1960378), once(user:nonvar(_824940)), '$restore_trace'(_1960376, _1960378))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] sig_atomic(system:'$notrace'(_1960376, _1960378))
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] [['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(293) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(293) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] self_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Call: </span>(295) [system] setup_call_cleanup('$notrace'(_1967532, _1967534), once(user:self_eval0([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])), '$restore_trace'(_1967532, _1967534))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [system] sig_atomic(system:'$notrace'(_1967532, _1967534))
^  <span class="ansi1 ansi31"
>Fail: </span>(293) [user] self_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Call: </span>(293) [user] eval_00(=, _1953090, 500, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940)
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] self_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Call: </span>(296) [system] setup_call_cleanup('$notrace'(_1972676, _1972678), once(user:self_eval0([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])), '$restore_trace'(_1972676, _1972678))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [system] sig_atomic(system:'$notrace'(_1972676, _1972678))
^  <span class="ansi1 ansi31"
>Fail: </span>(294) [user] self_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Call: </span>(294) [user] eval_01(=, _1953090, 500, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _824940)
   <span class="ansi1 ansi32"
>Call: </span>(295) [system] [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(295) [system] [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(297) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(295) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [system] setup_call_cleanup('$notrace'(_1982950, _1982952), once(user:(_1982926 is 500-1, copy_term([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _1982940))), '$restore_trace'(_1982950, _1982952))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [system] sig_atomic(system:'$notrace'(_1982950, _1982952))
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], [case, ['if-unify-or-empty', _1985048, _1985048], [['Empty', _1985078]]]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(295) [user] trace_eval(eval_20(=, _1953090), e, 499, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _1986114)
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] must_det_ll((notrace((flag(eval_num, _1987168, _1987168+1), _1987186 is _1987168 mod 500, _1987204 is 99-499 mod 100, _1987228=_1987230, option_else('trace-length', _1987242, 500), option_else('trace-depth', _1987250, 30))), quietly(if_t((nop(stop_rtrace), _1987186>_1987242), (set_debug(eval, false), _1987306 is _1987242+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1987306])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1987358)))))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] once(user:(notrace((flag(eval_num, _1987168, _1987168+1), _1987186 is _1987168 mod 500, _1987204 is 99-499 mod 100, _1987228=_1987230, option_else('trace-length', _1987242, 500), option_else('trace-depth', _1987250, 30))), quietly(if_t((nop(stop_rtrace), _1987186>_1987242), (set_debug(eval, false), _1987306 is _1987242+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1987306])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1987358)))))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [system] setup_call_cleanup('$notrace'(_1989404, _1989406), once(user:(flag(eval_num, _1987168, _1987168+1), _1987186 is _1987168 mod 500, _1987204 is 99-499 mod 100, _1987228=_1987230, option_else('trace-length', _1987242, 500), option_else('trace-depth', _1987250, 30))), '$restore_trace'(_1989404, _1989406))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] sig_atomic(system:'$notrace'(_1989404, _1989406))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 577, 577+1), 77 is 577 mod 500, 0 is 99-499 mod 100, _1987228=_1987228, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 77>500), (set_debug(eval, false), _1987306 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1987306])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 77>500), (set_debug(eval, false), _1987306 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1987306])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(299) [user] nop(notrace(no_repeats_var(_1987358)))
   <span class="ansi1 ansi32"
>Exit: </span>(299) [user] nop(notrace(no_repeats_var(_1987358)))
^  <span class="ansi1 ansi32"
>Exit: </span>(297) [system] once(user:(notrace((flag(eval_num, 577, 577+1), 77 is 577 mod 500, 0 is 99-499 mod 100, _1987228=_1987228, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 77>500), (set_debug(eval, false), _1987306 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1987306])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1987358)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] must_det_ll(user:(notrace((flag(eval_num, 577, 577+1), 77 is 577 mod 500, 0 is 99-499 mod 100, _1987228=_1987228, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 77>500), (set_debug(eval, false), _1987306 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_1987306])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_1987358)))))
   <span class="ansi1 ansi32"
>Call: </span>(296) [occurs] occurs:sub_term(_1999056, e)
   <span class="ansi1 ansi32"
>Exit: </span>(296) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(296) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(297) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(297) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(296) [occurs] occurs:sub_term(_1999056, e)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] _2006162=e
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] if_trace((eval;e), (_1987228=1, indentq(0, 77, -->, [e, [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(298) [system] setup_call_cleanup('$notrace'(_2009302, _2009304), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _1987228=1, indentq(0, 77, -->, [e, [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]]))), _2009260, fbug((_2009260-->if_trace((eval;e), (_1987228=1, indentq(0, 77, -->, [e, [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]])))))))), '$restore_trace'(_2009302, _2009304))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [system] sig_atomic(system:'$notrace'(_2009302, _2009304))
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _1987228=1, indentq(0, 77, -->, [e, [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]]))), _2009260, fbug((_2009260-->if_trace((eval;e), (_1987228=1, indentq(0, 77, -->, [e, [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(296) [user] if_trace((eval;e), (_1987228=1, indentq(0, 77, -->, [e, [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]])))
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] _2013498=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(296) [system] _2015536=(\+ \+ (flag(eval_num, _2015556, _2015556+1), (retval(fail)\=@=retval(fail), nonvar(_1986114)->indentq(0, _2015556, <--, [e, _1986114]);indentq(0, _2015556, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(296) [system] (\+ \+ (flag(eval_num, _2015556, _2015556+1), (retval(fail)\=@=retval(fail), nonvar(_1986114)->indentq(0, _2015556, <--, [e, _1986114]);indentq(0, _2015556, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _2015556, _2015556+1), (retval(fail)\=@=retval(fail), nonvar(_1986114)->indentq(0, _2015556, <--, [e, _1986114]);indentq(0, _2015556, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(296) [user] call_cleanup(((call(eval_20(=, _1953090), 499, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _1986114)*->nb_setarg(1, retval(fail), _1986114);fail, trace, call(eval_20(=, _1953090), 499, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _1986114)), ignore(notrace((\+_1986114\=_1987358, nb_setarg(1, retval(fail), _1986114))))), ignore((_1987228==1->ignore(\+ \+ (flag(eval_num, _2015556, _2015556+1), (retval(fail)\=@=retval(fail), nonvar(_1986114)->indentq(0, _2015556, <--, [e, _1986114]);indentq(0, _2015556, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _2015556, _2015556+1), (retval(fail)\=@=retval(fail), nonvar(_1986114)->indentq(0, _2015556, <--, [e, _1986114]);indentq(0, _2015556, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] eval_20(=, _1953090, 499, '&self', [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _1986114)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] atom([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] no_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] self_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_2022944, _2022946), once(user:self_eval0([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])), '$restore_trace'(_2022944, _2022946))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_2022944, _2022946))
^  <span class="ansi1 ansi31"
>Fail: </span>(300) [user] self_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] atomic(case)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] atomic(case)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] is_sl(case)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] number(case)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] [['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] callable(case)
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] callable(case)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] [['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]==[]
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] is_list([['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] is_list([['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] is_list(case)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] is_list([['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] is_list([['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] is_list([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
   <span class="ansi1 ansi32"
>Exit: </span>(299) [system] is_list([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] once(expand_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _2045288))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] expand_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _2045288)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] is_list([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] is_list([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] ground(case)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] ground(case)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] apply:maplist(expand_eval, [['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _2051388)
   <span class="ansi1 ansi32"
>Call: </span>(302) [apply] apply:maplist_([['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], _2051388, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] expand_eval(['if-unify-or-empty', _811998, _811998], _2053444)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] is_list(['if-unify-or-empty', _811998, _811998])
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] is_list(['if-unify-or-empty', _811998, _811998])
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] apply:maplist(expand_eval, [_811998, _811998], _2058522)
   <span class="ansi1 ansi32"
>Call: </span>(305) [apply] apply:maplist_([_811998, _811998], _2058522, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] expand_eval(_811998, _2060578)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list(_811998)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _811998=_2060578
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] _811998=_811998
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] expand_eval(_811998, _811998)
   <span class="ansi1 ansi32"
>Call: </span>(306) [apply] apply:maplist_([_811998], _2060580, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] expand_eval(_811998, _2066680)
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] is_list(_811998)
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] _811998=_2066680
   <span class="ansi1 ansi32"
>Exit: </span>(308) [system] _811998=_811998
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] expand_eval(_811998, _811998)
   <span class="ansi1 ansi32"
>Call: </span>(307) [apply] apply:maplist_([], _2066682, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(306) [apply] apply:maplist_([_811998], [_811998], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(305) [apply] apply:maplist_([_811998, _811998], [_811998, _811998], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [apply] apply:maplist(user:expand_eval, [_811998, _811998], [_811998, _811998])
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] expand_eval(['if-unify-or-empty', _811998, _811998], ['if-unify-or-empty', _811998, _811998])
   <span class="ansi1 ansi32"
>Call: </span>(303) [apply] apply:maplist_([[['Empty', _812016]]], _2053446, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] expand_eval([['Empty', _812016]], _2078904)
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] is_list([['Empty', _812016]])
   <span class="ansi1 ansi32"
>Exit: </span>(305) [system] is_list([['Empty', _812016]])
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] ground(['Empty', _812016])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] apply:maplist(expand_eval, [], _2081952)
   <span class="ansi1 ansi32"
>Call: </span>(306) [apply] apply:maplist_([], _2081952, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(306) [apply] apply:maplist_([], [], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [apply] apply:maplist(user:expand_eval, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] expand_eval([['Empty', _812016]], [['Empty', _812016]])
   <span class="ansi1 ansi32"
>Call: </span>(304) [apply] apply:maplist_([], _2078906, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [apply] apply:maplist_([[['Empty', _812016]]], [[['Empty', _812016]]], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [apply] apply:maplist_([['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], [['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [apply] apply:maplist(user:expand_eval, [['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], [['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] expand_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]])
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [system] once(user:expand_eval([case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]], [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]))
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] [case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]\==[case, ['if-unify-or-empty', _811998, _811998], [['Empty', _812016]]]
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] is_progn(case)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] var(case)
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] is_space_op(case)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] must_det_ll([]==[])
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] once(user:([]==[]))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] []==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [system] once(user:([]==[]))
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] must_det_ll(user:([]==[]))
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] into_case_list([['Empty', _6642]], _18882)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] is_list([['Empty', _6642]])
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] is_list([['Empty', _6642]])
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] into_case_list([['Empty', _6642]], [['Empty', _6642]])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] into_case_keys(1, [['Empty', _6642]], _22940)
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] _23980 is 1+1
   <span class="ansi1 ansi32"
>Exit: </span>(300) [system] 2 is 1+1
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] is_case(_23970, ['Empty', _6642], _23972)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] is_case('Empty', ['Empty', _6642], _6642)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_6642)))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_29146, _29148), once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_6642))), _29104, fbug((_29104-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_6642)))))))), '$restore_trace'(_29146, _29148))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_29146, _29148))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), format('~N'), writeqln(c(1, 'Empty')=_6642))), _29104, fbug((_29104-->if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_6642)))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] if_trace(case, (format('~N'), writeqln(c(1, 'Empty')=_6642)))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] into_case_keys(2, [], _23966)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] into_case_keys(2, [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(299) [user] into_case_keys(1, [['Empty', _6642]], ['Empty'-_6642])
^  <span class="ansi1 ansi32"
>Call: </span>(299) [user] eval_case(=, _7894, 499, '&self', ['if-unify-or-empty', _6624, _6624], ['Empty'-_6642], _7996)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _6624, _6624]))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_38514, _38516), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _6624, _6624]))), _38472, fbug((_38472-->if_trace(case, writeqln(case=['if-unify-or-empty', _6624, _6624]))))))), '$restore_trace'(_38514, _38516))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_38514, _38516))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(case=['if-unify-or-empty', _6624, _6624]))), _38472, fbug((_38472-->if_trace(case, writeqln(case=['if-unify-or-empty', _6624, _6624]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] if_trace(case, writeqln(case=['if-unify-or-empty', _6624, _6624]))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] eval_args(=, _42836, 499, '&self', ['if-unify-or-empty', _6624, _6624], _42710)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] var(['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_44768, _44770), once(user:self_eval(['if-unify-or-empty', _6624, _6624])), '$restore_trace'(_44768, _44770))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_44768, _44770))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_46856, _46858), once(user:nonvar(_42710)), '$restore_trace'(_46856, _46858))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_46856, _46858))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_48944, _48946), once(user:nonvar(_42710)), '$restore_trace'(_48944, _48946))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_48944, _48946))
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] [_6624, _6624]==[]
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(301) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] self_eval(['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] setup_call_cleanup('$notrace'(_56100, _56102), once(user:self_eval0(['if-unify-or-empty', _6624, _6624])), '$restore_trace'(_56100, _56102))
^  <span class="ansi1 ansi32"
>Call: </span>(304) [system] sig_atomic(system:'$notrace'(_56100, _56102))
^  <span class="ansi1 ansi31"
>Fail: </span>(301) [user] self_eval(['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] eval_00(=, _59188, 499, '&self', ['if-unify-or-empty', _6624, _6624], _42710)
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] self_eval(['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(304) [system] setup_call_cleanup('$notrace'(_61246, _61248), once(user:self_eval0(['if-unify-or-empty', _6624, _6624])), '$restore_trace'(_61246, _61248))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] sig_atomic(system:'$notrace'(_61246, _61248))
^  <span class="ansi1 ansi31"
>Fail: </span>(302) [user] self_eval(['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] eval_01(=, _59188, 499, '&self', ['if-unify-or-empty', _6624, _6624], _42710)
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] ['if-unify-or-empty', _6624, _6624]\==[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] ['if-unify-or-empty', _6624, _6624]\==[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] if_t((499<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] 499<1
   <span class="ansi1 ansi31"
>Fail: </span>(305) [system] 499<1
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] if_t((499<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(304) [system] setup_call_cleanup('$notrace'(_71520, _71522), once(user:(_71496 is 499-1, copy_term(['if-unify-or-empty', _6624, _6624], _71510))), '$restore_trace'(_71520, _71522))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] sig_atomic(system:'$notrace'(_71520, _71522))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(498 is 499-1, copy_term(['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _73606, _73606]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] trace_eval(eval_20(=, _59188), e, 498, '&self', ['if-unify-or-empty', _6624, _6624], _74648)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] must_det_ll((notrace((flag(eval_num, _75702, _75702+1), _75720 is _75702 mod 500, _75738 is 99-498 mod 100, _75762=_75764, option_else('trace-length', _75776, 500), option_else('trace-depth', _75784, 30))), quietly(if_t((nop(stop_rtrace), _75720>_75776), (set_debug(eval, false), _75840 is _75776+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_75840])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_75892)))))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] once(user:(notrace((flag(eval_num, _75702, _75702+1), _75720 is _75702 mod 500, _75738 is 99-498 mod 100, _75762=_75764, option_else('trace-length', _75776, 500), option_else('trace-depth', _75784, 30))), quietly(if_t((nop(stop_rtrace), _75720>_75776), (set_debug(eval, false), _75840 is _75776+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_75840])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_75892)))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_77938, _77940), once(user:(flag(eval_num, _75702, _75702+1), _75720 is _75702 mod 500, _75738 is 99-498 mod 100, _75762=_75764, option_else('trace-length', _75776, 500), option_else('trace-depth', _75784, 30))), '$restore_trace'(_77938, _77940))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_77938, _77940))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 578, 578+1), 78 is 578 mod 500, 1 is 99-498 mod 100, _75762=_75762, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _75840 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_75840])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _75840 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_75840])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(307) [user] nop(notrace(no_repeats_var(_75892)))
   <span class="ansi1 ansi32"
>Exit: </span>(307) [user] nop(notrace(no_repeats_var(_75892)))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] once(user:(notrace((flag(eval_num, 578, 578+1), 78 is 578 mod 500, 1 is 99-498 mod 100, _75762=_75762, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _75840 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_75840])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_75892)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] must_det_ll(user:(notrace((flag(eval_num, 578, 578+1), 78 is 578 mod 500, 1 is 99-498 mod 100, _75762=_75762, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _75840 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_75840])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_75892)))))
   <span class="ansi1 ansi32"
>Call: </span>(304) [occurs] occurs:sub_term(_87590, e)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(304) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(305) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(305) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(304) [occurs] occurs:sub_term(_87590, e)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _94696=e
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] if_trace((eval;e), (_75762=1, indentq(1, 78, -->, [e, ['if-unify-or-empty', _6624, _6624]])))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] setup_call_cleanup('$notrace'(_97836, _97838), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _75762=1, indentq(1, 78, -->, [e, ['if-unify-or-empty', _6624, _6624]]))), _97794, fbug((_97794-->if_trace((eval;e), (_75762=1, indentq(1, 78, -->, [e, ['if-unify-or-empty', _6624, _6624]])))))))), '$restore_trace'(_97836, _97838))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] sig_atomic(system:'$notrace'(_97836, _97838))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _75762=1, indentq(1, 78, -->, [e, ['if-unify-or-empty', _6624, _6624]]))), _97794, fbug((_97794-->if_trace((eval;e), (_75762=1, indentq(1, 78, -->, [e, ['if-unify-or-empty', _6624, _6624]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [user] if_trace((eval;e), (_75762=1, indentq(1, 78, -->, [e, ['if-unify-or-empty', _6624, _6624]])))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _102032=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _104070=(\+ \+ (flag(eval_num, _104090, _104090+1), (retval(fail)\=@=retval(fail), nonvar(_74648)->indentq(1, _104090, <--, [e, _74648]);indentq(1, _104090, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] (\+ \+ (flag(eval_num, _104090, _104090+1), (retval(fail)\=@=retval(fail), nonvar(_74648)->indentq(1, _104090, <--, [e, _74648]);indentq(1, _104090, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _104090, _104090+1), (retval(fail)\=@=retval(fail), nonvar(_74648)->indentq(1, _104090, <--, [e, _74648]);indentq(1, _104090, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] call_cleanup(((call(eval_20(=, _59188), 498, '&self', ['if-unify-or-empty', _6624, _6624], _74648)*->nb_setarg(1, retval(fail), _74648);fail, trace, call(eval_20(=, _59188), 498, '&self', ['if-unify-or-empty', _6624, _6624], _74648)), ignore(notrace((\+_74648\=_75892, nb_setarg(1, retval(fail), _74648))))), ignore((_75762==1->ignore(\+ \+ (flag(eval_num, _104090, _104090+1), (retval(fail)\=@=retval(fail), nonvar(_74648)->indentq(1, _104090, <--, [e, _74648]);indentq(1, _104090, <--, [e, retval(fail)]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _104090, _104090+1), (retval(fail)\=@=retval(fail), nonvar(_74648)->indentq(1, _104090, <--, [e, _74648]);indentq(1, _104090, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_20(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _74648)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] atom(['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] no_eval(['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] self_eval(['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_111478, _111480), once(user:self_eval0(['if-unify-or-empty', _6624, _6624])), '$restore_trace'(_111478, _111480))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_111478, _111480))
^  <span class="ansi1 ansi31"
>Fail: </span>(308) [user] self_eval(['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] atomic('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(308) [system] atomic('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] is_sl('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] number('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] [_6624, _6624]==[]
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _122672==eval
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] callable('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] [_6624, _6624]==[]
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list([_6624, _6624])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] is_list([_6624, _6624])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list([_6624, _6624])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] is_list([_6624, _6624])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list(['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] is_list(['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] once(expand_eval(['if-unify-or-empty', _6624, _6624], _134850))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] expand_eval(['if-unify-or-empty', _6624, _6624], _134850)
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] is_list(['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Exit: </span>(309) [system] is_list(['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] ground('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(309) [system] ground('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] apply:maplist(expand_eval, [_6624, _6624], _140950)
   <span class="ansi1 ansi32"
>Call: </span>(310) [apply] apply:maplist_([_6624, _6624], _140950, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] expand_eval(_6624, _143006)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] is_list(_6624)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] _6624=_143006
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] _6624=_6624
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] expand_eval(_6624, _6624)
   <span class="ansi1 ansi32"
>Call: </span>(311) [apply] apply:maplist_([_6624], _143008, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] expand_eval(_6624, _149108)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list(_6624)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _6624=_149108
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] _6624=_6624
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] expand_eval(_6624, _6624)
   <span class="ansi1 ansi32"
>Call: </span>(312) [apply] apply:maplist_([], _149110, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(312) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(311) [apply] apply:maplist_([_6624], [_6624], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [apply] apply:maplist_([_6624, _6624], [_6624, _6624], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [apply] apply:maplist(user:expand_eval, [_6624, _6624], [_6624, _6624])
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] expand_eval(['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [system] once(user:expand_eval(['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _6624, _6624]))
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] ['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] is_progn('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] is_space_op('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] arg(_166530, v('catch!', 'throw!', 'number-of!', 'limit!', 'offset!', 'max-time!', 'findall!', 'setup-call-cleanup!', 'call-cleanup!', 'call-cleanup!', 'with-output-to!'), 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _167428='if-unify-or-empty'
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] 'if-unify-or-empty'='if-unify-or-empty'
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _169462)
^  <span class="ansi1 ansi31"
>Fail: </span>(307) [user] metta_compiled_predicate('&self', 'if-unify-or-empty', _169462)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] is_list(['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] is_list(['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] apply:maplist(self_eval, ['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Call: </span>(308) [apply] apply:maplist_(['if-unify-or-empty', _6624, _6624], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] self_eval('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] setup_call_cleanup('$notrace'(_176596, _176598), once(user:self_eval0('if-unify-or-empty')), '$restore_trace'(_176596, _176598))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] sig_atomic(system:'$notrace'(_176596, _176598))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0('if-unify-or-empty')), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] self_eval('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(309) [apply] apply:maplist_([_6624, _6624], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] self_eval(_6624)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_182750, _182752), once(user:self_eval0(_6624)), '$restore_trace'(_182750, _182752))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_182750, _182752))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_6624)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] self_eval(_6624)
   <span class="ansi1 ansi32"
>Call: </span>(310) [apply] apply:maplist_([_6624], user:self_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] self_eval(_6624)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] setup_call_cleanup('$notrace'(_188904, _188906), once(user:self_eval0(_6624)), '$restore_trace'(_188904, _188906))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(system:'$notrace'(_188904, _188906))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(_6624)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] self_eval(_6624)
   <span class="ansi1 ansi32"
>Call: </span>(311) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(311) [apply] apply:maplist_([], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [apply] apply:maplist_([_6624], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(309) [apply] apply:maplist_([_6624, _6624], user:self_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(308) [apply] apply:maplist_(['if-unify-or-empty', _6624, _6624], user:self_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [apply] apply:maplist(user:self_eval, ['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] ['if-unify-or-empty', _6624, _6624]=[_199122|_199124]
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] ['if-unify-or-empty', _6624, _6624]=['if-unify-or-empty', _6624, _6624]
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _203182=do_more_defs(true)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] do_more_defs(true)=do_more_defs(true)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] clause(eval_21(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _74648), _205234)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] 'if-unify-or-empty'==(/)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] 'if-unify-or-empty'== ===
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] 'if-unify-or-empty'== ====
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] eval_40(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] eval_selfless(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_selfless_0(['if-unify-or-empty', _6624, _6624], _209306)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] is_assignment('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(311) [system] atom('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] eval_selfless_1(['if-unify-or-empty', _6624, _6624], _209306)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] allow_clp
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] false_flag
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(313) [system] fail
^  <span class="ansi1 ansi31"
>Fail: </span>(312) [user] false_flag
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] eval_selfless_2(['if-unify-or-empty', _6624, _6624], _209306)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var('if-unify-or-empty')
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] fake_notrace((ground(['if-unify-or-empty', _6624, _6624]), ['if-unify-or-empty', _6624, _6624]=[_224530, _224536, _224542], atom(_224530), catch_warn(current_op(_224568, yfx, _224530)), ['if-unify-or-empty', _6624, _6624]\=[_224588], s2ps(['if-unify-or-empty', _6624, _6624], _224596)))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] real_notrace(user:(ground(['if-unify-or-empty', _6624, _6624]), ['if-unify-or-empty', _6624, _6624]=[_224530, _224536, _224542], atom(_224530), catch_warn(current_op(_224568, yfx, _224530)), ['if-unify-or-empty', _6624, _6624]\=[_224588], s2ps(['if-unify-or-empty', _6624, _6624], _224596)))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] setup_call_cleanup('$notrace'(_226630, _226632), once(user:(ground(['if-unify-or-empty', _6624, _6624]), ['if-unify-or-empty', _6624, _6624]=[_224530, _224536, _224542], atom(_224530), catch_warn(current_op(_224568, yfx, _224530)), ['if-unify-or-empty', _6624, _6624]\=[_224588], s2ps(['if-unify-or-empty', _6624, _6624], _224596))), '$restore_trace'(_226630, _226632))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(user:'$notrace'(_226630, _226632))
^  <span class="ansi1 ansi31"
>Fail: </span>(312) [user] real_notrace(user:(ground(['if-unify-or-empty', _6624, _6624]), ['if-unify-or-empty', _6624, _6624]=[_224530, _224536, _224542], atom(_224530), catch_warn(current_op(_224568, yfx, _224530)), ['if-unify-or-empty', _6624, _6624]\=[_224588], s2ps(['if-unify-or-empty', _6624, _6624], _224596)))
^  <span class="ansi1 ansi31"
>Fail: </span>(311) [user] fake_notrace(user:(ground(['if-unify-or-empty', _6624, _6624]), ['if-unify-or-empty', _6624, _6624]=[_224530, _224536, _224542], atom(_224530), catch_warn(current_op(_224568, yfx, _224530)), ['if-unify-or-empty', _6624, _6624]\=[_224588], s2ps(['if-unify-or-empty', _6624, _6624], _224596)))
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] 'if-unify-or-empty'==(==)
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] 'if-unify-or-empty'==(==)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] eval_41(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] naive_eval_args
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] false
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_adjust_args(=, _59188, _239818, _209306, 498, '&self', ['if-unify-or-empty', _6624, _6624], _239820)
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _59188, _239818, _209306, 498, '&self', ['if-unify-or-empty', _6624, _6624], _239820)), eval_adjust_args1(=, _59188, _239818, _209306, 498, '&self', ['if-unify-or-empty', _6624, _6624], _239820))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] eval_all_args
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval_adjust_args2(=, _59188, _239818, _209306, 498, '&self', ['if-unify-or-empty', _6624, _6624], _239820)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] apply:maplist(must_eval_args(=, _246974, 498, '&self'), [_6624, _6624], _246968)
   <span class="ansi1 ansi32"
>Call: </span>(314) [apply] apply:maplist_([_6624, _6624], _246968, user:must_eval_args(=, _246974, 498, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] must_eval_args(=, _246974, 498, '&self', _6624, _249034)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] was_option_value(nodebug, _260198)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] current_prolog_flag(nodebug, _261216)
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] current_prolog_flag(nodebug, _261216)
   <span class="ansi1 ansi32"
>Call: </span>(321) [$syspreds] prolog_load_context(nodebug, _263250)
   <span class="ansi1 ansi31"
>Fail: </span>(321) [$syspreds] prolog_load_context(nodebug, _263250)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] nb_current(nodebug, _265284)
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] nb_current(nodebug, _265284)
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [user] was_option_value(nodebug, _260198)
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_271396, _271398), once(user:option_value0(nodebug, true)), '$restore_trace'(_271396, _271398))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_271396, _271398))
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(317) [prolog_debug] prolog_debug:debugging(metta(eval_args), _291736)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [prolog_debug] prolog_debug:debugging(metta(eval_args), _291736, _292880)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_296846, _296848, _296850), defined)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(320) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_296846, _296848, _296850))
   <span class="ansi1 ansi32"
>Call: </span>(321) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_296846, _296848, _296850))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] callable(debugging_logicmoo_setting(_296846, _296848, _296850))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] callable(debugging_logicmoo_setting(_296846, _296848, _296850))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(321) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_296846, _296848, _296850))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_296846, _296848, _296850))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_296846, _296848, _296850), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _291736, _309030)
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(317) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_args(=, _246974, 498, '&self', _6624, _249034)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] var(_6624)
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] var(_6624)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] nonvar(_249034)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_320256, _320258), once(user:self_eval(_6624)), '$restore_trace'(_320256, _320258))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_320256, _320258))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_6624)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] _249034=_6624
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] _6624=_6624
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] eval_args(=, _246974, 498, '&self', _6624, _6624)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] must_eval_args(=, _246974, 498, '&self', _6624, _6624)
   <span class="ansi1 ansi32"
>Call: </span>(315) [apply] apply:maplist_([_6624], _249036, user:must_eval_args(=, _246974, 498, '&self'))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] must_eval_args(=, _246974, 498, '&self', _6624, _328520)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] is_debugging(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] var(eval_args)
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] var(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] is_nodebug
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] option_value(nodebug, true)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] var(true)
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] var(true)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] true==true
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] option_value0(nodebug, 'True')
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] was_option_value(nodebug, _339684)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] current_prolog_flag(nodebug, _340702)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [system] current_prolog_flag(nodebug, _340702)
   <span class="ansi1 ansi32"
>Call: </span>(322) [$syspreds] prolog_load_context(nodebug, _342736)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [$syspreds] prolog_load_context(nodebug, _342736)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] nb_current(nodebug, _344770)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [system] nb_current(nodebug, _344770)
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] was_option_value(nodebug, _339684)
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [user] option_value0(nodebug, 'True')
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] true==false
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] true==false
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_350882, _350884), once(user:option_value0(nodebug, true)), '$restore_trace'(_350882, _350884))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_350882, _350884))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] option_value(nodebug, true)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] is_nodebug
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] eval_args==false
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] eval_args==false
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] eval_args==true
   <span class="ansi1 ansi31"
>Fail: </span>(318) [system] eval_args==true
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] fast_option_value(eval_args, debug)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] current_prolog_flag(eval_args, debug)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] current_prolog_flag(eval_args, debug)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] fast_option_value(eval_args, debug)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(eval_args)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] current_prolog_flag(eval_args, trace)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] current_prolog_flag(eval_args, trace)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] fast_option_value(eval_args, trace)
   <span class="ansi1 ansi32"
>Call: </span>(318) [prolog_debug] prolog_debug:debugging(metta(eval_args), _371222)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [prolog_debug] prolog_debug:debugging(metta(eval_args), _371222, _372366)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] current_prolog_flag(nodebugx, true)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [prolog_debug] current_predicate(debugging_logicmoo_setting/3)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [prolog_debug] predicate_property(bugger:debugging_logicmoo_setting(_376332, _376334, _376336), defined)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Exit: </span>(321) [system] nonvar(defined)
   <span class="ansi1 ansi32"
>Call: </span>(321) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_376332, _376334, _376336))
   <span class="ansi1 ansi32"
>Call: </span>(322) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_376332, _376334, _376336))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] callable(debugging_logicmoo_setting(_376332, _376334, _376336))
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] callable(debugging_logicmoo_setting(_376332, _376334, _376336))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] atom(bugger)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [$syspreds] define_or_generate(bugger:debugging_logicmoo_setting(_376332, _376334, _376336))
   <span class="ansi1 ansi32"
>Exit: </span>(321) [$syspreds] property_predicate(defined, bugger:debugging_logicmoo_setting(_376332, _376334, _376336))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [$syspreds] predicate_property(bugger:debugging_logicmoo_setting(_376332, _376334, _376336), defined)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), _371222, _388516)
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [prolog_debug] bugger:debugging_logicmoo_setting(metta(eval_args), true, [user_error])
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [prolog_debug] prolog_debug:debugging(metta(eval_args), true, [user_error])
   <span class="ansi1 ansi32"
>Exit: </span>(318) [prolog_debug] prolog_debug:debugging(metta(eval_args), true)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] true==true
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] true==true
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [user] is_debugging(eval_args)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] eval_args(=, _246974, 498, '&self', _6624, _328520)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] var(_6624)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] var(_6624)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nonvar(_328520)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_399742, _399744), once(user:self_eval(_6624)), '$restore_trace'(_399742, _399744))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_399742, _399744))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(_6624)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] _328520=_6624
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] _6624=_6624
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [user] eval_args(=, _246974, 498, '&self', _6624, _6624)
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] must_eval_args(=, _246974, 498, '&self', _6624, _6624)
   <span class="ansi1 ansi32"
>Call: </span>(316) [apply] apply:maplist_([], _328522, user:must_eval_args(=, _246974, 498, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(316) [apply] apply:maplist_([], [], user:must_eval_args(=, _246974, 498, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(315) [apply] apply:maplist_([_6624], [_6624], user:must_eval_args(=, _246974, 498, '&self'))
   <span class="ansi1 ansi32"
>Exit: </span>(314) [apply] apply:maplist_([_6624, _6624], [_6624, _6624], user:must_eval_args(=, _246974, 498, '&self'))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [apply] apply:maplist(user:must_eval_args(=, _246974, 498, '&self'), [_6624, _6624], [_6624, _6624])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] _239818=_209306
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] _209306=_209306
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [user] eval_adjust_args2(=, _59188, _209306, _209306, 498, '&self', ['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _6624, _6624])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else((eval_all_args, eval_adjust_args2(=, _59188, _209306, _209306, 498, '&self', ['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _6624, _6624])), eval_adjust_args1(=, _59188, _209306, _209306, 498, '&self', ['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _6624, _6624]))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_adjust_args(=, _59188, _209306, _209306, 498, '&self', ['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] if_trace((e;args), (['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _6624, _6624]->['if-unify-or-empty', _6624, _6624])));nop(indentq2(498, same(['if-unify-or-empty', _6624, _6624])))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] setup_call_cleanup('$notrace'(_418328, _418330), once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _6624, _6624]->['if-unify-or-empty', _6624, _6624])));nop(indentq2(498, same(['if-unify-or-empty', _6624, _6624])))))), _418286, fbug((_418286-->if_trace((e;args), (['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _6624, _6624]->['if-unify-or-empty', _6624, _6624])));nop(indentq2(498, same(['if-unify-or-empty', _6624, _6624])))))))))), '$restore_trace'(_418328, _418330))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] sig_atomic(system:'$notrace'(_418328, _418330))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((e;args)), (['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _6624, _6624]->['if-unify-or-empty', _6624, _6624])));nop(indentq2(498, same(['if-unify-or-empty', _6624, _6624])))))), _418286, fbug((_418286-->if_trace((e;args), (['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _6624, _6624]->['if-unify-or-empty', _6624, _6624])));nop(indentq2(498, same(['if-unify-or-empty', _6624, _6624])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] if_trace((e;args), (['if-unify-or-empty', _6624, _6624]\==['if-unify-or-empty', _6624, _6624]->color_g_mesg('#773733', indentq2(498, (['if-unify-or-empty', _6624, _6624]->['if-unify-or-empty', _6624, _6624])));nop(indentq2(498, same(['if-unify-or-empty', _6624, _6624])))))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_70(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306)
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] if_or_else(eval_maybe_python(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306), if_or_else(eval_maybe_host_predicate(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306), if_or_else(eval_maybe_host_function(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306), if_or_else(eval_maybe_defn(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306), eval_maybe_subst(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306)))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] eval_maybe_python(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306)
   <span class="ansi1 ansi32"
>Call: </span>(312) [user] metta_atom('&self', ['registered-python-function', _425688, _425694, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] typed_list('&self', _426834, _426708)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(313) [user] typed_list('&self', _429878, _426708)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] metta_atom_in_file('&self', ['registered-python-function', _425688, _425694, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] metta_atom_in_file('&self', ['registered-python-function', _425688, _425694, 'if-unify-or-empty'], _432932, _432934)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] loaded_into_kb('&self', _433830)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] loaded_into_kb('&self', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] once(user:asserted_metta_pred(_439798, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] asserted_metta_pred(_439798, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] asserted_metta_pred(_439798, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] metta_atom_asserted('&self', ['registered-python-function', _425688, _425694, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] metta_atom_asserted_deduced('&self', ['registered-python-function', _425688, _425694, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] metta_atom('&corelib', ['registered-python-function', _425688, _425694, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] typed_list('&corelib', _463864, _463738)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(315) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] typed_list('&corelib', _466908, _463738)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] metta_atom_in_file('&corelib', ['registered-python-function', _425688, _425694, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] metta_atom_in_file('&corelib', ['registered-python-function', _425688, _425694, 'if-unify-or-empty'], _469962, _469964)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] loaded_into_kb('&corelib', _470860)
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] once(user:asserted_metta_pred(_476804, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] asserted_metta_pred(_476804, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] asserted_metta_pred(_476804, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] once(user:asserted_metta_pred(_496486, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] asserted_metta_pred(_496486, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] asserted_metta_pred(_496486, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(314) [user] metta_atom_asserted('&corelib', ['registered-python-function', _425688, _425694, 'if-unify-or-empty'])
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] metta_atom_asserted_deduced('&corelib', ['registered-python-function', _425688, _425694, 'if-unify-or-empty'])
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] fail
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(311) [user] if_or_else(eval_maybe_host_predicate(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306), if_or_else(eval_maybe_host_function(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306), if_or_else(eval_maybe_defn(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306), eval_maybe_subst(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306))))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval_maybe_host_predicate(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] once((is_system_pred('if-unify-or-empty'), length([_6624, _6624], _521370), is_syspred('if-unify-or-empty', _521370, _521378)))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom_concat(_525562, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom_concat(_528606, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom_concat(_531650, '-p', 'if-unify-or-empty')
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(312) [user] if_or_else(eval_maybe_host_function(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306), if_or_else(eval_maybe_defn(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306), eval_maybe_subst(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306)))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval_maybe_host_function(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] allow_host_functions
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] is_system_pred('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom_concat(_540762, !, 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom_concat(_543806, '-fn', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] atom('if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] atom_concat(_546850, '-p', 'if-unify-or-empty')
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] if_or_else(eval_maybe_defn(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306), eval_maybe_subst(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] eval_maybe_defn(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] true_flag
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] fail_on_constructor
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] can_be_ok(eval_maybe_defn, ['if-unify-or-empty', _6624, _6624])
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] trace_eval(eval_defn_choose_candidates(=, _59188), defn, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] must_det_ll((notrace((flag(eval_num, _556890, _556890+1), _556908 is _556890 mod 500, _556926 is 99-498 mod 100, _556950=_556952, option_else('trace-length', _556964, 500), option_else('trace-depth', _556972, 30))), quietly(if_t((nop(stop_rtrace), _556908>_556964), (set_debug(eval, false), _557028 is _556964+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_557028])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_557080)))))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] once(user:(notrace((flag(eval_num, _556890, _556890+1), _556908 is _556890 mod 500, _556926 is 99-498 mod 100, _556950=_556952, option_else('trace-length', _556964, 500), option_else('trace-depth', _556972, 30))), quietly(if_t((nop(stop_rtrace), _556908>_556964), (set_debug(eval, false), _557028 is _556964+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_557028])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_557080)))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_559126, _559128), once(user:(flag(eval_num, _556890, _556890+1), _556908 is _556890 mod 500, _556926 is 99-498 mod 100, _556950=_556952, option_else('trace-length', _556964, 500), option_else('trace-depth', _556972, 30))), '$restore_trace'(_559126, _559128))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_559126, _559128))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 579, 579+1), 79 is 579 mod 500, 1 is 99-498 mod 100, _556950=_556950, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _557028 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_557028])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _557028 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_557028])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(319) [user] nop(notrace(no_repeats_var(_557080)))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [user] nop(notrace(no_repeats_var(_557080)))
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [system] once(user:(notrace((flag(eval_num, 579, 579+1), 79 is 579 mod 500, 1 is 99-498 mod 100, _556950=_556950, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _557028 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_557028])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_557080)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] must_det_ll(user:(notrace((flag(eval_num, 579, 579+1), 79 is 579 mod 500, 1 is 99-498 mod 100, _556950=_556950, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _557028 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_557028])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_557080)))))
   <span class="ansi1 ansi32"
>Call: </span>(316) [occurs] occurs:sub_term(_568778, defn)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [occurs] occurs:sub_term(defn, defn)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] defn\=defn
   <span class="ansi1 ansi31"
>Fail: </span>(316) [system] defn\=defn
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(317) [system] compound(defn)
   <span class="ansi1 ansi31"
>Fail: </span>(316) [occurs] occurs:sub_term(_568778, defn)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] _575884=defn
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] defn=defn
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] if_trace((eval;defn), (_556950=1, indentq(1, 79, -->, [defn, ['if-unify-or-empty', _6624, _6624]])))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_579024, _579026), once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _556950=1, indentq(1, 79, -->, [defn, ['if-unify-or-empty', _6624, _6624]]))), _578982, fbug((_578982-->if_trace((eval;defn), (_556950=1, indentq(1, 79, -->, [defn, ['if-unify-or-empty', _6624, _6624]])))))))), '$restore_trace'(_579024, _579026))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_579024, _579026))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;defn)), _556950=1, indentq(1, 79, -->, [defn, ['if-unify-or-empty', _6624, _6624]]))), _578982, fbug((_578982-->if_trace((eval;defn), (_556950=1, indentq(1, 79, -->, [defn, ['if-unify-or-empty', _6624, _6624]])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] if_trace((eval;defn), (_556950=1, indentq(1, 79, -->, [defn, ['if-unify-or-empty', _6624, _6624]])))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] _583220=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] _585258=(\+ \+ (flag(eval_num, _585278, _585278+1), (retval(fail)\=@=retval(fail), nonvar(_209306)->indentq(1, _585278, <--, [defn, _209306]);indentq(1, _585278, <--, [defn, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] (\+ \+ (flag(eval_num, _585278, _585278+1), (retval(fail)\=@=retval(fail), nonvar(_209306)->indentq(1, _585278, <--, [defn, _209306]);indentq(1, _585278, <--, [defn, retval(fail)]))))=(\+ \+ (flag(eval_num, _585278, _585278+1), (retval(fail)\=@=retval(fail), nonvar(_209306)->indentq(1, _585278, <--, [defn, _209306]);indentq(1, _585278, <--, [defn, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] call_cleanup(((call(eval_defn_choose_candidates(=, _59188), 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306)*->nb_setarg(1, retval(fail), _209306);fail, trace, call(eval_defn_choose_candidates(=, _59188), 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306)), ignore(notrace((\+_209306\=_557080, nb_setarg(1, retval(fail), _209306))))), ignore((_556950==1->ignore(\+ \+ (flag(eval_num, _585278, _585278+1), (retval(fail)\=@=retval(fail), nonvar(_209306)->indentq(1, _585278, <--, [defn, _209306]);indentq(1, _585278, <--, [defn, retval(fail)]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _585278, _585278+1), (retval(fail)\=@=retval(fail), nonvar(_209306)->indentq(1, _585278, <--, [defn, _209306]);indentq(1, _585278, <--, [defn, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] eval_defn_choose_candidates(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] findall((_589620->_589622), get_defn_expansions(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _589620, _589622), _589640)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [$bags] findall((_589620->_589622), user:get_defn_expansions(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _589620, _589622), _589640, [])
^  <span class="ansi1 ansi32"
>Call: </span>(321) [$bags] cleanup_bag(findall_loop((_589620->_589622), user:get_defn_expansions(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _589620, _589622), _589640, []), '$destroy_findall_bag')
   <span class="ansi1 ansi32"
>Call: </span>(322) [$bags] findall_loop((_589620->_589622), user:get_defn_expansions(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _589620, _589622), _589640, [])
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] get_defn_expansions(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _589620, _589622)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] same_len_copy([_6624, _6624], _594812)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] length([_6624, _6624], _595830)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(_595830)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] var(_595830)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] []==[]
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] []==[]
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _595830=2
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] 2=2
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] length([_6624, _6624], 2)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] length(_594812, 2)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(2)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] integer(2)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] integer(2)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _594812==[]
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(_594812)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] var(_594812)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] length([_611054, _611060], 2)
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [user] same_len_copy([_6624, _6624], [_611054, _611060])
   <span class="ansi1 ansi32"
>Call: </span>(324) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _611054, _611060], _589622)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] ignore((=)=(=))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] (=)=(=)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] (=)=(=)
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] ignore(user:((=)=(=)))
   <span class="ansi1 ansi32"
>Call: </span>(325) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _611054, _611060], _589622]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _611054, _611060], _589622]))
   <span class="ansi1 ansi32"
>Call: </span>(326) [user] metta_atom('&self', [=, ['if-unify-or-empty', _611054, _611060], _589622])
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] typed_list('&self', _620376, _620250)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] compound('&self')
   <span class="ansi1 ansi31"
>Fail: </span>(328) [system] compound('&self')
^  <span class="ansi1 ansi31"
>Fail: </span>(327) [user] typed_list('&self', _623420, _620250)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] '&self'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _611054, _611060], _589622])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] metta_atom_in_file('&self', [=, ['if-unify-or-empty', _611054, _611060], _589622], _626474, _626476)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] loaded_into_kb('&self', _627372)
^  <span class="ansi1 ansi32"
>Exit: </span>(329) [user] loaded_into_kb('&self', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] once(user:asserted_metta_pred(_633340, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] asserted_metta_pred(_633340, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(330) [user] asserted_metta_pred(_633340, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(327) [user] metta_atom_asserted('&self', [=, ['if-unify-or-empty', _611054, _611060], _589622])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] metta_atom_asserted_deduced('&self', [=, ['if-unify-or-empty', _611054, _611060], _589622])
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] '&self'\=='&corelib'
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] using_all_spaces
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] nb_current(with_all_spaces, t)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] '&self'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(327) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _611054, _611060], _589622])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] typed_list('&corelib', _657406, _657280)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] compound('&corelib')
   <span class="ansi1 ansi31"
>Fail: </span>(329) [system] compound('&corelib')
^  <span class="ansi1 ansi31"
>Fail: </span>(328) [user] typed_list('&corelib', _660450, _657280)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] '&corelib'=='&flybase'
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _611054, _611060], _589622])
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] metta_atom_in_file('&corelib', [=, ['if-unify-or-empty', _611054, _611060], _589622], _663504, _663506)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] loaded_into_kb('&corelib', _664402)
^  <span class="ansi1 ansi32"
>Exit: </span>(330) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] once(user:asserted_metta_pred(_670346, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] asserted_metta_pred(_670346, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(331) [user] asserted_metta_pred(_670346, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta'</span>)
^  <span class="ansi1 ansi32"
>Exit: </span>(330) [user] loaded_into_kb('&corelib', P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] once(user:asserted_metta_pred(_690028, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>))
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] asserted_metta_pred(_690028, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
^  <span class="ansi1 ansi31"
>Fail: </span>(331) [user] asserted_metta_pred(_690028, P;HTML|<span class="pl-atom"
>'/home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta'</span>)
   <span class="ansi1 ansi32"
>Call: </span>(328) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _611054, _611060], _589622])
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] metta_atom_asserted_deduced('&corelib', [=, ['if-unify-or-empty', _611054, _611060], _589622])
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] fail
   <span class="ansi1 ansi32"
>Exit: </span>(328) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _611054, _611054], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(327) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _611054, _611054], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(326) [user] metta_atom('&self', [=, ['if-unify-or-empty', _611054, _611054], unified])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _611054, _611054], unified]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _611054, _611054], unified]))
   <span class="ansi1 ansi32"
>Exit: </span>(324) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _611054, _611054], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] get_defn_expansions(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _611054, _611054], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [user] metta_atom_asserted('&corelib', [=, ['if-unify-or-empty', _611054, _611060], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(327) [user] metta_atom('&corelib', [=, ['if-unify-or-empty', _611054, _611060], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(326) [user] metta_atom('&self', [=, ['if-unify-or-empty', _611054, _611060], [empty]])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] if_or_else(metta_atom('&self', [=, ['if-unify-or-empty', _611054, _611060], [empty]]), not_metta_atom_corelib('&self', [=, ['if-unify-or-empty', _611054, _611060], [empty]]))
   <span class="ansi1 ansi32"
>Exit: </span>(324) [user] metta_eq_def(=, '&self', ['if-unify-or-empty', _611054, _611060], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] get_defn_expansions(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], ['if-unify-or-empty', _611054, _611060], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] '&corelib'\=='&corelib'
   <span class="ansi1 ansi32"
>Exit: </span>(322) [$bags] findall_loop((_589620->_589622), user:get_defn_expansions(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _589620, _589622), [(['if-unify-or-empty', _723032, _723032]->unified), (['if-unify-or-empty', _722996, _723002]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [$bags] cleanup_bag('$bags':findall_loop((_589620->_589622), user:get_defn_expansions(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _589620, _589622), [(['if-unify-or-empty', _723032, _723032]->unified), (['if-unify-or-empty', _722996, _723002]->[empty])], []), '$bags':'$destroy_findall_bag')
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [$bags] findall((_589620->_589622), user:get_defn_expansions(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _589620, _589622), [(['if-unify-or-empty', _723032, _723032]->unified), (['if-unify-or-empty', _722996, _723002]->[empty])], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [$bags] findall((_589620->_589622), user:get_defn_expansions(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _589620, _589622), [(['if-unify-or-empty', _723032, _723032]->unified), (['if-unify-or-empty', _722996, _723002]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_defn_bodies(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306, [(['if-unify-or-empty', _723032, _723032]->unified), (['if-unify-or-empty', _722996, _723002]->[empty])])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _723032, _723032]->unified), (['if-unify-or-empty', _722996, _723002]->[empty])]))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_729264, _729266), once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(498, '   '), [(['if-unify-or-empty', _723032, _723032]->unified), (['if-unify-or-empty', _722996, _723002]->[empty])]))), _729222, fbug((_729222-->if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _723032, _723032]->unified), (['if-unify-or-empty', _722996, _723002]->[empty])]))))))), '$restore_trace'(_729264, _729266))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_729264, _729266))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), maplist(print_templates(498, '   '), [(['if-unify-or-empty', _723032, _723032]->unified), (['if-unify-or-empty', _722996, _723002]->[empty])]))), _729222, fbug((_729222-->if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _723032, _723032]->unified), (['if-unify-or-empty', _722996, _723002]->[empty])]))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_trace(e, maplist(print_templates(498, '   '), [(['if-unify-or-empty', _723032, _723032]->unified), (['if-unify-or-empty', _722996, _723002]->[empty])]))
   <span class="ansi1 ansi32"
>Call: </span>(320) [user] if_or_else((member((_733474->_733476), [(['if-unify-or-empty', _723032, _723032]->unified), (['if-unify-or-empty', _722996, _723002]->[empty])]), copy_term((_733474->_733476), _733488), eval_defn_success(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306, _733474, _733476, _733488)), eval_defn_failure(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306))
   <span class="ansi1 ansi32"
>Call: </span>(322) [lists] lists:member((_733474->_733476), [(['if-unify-or-empty', _723032, _723032]->unified), (['if-unify-or-empty', _722996, _723002]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(323) [lists] lists:member_([(['if-unify-or-empty', _722996, _723002]->[empty])], (_733474->_733476), (['if-unify-or-empty', _723032, _723032]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(323) [lists] lists:member_([(['if-unify-or-empty', _722996, _723002]->[empty])], (['if-unify-or-empty', _723032, _723032]->unified), (['if-unify-or-empty', _723032, _723032]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [lists] lists:member((['if-unify-or-empty', _723032, _723032]->unified), [(['if-unify-or-empty', _723032, _723032]->unified), (['if-unify-or-empty', _722996, _723002]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] copy_term((['if-unify-or-empty', _723032, _723032]->unified), _733488)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] copy_term((['if-unify-or-empty', _723032, _723032]->unified), (['if-unify-or-empty', _739638, _739638]->unified))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] eval_defn_success(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306, ['if-unify-or-empty', _723032, _723032], unified, (['if-unify-or-empty', _739638, _739638]->unified))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] ['if-unify-or-empty', _6624, _6624]=['if-unify-or-empty', _723032, _723032]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] ['if-unify-or-empty', _6624, _6624]=['if-unify-or-empty', _6624, _6624]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _209306=unified
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] unified=unified
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] ['if-unify-or-empty', _6624, _6624]\=@=unified
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] ['if-unify-or-empty', _6624, _6624]\=@=unified
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _739638, _739638]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_748886, _748888), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _739638, _739638]->unified)))))), _748844, fbug((_748844-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _739638, _739638]->unified)))))))))), '$restore_trace'(_748886, _748888))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_748886, _748888))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _739638, _739638]->unified)))))), _748844, fbug((_748844-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _739638, _739638]->unified)))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _739638, _739638]->unified)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] light_eval(=, _59188, 498, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] light_eval(=, _59188, 498, '&self', unified, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] eval_defn_success(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified, ['if-unify-or-empty', _6624, _6624], unified, (['if-unify-or-empty', _739638, _739638]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_or_else((member((['if-unify-or-empty', _6624, _6624]->unified), [(['if-unify-or-empty', _6624, _6624]->unified), (['if-unify-or-empty', _722996, _723002]->[empty])]), copy_term((['if-unify-or-empty', _6624, _6624]->unified), (['if-unify-or-empty', _739638, _739638]->unified)), eval_defn_success(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified, ['if-unify-or-empty', _6624, _6624], unified, (['if-unify-or-empty', _739638, _739638]->unified))), eval_defn_failure(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] eval_defn_bodies(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified, [(['if-unify-or-empty', _6624, _6624]->unified), (['if-unify-or-empty', _722996, _723002]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] eval_defn_choose_candidates(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] ignore(notrace((\+unified\=_557080, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_762334, _762336), once(user:(\+unified\=_557080, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_762334, _762336))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_762334, _762336))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_557080, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] ignore(user:notrace((\+unified\=_557080, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _59188), 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_defn_choose_candidates(=, _59188), 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)), ignore(notrace((\+unified\=_557080, nb_setarg(1, retval(unified), unified))))), user:ignore((_556950==1->ignore(\+ \+ (flag(eval_num, _585278, _585278+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _585278, <--, [defn, unified]);indentq(1, _585278, <--, [defn, retval(unified)]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _585278, _585278+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _585278, <--, [defn, unified]);indentq(1, _585278, <--, [defn, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] trace_eval(eval_defn_choose_candidates(=, _59188), defn, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] eval_maybe_defn(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [user] if_or_else(eval_maybe_defn(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), eval_maybe_subst(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified))
   <span class="ansi1 ansi32"
>Exit: </span>(312) [user] if_or_else(eval_maybe_host_function(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), if_or_else(eval_maybe_defn(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), eval_maybe_subst(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)))
   <span class="ansi1 ansi32"
>Exit: </span>(311) [user] if_or_else(eval_maybe_host_predicate(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), if_or_else(eval_maybe_host_function(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), if_or_else(eval_maybe_defn(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), eval_maybe_subst(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified))))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else(eval_maybe_python(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), if_or_else(eval_maybe_host_predicate(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), if_or_else(eval_maybe_host_function(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), if_or_else(eval_maybe_defn(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified), eval_maybe_subst(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_70(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] check_returnval(=, _59188, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] check_returnval(=, _59188, unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] eval_41(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] eval_40(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] unified=_74648
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_20(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] nb_setarg(1, retval(fail), unified)
   <span class="ansi1 ansi32"
>Exit: </span>(306) [system] nb_setarg(1, retval(unified), unified)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] ignore(notrace((\+unified\=_75892, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_786864, _786866), once(user:(\+unified\=_75892, nb_setarg(1, retval(unified), unified))), '$restore_trace'(_786864, _786866))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_786864, _786866))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+unified\=_75892, nb_setarg(1, retval(unified), unified))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] ignore(user:notrace((\+unified\=_75892, nb_setarg(1, retval(unified), unified))))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [system] call_cleanup(user:((call(eval_20(=, _59188), 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)*->nb_setarg(1, retval(unified), unified);fail, trace, call(eval_20(=, _59188), 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)), ignore(notrace((\+unified\=_75892, nb_setarg(1, retval(unified), unified))))), user:ignore((_75762==1->ignore(\+ \+ (flag(eval_num, _104090, _104090+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _104090, <--, [e, unified]);indentq(1, _104090, <--, [e, retval(unified)]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _104090, _104090+1), (retval(unified)\=@=retval(fail), nonvar(unified)->indentq(1, _104090, <--, [e, unified]);indentq(1, _104090, <--, [e, retval(unified)])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] retval(unified)\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] retval(unified)\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] trace_eval(eval_20(=, _59188), e, 498, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] self_eval(unified)
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_796098, _796100), once(user:self_eval0(unified)), '$restore_trace'(_796098, _796100))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_796098, _796100))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval0(unified)), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] self_eval(unified)
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] _42710=unified
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] unified=unified
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [user] eval_01(=, _59188, 499, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] eval_00(=, _59188, 499, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] eval_args(=, _59188, 499, '&self', ['if-unify-or-empty', _6624, _6624], unified)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] setup_call_cleanup('$notrace'(_806416, _806418), once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _806374, fbug((_806374-->if_trace(case, writeqln(switch=unified))))))), '$restore_trace'(_806416, _806418))
^  <span class="ansi1 ansi32"
>Call: </span>(303) [system] sig_atomic(system:'$notrace'(_806416, _806418))
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(case), writeqln(switch=unified))), _806374, fbug((_806374-->if_trace(case, writeqln(switch=unified))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(300) [user] if_trace(case, writeqln(switch=unified))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] select_case(499, '&self', unified, ['Empty'-_6642], _810612)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] best_key(unified, ['Empty'-_6642], _810612)
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_812664-_810612, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(303) [lists] lists:member_([], _812664-_810612, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [lists] lists:member_([], 'Empty'-_6642, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [lists] lists:member('Empty'-_6642, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] unified='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_817758-_810612, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(303) [lists] lists:member_([], _817758-_810612, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [lists] lists:member_([], 'Empty'-_6642, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [lists] lists:member('Empty'-_6642, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] unified=='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_822852-_810612, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(303) [lists] lists:member_([], _822852-_810612, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [lists] lists:member_([], 'Empty'-_6642, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [lists] lists:member('Empty'-_6642, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] unified=@='Empty'
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_827946-_810612, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(303) [lists] lists:member_([], _827946-_810612, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [lists] lists:member_([], 'Empty'-_6642, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(302) [lists] lists:member('Empty'-_6642, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] unified='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] maybe_special_keys(499, '&self', ['Empty'-_6642], _833038)
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] eval_args(499, '&self', 'Empty', _834072)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_args(=, _835224, 499, '&self', 'Empty', _834072)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] var('Empty')
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_837156, _837158), once(user:self_eval('Empty')), '$restore_trace'(_837156, _837158))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_837156, _837158))
^  <span class="ansi1 ansi32"
>Exit: </span>(305) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval('Empty')), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] _834072='Empty'
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] 'Empty'='Empty'
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] eval_args(=, _842458, 499, '&self', 'Empty', 'Empty')
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [user] eval_args(499, '&self', 'Empty', 'Empty')
   <span class="ansi1 ansi32"
>Call: </span>(302) [system] 'Empty'\=@='Empty'
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] maybe_special_keys(499, '&self', [], _833038)
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [user] maybe_special_keys(499, '&self', [], [])
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [user] maybe_special_keys(499, '&self', ['Empty'-_6642], [])
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] best_key(unified, [], _810612)
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_849500-_810612, [])
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_850522-_810612, [])
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_851544-_810612, [])
   <span class="ansi1 ansi32"
>Call: </span>(302) [lists] lists:member(_852566-_810612, [])
   <span class="ansi1 ansi32"
>Call: </span>(301) [lists] lists:member(_853588-_810612, [])
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member(_854610-_854612, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(301) [lists] lists:member_([], _854610-_854612, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [lists] lists:member_([], 'Empty'-_6642, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member('Empty'-_6642, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] 'Empty'=='%void%'
   <span class="ansi1 ansi32"
>Call: </span>(324) [lists] lists:member_([], (_733474->_733476), (['if-unify-or-empty', _722996, _723002]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(324) [lists] lists:member_([], (['if-unify-or-empty', _722996, _723002]->[empty]), (['if-unify-or-empty', _722996, _723002]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(323) [lists] lists:member_([(['if-unify-or-empty', _722996, _723002]->[empty])], (['if-unify-or-empty', _722996, _723002]->[empty]), (['if-unify-or-empty', _723032, _723032]->unified))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [lists] lists:member((['if-unify-or-empty', _722996, _723002]->[empty]), [(['if-unify-or-empty', _723032, _723032]->unified), (['if-unify-or-empty', _722996, _723002]->[empty])])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] copy_term((['if-unify-or-empty', _722996, _723002]->[empty]), _733488)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] copy_term((['if-unify-or-empty', _722996, _723002]->[empty]), (['if-unify-or-empty', _864810, _864816]->[empty]))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] eval_defn_success(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], _209306, ['if-unify-or-empty', _722996, _723002], [empty], (['if-unify-or-empty', _864810, _864816]->[empty]))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] ['if-unify-or-empty', _6624, _6624]=['if-unify-or-empty', _722996, _723002]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] ['if-unify-or-empty', _6624, _6624]=['if-unify-or-empty', _6624, _6624]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _209306=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] [empty]=[empty]
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] ['if-unify-or-empty', _6624, _6624]\=@=[empty]
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] ['if-unify-or-empty', _6624, _6624]\=@=[empty]
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _864810, _864816]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_874058, _874060), once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _864810, _864816]->[empty])))))), _874016, fbug((_874016-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _864810, _864816]->[empty])))))))))), '$restore_trace'(_874058, _874060))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_874058, _874060))
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging(e), color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _864810, _864816]->[empty])))))), _874016, fbug((_874016-->if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _864810, _864816]->[empty])))))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] if_trace(e, color_g_mesg('#773700', indentq2(498, defs_used((['if-unify-or-empty', _864810, _864816]->[empty])))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] light_eval(=, _59188, 498, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] light_eval(=, _59188, 498, '&self', [empty], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] eval_defn_success(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty], ['if-unify-or-empty', _6624, _6624], [empty], (['if-unify-or-empty', _864810, _864816]->[empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(320) [user] if_or_else((member((['if-unify-or-empty', _6624, _6624]->[empty]), [(['if-unify-or-empty', _723032, _723032]->unified), (['if-unify-or-empty', _6624, _6624]->[empty])]), copy_term((['if-unify-or-empty', _6624, _6624]->[empty]), (['if-unify-or-empty', _864810, _864816]->[empty])), eval_defn_success(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty], ['if-unify-or-empty', _6624, _6624], [empty], (['if-unify-or-empty', _864810, _864816]->[empty]))), eval_defn_failure(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] eval_defn_bodies(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty], [(['if-unify-or-empty', _723032, _723032]->unified), (['if-unify-or-empty', _6624, _6624]->[empty])])
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] eval_defn_choose_candidates(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] ignore(notrace((\+[empty]\=_557080, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_887514, _887516), once(user:(\+[empty]\=_557080, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_887514, _887516))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_887514, _887516))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_557080, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] ignore(user:notrace((\+[empty]\=_557080, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] ignore((_556950==1->ignore(\+ \+ (flag(eval_num, _585278, _585278+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _585278, <--, [defn, [empty]]);indentq(1, _585278, <--, [defn, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _585278, _585278+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _585278, <--, [defn, [empty]]);indentq(1, _585278, <--, [defn, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] _556950==1
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] _556950==1
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_894706, _894708), once(user:ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _585278, _585278+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _585278, <--, [defn, [empty]]);indentq(1, _585278, <--, [defn, retval([empty])])))))))), '$restore_trace'(_894706, _894708))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_894706, _894708))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _585278, _585278+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _585278, <--, [defn, [empty]]);indentq(1, _585278, <--, [defn, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [system] ignore(user:(_556950==1->ignore(\+ \+ (flag(eval_num, _585278, _585278+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _585278, <--, [defn, [empty]]);indentq(1, _585278, <--, [defn, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _585278, _585278+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _585278, <--, [defn, [empty]]);indentq(1, _585278, <--, [defn, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [system] call_cleanup(user:((call(eval_defn_choose_candidates(=, _59188), 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_defn_choose_candidates(=, _59188), 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])), ignore(notrace((\+[empty]\=_557080, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_556950==1->ignore(\+ \+ (flag(eval_num, _585278, _585278+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _585278, <--, [defn, [empty]]);indentq(1, _585278, <--, [defn, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;defn), ignore(\+ \+ (flag(eval_num, _585278, _585278+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _585278, <--, [defn, [empty]]);indentq(1, _585278, <--, [defn, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] trace_eval(eval_defn_choose_candidates(=, _59188), defn, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] eval_maybe_defn(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [user] if_or_else(eval_maybe_defn(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), eval_maybe_subst(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]))
   <span class="ansi1 ansi32"
>Exit: </span>(312) [user] if_or_else(eval_maybe_host_function(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), if_or_else(eval_maybe_defn(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), eval_maybe_subst(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])))
   <span class="ansi1 ansi32"
>Exit: </span>(311) [user] if_or_else(eval_maybe_host_predicate(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), if_or_else(eval_maybe_host_function(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), if_or_else(eval_maybe_defn(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), eval_maybe_subst(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]))))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_or_else(eval_maybe_python(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), if_or_else(eval_maybe_host_predicate(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), if_or_else(eval_maybe_host_function(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), if_or_else(eval_maybe_defn(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty]), eval_maybe_subst(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])))))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] eval_70(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] check_returnval(=, _59188, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] check_returnval(=, _59188, [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [user] eval_41(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] eval_40(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] [empty]=_74648
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] [empty]=[empty]
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] eval_20(=, _59188, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
   <span class="ansi1 ansi32"
>Call: </span>(306) [system] nb_setarg(1, retval(unified), [empty])
   <span class="ansi1 ansi32"
>Exit: </span>(306) [system] nb_setarg(1, retval([empty]), [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] ignore(notrace((\+[empty]\=_75892, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_919410, _919412), once(user:(\+[empty]\=_75892, nb_setarg(1, retval([empty]), [empty]))), '$restore_trace'(_919410, _919412))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_919410, _919412))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(\+[empty]\=_75892, nb_setarg(1, retval([empty]), [empty]))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] ignore(user:notrace((\+[empty]\=_75892, nb_setarg(1, retval([empty]), [empty]))))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] ignore((_75762==1->ignore(\+ \+ (flag(eval_num, _104090, _104090+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _104090, <--, [e, [empty]]);indentq(1, _104090, <--, [e, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _104090, _104090+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _104090, <--, [e, [empty]]);indentq(1, _104090, <--, [e, retval([empty])]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] _75762==1
   <span class="ansi1 ansi31"
>Fail: </span>(308) [system] _75762==1
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_926602, _926604), once(user:ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _104090, _104090+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _104090, <--, [e, [empty]]);indentq(1, _104090, <--, [e, retval([empty])])))))))), '$restore_trace'(_926602, _926604))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_926602, _926604))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _104090, _104090+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _104090, <--, [e, [empty]]);indentq(1, _104090, <--, [e, retval([empty])])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [system] ignore(user:(_75762==1->ignore(\+ \+ (flag(eval_num, _104090, _104090+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _104090, <--, [e, [empty]]);indentq(1, _104090, <--, [e, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _104090, _104090+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _104090, <--, [e, [empty]]);indentq(1, _104090, <--, [e, retval([empty])]))))))))))
^  <span class="ansi1 ansi32"
>Exit: </span>(304) [system] call_cleanup(user:((call(eval_20(=, _59188), 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])*->nb_setarg(1, retval([empty]), [empty]);fail, trace, call(eval_20(=, _59188), 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])), ignore(notrace((\+[empty]\=_75892, nb_setarg(1, retval([empty]), [empty]))))), user:ignore((_75762==1->ignore(\+ \+ (flag(eval_num, _104090, _104090+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _104090, <--, [e, [empty]]);indentq(1, _104090, <--, [e, retval([empty])]))));notrace(ignore(if_t(1<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _104090, _104090+1), (retval([empty])\=@=retval(fail), nonvar([empty])->indentq(1, _104090, <--, [e, [empty]]);indentq(1, _104090, <--, [e, retval([empty])])))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] retval([empty])\=@=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] retval([empty])\=@=retval(fail)
^  <span class="ansi1 ansi32"
>Exit: </span>(303) [user] trace_eval(eval_20(=, _59188), e, 498, '&self', ['if-unify-or-empty', _6624, _6624], [empty])
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] self_eval([empty])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_936002, _936004), once(user:self_eval0([empty])), '$restore_trace'(_936002, _936004))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_936002, _936004))
^  <span class="ansi1 ansi31"
>Fail: </span>(303) [user] self_eval([empty])
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] [empty]=@=['if-unify-or-empty', _73606, _73606]
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_01(=, _59188, 498, '&self', [empty], _940106)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [empty]\==[empty]
   <span class="ansi1 ansi32"
>Call: </span>(300) [lists] lists:member(_942164-_942166, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(301) [lists] lists:member_([], _942164-_942166, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(301) [lists] lists:member_([], 'Empty'-_6642, 'Empty'-_6642)
   <span class="ansi1 ansi32"
>Exit: </span>(300) [lists] lists:member('Empty'-_6642, ['Empty'-_6642])
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] 'Empty'=='%void%'
^  <span class="ansi1 ansi31"
>Fail: </span>(298) [user] eval_20(=, _7894, 499, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7996)
   <span class="ansi1 ansi32"
>Call: </span>(298) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(298) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] ignore((_8004==1->ignore(\+ \+ (flag(eval_num, _8042, _8042+1), (retval(fail)\=@=retval(fail), nonvar(_7996)->indentq(0, _8042, <--, [e, _7996]);indentq(0, _8042, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8042, _8042+1), (retval(fail)\=@=retval(fail), nonvar(_7996)->indentq(0, _8042, <--, [e, _7996]);indentq(0, _8042, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(300) [system] _8004==1
   <span class="ansi1 ansi31"
>Fail: </span>(300) [system] _8004==1
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] setup_call_cleanup('$notrace'(_953360, _953362), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8042, _8042+1), (retval(fail)\=@=retval(fail), nonvar(_7996)->indentq(0, _8042, <--, [e, _7996]);indentq(0, _8042, <--, [e, retval(fail)])))))))), '$restore_trace'(_953360, _953362))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] sig_atomic(system:'$notrace'(_953360, _953362))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8042, _8042+1), (retval(fail)\=@=retval(fail), nonvar(_7996)->indentq(0, _8042, <--, [e, _7996]);indentq(0, _8042, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(298) [system] ignore(user:(_8004==1->ignore(\+ \+ (flag(eval_num, _8042, _8042+1), (retval(fail)\=@=retval(fail), nonvar(_7996)->indentq(0, _8042, <--, [e, _7996]);indentq(0, _8042, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8042, _8042+1), (retval(fail)\=@=retval(fail), nonvar(_7996)->indentq(0, _8042, <--, [e, _7996]);indentq(0, _8042, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(296) [system] call_cleanup(user:((call(eval_20(=, _7894), 499, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7996)*->nb_setarg(1, retval(fail), _7996);fail, trace, call(eval_20(=, _7894), 499, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7996)), ignore(notrace((\+_7996\=_8012, nb_setarg(1, retval(fail), _7996))))), user:ignore((_8004==1->ignore(\+ \+ (flag(eval_num, _8042, _8042+1), (retval(fail)\=@=retval(fail), nonvar(_7996)->indentq(0, _8042, <--, [e, _7996]);indentq(0, _8042, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _8042, _8042+1), (retval(fail)\=@=retval(fail), nonvar(_7996)->indentq(0, _8042, <--, [e, _7996]);indentq(0, _8042, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(295) [user] trace_eval(eval_20(=, _7894), e, 499, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7996)
^  <span class="ansi1 ansi31"
>Fail: </span>(292) [user] eval_args(=, _7894, 500, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7346)
^  <span class="ansi1 ansi31"
>Fail: </span>(283) [system] call(user:once, user:if_or_else(eval(=, _7326, 497, '&self', [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7346), call(eval, [case, ['if-unify-or-empty', _6624, _6624], [['Empty', _6642]]], _7346)))
^  <span class="ansi1 ansi32"
>Call: </span>(283) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(285) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(285) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(287) [system] setup_call_cleanup('$notrace'(_964822, _964824), once(rtrace:retract(t_l:tracer_reset(_964812))), '$restore_trace'(_964822, _964824))
^  <span class="ansi1 ansi32"
>Call: </span>(288) [system] sig_atomic(system:'$notrace'(_964822, _964824))
^  <span class="ansi1 ansi32"
>Exit: </span>(287) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(287) [rtrace] tAt(false, 271, 271, false)
; 
; EVAL TEST
; took 0.560 secs. (559.96 milliseconds) 

!(assertEqualToResult (get-atoms &space) ((a a)))

<span class="ansi31"
>#(loonit_failureR #(equal_enough_for_test ((@doc Any (@desc "The universal type; any value belongs to this type.")) (: Any Type) (@doc Atom (@desc "Type representing any atom.")) (: Atom Type) (@doc LazyEvaluatable (@desc "A type of Atom/Value that hyperon does not implicitly evaluate")) (: LazyEvaluatable Type) (:> Atom LazyEvaluatable) (@doc Bool (@desc "Boolean type of True or False.")) (: Bool Type) (@doc LazyBool (@desc "A LazyEvaluatable that when evaluated returns True or False.")) (: LazyBool Type) (:> LazyBool LazyEvaluatable) (@doc Expression (@desc "Type representing an S-Expression, which is a combination of atoms.")) (: Expression Type) (:> Expression LazyEvaluatable) (@doc Number (@desc "Numeric type, including integers and floating-point numbers.")) (: Number Type) (@doc hyperon::space::DynSpace (@desc "Dynamic space type, representing an Atomspace.")) (: hyperon::space::DynSpace Type) (@doc ReturnType (@desc "Type representing a function's return value.")) (: ReturnType Type) (@doc Symbol (@desc "Type representing a symbol or identifier.")) (: Symbol Type) (@doc StateMonad (@desc "Type representing a state monad, used for encapsulating stateful computations.")) (: StateMonad Type) (@doc Type (@desc "Type representing a type.")) (: Type Type) (@doc True (@desc "Boolean value representing truth.")) (: True Bool) (@doc False (@desc "Boolean value representing falsehood.")) (: False Bool) (@doc %Undefined% (@desc "Special type representing an undefined value or type.")) (: %Undefined% Type) (@doc Variable (@desc "Type representing a variable in the language.")) (: Variable Type) (@doc : (@desc "Type declarion operator")) (@doc <: (@desc "Super Type declarion operator")) (: : %Undefined%) (: if-empty (-> Atom Atom Atom Atom)) (: if-non-empty-expression (-> Atom Atom Atom Atom)) (: if-not-reducible (-> Atom Atom Atom Atom)) (: return (-> Atom ReturnType)) (: switch (-> %Undefined% Expression Atom)) (: unify (-> Atom Atom Atom Atom %Undefined%)) (: get-type (-> Atom Type)) (: get-type0 (-> Atom Atom)) (: get-ftype (-> Atom Atom)) (: pragma! (-> Atom Atom (->))) (: = (-> Atom Atom %Undefined%)) (: match (-> hyperon::space::DynSpace Atom Atom %Undefined%)) (: case (-> Expression Atom Atom)) (: combine (-> $10000 $10000 $10000)) (: import! (-> hyperon::space::DynSpace Atom (->))) (: If (-> Bool Atom Atom Atom)) (: If (-> Bool Atom Atom)) (= (If True $10001)  $10001) (= (If False $10002)  
  (let $10003 0 
    (let $10003 1 $10003))) (= (If $10004 $10005 $10006)  
  (if $10004 $10005 $10006)) (iz predicate-arity MeTTaLog) (@doc predicate-arity (@desc "Specifies the arity (number of arguments) for a given predicate, allowing it to be queriable in the system's match framework. This is particularly useful for enabling built-in functions, such as `size-atom`, to be used as predicates in declarative contexts and run in reverse to compute inputs based on outputs.\n\nFor example:\n  ; Enable the built-in function `size-atom` that takes an atom and returns the size\n    as a predicate with arity 2\n  (add-atom &dyn-space (predicate-arity size-atom 2))\n\n  ; Now `size-atom` can be used as a predicate in pattern matching\n  (match &dyn-space '(size-atom (a b c) $size) \n         (The abc tuple was len $size))\n  ; This pattern will resolve `Size = 3` and execute the action.\n\nAdditionally, by running `size-atom` in reverse, you can compute a new atom based on a desired size:\n  (match &dyn-space '(size-atom $new-atom 4) \n         (The new atom is $new-atom))\n  ; This resolves `$new-atom` to a tuple of size 4, such as ($1 $2 $3 $4).\n\nThis reverse functionality is made possible because predicates can describe relationships, allowing you to infer inputs from outputs.") (@params ((@param "Predicate symbol" "The name of the predicate whose arity is being defined."))) (@return "The number of arguments required for the predicate.")) (: predicate-arity (-> Symbol Number)) (predicate-arity predicate-arity 2) (function-arity predicate-arity 1) (@doc function-arity (@desc "Defines the arity of a function, allowing predicates or built-in facts to also behave as callable functions. This enables procedural-style execution where the last argument of the predicate becomes the function's return value, and the system internally resolves the function using a `match` query. \n\nFor example:\n  ; Declare the built-in predicate `max` with arity 2\n  (predicate-arity max 2)\n\n  ; Enable `max` as a function\n  (add-atom &dyn-space (function-arity max 2))\n\n  ; Define the rules for `max`\n  (add-atom &dyn-space (max $X $Y $X) (<= $X $Y))\n  (add-atom &dyn-space (max $X $Y $Y) (> $X $Y))\n\n  ; Using `max` declaratively as a predicate\n  (match &dyn-space (max (5 10) $max)\n         (The maximum is $max))\n  ; This resolves `$max = 10`.\n\n  ; Using `max` procedurally as a function\n  (max 5 10)\n  ; Returns: 10.\n\n  ; Reverse execution with `max`\n  (max $pair 10)\n  ; Returns: a pair such as (8 10) or (10 5) where the maximum is 10.\n\n  This dual behavior allows predicates to act as functions, bridging procedural and declarative paradigms. By defining `function-arity`, the function automatically resolves using the logic of the associated predicate.") (@params ((@param "Function symbol" "The name of the function or predicate to enable as a callable function."))) (@return "The number of arguments expected by the function.")) (: function-arity (-> Symbol Number)) (predicate-arity function-arity 2) (function-arity function-arity 1) (iz If MeTTa) (@doc If (@desc "Conditional function that evaluates and returns one of the provided atoms based on a boolean condition.") (@params ((@param "Boolean condition") (@param "Atom to return if condition is True") (@param "Atom to return if condition is False (optional)"))) (@return "Either the second or third argument depending on the condition")) (predicate-arity : 2) (= (: $10007 P1)  
  (predicate-arity $10007 1)) (iz SrcPredicate MeTTa) (@doc SrcPredicate (@desc "Type representing a source predicate.")) (: SrcPredicate Type) (iz SrcFunction MeTTa) (@doc SrcFunction (@desc "Type representing a source function.")) (: SrcFunction Type) (iz MeTTaResult MeTTa) (@doc MeTTaResult (@desc "Type representing the result of a MeTTa evaluation.")) (: MeTTaResult Type) (iz NotReducible MeTTaResult) (@doc NotReducible (@desc "Result indicating that an atom cannot be reduced further.")) (: NotReducible MeTTaResult) (iz ValueAtom MeTTa) (@doc ValueAtom (@desc "Type representing a value atom.")) (:> ValueAtom Atom) (iz ForeignObject MeTTa) (@doc ForeignObject (@desc "Type representing a foreign object, such as a Python object.")) (: ForeignObject Type) (:> ValueAtom Grounded) (:> ForeignObject ValueAtom) (iz PyObject MeTTa) (@doc PyObject (@desc "Type representing a Python object.")) (:> PyObject ForeignObject) (:> hyperon::space::DynSpace Grounded) (iz py-list MeTTa) (@doc py-list (@desc "Converts a MeTTa Expression into a Python list and returns it as a PyObject.") (@params ((@param (@desc "A MeTTa List that will be converted into a Python list")))) (@return (@desc "A Python list object that represents the given MeTTa Expression as a PyObject"))) (: py-list (-> Expression PyObject)) (iz py-chain MeTTa) (@doc py-chain (@desc "Chains together a list of Python objects contained in a MeTTa Expression, applying the Python vertical bar | OR operation jointly to all elements.") (@params ((@param (@desc "A MeTTa list of atoms, each embedding a Python object.")))) (@return (@desc "A MeTTa atom which embeds the result of applying the Python OR | operator to all elements of the list."))) (: py-chain (-> Expression PyObject)) (iz py-eval MeTTaLog) (@doc py-eval (@desc "Evaluates a Python expression from a string and returns the result as a PyObject.") (@params ((@param (@desc "A string representing a Python expression that will be evaluated")))) (@return (@desc "The result of evaluating the Python expression as a PyObject"))) (: py-eval (-> String PyObject)) (iz py-exec! MeTTaLog) (@doc py-exec! (@desc "Executes some Python sourcecode from a string !(py-exec! \"import torch\") -> True.  !(py-exec! \"import torche\") -> False. ") (@params ((@param (@type String) (@desc "A string representing a Python sourcecode that will be executed")))) (@return (@desc "The True|False results of executing the Python expression"))) (: py-exec! (-> String Bool)) (iz = MeTTa) (@doc = (@desc "A symbol used to define reduction rules for expressions.") (@params ((@param "Pattern to be matched against expression to be reduced") (@param "Result of reduction or transformation of the first pattern"))) (@return "Not reduced itself unless custom equalities over equalities are added")) (: = (-> $10008 $10008 Atom)) (: = (-> Atom Atom Atom)) (iz ErrorType MeTTa) (@doc ErrorType (@desc "Type of the atom which contains error")) (: ErrorType Type) (iz Error MeTTa) (@doc Error (@desc "Error constructor") (@params ((@param "Atom which contains error") (@param "Error message, can be one of the reserved symbols: BadType, IncorrectNumberOfArguments"))) (@return "Instance of the error atom")) (: Error (-> Atom Atom ErrorType)) (iz return MinimalMeTTa) (@doc return (@desc "Returns value from the (function ...) expression") (@params ((@param "Value to be returned"))) (@return "Passed argument")) (: return (-> $10009 $10009)) (iz function MinimalMeTTa) (@doc function (@desc "Evaluates the argument until it becomes (return <result>). Then (function (return <result>)) is reduced to the <result>.") (@params ((@param "Atom to be evaluated"))) (@return "Result of atom's evaluation")) (: function (-> Atom Atom)) (iz eval MinimalMeTTa) (@doc eval (@desc "Evaluates input Atom, performs one step of the evaluation. Empty results (Empty, ()) are removed from the result set. If no results are produced for a non-grounded function, eval returns NotReducible.") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function"))) (@return "Result of evaluation")) (: eval (-> Atom Atom)) (@doc evalc (@desc "Evaluates input atom, makes one step of the evaluation") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function") (@param "Space to evaluate atom in its context"))) (@return "Result of evaluation")) (: evalc (-> Atom Grounded Atom)) (iz chain MinimalMeTTa) (@doc chain (@desc "Evaluates first argument Atom, binds it to the Variable (second argument) and then evaluates third argument Template with Variable substituted in. When evaluation of the first Atom brings more than a single result, chain returns one instance of the Template expression for each result. The first argument Atom is only evaluated if it is part of the Minimal MeTTa specification; evaluation of non-Minimal MeTTa atoms can be controlled by wrapping in a call to eval (for one evaluation step) or metta (for full evaluation).") (@params ((@param "Atom to be evaluated") (@param "Variable") (@param "Template which will be evaluated at the end with Variable substituted"))) (@return "Result of evaluating third input argument")) (: chain (-> Atom Variable Atom Atom)) (iz unify MeTTa) (@doc unify (@desc "Like Match but allows any sort of container for the first argument. (Match only allows MeTTa spaces.)") (@params ((@param "The collection or space to match") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when found or fourth one otherwise")) (: unify (-> Atom Atom Atom Atom Atom)) (iz if-unify MinimalMeTTaHelper) (@doc if-unify (@desc "Matches two first terms and returns third argument if they are matched and fourth argument otherwise") (@params ((@param "First term to unify with") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when first two atoms are unifiable or fourth one otherwise")) (: if-unify (-> Atom Atom Atom Atom %Undefined%)) (ALT= $10010 $10010) (iz if-unify-or-empty MinimalMeTTaHelper) (@doc if-unify-or-empty (@desc "Attempts to unify two atoms and returns a result. Returns Empty if they cannot be unified.") (@params ((@param "First atom") (@param "Second atom"))) (@return "Unification result or Empty")) (: if-unify-or-empty (-> Atom Atom Atom)) (= (if-unify-or-empty $10011 $10011)  unified) (= (if-unify-or-empty $10012 $10013)  
  (empty)) (iz cons-atom MinimalMeTTa) (@doc cons-atom (@desc "Constructs an expression using two arguments") (@params ((@param "Head of an expression") (@param "Tail of an expression"))) (@return "New expression consisting of the two input arguments")) (: cons-atom (-> Atom Expression Expression)) (iz decons-atom MinimalMeTTa) (@doc decons-atom (@desc "Works as a reverse to cons-atom function. It gets Expression as an input and returns it split into head and tail, e.g. (decons-atom (Cons X Nil)) -> (Cons (X Nil))") (@params ((@param "Expression to be Deconsed"))) (@return "Deconsed expression")) (: decons-atom (-> Expression Expression)) (iz min-atom MeTTa) (@doc min-atom (@desc "Returns atom with minimum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Minimum value in the expression. Error if expression contains non-numeric value or is empty.")) (: min-atom (-> Expression Number)) (= (min-atom $10014)  
  (call-fn! min_list $10014)) (iz max-atom MeTTa) (@doc max-atom (@desc "Returns atom with maximum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Maximum value in the expression. Error if expression contains non-numeric value or is empty.")) (: max-atom (-> Expression Number)) (is-fn-1 max-atom max_list) (iz size-atom MeTTa) (@doc size-atom (@desc "Returns the size of an expression (first argument).") (@params ((@param "Expression to measure the size of"))) (@return "Size of the expression")) (: size-atom (-> Expression Integer)) (is-fn-1 size-atom length) (iz index-atom MeTTa) (@doc index-atom (@desc "Returns atom from an expression (first argument) using index (second argument) or error if index is out of bounds.") (@params ((@param "Expression") (@param "Index"))) (@return "Atom at the specified index in the expression. Error if index is out of bounds.")) (: index-atom (-> Expression Number Atom)) (is-fn-21 index-atom nth0) (iz powi MeTTa) (@doc powi (@desc "Takes base (first argument) and power (second argument) and returns the result of raising the base to the power.") (@params ((@param "Base. Could be a float.") (@param "Power. Must be an integer."))) (@return "Result of base raised to the power")) (= (powi $10015 $10016)  
  (call-fn! pow $10015 $10016)) (==> (is-op-1 $10017 $10018) (is-fn-1 $10017 $10018))) ((a a))))
</span>
Script done on 2024-12-03 11:21:28+00:00 [COMMAND_EXIT_CODE="143"]

</pre>
</body>

</html>
\033[1;33mCompleted (EXITCODE=143) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat/' --timeout=40 --html --repl=false  --test "tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta" --halt=true\033[0m
