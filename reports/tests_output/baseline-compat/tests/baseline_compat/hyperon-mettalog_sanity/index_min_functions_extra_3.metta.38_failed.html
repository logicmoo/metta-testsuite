<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi36 { color: #00aaaa; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-12-22 03:06:59+00:00 [COMMAND="timeout --preserve-status --foreground --signal=SIGTERM --kill-after=5s 40 swipl  /home/runner/work/metta-testsuite/metta-testsuite/prolog/metta_lang/metta_interp.pl -- --python=enable -- --timeout=40 --output=./reports/tests_output/baseline-compat/ --html --test tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta --halt=true  --stdin=tty --stdout=tty --stderr=tty" TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;         #(set_debug transpiler false)

P;HTML|
;          #(set_debug overtime 4.0)

P;HTML|
;          #(set_debug overflow 1000)

P;HTML|
;          #(set_debug eval false)

P;HTML|
;          #(set_debug load silent)

P;HTML|
;          #(set_debug trace-on-load false)

P;HTML|
;          #(set_debug exec false)

P;HTML|
;          #(set_debug error non-type)

P;HTML|
;          #(set_debug fail false)

P;HTML|
;          #(set_debug test true)

P;HTML|
;         #(set_debug test false)

P;HTML|
;         #(set_debug fail false)
P;HTML|
;          #(set_debug transpiler false)
P;HTML|
;          #(set_debug overtime 4.0)
P;HTML|
;          #(set_debug overflow 1000)
P;HTML|
;          #(set_debug eval false)
P;HTML|
;          #(set_debug load silent)
P;HTML|
;          #(set_debug trace-on-load false)
P;HTML|
;          #(set_debug exec false)
P;HTML|
;          #(set_debug error non-type)
P;HTML|
;          #(set_debug fail false)
P;HTML|
;          #(set_debug test true)
P;HTML|
;          #(set_debug test false)
P;HTML|
;          #(set_debug fail false)

; #( : user #(load_metta_file &self tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta) )
P;HTML|
;                #(track_load_into_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta)
P;HTML|
;                        #(load_answer_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta.answers /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta)
P;HTML|
;                         #( = 1 "[()]" )
P;HTML|
;                         #( = 2 "[()]" )
P;HTML|
;                         #( = 3 "[(Error (assertEqualToResult (get-atoms GroundingSpace-0x240a658) ((mod-space! stdlib))) " )
P;HTML|
;                          #( = 3 "Expected: [(mod-space! stdlib)]" )
P;HTML|
;                          #( = 3 "Got: [GroundingSpace-top:stdlib]" )
P;HTML|
;                           #( = 4 "Missed result: (mod-space! stdlib))]" )
P;HTML|
;                           #( = 4 "0.04user 0.00system 0:00.05elapsed 98%CPU (0avgtext+0avgdata 27744maxresident)k" )
P;HTML|
;                           #( = 4 "0inputs+0outputs (0major+3318minor)pagefaults 0swaps" )
P;HTML|
;                        #(load_answer_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta.answers /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta)

;;; Test mod-space! operation to import a module into a new space
<span class="ansi38-013099040"
>!(bind! &new-space (new-space))

</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Add the stdlib module to the new space
<span class="ansi38-013099040"
>!(add-atom &new-space (mod-space! stdlib))

</span><span class="ansi38-255165000"
> (mod-space! stdlib)
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Get atoms from the new space, expecting to include stdlib module
<span class="ansi38-013099040"
>!(assertEqualToResult (get-atoms &new-space) ((mod-space! stdlib)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.01"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.01</h3>
; 
; EVAL TEST
; took 0.000428 secs. (428.18 microseconds) 

!(assertEqualToResult (get-atoms &new-space) ((mod-space! stdlib)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (&stdlib) 
      ( (mod-space! stdlib))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (&stdlib)) #(expected ((mod-space! stdlib)))))
</span>;;; Test removing duplicated atom
;;; Create a new space
<span class="ansi38-013099040"
>!(bind! &space (new-space))

</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Add 'a' multiple times to the space
<span class="ansi38-013099040"
>!(add-atom &space a)

</span><span class="ansi38-255165000"
> a
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &space a)

</span><span class="ansi38-255165000"
> a
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &space a)

</span><span class="ansi38-255165000"
> a
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Remove 'a' once, expecting 'a' to remain twice
<span class="ansi38-013099040"
>!(remove-atom &space a)

</span><span class="ansi38-255165000"
> a
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Get atoms from space, expecting two 'a's
<span class="ansi38-013099040"
>!(assertEqualToResult (get-atoms &space) ((a a)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.02"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.02</h3>
; 
; EVAL TEST
; took 0.000175 secs. (174.62 microseconds) 

!(assertEqualToResult (get-atoms &space) ((a a)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test () 
      ( (a a))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ()) #(expected ((a a)))))
</span>;;; Test that an expression with multiple types returns all types
;;; Define types and assign types to 'a' and 'b'
<span class="ansi38-013099040"
>!(add-atom &self (: A Type))

</span><span class="ansi38-255165000"
> (: A Type)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: AA Type))

</span><span class="ansi38-255165000"
> (: AA Type)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: B Type))

</span><span class="ansi38-255165000"
> (: B Type)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: BB Type))

</span><span class="ansi38-255165000"
> (: BB Type)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: a A))

</span><span class="ansi38-255165000"
> (: a A)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: a AA))

</span><span class="ansi38-255165000"
> (: a AA)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: b B))

</span><span class="ansi38-255165000"
> (: b B)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: b BB))

</span><span class="ansi38-255165000"
> (: b BB)
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test get-type of (a b), expecting multiple types
<span class="ansi38-013099040"
>!(assertEqualToResult (get-type (a b) &self) (((A B) (AA B) (A BB) (AA BB) %Undefined%)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.03"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.03</h3>
; 
; EVAL TEST
; took 0.000389 secs. (388.69 microseconds) 

!(assertEqualToResult (get-type (a b) &self) (((A B) (AA B) (A BB) (AA BB) %Undefined%)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (()) 
      ( ( (A B) 
          (AA B) 
          (A BB) 
          (AA BB) %Undefined%))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (())) #(expected (((A B) (AA B) (A BB) (AA BB) %Undefined%)))))
</span>;;; Test index-atom operation with valid index
;;; Test index-atom with index 2 in list (5 4 3 2 1), expecting 3
<span class="ansi38-013099040"
>!(assertEqualToResult (index-atom (5 4 3 2 1) 2) ((3)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.04"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.04</h3>
P;HTML|
;                                    #(eval_call_fn #(nth0 2 (5 4 3 2 1)) $R)

; 
; EVAL TEST
; took 0.005 secs. (5.00 milliseconds) 

!(assertEqualToResult (index-atom (5 4 3 2 1) 2) ((3)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (3) 
      ( (3))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (3)) #(expected ((3)))))
</span>;;; Test index-atom operation with out-of-bounds index
;;; Test index-atom with index 5 in list (A B C D E), expecting error
<span class="ansi38-013099040"
>!(assertEqualToResult (index-atom (A B C D E) 5) ((Error (index-atom (A B C D E) 5) "Index is out of bounds")))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.05"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.05</h3>
P;HTML|
;                                    #(eval_call_fn #(nth0 5 (A B C D E)) $R)

; 
; EVAL TEST
; took 0.005 secs. (5.17 milliseconds) 

!(assertEqualToResult (index-atom (A B C D E) 5) ((Error (index-atom (A B C D E) 5) "Index is out of bounds")))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test () 
      ( (Error 
          (index-atom 
            (A B C D E) 5) "Index is out of bounds"))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ()) #(expected ((Error (index-atom (A B C D E) 5) "Index is out of bounds")))))
</span>;;; Test handling of empty space during removal
;;; Create a new space
<span class="ansi38-013099040"
>!(bind! &space (new-space))

</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Add atom 'a' to the space
<span class="ansi38-013099040"
>!(add-atom &space a)

</span><span class="ansi38-255165000"
> a
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Attempt to remove atom 'b' which is not in the space, expecting False
<span class="ansi38-013099040"
>!(assertEqualToResult (remove-atom &space b) ((False)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.06"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.06</h3>
<span class="ansi38-255165000"
> b
</span>; 
; EVAL TEST
; took 0.000509 secs. (508.65 microseconds) 

!(assertEqualToResult (remove-atom &space b) ((False)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (()) 
      ( (False))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (())) #(expected ((False)))))
</span>;;; Test that an operation can be an expression
;;; Define higher-order function 'foo' and 'bar'
<span class="ansi38-013099040"
>!(add-atom &self (: foo (-> (-> A A))))

</span><span class="ansi38-255165000"
> (: foo (-> (-> A A)))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: a A))

</span><span class="ansi38-255165000"
> (: a A)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (foo)  bar))

</span><span class="ansi38-255165000"
> (= (foo)  bar)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (bar $x)  $x))

</span><span class="ansi38-255165000"
> (= (bar $_454514)  $_454514)
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that applying 'foo' to 'a' evaluates to 'a'
<span class="ansi38-013099040"
>!(assertEqualToResult (metta ((foo) a) %Undefined% &self) ((a)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.07"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.07</h3>
; 
; EVAL TEST
; took 0.000913 secs. (912.83 microseconds) 

!(assertEqualToResult (metta ((foo) a) %Undefined% &self) ((a)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (a) 
      ( (a))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (a)) #(expected ((a)))))
</span>;;; Test variable name conflict resolution
;;; Define a function 'b' that takes a tuple and returns a 'c' expression
<span class="ansi38-013099040"
>!(add-atom &self (= (b ($x $y))  
  (c $x $y)))

</span><span class="ansi38-255165000"
> (= (b ($_499708 $_499730))  
  (c $_499708 $_499730))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that variable names are correctly handled to avoid conflicts
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (a (b $a) $x $y) %Undefined% &self) ((a (c $a $y) $x $y)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.08"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.08</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.27 milliseconds) 

!(assertEqualToResult (metta (a (b $a) $x $y) %Undefined% &self) ((a (c $a $y) $x $y)))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (a 
          (c $_515120 $_515164) $_535996 $_515164)) 
      ( (a 
          (c $_515120 $_515164) $_515142 $_515164))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test sealed operation to create scoped variables
;;; Use 'sealed' to prevent variable capture
<span class="ansi38-013099040"
>!(assertEqualToResult (sealed ($x) (sealed ($a $b) (quote (= ($a $x $c)  
  ($b))))) ((quote (= ($a $x $c)  
  ($b)))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.09"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.09</h3>
; 
; EVAL TEST
; took 0.000288 secs. (288.15 microseconds) 

!(assertEqualToResult (sealed ($x) (sealed ($a $b) (quote (= ($a $x $c)  
  ($b))))) ((quote (= ($a $x $c)  
  ($b)))))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (quote (= (= $_555884  $_555890)  
          ($_555902)))) 
      ( (quote (= (= $_548098  $_548264)  
          ($_548166))))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Use 'sealed' to replace variables uniquely
<span class="ansi38-013099040"
>!(assertEqualToResult (sealed ($x $y) (quote (= ($y $z)))) ((quote (= ($y $z)))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.10"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.10</h3>
; 
; EVAL TEST
; took 0.000156 secs. (156.01 microseconds) 

!(assertEqualToResult (sealed ($x $y) (quote (= ($y $z)))) ((quote (= ($y $z)))))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (quote (= ($_573110 $_573116)))) 
      ( (quote (= ($_567182 $_567262))))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test using 'sealed' in a 'let' expression to create scoped variables
;;; Use 'sealed' to prevent variable capture in 'let' bindings
<span class="ansi38-013099040"
>!(assertEqualToResult (let (quote ($sv $st)) (sealed ($x) (quote ($x (output $x)))) (let $sv (input $x) $st)) ((output (input $x))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.11"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.11</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.10 milliseconds) 

!(assertEqualToResult (let (quote ($sv $st)) (sealed ($x) (quote ($x (output $x)))) (let $sv (input $x) $st)) ((output (input $x))))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (output (input $_604254))) 
      ( (output (input $_584874)))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test pragma interpreter with bare-minimal mode
;;; Define functions 'foo' and 'bar'
<span class="ansi38-013099040"
>!(add-atom &self (= (bar)  baz))

</span><span class="ansi38-255165000"
> (= (bar)  baz)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (foo)  
  (bar)))

</span><span class="ansi38-255165000"
> (= (foo)  
  (bar))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that '!(foo)' does not evaluate in default interpreter
<span class="ansi38-013099040"
>!(assertEqualToResult (foo) ((baz)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.12"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.12</h3>
; 
; EVAL TEST
; took 0.000569 secs. (568.64 microseconds) 

!(assertEqualToResult (foo) ((baz)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (bar baz) 
      ( (baz))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (bar baz)) #(expected ((baz)))))
</span>;;; Switch to bare-minimal interpreter
<span class="ansi38-013099040"
>!(pragma! interpreter bare-minimal)

</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that '!(foo)' does not evaluate in bare-minimal interpreter
<span class="ansi38-013099040"
>!(assertEqualToResult (foo) ((foo)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.13"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.13</h3>
; 
; EVAL TEST
; took 0.000592 secs. (591.71 microseconds) 

!(assertEqualToResult (foo) ((foo)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (bar baz) 
      ( (foo))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (bar baz)) #(expected ((foo)))))
</span>;;; Use 'eval' to force evaluation in bare-minimal interpreter
<span class="ansi38-013099040"
>!(assertEqualToResult (eval (foo)) ((baz)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.14"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.14</h3>
; 
; EVAL TEST
; took 0.000016 secs. (15.65 microseconds) 

!(assertEqualToResult (eval (foo)) ((baz)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (bar) 
      ( (baz))))
</span>
N(1): <span class="ansi33"
>(#(Error #(got (bar)) #(expected ((baz)))))
</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.15"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.15</h3>
; 
; EVAL TEST
; took 0.000025 secs. (25.17 microseconds) 

!(assertEqualToResult (eval (foo)) ((baz)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (baz) 
      ( (baz))))
</span>
R(2): <span class="ansi33"
>(#(Error #(got (baz)) #(expected ((baz)))))
</span>;;; Test that Error can be used as an argument and has appropriate types
;;; Test get-type of 'Error', expecting (-> Atom Atom ErrorType)
<span class="ansi38-013099040"
>!(assertEqualToResult (get-type Error) (((-> Atom Atom ErrorType))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.16"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.16</h3>
; 
; EVAL TEST
; took 0.000348 secs. (347.90 microseconds) 

!(assertEqualToResult (get-type Error) (((-> Atom Atom ErrorType))))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (-> Atom Atom ErrorType)) 
      ( ( (-> Atom Atom ErrorType)))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((-> Atom Atom ErrorType))) #(expected (((-> Atom Atom ErrorType))))))
</span>;;; Test get-metatype of 'Error', expecting 'Symbol'
<span class="ansi38-013099040"
>!(assertEqualToResult (get-metatype Error) ((Symbol)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.17"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.17</h3>
; 
; EVAL TEST
; took 0.000316 secs. (316.11 microseconds) 

!(assertEqualToResult (get-metatype Error) ((Symbol)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (Grounded) 
      ( (Symbol))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (Grounded)) #(expected ((Symbol)))))
</span>;;; Test get-type of an 'Error' expression, expecting 'ErrorType'
<span class="ansi38-013099040"
>!(assertEqualToResult (get-type (Error Foo Boo)) ((ErrorType)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.18"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.18</h3>
; 
; EVAL TEST
; took 0.000454 secs. (454.04 microseconds) 

!(assertEqualToResult (get-type (Error Foo Boo)) ((ErrorType)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (()) 
      ( (ErrorType))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (())) #(expected ((ErrorType)))))
</span>;;; Test constructing an 'Error' expression with invalid arguments
<span class="ansi38-013099040"
>!(assertEqualToResult (Error (+ 1 2) (+ 1 +)) ((Error (+ 1 2) (+ 1 +))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.19"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.19</h3>
; 
; EVAL TEST
; took 0.000023 secs. (23.45 microseconds) 

!(assertEqualToResult (Error (+ 1 2) (+ 1 +)) ((Error (+ 1 2) (+ 1 +))))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (Error 
          (+ 1 2) 
          (+ 1 +))) 
      ( (Error 
          (+ 1 2) 
          (+ 1 +)))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test string parsing with various inputs
;;; Test that '!(id "test")' returns ("test")
<span class="ansi38-013099040"
>!(assertEqualToResult (id "test") (("test")))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.20"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.20</h3>
; 
; EVAL TEST
; took 0.000485 secs. (484.82 microseconds) 

!(assertEqualToResult (id "test") (("test")))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ("test") 
      ( ("test"))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ("test")) #(expected (("test")))))
</span>;;; Test that '!(id "te st")' returns ("te st")
<span class="ansi38-013099040"
>!(assertEqualToResult (id "te st") (("te st")))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.21"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.21</h3>
; 
; EVAL TEST
; took 0.000405 secs. (405.09 microseconds) 

!(assertEqualToResult (id "te st") (("te st")))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ("te st") 
      ( ("te st"))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ("te st")) #(expected (("te st")))))
</span>;;; Test that '!(id "te\"st")' returns ("te\"st")
<span class="ansi38-013099040"
>!(assertEqualToResult (id "te\"st") (("te\"st")))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.22"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.22</h3>
; 
; EVAL TEST
; took 0.000468 secs. (467.93 microseconds) 

!(assertEqualToResult (id "te\"st") (("te\"st")))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ("te\"st") 
      ( ("te\"st"))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ("te\"st")) #(expected (("te\"st")))))
</span>;;; Test that '!(id "")' returns ((""))
<span class="ansi38-013099040"
>!(assertEqualToResult (id "") (("")))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.23"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.23</h3>
; 
; EVAL TEST
; took 0.000513 secs. (512.93 microseconds) 

!(assertEqualToResult (id "") (("")))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ("") 
      ( (""))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ("")) #(expected (("")))))
</span>;;; Test that '!(id "te\nst")' returns ("te\nst")
<span class="ansi38-013099040"
>!(assertEqualToResult (id "te\nst") (("te\nst")))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.24"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.24</h3>
; 
; EVAL TEST
; took 0.000528 secs. (528.13 microseconds) 

!(assertEqualToResult (id "te\nst") (("te\nst")))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ("te\nst") 
      ( ("te\nst"))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ("te\nst")) #(expected (("te\nst")))))
</span>;;; Test that '!("te\nst" test)' returns (("te\nst" test))
<span class="ansi38-013099040"
>!(assertEqualToResult ("te\nst" test) (("te\nst" test)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.25"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.25</h3>
; 
; EVAL TEST
; took 0.000206 secs. (206.00 microseconds) 

!(assertEqualToResult ("te\nst" test) (("te\nst" test)))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( ("te\nst" test)) 
      ( ("te\nst" test))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that an expression with multiple function types resolves correctly
;;; Define functions 'f_sym', 'f_expr', and 'f_var' with different types
<span class="ansi38-013099040"
>!(add-atom &self (: f_sym (-> Symbol D)))

</span><span class="ansi38-255165000"
> (: f_sym (-> Symbol D))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: f_expr (-> Expression D)))

</span><span class="ansi38-255165000"
> (: f_expr (-> Expression D))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: f_var (-> Variable D)))

</span><span class="ansi38-255165000"
> (: f_var (-> Variable D))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: b B))

</span><span class="ansi38-255165000"
> (: b B)
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test applying 'f_sym' to an expression, expecting 'D'
<span class="ansi38-013099040"
>!(assertEqualToResult (get-type (f_sym (b))) ((D)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.26"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.26</h3>
; 
; EVAL TEST
; took 0.000314 secs. (313.84 microseconds) 

!(assertEqualToResult (get-type (f_sym (b))) ((D)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (()) 
      ( (D))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (())) #(expected ((D)))))
</span>;;; Test applying 'f_expr' to an expression, expecting 'D'
<span class="ansi38-013099040"
>!(assertEqualToResult (get-type (f_expr (b))) ((D)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.27"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.27</h3>
; 
; EVAL TEST
; took 0.000410 secs. (410.23 microseconds) 

!(assertEqualToResult (get-type (f_expr (b))) ((D)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (D) 
      ( (D))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (D)) #(expected ((D)))))
</span>;;; Test applying 'f_var' to an expression, expecting 'D'
<span class="ansi38-013099040"
>!(assertEqualToResult (get-type (f_var (b))) ((D)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.28"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.28</h3>
; 
; EVAL TEST
; took 0.000384 secs. (383.68 microseconds) 

!(assertEqualToResult (get-type (f_var (b))) ((D)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (()) 
      ( (D))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (())) #(expected ((D)))))
</span>;;; Test that variables keep their value in different sub-expressions
;;; Define equality and addition functions
<span class="ansi38-013099040"
>!(add-atom &self (= (eq $x $x)  True))

</span><span class="ansi38-255165000"
> (= (eq $_63116 $_63116)  True)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (plus Z $y)  $y))

</span><span class="ansi38-255165000"
> (= (plus Z $_77980)  $_77980)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (plus (S $k) $y)  
  (S (plus $k $y))))

</span><span class="ansi38-255165000"
> (= (plus (S $_93066) $_93088)  
  (S (plus $_93066 $_93088)))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that (eq (plus Z $n) $n) evaluates to True
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (eq (plus Z $n) $n) %Undefined% &self) ((True)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.29"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.29</h3>
; 
; EVAL TEST
; took 0.000743 secs. (742.52 microseconds) 

!(assertEqualToResult (metta (eq (plus Z $n) $n) %Undefined% &self) ((True)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (True) 
      ( (True))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (True)) #(expected ((True)))))
</span>;;; Test that (eq (plus (S Z) $n) $n) evaluates to False
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (eq (plus (S Z) $n) $n) %Undefined% &self) (()))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.30"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.30</h3>
; 
; EVAL TEST
; took 0.003 secs. (2.60 milliseconds) 

!(assertEqualToResult (metta (eq (plus (S Z) $n) $n) %Undefined% &self) (()))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (eq 
          (S $_162386) $_162386)) 
      (())))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((eq (S $_162386) $_162386))) #(expected (()))))
</span>;;; Test that variables defined via other variables are handled correctly
;;; Define functions 'myif', 'mynot', 'a', and 'b'
<span class="ansi38-013099040"
>!(add-atom &self (= (myif T $y)  $y))

</span><span class="ansi38-255165000"
> (= (myif T $_179574)  $_179574)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (mynot F)  T))

</span><span class="ansi38-255165000"
> (= (mynot F)  T)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (a $z)  
  (mynot (b $z))))

</span><span class="ansi38-255165000"
> (= (a $_209060)  
  (mynot (b $_209060)))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (b d)  F))

</span><span class="ansi38-255165000"
> (= (b d)  F)
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that (myif (a $x) $x) evaluates correctly
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (myif (a $x) $x) %Undefined% &self) ((d)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.31"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.31</h3>
; 
; EVAL TEST
; took 0.004 secs. (3.85 milliseconds) 

!(assertEqualToResult (metta (myif (a $x) $x) %Undefined% &self) ((d)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (myif 
          (mynot (c $_275776 $_275782)) 
          ($_275776 $_275782)) d) 
      ( (d))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((myif (mynot (c $_275776 $_275782)) ($_275776 $_275782)) d)) #(expected ((d)))))
</span>;;; Test that variable name conflicts are resolved by renaming
;;; Define a function with a potential variable name conflict
<span class="ansi38-013099040"
>!(add-atom &self (= (a ($W))  True))

</span><span class="ansi38-255165000"
> (= (a ($_293698))  True)
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that matching 'a' with variable $W works correctly
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (a $W) %Undefined% &self) ((True)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.32"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.32</h3>
; 
; EVAL TEST
; took 0.003 secs. (2.50 milliseconds) 

!(assertEqualToResult (metta (a $W) %Undefined% &self) ((True)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (mynot (c $_331838 $_331844)) T True) 
      ( (True))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((mynot (c $_331838 $_331844)) T True)) #(expected ((True)))))
</span>;;; Test that operations can be higher-order functions
;;; Define types and functions
<span class="ansi38-013099040"
>!(add-atom &self (: foo (-> (-> A A))))

</span><span class="ansi38-255165000"
> (: foo (-> (-> A A)))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: a A))

</span><span class="ansi38-255165000"
> (: a A)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (foo)  bar))

</span><span class="ansi38-255165000"
> (= (foo)  bar)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (bar $x)  $x))

</span><span class="ansi38-255165000"
> (= (bar $_391718)  $_391718)
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that ((foo) a) evaluates to 'a'
<span class="ansi38-013099040"
>!(assertEqualToResult (metta ((foo) a) %Undefined% &self) ((a)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.33"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.33</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.94 milliseconds) 

!(assertEqualToResult (metta ((foo) a) %Undefined% &self) ((a)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (a (baz a)) 
      ( (a))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (a (baz a))) #(expected ((a)))))
</span>;;; Test the use of sealed operation for scope management
;;; Test that sealed variables prevent name clashes
<span class="ansi38-013099040"
>!(assertEqualToResult (sealed ($x) (sealed ($a $b) (quote (= ($a $x $c)  
  ($b))))) ((quote (= ($a $x $c)  
  ($b)))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.34"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.34</h3>
; 
; EVAL TEST
; took 0.000270 secs. (269.66 microseconds) 

!(assertEqualToResult (sealed ($x) (sealed ($a $b) (quote (= ($a $x $c)  
  ($b))))) ((quote (= ($a $x $c)  
  ($b)))))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (quote (= (= $_454652  $_454658)  
          ($_454670)))) 
      ( (quote (= (= $_446866  $_447032)  
          ($_446934))))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that sealed variables are uniquely replaced
<span class="ansi38-013099040"
>!(assertEqualToResult (sealed ($x $y) (quote (= ($y $z)))) ((quote (= ($y $z)))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.35"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.35</h3>
; 
; EVAL TEST
; took 0.000143 secs. (143.35 microseconds) 

!(assertEqualToResult (sealed ($x $y) (quote (= ($y $z)))) ((quote (= ($y $z)))))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (quote (= ($_471878 $_471884)))) 
      ( (quote (= ($_465950 $_466030))))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test using sealed to create scoped variables in 'let' expressions
<span class="ansi38-013099040"
>!(assertEqualToResult (let (quote ($sv $st)) (sealed ($x) (quote ($x (output $x)))) (let $sv (input $x) $st)) ((output (input $x))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.36"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.36</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.10 milliseconds) 

!(assertEqualToResult (let (quote ($sv $st)) (sealed ($x) (quote ($x (output $x)))) (let $sv (input $x) $st)) ((output (input $x))))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (output (input $_502814))) 
      ( (output (input $_483434)))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that the interpreter can switch to bare-minimal mode
;;; Define functions 'foo' and 'bar'
<span class="ansi38-013099040"
>!(add-atom &self (= (bar)  baz))

</span><span class="ansi38-255165000"
> (= (bar)  baz)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (foo)  
  (bar)))

</span><span class="ansi38-255165000"
> (= (foo)  
  (bar))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that '!(foo)' evaluates to 'baz' in default interpreter
<span class="ansi38-013099040"
>!(assertEqualToResult (foo) ((baz)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.37"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.37</h3>
; 
; EVAL TEST
; took 0.000621 secs. (621.50 microseconds) 

!(assertEqualToResult (foo) ((baz)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (bar baz) 
      ( (baz))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (bar baz)) #(expected ((baz)))))
</span>;;; Switch to bare-minimal interpreter
<span class="ansi38-013099040"
>!(pragma! interpreter bare-minimal)

</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that '!(foo)' does not evaluate in bare-minimal interpreter
<span class="ansi38-013099040"
>!(assertEqualToResult (foo) ((foo)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.38"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.38</h3>
; 
; EVAL TEST
; took 0.000618 secs. (617.96 microseconds) 

!(assertEqualToResult (foo) ((foo)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (bar baz) 
      ( (foo))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (bar baz)) #(expected ((foo)))))
</span>;;; Use 'eval' to force evaluation in bare-minimal interpreter
<span class="ansi38-013099040"
>!(assertEqualToResult (eval (foo)) ((baz)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.39"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.39</h3>
; 
; EVAL TEST
; took 0.000023 secs. (22.86 microseconds) 

!(assertEqualToResult (eval (foo)) ((baz)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (bar) 
      ( (baz))))
</span>
N(1): <span class="ansi33"
>(#(Error #(got (bar)) #(expected ((baz)))))
</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.40"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.40</h3>
; 
; EVAL TEST
; took 0.000015 secs. (14.81 microseconds) 

!(assertEqualToResult (eval (foo)) ((baz)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (baz) 
      ( (baz))))
</span>
R(2): <span class="ansi33"
>(#(Error #(got (baz)) #(expected ((baz)))))
</span>;;; Test handling of empty expressions in metta_interpret
;;; Test that interpreting an empty expression returns an empty tuple
<span class="ansi38-013099040"
>!(assertEqualToResult (metta () %Undefined% &self) (()))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.41"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.41</h3>
; 
; EVAL TEST
; took 0.000232 secs. (231.50 microseconds) 

!(assertEqualToResult (metta () %Undefined% &self) (()))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test () 
      (())))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that interpreting an expression with unknown function returns the expression itself
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (unknown-func a) %Undefined% &self) ((unknown-func a)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.42"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.42</h3>
; 
; EVAL TEST
; took 0.000984 secs. (983.58 microseconds) 

!(assertEqualToResult (metta (unknown-func a) %Undefined% &self) ((unknown-func a)))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (unknown-func a)) 
      ( (unknown-func a))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that interpreting an expression with known function evaluates correctly
<span class="ansi38-013099040"
>!(add-atom &self (= (known-func $x)  
  ($x $x)))

</span><span class="ansi38-255165000"
> (= (known-func $_693314)  
  ($_693314 $_693314))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqualToResult (metta (known-func a) %Undefined% &self) ((a a)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.43"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.43</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.68 milliseconds) 

!(assertEqualToResult (metta (known-func a) %Undefined% &self) ((a a)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (mynot (b a))) 
      ( (a a))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((mynot (b a)))) #(expected ((a a)))))
</span>;;; Test that metta can interpret expressions with multiple possible outcomes
;;; Define multiple definitions for 'color'
<span class="ansi38-013099040"
>!(add-atom &self (= (color)  blue))

</span><span class="ansi38-255165000"
> (= (color)  blue)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (color)  red))

</span><span class="ansi38-255165000"
> (= (color)  red)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (color)  green))

</span><span class="ansi38-255165000"
> (= (color)  green)
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that interpreting 'color' returns all possible colors
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (color) %Undefined% &self) ((blue red green)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.44"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.44</h3>
; 
; EVAL TEST
; took 0.000957 secs. (956.84 microseconds) 

!(assertEqualToResult (metta (color) %Undefined% &self) ((blue red green)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (blue red green) 
      ( (blue red green))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (blue red green)) #(expected ((blue red green)))))
</span>;;; Test that variables are correctly assigned in higher-order functions
;;; Define functions 'b' and 'c'
<span class="ansi38-013099040"
>!(add-atom &self (= (b ($x $y))  
  (c $x $y)))

</span><span class="ansi38-255165000"
> (= (b ($_809102 $_809124))  
  (c $_809102 $_809124))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that variables in 'b' are correctly handled
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (a (b $a) $x $y) %Undefined% &self) ((a (c $a $y) $x $y)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.45"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.45</h3>
; 
; EVAL TEST
; took 0.003 secs. (2.94 milliseconds) 

!(assertEqualToResult (metta (a (b $a) $x $y) %Undefined% &self) ((a (c $a $y) $x $y)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (a 
          (c $_850898 $_850904) $_850910 $_850916) (a F $_850862 $_850868)) 
      ( (a 
          (c $_824032 $_824076) $_824054 $_824076))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((a (c $_850898 $_850904) $_850910 $_850916) (a F $_850862 $_850868))) #(expected ((a (c $a $y) $x $y)))))
</span>;;; Test that error is returned when incorrect number of arguments are provided
;;; Define function 'foo' with two arguments
<span class="ansi38-013099040"
>!(add-atom &self (: foo (-> A B C)))

</span><span class="ansi38-255165000"
> (: foo (-> A B C))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: a A))

</span><span class="ansi38-255165000"
> (: a A)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: b B))

</span><span class="ansi38-255165000"
> (: b B)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: c C))

</span><span class="ansi38-255165000"
> (: c C)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (foo $a $b)  c))

</span><span class="ansi38-255165000"
> (= (foo $_926756 $_926778)  c)
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that calling 'foo' with correct arguments returns 'c'
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (foo a b) %Undefined% &self) ((c)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.46"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.46</h3>
; 
; EVAL TEST
; took 0.000569 secs. (568.75 microseconds) 

!(assertEqualToResult (metta (foo a b) %Undefined% &self) ((c)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (c) 
      ( (c))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (c)) #(expected ((c)))))
</span>;;; Test that calling 'foo' with insufficient arguments returns an error
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (foo a) %Undefined% &self) ((Error (foo a) "IncorrectNumberOfArguments")))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.47"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.47</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.00 milliseconds) 

!(assertEqualToResult (metta (foo a) %Undefined% &self) ((Error (foo a) "IncorrectNumberOfArguments")))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (foo a)) 
      ( (Error 
          (foo a) "IncorrectNumberOfArguments"))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((foo a))) #(expected ((Error (foo a) "IncorrectNumberOfArguments")))))
</span>;;; Test that metta can handle function calls with variables as types
;;; Define a function 'id_num' that returns its argument if it's a number
<span class="ansi38-013099040"
>!(add-atom &self (= (id_num $x)  $x))

</span><span class="ansi38-255165000"
> (= (id_num $_994932)  $_994932)
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that 'id_num' returns 'myAtom' even if it's not a number (since types are not enforced)
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (id_num myAtom) %Undefined% &self) ((myAtom)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.48"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.48</h3>
; 
; EVAL TEST
; took 0.000679 secs. (679.19 microseconds) 

!(assertEqualToResult (metta (id_num myAtom) %Undefined% &self) ((myAtom)))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (myAtom) 
      ( (myAtom))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (myAtom)) #(expected ((myAtom)))))
</span>;;; Test that metta returns a 'BadType' error when type checking fails
;;; Define 'myAtom' with type 'myType' and function 'id_a' of type (-> A A)
<span class="ansi38-013099040"
>!(add-atom &self (: myAtom myType))

</span><span class="ansi38-255165000"
> (: myAtom myType)
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: id_a (-> A A)))

</span><span class="ansi38-255165000"
> (: id_a (-> A A))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (id_a $a)  $a))

</span><span class="ansi38-255165000"
> (= (id_a $_15056)  $_15056)
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that calling 'id_a' with 'myAtom' returns a 'BadType' error
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (id_a myAtom) %Undefined% &self) ((Error myAtom "BadType")))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.49"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.49</h3>
; 
; EVAL TEST
; took 0.000615 secs. (615.04 microseconds) 

!(assertEqualToResult (metta (id_a myAtom) %Undefined% &self) ((Error myAtom "BadType")))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      (myAtom) 
      ( (Error myAtom "BadType"))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got (myAtom)) #(expected ((Error myAtom "BadType")))))
</span><span class="ansi32"
>% 16,310,430 inferences, 4.601 CPU in 4.604 seconds (100% CPU, 3544595 Lips)
</span>P;HTML|
;                #( = /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta 0 )
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 11
</span><span class="ansi31"
>Failures: 38
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
P;HTML|
;          #(set_debug transpiler false)
P;HTML|
;          #(set_debug overtime 4.0)
P;HTML|
;          #(set_debug overflow 1000)
P;HTML|
;          #(set_debug eval false)
P;HTML|
;          #(set_debug load silent)
P;HTML|
;          #(set_debug trace-on-load false)
P;HTML|
;          #(set_debug exec false)
P;HTML|
;          #(set_debug error non-type)
P;HTML|
;          #(set_debug fail false)
P;HTML|
;          #(set_debug test true)
P;HTML|
;          #(set_debug test false)
P;HTML|
;          #(set_debug fail false)

[()]

[()]

[(#(Error #(got (&stdlib)) #(expected ((mod-space! stdlib)))))]

[()]

[()]

[()]

[()]

[()]

[(#(Error #(got ()) #(expected ((a a)))))]

[()]

[()]

[()]

[()]

[()]

[()]

[()]

[()]

[(#(Error #(got (())) #(expected (((A B) (AA B) (A BB) (AA BB) %Undefined%)))))]

[(#(Error #(got (3)) #(expected ((3)))))]

[(#(Error #(got ()) #(expected ((Error (index-atom (A B C D E) 5) "Index is out of bounds")))))]

[()]

[()]

[(#(Error #(got (())) #(expected ((False)))))]

[()]

[()]

[()]

[()]

[(#(Error #(got (a)) #(expected ((a)))))]

[()]

[()]

[()]

[()]

[()]

[()]

[()]

[(#(Error #(got (bar baz)) #(expected ((baz)))))]

[()]

[(#(Error #(got (bar baz)) #(expected ((foo)))))]

[(#(Error #(got (bar)) #(expected ((baz))))), (#(Error #(got (baz)) #(expected ((baz)))))]

[(#(Error #(got ((-> Atom Atom ErrorType))) #(expected (((-> Atom Atom ErrorType))))))]

[(#(Error #(got (Grounded)) #(expected ((Symbol)))))]

[(#(Error #(got (())) #(expected ((ErrorType)))))]

[()]

[(#(Error #(got ("test")) #(expected (("test")))))]

[(#(Error #(got ("te st")) #(expected (("te st")))))]

[(#(Error #(got ("te\"st")) #(expected (("te\"st")))))]

[(#(Error #(got ("")) #(expected (("")))))]

[(#(Error #(got ("te\nst")) #(expected (("te\nst")))))]

[()]

[()]

[()]

[()]

[()]

[(#(Error #(got (())) #(expected ((D)))))]

[(#(Error #(got (D)) #(expected ((D)))))]

[(#(Error #(got (())) #(expected ((D)))))]

[()]

[()]

[()]

[(#(Error #(got (True)) #(expected ((True)))))]

[(#(Error #(got ((eq (S $_162386) $_162386))) #(expected (()))))]

[()]

[()]

[()]

[()]

[(#(Error #(got ((myif (mynot (c $_275776 $_275782)) ($_275776 $_275782)) d)) #(expected ((d)))))]

[()]

[(#(Error #(got ((mynot (c $_331838 $_331844)) T True)) #(expected ((True)))))]

[()]

[()]

[()]

[()]

[(#(Error #(got (a (baz a))) #(expected ((a)))))]

[()]

[()]

[()]

[()]

[()]

[(#(Error #(got (bar baz)) #(expected ((baz)))))]

[()]

[(#(Error #(got (bar baz)) #(expected ((foo)))))]

[(#(Error #(got (bar)) #(expected ((baz))))), (#(Error #(got (baz)) #(expected ((baz)))))]

[()]

[()]

[()]

[(#(Error #(got ((mynot (b a)))) #(expected ((a a)))))]

[()]

[()]

[()]

[(#(Error #(got (blue red green)) #(expected ((blue red green)))))]

[()]

[(#(Error #(got ((a (c $_850898 $_850904) $_850910 $_850916) (a F $_850862 $_850868))) #(expected ((a (c $_824032 $_824076) $_824054 $_824076)))))]

[()]

[()]

[()]

[()]

[()]

[(#(Error #(got (c)) #(expected ((c)))))]

[(#(Error #(got ((foo a))) #(expected ((Error (foo a) "IncorrectNumberOfArguments")))))]

[()]

[(#(Error #(got (myAtom)) #(expected ((myAtom)))))]

[()]

[()]

[()]

[(#(Error #(got (myAtom)) #(expected ((Error myAtom "BadType")))))]
P;HTML|
;         #(maybe_halt 7)
<span class="ansi31"
>#(in #(maybe_halt 7) #(unwind #(halt 7)))
</span>
Script done on 2024-12-22 03:07:12+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat/' --timeout=40 --html --repl=false  --test "tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta" --halt=true\033[0m
