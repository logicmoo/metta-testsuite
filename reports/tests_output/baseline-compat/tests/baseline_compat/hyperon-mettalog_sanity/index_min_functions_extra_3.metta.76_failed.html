<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi36 { color: #00aaaa; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2025-02-22 20:48:57+00:00 [COMMAND="timeout --preserve-status --foreground 40 swipl -x /home/runner/work/metta-testsuite/metta-testsuite/prolog/metta_lang/Sav.fv-az1947-39.MeTTaLog  -- --python=enable -- --timeout=40 --output=/home/runner/work/metta-testsuite/metta-testsuite/reports/tests_output/baseline-compat --html --test tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta --halt=true  --stdin=tty --stdout=tty --stderr=tty" TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]

; [ : user [load_metta_file &self tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta] ]
P;HTML|
;               [track_load_into_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta]
P;HTML|
;                      [load_answer_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta.test_error /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta]
P;HTML|
;                       [ = 1 "[()]" ]
P;HTML|
;                       [ = 2 "[()]" ]
P;HTML|
;                       [ = 3 "[(Error (assertEqualToResult (get-atoms GroundingSpace-0x55ed4acd8268) ((mod-space! stdlib))) " ]
P;HTML|
;                        [ = 3 "Expected: [(mod-space! stdlib)]" ]
P;HTML|
;                        [ = 3 "Got: [ModuleSpace(GroundingSpace-top:stdlib)]" ]
P;HTML|
;                         [ = 4 "Missed results: (mod-space! stdlib)" ]
P;HTML|
;                         [ = 4 "Excessive results: ModuleSpace(GroundingSpace-top:stdlib))]" ]
P;HTML|
;                      [load_answer_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta.test_error /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta]

;;; Test mod-space! operation to import a module into a new space
<span class="ansi38-013099040"
>!(bind! &new-space (new-space))

</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Add the stdlib module to the new space
<span class="ansi38-013099040"
>!(add-atom &new-space (mod-space! stdlib))

</span><span class="ansi38-255165000"
> (mod-space! stdlib)
 
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Get atoms from the new space, expecting to include stdlib module
<span class="ansi38-013099040"
>!(assertEqualToResult (get-atoms &new-space) ((mod-space! stdlib)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.01"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.01</h3>
; 
; EVAL TEST
; took 0.000380 secs. (380.21 microseconds) 

!(assertEqualToResult (get-atoms &new-space) ((mod-space! stdlib)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (&stdlib) 
      ( (mod-space! stdlib))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'('&stdlib',[]),'[|]'('[|]'('mod-space!','[|]'(stdlib,[])),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (&stdlib)) ('~nExpected: ' ((mod-space! stdlib))))
</span>;;; Test removing duplicated atom
;;; Create a new space
<span class="ansi38-013099040"
>!(bind! &space (new-space))

</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Add 'a' multiple times to the space
<span class="ansi38-013099040"
>!(add-atom &space a)

</span><span class="ansi38-255165000"
> a
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &space a)

</span><span class="ansi38-255165000"
> a
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &space a)

</span><span class="ansi38-255165000"
> a
 
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Remove 'a' once, expecting 'a' to remain twice
<span class="ansi38-013099040"
>!(remove-atom &space a)

</span><span class="ansi38-255165000"
> a
 
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Get atoms from space, expecting two 'a's
<span class="ansi38-013099040"
>!(assertEqualToResult (get-atoms &space) ((a a)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.02"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.02</h3>
; 
; EVAL TEST
; took 0.000158 secs. (158.25 microseconds) 

!(assertEqualToResult (get-atoms &space) ((a a)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn () 
      ( (a a))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,[],'[|]'('[|]'(a,'[|]'(a,[])),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' ()) ('~nExpected: ' ((a a))))
</span>;;; Test that an expression with multiple types returns all types
;;; Define types and assign types to 'a' and 'b'
<span class="ansi38-013099040"
>!(add-atom &self (: A Type))

</span><span class="ansi38-255165000"
> (: A Type)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: AA Type))

</span><span class="ansi38-255165000"
> (: AA Type)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: B Type))

</span><span class="ansi38-255165000"
> (: B Type)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: BB Type))

</span><span class="ansi38-255165000"
> (: BB Type)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: a A))

</span><span class="ansi38-255165000"
> (: a A)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: a AA))

</span><span class="ansi38-255165000"
> (: a AA)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: b B))

</span><span class="ansi38-255165000"
> (: b B)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: b BB))

</span><span class="ansi38-255165000"
> (: b BB)
 
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test get-type of (a b), expecting multiple types
<span class="ansi38-013099040"
>!(assertEqualToResult (get-type (a b) &self) (((A B) (AA B) (A BB) (AA BB) %Undefined%)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.03"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.03</h3>
; 
; EVAL TEST
; took 0.000540 secs. (539.99 microseconds) 

!(assertEqualToResult (get-type (a b) &self) (((A B) (AA B) (A BB) (AA BB) %Undefined%)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (AnyRet AnyRet) 
      ( ( (A B) 
          (AA B) 
          (A BB) 
          (AA BB) %Undefined%))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'('AnyRet','[|]'('AnyRet',[])),'[|]'('[|]'('[|]'('A','[|]'('B',[])),'[|]'('[|]'('AA','[|]'('B',[])),'[|]'('[|]'('A','[|]'('BB',[])),'[|]'('[|]'('AA','[|]'('BB',[])),'[|]'('%Undefined%',[]))))),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (AnyRet AnyRet)) ('~nExpected: ' (((A B) (AA B) (A BB) (AA BB) %Undefined%))))
</span>;;; Test index-atom operation with valid index
;;; Test index-atom with index 2 in list (5 4 3 2 1), expecting 3
<span class="ansi38-013099040"
>!(assertEqualToResult (index-atom (5 4 3 2 1) 2) ((3)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.04"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.04</h3>
; 
; EVAL TEST
; took 0.000294 secs. (294.16 microseconds) 

!(assertEqualToResult (index-atom (5 4 3 2 1) 2) ((3)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (3) 
      ( (3))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'(3,[]),'[|]'('[|]'(3,[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (3)) ('~nExpected: ' ((3))))
</span>;;; Test index-atom operation with out-of-bounds index
;;; Test index-atom with index 5 in list (A B C D E), expecting error
<span class="ansi38-013099040"
>!(assertEqualToResult (index-atom (A B C D E) 5) ((Error (index-atom (A B C D E) 5) "Index is out of bounds")))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.05"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.05</h3>
; 
; EVAL TEST
; took 0.000271 secs. (270.97 microseconds) 

!(assertEqualToResult (index-atom (A B C D E) 5) ((Error (index-atom (A B C D E) 5) "Index is out of bounds")))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn () 
      ( (Error 
          (index-atom 
            (A B C D E) 5) "Index is out of bounds"))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,[],'[|]'('[|]'('Error','[|]'('[|]'('index-atom','[|]'('[|]'('A','[|]'('B','[|]'('C','[|]'('D','[|]'('E',[]))))),'[|]'(5,[]))),'[|]'("Index is out of bounds",[]))),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' ()) ('~nExpected: ' ((Error (index-atom (A B C D E) 5) "Index is out of bounds"))))
</span>;;; Test handling of empty space during removal
;;; Create a new space
<span class="ansi38-013099040"
>!(bind! &space (new-space))

</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Add atom 'a' to the space
<span class="ansi38-013099040"
>!(add-atom &space a)

</span><span class="ansi38-255165000"
> a
 
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Attempt to remove atom 'b' which is not in the space, expecting False
<span class="ansi38-013099040"
>!(assertEqualToResult (remove-atom &space b) ((False)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.06"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.06</h3>
<span class="ansi38-255165000"
> b
 
</span>; 
; EVAL TEST
; took 0.000420 secs. (420.07 microseconds) 

!(assertEqualToResult (remove-atom &space b) ((False)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (()) 
      ( (False))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'([],[]),'[|]'('[|]'('False',[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (())) ('~nExpected: ' ((False))))
</span>;;; Test that an operation can be an expression
;;; Define higher-order function 'foo' and 'bar'
<span class="ansi38-013099040"
>!(add-atom &self (: foo (-> (-> A A))))

</span><span class="ansi38-255165000"
> (: foo (-> (-> A A)))
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: a A))

</span><span class="ansi38-255165000"
> (: a A)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (foo)  bar))

</span><span class="ansi38-255165000"
> (= (foo)  bar)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (bar $49232)  $49232))

</span><span class="ansi38-255165000"
> (= (bar $x)  $x)
 
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that applying 'foo' to 'a' evaluates to 'a'
<span class="ansi38-013099040"
>!(assertEqualToResult (metta ((foo) a) %Undefined% &self) ((a)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.07"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.07</h3>
; 
; EVAL TEST
; took 0.000926 secs. (925.93 microseconds) 

!(assertEqualToResult (metta ((foo) a) %Undefined% &self) ((a)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (a) 
      ( (a))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'(a,[]),'[|]'('[|]'(a,[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (a)) ('~nExpected: ' ((a))))
</span>;;; Test variable name conflict resolution
;;; Define a function 'b' that takes a tuple and returns a 'c' expression
<span class="ansi38-013099040"
>!(add-atom &self (= (b ($23716 $23722))  
  (c $23716 $23722)))

</span><span class="ansi38-255165000"
> (= (b ($x $y))  
  (c $x $y))
 
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that variable names are correctly handled to avoid conflicts
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (a (b $41392) $41398 $41404) %Undefined% &self) ((a (c $41392 $41404) $41398 $41404)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.08"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.08</h3>
; 
; EVAL TEST
; took 0.006 secs. (6.03 milliseconds) 

!(assertEqualToResult (metta (a (b $26578) $26584 $26590) %Undefined% &self) ((a (c $26578 $26590) $26584 $26590)))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (a 
          (c $31774 $31780) $31786 $31792)) 
      ( (a 
          (c $31822 $31828) $31834 $31828))]]
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test sealed operation to create scoped variables
;;; Use 'sealed' to prevent variable capture
<span class="ansi38-013099040"
>!(assertEqualToResult (sealed ($41214) (sealed ($41238 $41244) (quote (= ($41238 $41214 $41292)  
  ($41244))))) ((quote (= ($41238 $41214 $41292)  
  ($41244)))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.09"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.09</h3>
; 
; EVAL TEST
; took 0.000289 secs. (289.47 microseconds) 

!(assertEqualToResult (sealed ($52768) (sealed ($52792 $52798) (quote (= ($52792 $52768 $52846)  
  ($52798))))) ((quote (= ($52792 $52768 $52846)  
  ($52798)))))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (quote (= ($58794 $58800 $58806)  
          ($58818)))) 
      ( (quote (= ($58854 $58860 $58866)  
          ($58878))))]]
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Use 'sealed' to replace variables uniquely
<span class="ansi38-013099040"
>!(assertEqualToResult (sealed ($5272 $5278) (quote (= ($5278 $5320)))) ((quote (= ($5278 $5320)))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.10"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.10</h3>
; 
; EVAL TEST
; took 0.000166 secs. (165.86 microseconds) 

!(assertEqualToResult (sealed ($14224 $14230) (quote (= ($14230 $14272)))) ((quote (= ($14230 $14272)))))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (quote (= ($18562 $18568)))) 
      ( (quote (= ($18604 $18610))))]]
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test using 'sealed' in a 'let' expression to create scoped variables
;;; Use 'sealed' to prevent variable capture in 'let' bindings
<span class="ansi38-013099040"
>!(assertEqualToResult (let (quote ($27272 $27278)) (sealed ($27302) (quote ($27302 (output $27302)))) (let $27272 (input $27302) $27278)) ((output (input $27302))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.11"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.11</h3>
; 
; EVAL TEST
; took 0.006 secs. (6.24 milliseconds) 

!(assertEqualToResult (let (quote ($13542 $13548)) (sealed ($13572) (quote ($13572 (output $13572)))) (let $13542 (input $13572) $13548)) ((output (input $13572))))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (output (input $16940))) 
      ( (output (input $16970)))]]
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test pragma interpreter with bare-minimal mode
;;; Define functions 'foo' and 'bar'
<span class="ansi38-013099040"
>!(add-atom &self (= (bar)  baz))

</span><span class="ansi38-255165000"
> (= (bar)  baz)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (foo)  
  (bar)))

</span><span class="ansi38-255165000"
> (= (foo)  
  (bar))
 
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that '!(foo)' does not evaluate in default interpreter
<span class="ansi38-013099040"
>!(assertEqualToResult (foo) ((baz)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.12"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.12</h3>
; 
; EVAL TEST
; took 0.000483 secs. (483.18 microseconds) 

!(assertEqualToResult (foo) ((baz)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (bar baz) 
      ( (baz))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'(bar,'[|]'(baz,[])),'[|]'('[|]'(baz,[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (bar baz)) ('~nExpected: ' ((baz))))
</span>;;; Switch to bare-minimal interpreter
<span class="ansi38-013099040"
>!(pragma! interpreter bare-minimal)

</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that '!(foo)' does not evaluate in bare-minimal interpreter
<span class="ansi38-013099040"
>!(assertEqualToResult (foo) ((foo)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.13"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.13</h3>
; 
; EVAL TEST
; took 0.000487 secs. (487.18 microseconds) 

!(assertEqualToResult (foo) ((foo)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (bar baz) 
      ( (foo))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'(bar,'[|]'(baz,[])),'[|]'('[|]'(foo,[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (bar baz)) ('~nExpected: ' ((foo))))
</span>;;; Use 'eval' to force evaluation in bare-minimal interpreter
<span class="ansi38-013099040"
>!(assertEqualToResult (eval (foo)) ((baz)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.14"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.14</h3>
; 
; EVAL TEST
; took 0.000016 secs. (16.19 microseconds) 

!(assertEqualToResult (eval (foo)) ((baz)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (bar) 
      ( (baz))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'(bar,[]),'[|]'('[|]'(baz,[]),[]))

N(1): <span class="ansi33"
>(Error ('~nGot: ' (bar)) ('~nExpected: ' ((baz))))
</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.15"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.15</h3>
; 
; EVAL TEST
; took 0.000017 secs. (16.85 microseconds) 

!(assertEqualToResult (eval (foo)) ((baz)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (baz) 
      ( (baz))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'(baz,[]),'[|]'('[|]'(baz,[]),[]))

R(2): <span class="ansi33"
>(Error ('~nGot: ' (baz)) ('~nExpected: ' ((baz))))
</span>;;; Test that Error can be used as an argument and has appropriate types
;;; Test get-type of 'Error', expecting (-> Atom Atom ErrorType)
<span class="ansi38-013099040"
>!(assertEqualToResult (get-type Error) (((-> Atom Atom ErrorType))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.16"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.16</h3>
; 
; EVAL TEST
; took 0.000334 secs. (333.96 microseconds) 

!(assertEqualToResult (get-type Error) (((-> Atom Atom ErrorType))))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (-> Atom Atom ErrorType)) 
      ( ( (-> Atom Atom ErrorType)))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'('[|]'(->,'[|]'('Atom','[|]'('Atom','[|]'('ErrorType',[])))),[]),'[|]'('[|]'('[|]'(->,'[|]'('Atom','[|]'('Atom','[|]'('ErrorType',[])))),[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' ((-> Atom Atom ErrorType))) ('~nExpected: ' (((-> Atom Atom ErrorType)))))
</span>;;; Test get-metatype of 'Error', expecting 'Symbol'
<span class="ansi38-013099040"
>!(assertEqualToResult (get-metatype Error) ((Symbol)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.17"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.17</h3>
; 
; EVAL TEST
; took 0.000426 secs. (426.04 microseconds) 

!(assertEqualToResult (get-metatype Error) ((Symbol)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (Grounded) 
      ( (Symbol))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'('Grounded',[]),'[|]'('[|]'('Symbol',[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (Grounded)) ('~nExpected: ' ((Symbol))))
</span>;;; Test get-type of an 'Error' expression, expecting 'ErrorType'
<span class="ansi38-013099040"
>!(assertEqualToResult (get-type (Error Foo Boo)) ((ErrorType)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.18"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.18</h3>
; 
; EVAL TEST
; took 0.000514 secs. (514.09 microseconds) 

!(assertEqualToResult (get-type (Error Foo Boo)) ((ErrorType)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (() ()) 
      ( (ErrorType))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'([],'[|]'([],[])),'[|]'('[|]'('ErrorType',[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (() ())) ('~nExpected: ' ((ErrorType))))
</span>;;; Test constructing an 'Error' expression with invalid arguments
<span class="ansi38-013099040"
>!(assertEqualToResult (Error (+ 1 2) (+ 1 +)) ((Error (+ 1 2) (+ 1 +))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.19"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.19</h3>
; 
; EVAL TEST
; took 0.000028 secs. (28.28 microseconds) 

!(assertEqualToResult (Error (+ 1 2) (+ 1 +)) ((Error (+ 1 2) (+ 1 +))))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (Error 
          (+ 1 2) 
          (+ 1 +))) 
      ( (Error 
          (+ 1 2) 
          (+ 1 +)))]]
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test string parsing with various inputs
;;; Test that '!(id "test")' returns ("test")
<span class="ansi38-013099040"
>!(assertEqualToResult (id "test") (("test")))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.20"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.20</h3>
; 
; EVAL TEST
; took 0.000242 secs. (241.50 microseconds) 

!(assertEqualToResult (id "test") (("test")))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("test") 
      ( ("test"))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'("test",[]),'[|]'('[|]'("test",[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' ("test")) ('~nExpected: ' (("test"))))
</span>;;; Test that '!(id "te st")' returns ("te st")
<span class="ansi38-013099040"
>!(assertEqualToResult (id "te st") (("te st")))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.21"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.21</h3>
; 
; EVAL TEST
; took 0.000246 secs. (245.90 microseconds) 

!(assertEqualToResult (id "te st") (("te st")))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("te st") 
      ( ("te st"))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'("te st",[]),'[|]'('[|]'("te st",[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' ("te st")) ('~nExpected: ' (("te st"))))
</span>;;; Test that '!(id "te\"st")' returns ("te\"st")
<span class="ansi38-013099040"
>!(assertEqualToResult (id "te\"st") (("te\"st")))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.22"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.22</h3>
; 
; EVAL TEST
; took 0.000238 secs. (238.29 microseconds) 

!(assertEqualToResult (id "te\"st") (("te\"st")))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("te\"st") 
      ( ("te\"st"))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'("te\"st",[]),'[|]'('[|]'("te\"st",[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' ("te\"st")) ('~nExpected: ' (("te\"st"))))
</span>;;; Test that '!(id "")' returns ((""))
<span class="ansi38-013099040"
>!(assertEqualToResult (id "") (("")))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.23"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.23</h3>
; 
; EVAL TEST
; took 0.000255 secs. (254.65 microseconds) 

!(assertEqualToResult (id "") (("")))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("") 
      ( (""))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'("",[]),'[|]'('[|]'("",[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' ("")) ('~nExpected: ' ((""))))
</span>;;; Test that '!(id "te\nst")' returns ("te\nst")
<span class="ansi38-013099040"
>!(assertEqualToResult (id "te\nst") (("te\nst")))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.24"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.24</h3>
; 
; EVAL TEST
; took 0.000241 secs. (241.33 microseconds) 

!(assertEqualToResult (id "te\nst") (("te\nst")))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("te\nst") 
      ( ("te\nst"))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'("te\nst",[]),'[|]'('[|]'("te\nst",[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' ("te\nst")) ('~nExpected: ' (("te\nst"))))
</span>;;; Test that '!("te\nst" test)' returns (("te\nst" test))
<span class="ansi38-013099040"
>!(assertEqualToResult ("te\nst" test) (("te\nst" test)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.25"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.25</h3>
; 
; EVAL TEST
; took 0.000206 secs. (205.57 microseconds) 

!(assertEqualToResult ("te\nst" test) (("te\nst" test)))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( ("te\nst" test)) 
      ( ("te\nst" test))]]
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that an expression with multiple function types resolves correctly
;;; Define functions 'f_sym', 'f_expr', and 'f_var' with different types
<span class="ansi38-013099040"
>!(add-atom &self (: f_sym (-> Symbol D)))

</span><span class="ansi38-255165000"
> (: f_sym (-> Symbol D))
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: f_expr (-> Expression D)))

</span><span class="ansi38-255165000"
> (: f_expr (-> Expression D))
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: f_var (-> Variable D)))

</span><span class="ansi38-255165000"
> (: f_var (-> Variable D))
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: b B))

</span><span class="ansi38-255165000"
> (: b B)
 
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test applying 'f_sym' to an expression, expecting 'D'
<span class="ansi38-013099040"
>!(assertEqualToResult (get-type (f_sym (b))) ((D)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.26"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.26</h3>
; 
; EVAL TEST
; took 0.000475 secs. (474.93 microseconds) 

!(assertEqualToResult (get-type (f_sym (b))) ((D)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (() ()) 
      ( (D))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'([],'[|]'([],[])),'[|]'('[|]'('D',[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (() ())) ('~nExpected: ' ((D))))
</span>;;; Test applying 'f_expr' to an expression, expecting 'D'
<span class="ansi38-013099040"
>!(assertEqualToResult (get-type (f_expr (b))) ((D)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.27"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.27</h3>
; 
; EVAL TEST
; took 0.000444 secs. (444.20 microseconds) 

!(assertEqualToResult (get-type (f_expr (b))) ((D)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (D D) 
      ( (D))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'('D','[|]'('D',[])),'[|]'('[|]'('D',[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (D D)) ('~nExpected: ' ((D))))
</span>;;; Test applying 'f_var' to an expression, expecting 'D'
<span class="ansi38-013099040"
>!(assertEqualToResult (get-type (f_var (b))) ((D)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.28"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.28</h3>
; 
; EVAL TEST
; took 0.000467 secs. (466.60 microseconds) 

!(assertEqualToResult (get-type (f_var (b))) ((D)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (() ()) 
      ( (D))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'([],'[|]'([],[])),'[|]'('[|]'('D',[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (() ())) ('~nExpected: ' ((D))))
</span>;;; Test that variables keep their value in different sub-expressions
;;; Define equality and addition functions
<span class="ansi38-013099040"
>!(add-atom &self (= (eq $28778 $28778)  True))

</span><span class="ansi38-255165000"
> (= (eq $x $x)  True)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (plus Z $44186)  $44186))

</span><span class="ansi38-255165000"
> (= (plus Z $y)  $y)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (plus (S $60058) $60064)  
  (S (plus $60058 $60064))))

</span><span class="ansi38-255165000"
> (= (plus (S $k) $y)  
  (S (plus $k $y)))
 
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that (eq (plus Z $n) $n) evaluates to True
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (eq (plus Z $15364) $15364) %Undefined% &self) ((True)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.29"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.29</h3>
; 
; EVAL TEST
; took 0.000929 secs. (928.58 microseconds) 

!(assertEqualToResult (metta (eq (plus Z $27974) $27974) %Undefined% &self) ((True)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (True) 
      ( (True))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'('True',[]),'[|]'('[|]'('True',[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (True)) ('~nExpected: ' ((True))))
</span>;;; Test that (eq (plus (S Z) $n) $n) evaluates to False
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (eq (plus (S Z) $37144) $37144) %Undefined% &self) (()))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.30"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.30</h3>
; 
; EVAL TEST
; took 0.006 secs. (6.45 milliseconds) 

!(assertEqualToResult (metta (eq (plus (S Z) $22696) $22696) %Undefined% &self) (()))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (eq 
          (S $23638) $23638)) 
      (())]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'('[|]'(eq,'[|]'('[|]'('S','[|]'(_21620{vn = ...},[])),'[|]'(_21620{vn = ...},[]))),[]),'[|]'([],[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' ((eq (S $29468) $29468))) ('~nExpected: ' (())))
</span>;;; Test that variables defined via other variables are handled correctly
;;; Define functions 'myif', 'mynot', 'a', and 'b'
<span class="ansi38-013099040"
>!(add-atom &self (= (myif T $32128)  $32128))

</span><span class="ansi38-255165000"
> (= (myif T $y)  $y)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (mynot F)  T))

</span><span class="ansi38-255165000"
> (= (mynot F)  T)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (a $62136)  
  (mynot (b $62136))))

</span><span class="ansi38-255165000"
> (= (a $z)  
  (mynot (b $z)))
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (b d)  F))

</span><span class="ansi38-255165000"
> (= (b d)  F)
 
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that (myif (a $x) $x) evaluates correctly
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (myif (a $29244) $29244) %Undefined% &self) ((d)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.31"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.31</h3>
; 
; EVAL TEST
; took 0.013 secs. (12.70 milliseconds) 

!(assertEqualToResult (metta (myif (a $59734) $59734) %Undefined% &self) ((d)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (myif 
          (mynot (c $60678 $60684)) 
          ($60678 $60684))) 
      ( (d))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'('[|]'(myif,'[|]'('[|]'(mynot,'[|]'('[|]'(c,'[|]'(_3566,'[|]'(_3572,[]))),[])),'[|]'('[|]'(_3566,'[|]'(_3572,[])),[]))),[]),'[|]'('[|]'(d,[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' ((myif (mynot (c $8542 $8548)) ($8542 $8548)))) ('~nExpected: ' ((d))))
</span>;;; Test that variable name conflicts are resolved by renaming
;;; Define a function with a potential variable name conflict
<span class="ansi38-013099040"
>!(add-atom &self (= (a ($11248))  True))

</span><span class="ansi38-255165000"
> (= (a ($W))  True)
 
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that matching 'a' with variable $W works correctly
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (a $26304) %Undefined% &self) ((True)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.32"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.32</h3>
; 
; EVAL TEST
; took 0.008 secs. (7.85 milliseconds) 

!(assertEqualToResult (metta (a $15402) %Undefined% &self) ((True)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (mynot (c $16334 $16340)) T True) 
      ( (True))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'('[|]'(mynot,'[|]'('[|]'(c,'[|]'(_14364,'[|]'(_14370,[]))),[])),'[|]'('T','[|]'('True',[]))),'[|]'('[|]'('True',[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' ((mynot (c $22046 $22052)) T True)) ('~nExpected: ' ((True))))
</span>;;; Test that operations can be higher-order functions
;;; Define types and functions
<span class="ansi38-013099040"
>!(add-atom &self (: foo (-> (-> A A))))

</span><span class="ansi38-255165000"
> (: foo (-> (-> A A)))
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: a A))

</span><span class="ansi38-255165000"
> (: a A)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (foo)  bar))

</span><span class="ansi38-255165000"
> (= (foo)  bar)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (bar $2332)  $2332))

</span><span class="ansi38-255165000"
> (= (bar $x)  $x)
 
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that ((foo) a) evaluates to 'a'
<span class="ansi38-013099040"
>!(assertEqualToResult (metta ((foo) a) %Undefined% &self) ((a)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.33"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.33</h3>
; 
; EVAL TEST
; took 0.003 secs. (3.44 milliseconds) 

!(assertEqualToResult (metta ((foo) a) %Undefined% &self) ((a)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (a (baz a)) 
      ( (a))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'(a,'[|]'('[|]'(baz,'[|]'(a,[])),[])),'[|]'('[|]'(a,[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (a (baz a))) ('~nExpected: ' ((a))))
</span>;;; Test the use of sealed operation for scope management
;;; Test that sealed variables prevent name clashes
<span class="ansi38-013099040"
>!(assertEqualToResult (sealed ($53546) (sealed ($53570 $53576) (quote (= ($53570 $53546 $53624)  
  ($53576))))) ((quote (= ($53570 $53546 $53624)  
  ($53576)))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.34"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.34</h3>
; 
; EVAL TEST
; took 0.000316 secs. (316.49 microseconds) 

!(assertEqualToResult (sealed ($5042) (sealed ($5066 $5072) (quote (= ($5066 $5042 $5120)  
  ($5072))))) ((quote (= ($5066 $5042 $5120)  
  ($5072)))))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (quote (= ($12230 $12236 $12242)  
          ($12254)))) 
      ( (quote (= ($12290 $12296 $12302)  
          ($12314))))]]
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that sealed variables are uniquely replaced
<span class="ansi38-013099040"
>!(assertEqualToResult (sealed ($21334 $21340) (quote (= ($21340 $21382)))) ((quote (= ($21340 $21382)))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.35"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.35</h3>
; 
; EVAL TEST
; took 0.000193 secs. (192.64 microseconds) 

!(assertEqualToResult (sealed ($30290 $30296) (quote (= ($30296 $30338)))) ((quote (= ($30296 $30338)))))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (quote (= ($34628 $34634)))) 
      ( (quote (= ($34670 $34676))))]]
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test using sealed to create scoped variables in 'let' expressions
<span class="ansi38-013099040"
>!(assertEqualToResult (let (quote ($42936 $42942)) (sealed ($42966) (quote ($42966 (output $42966)))) (let $42936 (input $42966) $42942)) ((output (input $42966))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.36"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.36</h3>
; 
; EVAL TEST
; took 0.007 secs. (6.83 milliseconds) 

!(assertEqualToResult (let (quote ($30558 $30564)) (sealed ($30588) (quote ($30588 (output $30588)))) (let $30558 (input $30588) $30564)) ((output (input $30588))))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (output (input $33956))) 
      ( (output (input $33986)))]]
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that the interpreter can switch to bare-minimal mode
;;; Define functions 'foo' and 'bar'
<span class="ansi38-013099040"
>!(add-atom &self (= (bar)  baz))

</span><span class="ansi38-255165000"
> (= (bar)  baz)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (foo)  
  (bar)))

</span><span class="ansi38-255165000"
> (= (foo)  
  (bar))
 
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that '!(foo)' evaluates to 'baz' in default interpreter
<span class="ansi38-013099040"
>!(assertEqualToResult (foo) ((baz)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.37"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.37</h3>
; 
; EVAL TEST
; took 0.000623 secs. (622.67 microseconds) 

!(assertEqualToResult (foo) ((baz)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (bar baz) 
      ( (baz))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'(bar,'[|]'(baz,[])),'[|]'('[|]'(baz,[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (bar baz)) ('~nExpected: ' ((baz))))
</span>;;; Switch to bare-minimal interpreter
<span class="ansi38-013099040"
>!(pragma! interpreter bare-minimal)

</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that '!(foo)' does not evaluate in bare-minimal interpreter
<span class="ansi38-013099040"
>!(assertEqualToResult (foo) ((foo)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.38"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.38</h3>
; 
; EVAL TEST
; took 0.000578 secs. (577.51 microseconds) 

!(assertEqualToResult (foo) ((foo)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (bar baz) 
      ( (foo))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'(bar,'[|]'(baz,[])),'[|]'('[|]'(foo,[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (bar baz)) ('~nExpected: ' ((foo))))
</span>;;; Use 'eval' to force evaluation in bare-minimal interpreter
<span class="ansi38-013099040"
>!(assertEqualToResult (eval (foo)) ((baz)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.39"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.39</h3>
; 
; EVAL TEST
; took 0.000016 secs. (15.80 microseconds) 

!(assertEqualToResult (eval (foo)) ((baz)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (bar) 
      ( (baz))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'(bar,[]),'[|]'('[|]'(baz,[]),[]))

N(1): <span class="ansi33"
>(Error ('~nGot: ' (bar)) ('~nExpected: ' ((baz))))
</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.40"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.40</h3>
; 
; EVAL TEST
; took 0.000042 secs. (42.03 microseconds) 

!(assertEqualToResult (eval (foo)) ((baz)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (baz) 
      ( (baz))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'(baz,[]),'[|]'('[|]'(baz,[]),[]))

R(2): <span class="ansi33"
>(Error ('~nGot: ' (baz)) ('~nExpected: ' ((baz))))
</span>;;; Test handling of empty expressions in metta_interpret
;;; Test that interpreting an empty expression returns an empty tuple
<span class="ansi38-013099040"
>!(assertEqualToResult (metta () %Undefined% &self) (()))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.41"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.41</h3>
; 
; EVAL TEST
; took 0.000341 secs. (340.97 microseconds) 

!(assertEqualToResult (metta () %Undefined% &self) (()))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (()) 
      (())]]
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that interpreting an expression with unknown function returns the expression itself
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (unknown-func a) %Undefined% &self) ((unknown-func a)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.42"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.42</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.99 milliseconds) 

!(assertEqualToResult (metta (unknown-func a) %Undefined% &self) ((unknown-func a)))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (unknown-func a)) 
      ( (unknown-func a))]]
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that interpreting an expression with known function evaluates correctly
<span class="ansi38-013099040"
>!(add-atom &self (= (known-func $61626)  
  ($61626 $61626)))

</span><span class="ansi38-255165000"
> (= (known-func $x)  
  ($x $x))
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqualToResult (metta (known-func a) %Undefined% &self) ((a a)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.43"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.43</h3>
; 
; EVAL TEST
; took 0.006 secs. (5.72 milliseconds) 

!(assertEqualToResult (metta (known-func a) %Undefined% &self) ((a a)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (mynot (b a))) 
      ( (a a))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'('[|]'(mynot,'[|]'('[|]'(b,'[|]'(a,[])),[])),[]),'[|]'('[|]'(a,'[|]'(a,[])),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' ((mynot (b a)))) ('~nExpected: ' ((a a))))
</span>;;; Test that metta can interpret expressions with multiple possible outcomes
;;; Define multiple definitions for 'color'
<span class="ansi38-013099040"
>!(add-atom &self (= (color)  blue))

</span><span class="ansi38-255165000"
> (= (color)  blue)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (color)  red))

</span><span class="ansi38-255165000"
> (= (color)  red)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (color)  green))

</span><span class="ansi38-255165000"
> (= (color)  green)
 
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that interpreting 'color' returns all possible colors
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (color) %Undefined% &self) ((blue red green)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.44"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.44</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.24 milliseconds) 

!(assertEqualToResult (metta (color) %Undefined% &self) ((blue red green)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (blue red green) 
      ( (blue red green))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'(blue,'[|]'(red,'[|]'(green,[]))),'[|]'('[|]'(blue,'[|]'(red,'[|]'(green,[]))),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (blue red green)) ('~nExpected: ' ((blue red green))))
</span>;;; Test that variables are correctly assigned in higher-order functions
;;; Define functions 'b' and 'c'
<span class="ansi38-013099040"
>!(add-atom &self (= (b ($1696 $1702))  
  (c $1696 $1702)))

</span><span class="ansi38-255165000"
> (= (b ($x $y))  
  (c $x $y))
 
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that variables in 'b' are correctly handled
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (a (b $19490) $19496 $19502) %Undefined% &self) ((a (c $19490 $19502) $19496 $19502)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.45"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.45</h3>
; 
; EVAL TEST
; took 0.009 secs. (8.72 milliseconds) 

!(assertEqualToResult (metta (a (b $17954) $17960 $17966) %Undefined% &self) ((a (c $17954 $17966) $17960 $17966)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (a 
          (c $19456 $19462) $19468 $19474) (a F $19498 $19504)) 
      ( (a 
          (c $19534 $19540) $19546 $19540))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'('[|]'(a,'[|]'('[|]'(c,'[|]'(_16558,'[|]'(_16564,[]))),'[|]'(_16576{vn = ...},'[|]'(_16596{vn = ...},[])))),'[|]'('[|]'(a,'[|]'('F','[|]'(_16500{vn = ...},'[|]'(_16520{vn = ...},[])))),[])),'[|]'('[|]'(a,'[|]'('[|]'(c,'[|]'(_1080{vn = ...},'[|]'(_1052{vn = ...},[]))),'[|]'(_1066{vn = ...},'[|]'(_1052{vn = ...},[])))),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' ((a (c $26392 $26398) $26404 $26410) (a F $26434 $26440))) ('~nExpected: ' ((a (c $26488 $26494) $26500 $26494))))
</span>;;; Test that error is returned when incorrect number of arguments are provided
;;; Define function 'foo' with two arguments
<span class="ansi38-013099040"
>!(add-atom &self (: foo (-> A B C)))

</span><span class="ansi38-255165000"
> (: foo (-> A B C))
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: a A))

</span><span class="ansi38-255165000"
> (: a A)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: b B))

</span><span class="ansi38-255165000"
> (: b B)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: c C))

</span><span class="ansi38-255165000"
> (: c C)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (foo $20938 $20944)  c))

</span><span class="ansi38-255165000"
> (= (foo $a $b)  c)
 
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that calling 'foo' with correct arguments returns 'c'
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (foo a b) %Undefined% &self) ((c)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.46"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.46</h3>
; 
; EVAL TEST
; took 0.000531 secs. (530.91 microseconds) 

!(assertEqualToResult (metta (foo a b) %Undefined% &self) ((c)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (c) 
      ( (c))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'(c,[]),'[|]'('[|]'(c,[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (c)) ('~nExpected: ' ((c))))
</span>;;; Test that calling 'foo' with insufficient arguments returns an error
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (foo a) %Undefined% &self) ((Error (foo a) "IncorrectNumberOfArguments")))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.47"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.47</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.28 milliseconds) 

!(assertEqualToResult (metta (foo a) %Undefined% &self) ((Error (foo a) "IncorrectNumberOfArguments")))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (foo a)) 
      ( (Error 
          (foo a) "IncorrectNumberOfArguments"))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'('[|]'(foo,'[|]'(a,[])),[]),'[|]'('[|]'('Error','[|]'('[|]'(foo,'[|]'(a,[])),'[|]'("IncorrectNumberOfArguments",[]))),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' ((foo a))) ('~nExpected: ' ((Error (foo a) "IncorrectNumberOfArguments"))))
</span>;;; Test that metta can handle function calls with variables as types
;;; Define a function 'id_num' that returns its argument if it's a number
<span class="ansi38-013099040"
>!(add-atom &self (= (id_num $20314)  $20314))

</span><span class="ansi38-255165000"
> (= (id_num $x)  $x)
 
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that 'id_num' returns 'myAtom' even if it's not a number (since types are not enforced)
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (id_num myAtom) %Undefined% &self) ((myAtom)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.48"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.48</h3>
; 
; EVAL TEST
; took 0.000640 secs. (639.86 microseconds) 

!(assertEqualToResult (metta (id_num myAtom) %Undefined% &self) ((myAtom)))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (myAtom) 
      ( (myAtom))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'(myAtom,[]),'[|]'('[|]'(myAtom,[]),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (myAtom)) ('~nExpected: ' ((myAtom))))
</span>;;; Test that metta returns a 'BadType' error when type checking fails
;;; Define 'myAtom' with type 'myType' and function 'id_a' of type (-> A A)
<span class="ansi38-013099040"
>!(add-atom &self (: myAtom myType))

</span><span class="ansi38-255165000"
> (: myAtom myType)
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (: id_a (-> A A)))

</span><span class="ansi38-255165000"
> (: id_a (-> A A))
 
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &self (= (id_a $16156)  $16156))

</span><span class="ansi38-255165000"
> (= (id_a $a)  $a)
 
</span>
Deterministic: <span class="ansi33"
>()
</span>;;; Test that calling 'id_a' with 'myAtom' returns a 'BadType' error
<span class="ansi38-013099040"
>!(assertEqualToResult (metta (id_a myAtom) %Undefined% &self) ((Error myAtom "BadType")))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.49"
>;; HYPERON-METTALOG-SANITY.INDEX-MIN-FUNCTIONS-EXTRA-3.49</h3>
; 
; EVAL TEST
; took 0.000543 secs. (542.95 microseconds) 

!(assertEqualToResult (metta (id_a myAtom) %Undefined% &self) ((Error myAtom "BadType")))

<span class="ansi31"
>  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (myAtom) 
      ( (Error myAtom "BadType"))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'(myAtom,[]),'[|]'('[|]'('Error','[|]'(myAtom,'[|]'("BadType",[]))),[]))

Deterministic: <span class="ansi33"
>(Error ('~nGot: ' (myAtom)) ('~nExpected: ' ((Error myAtom "BadType"))))
</span>P;HTML|
;               [ = /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta 0 ]
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 11
</span><span class="ansi31"
>Failures: 38
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
[()]
[()]
[(Error ('~nGot: ' (&stdlib)) ('~nExpected: ' ((mod-space! stdlib))))]
[()]
[()]
[()]
[()]
[()]
[(Error ('~nGot: ' ()) ('~nExpected: ' ((a a))))]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[(Error ('~nGot: ' (AnyRet AnyRet)) ('~nExpected: ' (((A B) (AA B) (A BB) (AA BB) %Undefined%))))]
[(Error ('~nGot: ' (3)) ('~nExpected: ' ((3))))]
[(Error ('~nGot: ' ()) ('~nExpected: ' ((Error (index-atom (A B C D E) 5) "Index is out of bounds"))))]
[()]
[()]
[(Error ('~nGot: ' (())) ('~nExpected: ' ((False))))]
[()]
[()]
[()]
[()]
[(Error ('~nGot: ' (a)) ('~nExpected: ' ((a))))]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[(Error ('~nGot: ' (bar baz)) ('~nExpected: ' ((baz))))]
[()]
[(Error ('~nGot: ' (bar baz)) ('~nExpected: ' ((foo))))]
[(Error ('~nGot: ' (bar)) ('~nExpected: ' ((baz)))), (Error ('~nGot: ' (baz)) ('~nExpected: ' ((baz))))]
[(Error ('~nGot: ' ((-> Atom Atom ErrorType))) ('~nExpected: ' (((-> Atom Atom ErrorType)))))]
[(Error ('~nGot: ' (Grounded)) ('~nExpected: ' ((Symbol))))]
[(Error ('~nGot: ' (() ())) ('~nExpected: ' ((ErrorType))))]
[()]
[(Error ('~nGot: ' ("test")) ('~nExpected: ' (("test"))))]
[(Error ('~nGot: ' ("te st")) ('~nExpected: ' (("te st"))))]
[(Error ('~nGot: ' ("te\"st")) ('~nExpected: ' (("te\"st"))))]
[(Error ('~nGot: ' ("")) ('~nExpected: ' ((""))))]
[(Error ('~nGot: ' ("te\nst")) ('~nExpected: ' (("te\nst"))))]
[()]
[()]
[()]
[()]
[()]
[(Error ('~nGot: ' (() ())) ('~nExpected: ' ((D))))]
[(Error ('~nGot: ' (D D)) ('~nExpected: ' ((D))))]
[(Error ('~nGot: ' (() ())) ('~nExpected: ' ((D))))]
[()]
[()]
[()]
[(Error ('~nGot: ' (True)) ('~nExpected: ' ((True))))]
[(Error ('~nGot: ' ((eq (S $30318) $30318))) ('~nExpected: ' (())))]
[()]
[()]
[()]
[()]
[(Error ('~nGot: ' ((myif (mynot (c $9398 $9404)) ($9398 $9404)))) ('~nExpected: ' ((d))))]
[()]
[(Error ('~nGot: ' ((mynot (c $22900 $22906)) T True)) ('~nExpected: ' ((True))))]
[()]
[()]
[()]
[()]
[(Error ('~nGot: ' (a (baz a))) ('~nExpected: ' ((a))))]
[()]
[()]
[()]
[()]
[()]
[(Error ('~nGot: ' (bar baz)) ('~nExpected: ' ((baz))))]
[()]
[(Error ('~nGot: ' (bar baz)) ('~nExpected: ' ((foo))))]
[(Error ('~nGot: ' (bar)) ('~nExpected: ' ((baz)))), (Error ('~nGot: ' (baz)) ('~nExpected: ' ((baz))))]
[()]
[()]
[()]
[(Error ('~nGot: ' ((mynot (b a)))) ('~nExpected: ' ((a a))))]
[()]
[()]
[()]
[(Error ('~nGot: ' (blue red green)) ('~nExpected: ' ((blue red green))))]
[()]
[(Error ('~nGot: ' ((a (c $27258 $27264) $27270 $27276) (a F $27300 $27306))) ('~nExpected: ' ((a (c $27354 $27360) $27366 $27360))))]
[()]
[()]
[()]
[()]
[()]
[(Error ('~nGot: ' (c)) ('~nExpected: ' ((c))))]
[(Error ('~nGot: ' ((foo a))) ('~nExpected: ' ((Error (foo a) "IncorrectNumberOfArguments"))))]
[()]
[(Error ('~nGot: ' (myAtom)) ('~nExpected: ' ((myAtom))))]
[()]
[()]
[()]
[(Error ('~nGot: ' (myAtom)) ('~nExpected: ' ((Error myAtom "BadType"))))]

Script done on 2025-02-22 20:48:58+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: /home/runner/work/metta-testsuite/metta-testsuite/mettalog '--output=/home/runner/work/metta-testsuite/metta-testsuite/reports/tests_output/baseline-compat' --timeout=40 --html --repl=false  --test "tests/baseline_compat/hyperon-mettalog_sanity/index_min_functions_extra_3.metta" --halt=true\033[0m
