<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi36 { color: #00aaaa; }
.ansi90 { color: #7f7f7f; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-11-28 15:08:10+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;         {set_option_value compat false}

P;HTML|
;         {set_option_value compatio false}

P;HTML|
;         {set_option_value src_indents false}

P;HTML|
;         {set_option_value devel false}

P;HTML|
;         {set_option_value stack-max 500}

P;HTML|
;         {set_option_value limit inf}

P;HTML|
;         {set_option_value initial-result-count 10}

P;HTML|
;         {set_option_value answer-format show}

P;HTML|
;         {set_option_value repeats true}

P;HTML|
;         {set_option_value time true}

P;HTML|
;         {set_option_value synth-unit-tests false}

P;HTML|
;         {set_option_value optimize true}

P;HTML|
;         {set_option_value transpiler silent}

P;HTML|
;          {set_debug transpiler false}

P;HTML|
;         {set_option_value compile false}

P;HTML|
;         {set_option_value tabling auto}

P;HTML|
;         {set_option_value log false}

P;HTML|
;         {set_option_value output ./}

P;HTML|
;         {set_option_value exeout ./Sav.gitlab.MeTTaLog}

P;HTML|
;         {set_option_value halt false}

P;HTML|
;         {set_option_value trace-length 500}

P;HTML|
;         {set_option_value trace-on-overtime 4.0}

P;HTML|
;          {set_debug overtime 4.0}

P;HTML|
;         {set_option_value trace-on-overflow 1000}

P;HTML|
;          {set_debug overflow 1000}

P;HTML|
;         {set_option_value trace-on-eval false}

P;HTML|
;          {set_debug eval false}

P;HTML|
;         {set_option_value trace-on-load silent}

P;HTML|
;          {set_debug load silent}

P;HTML|
;          {set_debug trace-on-load false}

P;HTML|
;         {set_option_value trace-on-exec false}

P;HTML|
;          {set_debug exec false}

P;HTML|
;         {set_option_value trace-on-error non-type}

P;HTML|
;          {set_debug error non-type}

P;HTML|
;         {set_option_value trace-on-fail false}

P;HTML|
;          {set_debug fail false}

P;HTML|
;         {set_option_value trace-on-test true}

P;HTML|
;          {set_debug test true}

P;HTML|
;         {set_option_value repl-on-error true}

P;HTML|
;         {set_option_value repl-on-fail false}

P;HTML|
;         {set_option_value exit-on-fail false}

P;HTML|
;         {set_option_value repl auto}

P;HTML|
;         {set_option_value prolog false}

P;HTML|
;         {set_option_value exec noskip}

P;HTML|
;         {set_option_value maximum-result-count inf}

P;HTML|
;         {set_option_value html false}

P;HTML|
;         {set_option_value python true}

P;HTML|
;         {set_option_value trace-on-test false}

P;HTML|
;         {set_debug test false}

P;HTML|
;         {set_option_value trace-on-fail false}

P;HTML|
;         {set_debug fail false}

P;HTML|
;         {set_option_value load show}

P;HTML|
;         {set_option_value test false}
<span class="ansi32"
>
% 46,854 inferences, 0.180 CPU in 0.180 seconds (100% CPU, 260898 Lips)
</span>P;HTML|
;          {is_cmd_option prescan halt --halt=true true}
P;HTML|
;          {set_option_value halt true}
P;HTML|
;          {is_cmd_option prescan stdin --stdin=tty tty}
P;HTML|
;           {set_option_value stdin tty}
P;HTML|
;          {is_cmd_option prescan stdout --stdout=tty tty}
P;HTML|
;           {set_option_value stdout tty}
P;HTML|
;          {is_cmd_option prescan stderr --stderr=tty tty}
P;HTML|
;           {set_option_value stderr tty}
P;HTML|
;          {set_option_value compat false}
P;HTML|
;          {set_option_value compatio false}
P;HTML|
;          {set_option_value src_indents false}
P;HTML|
;          {set_option_value devel false}
P;HTML|
;          {set_option_value stack-max 500}
P;HTML|
;          {set_option_value limit inf}
P;HTML|
;          {set_option_value initial-result-count 10}
P;HTML|
;          {set_option_value answer-format show}
P;HTML|
;          {set_option_value repeats true}
P;HTML|
;          {set_option_value time true}
P;HTML|
;          {set_option_value synth-unit-tests false}
P;HTML|
;          {set_option_value optimize true}
P;HTML|
;          {set_option_value transpiler silent}
P;HTML|
;          {set_debug transpiler false}
P;HTML|
;          {set_option_value compile false}
P;HTML|
;          {set_option_value tabling auto}
P;HTML|
;          {set_option_value log false}
P;HTML|
;          {set_option_value output ./}
P;HTML|
;          {set_option_value exeout ./Sav.gitlab.MeTTaLog}
P;HTML|
;          {set_option_value halt false}
P;HTML|
;          {set_option_value trace-length 500}
P;HTML|
;          {set_option_value trace-on-overtime 4.0}
P;HTML|
;          {set_debug overtime 4.0}
P;HTML|
;          {set_option_value trace-on-overflow 1000}
P;HTML|
;          {set_debug overflow 1000}
P;HTML|
;          {set_option_value trace-on-eval false}
P;HTML|
;          {set_debug eval false}
P;HTML|
;          {set_option_value trace-on-load silent}
P;HTML|
;          {set_debug load silent}
P;HTML|
;          {set_debug trace-on-load false}
P;HTML|
;          {set_option_value trace-on-exec false}
P;HTML|
;          {set_debug exec false}
P;HTML|
;          {set_option_value trace-on-error non-type}
P;HTML|
;          {set_debug error non-type}
P;HTML|
;          {set_option_value trace-on-fail false}
P;HTML|
;          {set_debug fail false}
P;HTML|
;          {set_option_value trace-on-test true}
P;HTML|
;          {set_debug test true}
P;HTML|
;          {set_option_value repl-on-error true}
P;HTML|
;          {set_option_value repl-on-fail false}
P;HTML|
;          {set_option_value exit-on-fail false}
P;HTML|
;          {set_option_value repl auto}
P;HTML|
;          {set_option_value prolog false}
P;HTML|
;          {set_option_value exec noskip}
P;HTML|
;          {set_option_value maximum-result-count inf}
P;HTML|
;          {set_option_value html false}
P;HTML|
;          {set_option_value python true}
P;HTML|
;         {set_option_value trace-on-test false}
P;HTML|
;          {set_debug test false}
P;HTML|
;         {set_option_value trace-on-fail false}
P;HTML|
;          {set_debug fail false}
P;HTML|
;         {set_option_value load show}
P;HTML|
;         {set_option_value test true}
P;HTML|
;        {is_cmd_option execute python --python=enable enable}
P;HTML|
;         {set_option_value python enable}
P;HTML|
;        {is_cmd_option execute timeout --timeout=40 40}
P;HTML|
;         {set_option_value timeout 40}
P;HTML|
;         {is_cmd_option execute output --output=./reports/tests_output/baseline-compat/ ./reports/tests_output/baseline-compat/}
P;HTML|
;         {set_option_value output ./reports/tests_output/baseline-compat/}
P;HTML|
;         {is_cmd_option execute html --html true}
P;HTML|
;          {set_option_value html true}
P;HTML|
;         {is_cmd_option execute test --test true}
P;HTML|
;          {set_option_value test true}

; 
{load_metta_file &self tests/baseline_compat/hyperon-mettalog_sanity/minimal_metta_tests.metta}

P;HTML|
;                       {track_load_into_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/minimal_metta_tests.metta}
P;HTML|
;                                        {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/minimal_metta_tests.metta.answers
;                                           /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/minimal_metta_tests.metta}
P;HTML|
;                                         { = 1 "[()]" }
P;HTML|
;                                         { = 2 "[()]" }
P;HTML|
;                                         { = 3 "[()]" }
P;HTML|
;                                         { = 4 "[()]" }
P;HTML|
;                                         { = 5 "[()]" }
P;HTML|
;                                         { = 6 "[()]" }
P;HTML|
;                                         { = 7 "[()]" }
P;HTML|
;                                         { = 8 "[()]" }
P;HTML|
;                                         { = 9 "[()]" }
P;HTML|
;                                         { = 10 "[()]" }
P;HTML|
;                                         { = 11 "[()]" }
P;HTML|
;                                         { = 12 "[()]" }
P;HTML|
;                                         { = 13 "[()]" }
P;HTML|
;                                         { = 14 "[()]" }
P;HTML|
;                                         { = 15 "[()]" }
P;HTML|
;                                         { = 16 "[()]" }
P;HTML|
;                                         { = 17 "[()]" }
P;HTML|
;                                         { = 18 "[()]" }
P;HTML|
;                                         { = 19 "[(H-E-Fails (Error (assertEqualToResult (chain (collapse-bind (foo $x)) $a (quote $a)) ((quote (((foo $x) { }))))) " }
P;HTML|
;                                         { = 19 "Expected: [(quote (((foo $x) { })))]" }
P;HTML|
;                                         { = 19 "Got: [(quote (((foo $x) {  })))]" }
P;HTML|
;                                         { = 20 "Missed result: (quote (((foo $x) { })))))]" }
P;HTML|
;                                         { = 20 "[(H-E-Fails (Error (assertEqualToResult (chain (collapse-bind (eval (foo $x))) $a (quote $a)) ((quote (((bar $x) { }))))) " }
P;HTML|
;                                         { = 20 "Expected: [(quote (((bar $x) { })))]" }
P;HTML|
;                                         { = 20 "Got: [(quote (((bar $x) { $x })))]" }
P;HTML|
;                                         { = 21 "Missed result: (quote (((bar $x) { })))))]" }
P;HTML|
;                                         { = 21 "[(H-E-Fails (Error (assertEqualToResult (chain (collapse-bind (metta (foo $x) %Undefined% GroundingSpace-top)) $a (quote $a)) ((quote (((input B) { $x <- B }) ((input A) { $x <- A }))))) " }
P;HTML|
;                                         { = 21 "Expected: [(quote (((input B) { $x <- B }) ((input A) { $x <- A })))]" }
P;HTML|
;                                         { = 21 "Got: [(quote (((input A) { $x <- A }) ((input B) { $x <- B })))]" }
P;HTML|
;                                         { = 22 "Missed result: (quote (((input B) { $x <- B }) ((input A) { $x <- A })))))]" }
P;HTML|
;                                         { = 22 "[()]" }
P;HTML|
;                                         { = 23 "[()]" }
P;HTML|
;                                         { = 24 "[()]" }
P;HTML|
;                                         { = 25 "[()]" }
P;HTML|
;                                         { = 26 "[()]" }
P;HTML|
;                                         { = 27 "[(H-E-Fails (Error (assertEqualToResult (collapse-bind (metta (foobar) $type GroundingSpace-top)) ((1 { $type <- Number }) (\"a\" { $type <- String }))) " }
P;HTML|
;                                         { = 27 "Expected: [(1 { $type <- Number }), (\"a\" { $type <- String })]" }
P;HTML|
;                                         { = 27 "Got: [((1 { $type <- Number }) (\"a\" { $type <- String }))]" }
P;HTML|
;                                         { = 28 "Missed result: (1 { $type <- Number })))]" }
P;HTML|
;                                         { = 28 "[()]" }
P;HTML|
;                                         { = 29 "[()]" }
P;HTML|
;                                         { = 30 "[(H-E-Fails (Error (assertEqualToResult (collapse-bind (metta (chain-to-foobar) $type GroundingSpace-top)) ((1 { $type <- Number }) (\"a\" { $type <- String }))) " }
P;HTML|
;                                         { = 30 "Expected: [(1 { $type <- Number }), (\"a\" { $type <- String })]" }
P;HTML|
;                                         { = 30 "Got: [((\"a\" { $type <- String }) (1 { $type <- Number }))]" }
P;HTML|
;                                         { = 31 "Missed result: (1 { $type <- Number })))]" }
P;HTML|
;                                         { = 31 "[()]" }
P;HTML|
;                                         { = 32 "[()]" }
P;HTML|
;                                         { = 33 "[()]" }
P;HTML|
;                                         { = 34 "[()]" }
P;HTML|
;                                         { = 35 "[()]" }
P;HTML|
;                                         { = 36 "[()]" }
P;HTML|
;                                         { = 37 "[()]" }
P;HTML|
;                                         { = 38 "[()]" }
P;HTML|
;                                         { = 39 "0.07user 0.00system 0:00.07elapsed 98%CPU (0avgtext+0avgdata 26412maxresident)k" }
P;HTML|
;                                         { = 39 "0inputs+0outputs (0major+3166minor)pagefaults 0swaps" }
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/minimal_metta_tests.metta is 4.85K bytes (113 lines)
</span>P;HTML|
;                                        {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/minimal_metta_tests.metta.answers
;                                           /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/minimal_metta_tests.metta}

;;;; remove Empty result
<span class="ansi38-255165000"
> (= 
  (returns-empty) )

</span><span class="ansi38-255165000"
> (= 
  (returns-empty) 1)

</span><span class="ansi38-255165000"
> (= 
  (chain-to-empty) 
  (returns-empty))

</span><span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (returns-empty) 
    (1))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.01"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.01</h3>
; 
; EVAL TEST
; took 0.000505 secs. (505.29 microseconds) 

{exec 
  (assertEqualToResult 
    (returns-empty) 
    (1))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (1) 
    (1)}}

</span>
Deterministic: ()
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (eval 
      (returns-empty)) 
    (1))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.02"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.02</h3>
; 
; EVAL TEST
; took 0.000024 secs. (23.87 microseconds) 

{exec 
  (assertEqualToResult 
    (eval 
      (returns-empty)) 
    (1))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    () 
    (1)}}

</span>
NDet Result(1): Empty

;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.03"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.03</h3>
; 
; EVAL TEST
; took 0.000021 secs. (20.72 microseconds) 

{exec 
  (assertEqualToResult 
    (eval 
      (returns-empty)) 
    (1))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (1) 
    (1)}}

</span>
Last Result(2): ()
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (chain-to-empty) 
    (1))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.04"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.04</h3>
; 
; EVAL TEST
; took 0.000641 secs. (640.75 microseconds) 

{exec 
  (assertEqualToResult 
    (chain-to-empty) 
    (1))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (1) 
    (1)}}

</span>
Deterministic: ()
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (eval 
      (chain-to-empty)) 
    (1))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.05"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.05</h3>
; 
; EVAL TEST
; took 0.000014 secs. (14.48 microseconds) 

{exec 
  (assertEqualToResult 
    (eval 
      (chain-to-empty)) 
    (1))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    () 
    (1)}}

</span>
NDet Result(1): Empty

;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.06"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.06</h3>
; 
; EVAL TEST
; took 0.000021 secs. (21.16 microseconds) 

{exec 
  (assertEqualToResult 
    (eval 
      (chain-to-empty)) 
    (1))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (1) 
    (1)}}

</span>
Last Result(2): ()
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (chain 
      (eval 
    (returns-empty)) $x 
      (quote $x)) 
    ((quote 1)
 
      (quote )))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.07"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.07</h3>
; 
; EVAL TEST
; took 0.000722 secs. (721.84 microseconds) 

{exec 
  (assertEqualToResult 
    (chain 
      (eval 
    (returns-empty)) $x 
      (quote $x)) 
    ((quote 1)
 
      (quote )))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    ((quote 1)
) 
    ((quote 1)
 
      (quote ))}}

</span>
Deterministic: Empty
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (chain 
      (eval 
    (chain-to-empty)) $x 
      (quote $x)) 
    ((quote 
  (returns-empty))
))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.08"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.08</h3>
; 
; EVAL TEST
; took 0.000915 secs. (914.64 microseconds) 

{exec 
  (assertEqualToResult 
    (chain 
      (eval 
    (chain-to-empty)) $x 
      (quote $x)) 
    ((quote 
  (returns-empty))
))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    ((quote 1)
) 
    ((quote 
  (returns-empty))
)}}

</span>
Deterministic: ({Error 
  {got 
    ((quote 1)
)} 
  {expected 
    ((quote 
  (returns-empty))
)}}
)
;;;; include empty expression ()
<span class="ansi38-255165000"
> (= 
  (returns-empty-expression) ())

</span><span class="ansi38-255165000"
> (= 
  (returns-empty-expression) 1)

</span><span class="ansi38-255165000"
> (= 
  (chain-to-empty-expression) 
  (returns-empty-expression))

</span><span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (returns-empty-expression) 
    (1 ()))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.09"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.09</h3>
; 
; EVAL TEST
; took 0.000424 secs. (424.17 microseconds) 

{exec 
  (assertEqualToResult 
    (returns-empty-expression) 
    (1 ()))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (() 1) 
    (1 ())}}

</span>
Deterministic: ()
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (eval 
      (returns-empty-expression)) 
    (1 ()))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.10"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.10</h3>
; 
; EVAL TEST
; took 0.000013 secs. (13.28 microseconds) 

{exec 
  (assertEqualToResult 
    (eval 
      (returns-empty-expression)) 
    (1 ()))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    (()) 
    (1 ())}}

</span>
NDet Result(1): ({Error 
  {got 
    (())} 
  {expected 
    (1 ())}}
)

;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.11"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.11</h3>
; 
; EVAL TEST
; took 0.000020 secs. (20.33 microseconds) 

{exec 
  (assertEqualToResult 
    (eval 
      (returns-empty-expression)) 
    (1 ()))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (1) 
    (1 ())}}

</span>
Last Result(2): ()
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (chain-to-empty-expression) 
    (1 ()))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.12"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.12</h3>
; 
; EVAL TEST
; took 0.000623 secs. (623.27 microseconds) 

{exec 
  (assertEqualToResult 
    (chain-to-empty-expression) 
    (1 ()))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (() 1) 
    (1 ())}}

</span>
Deterministic: ()
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (eval 
      (chain-to-empty-expression)) 
    (1 ()))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.13"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.13</h3>
; 
; EVAL TEST
; took 0.000020 secs. (19.72 microseconds) 

{exec 
  (assertEqualToResult 
    (eval 
      (chain-to-empty-expression)) 
    (1 ()))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    (()) 
    (1 ())}}

</span>
NDet Result(1): ({Error 
  {got 
    (())} 
  {expected 
    (1 ())}}
)

;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.14"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.14</h3>
; 
; EVAL TEST
; took 0.000021 secs. (21.36 microseconds) 

{exec 
  (assertEqualToResult 
    (eval 
      (chain-to-empty-expression)) 
    (1 ()))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (1) 
    (1 ())}}

</span>
Last Result(2): ()
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (chain 
      (eval 
    (returns-empty-expression)) $x 
      (quote $x)) 
    ((quote 1)
 
      (quote ())))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.15"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.15</h3>
; 
; EVAL TEST
; took 0.000715 secs. (714.63 microseconds) 

{exec 
  (assertEqualToResult 
    (chain 
      (eval 
    (returns-empty-expression)) $x 
      (quote $x)) 
    ((quote 1)
 
      (quote ())))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    ((quote ())
 
      (quote 1)) 
    ((quote 1)
 
      (quote ()))}}

</span>
Deterministic: ()
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (chain 
      (eval 
    (chain-to-empty-expression)) $x 
      (quote $x)) 
    ((quote 
  (returns-empty-expression))
))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.16"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.16</h3>
; 
; EVAL TEST
; took 0.000950 secs. (949.73 microseconds) 

{exec 
  (assertEqualToResult 
    (chain 
      (eval 
    (chain-to-empty-expression)) $x 
      (quote $x)) 
    ((quote 
  (returns-empty-expression))
))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    ((quote ())
 
      (quote 1)) 
    ((quote 
  (returns-empty-expression))
)}}

</span>
Deterministic: ({Error 
  {got 
    ((quote ())
 
      (quote 1))} 
  {expected 
    ((quote 
  (returns-empty-expression))
)}}
)
;;;; return original form for NotReducible
<span class="ansi38-255165000"
> (= 
  (returns-not-reducible) NotReducible)

</span><span class="ansi38-255165000"
> (= 
  (returns-not-reducible) 1)

</span><span class="ansi38-255165000"
> (= 
  (chain-to-not-reducible) 
  (returns-not-reducible))

</span><span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (returns-not-reducible) 
    (1 
      (returns-not-reducible)))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.17"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.17</h3>
; 
; EVAL TEST
; took 0.000409 secs. (408.62 microseconds) 

{exec 
  (assertEqualToResult 
    (returns-not-reducible) 
    (1 
      (returns-not-reducible)))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    (NotReducible 1) 
    (1 
      (returns-not-reducible))}}

</span>
Deterministic: ({Error 
  {got 
    (NotReducible 1)} 
  {expected 
    (1 
      (returns-not-reducible))}}
)
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (chain-to-not-reducible) 
    (1 
      (returns-not-reducible)))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.18"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.18</h3>
; 
; EVAL TEST
; took 0.000637 secs. (637.32 microseconds) 

{exec 
  (assertEqualToResult 
    (chain-to-not-reducible) 
    (1 
      (returns-not-reducible)))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    (NotReducible 1) 
    (1 
      (returns-not-reducible))}}

</span>
Deterministic: ({Error 
  {got 
    (NotReducible 1)} 
  {expected 
    (1 
      (returns-not-reducible))}}
)
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (eval 
      (returns-not-reducible)) 
    (1 
      (eval 
    (returns-not-reducible))))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.19"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.19</h3>
; 
; EVAL TEST
; took 0.000024 secs. (23.84 microseconds) 

{exec 
  (assertEqualToResult 
    (eval 
      (returns-not-reducible)) 
    (1 
      (eval 
    (returns-not-reducible))))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    (NotReducible) 
    (1 
      (eval 
    (returns-not-reducible)))}}

</span>
NDet Result(1): ({Error 
  {got 
    (NotReducible)} 
  {expected 
    (1 
      (eval 
    (returns-not-reducible)))}}
)

;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.20"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.20</h3>
; 
; EVAL TEST
; took 0.000021 secs. (20.64 microseconds) 

{exec 
  (assertEqualToResult 
    (eval 
      (returns-not-reducible)) 
    (1 
      (eval 
    (returns-not-reducible))))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    (1) 
    (1 
      (eval 
    (returns-not-reducible)))}}

</span>
Last Result(2): ({Error 
  {got 
    (1)} 
  {expected 
    (1 
      (eval 
    (returns-not-reducible)))}}
)
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (eval 
      (chain-to-not-reducible)) 
    (1 
      (returns-not-reducible)))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.21"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.21</h3>
; 
; EVAL TEST
; took 0.000023 secs. (23.40 microseconds) 

{exec 
  (assertEqualToResult 
    (eval 
      (chain-to-not-reducible)) 
    (1 
      (returns-not-reducible)))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    (NotReducible) 
    (1 
      (returns-not-reducible))}}

</span>
NDet Result(1): ({Error 
  {got 
    (NotReducible)} 
  {expected 
    (1 
      (returns-not-reducible))}}
)

;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.22"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.22</h3>
; 
; EVAL TEST
; took 0.000022 secs. (21.69 microseconds) 

{exec 
  (assertEqualToResult 
    (eval 
      (chain-to-not-reducible)) 
    (1 
      (returns-not-reducible)))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    (1) 
    (1 
      (returns-not-reducible))}}

</span>
Last Result(2): ({Error 
  {got 
    (1)} 
  {expected 
    (1 
      (returns-not-reducible))}}
)
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (chain 
      (eval 
    (returns-not-reducible)) $x 
      (quote $x)) 
    ((quote 1)
 
      (quote NotReducible)))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.23"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.23</h3>
; 
; EVAL TEST
; took 0.000672 secs. (672.27 microseconds) 

{exec 
  (assertEqualToResult 
    (chain 
      (eval 
    (returns-not-reducible)) $x 
      (quote $x)) 
    ((quote 1)
 
      (quote NotReducible)))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    ((quote NotReducible)
 
      (quote 1)) 
    ((quote 1)
 
      (quote NotReducible))}}

</span>
Deterministic: ()
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (chain 
      (eval 
    (chain-to-not-reducible)) $x 
      (quote $x)) 
    ((quote 
  (returns-not-reducible))
))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.24"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.24</h3>
; 
; EVAL TEST
; took 0.000925 secs. (924.62 microseconds) 

{exec 
  (assertEqualToResult 
    (chain 
      (eval 
    (chain-to-not-reducible)) $x 
      (quote $x)) 
    ((quote 
  (returns-not-reducible))
))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    ((quote NotReducible)
 
      (quote 1)) 
    ((quote 
  (returns-not-reducible))
)}}

</span>
Deterministic: ({Error 
  {got 
    ((quote NotReducible)
 
      (quote 1))} 
  {expected 
    ((quote 
  (returns-not-reducible))
)}}
)
;;;; collapse-bind operates on Minimal MeTTa
<span class="ansi38-255165000"
> (= 
  (bar A) 
  (input A))

</span><span class="ansi38-255165000"
> (= 
  (bar B) 
  (input B))

</span><span class="ansi38-255165000"
> (= 
  (foo $x) 
  (bar $x))

</span><span class="ansi38-013099040"
>{exec 
  (H-E-Fails 
    (assertEqualToResult 
      (chain 
    (collapse-bind 
     (foo $x)) $a 
    (quote $a)) 
      ((quote 
  (((foo $x)
 
  ({...} ()))
))
)))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.25"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.25</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.44 milliseconds) 

{exec 
  (H-E-Fails 
    (assertEqualToResult 
      (chain 
    (collapse-bind 
     (foo $x)) $a 
    (quote $a)) 
      ((quote 
  (((foo $x)
 
  ({...} ()))
))
)))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    ((quote 
  (input A))
 
      (quote 
    (input B))) 
    ((quote 
  (((foo $10000)
 
  ({...} ()))
))
)}}

</span>
{failed 
 once 

  {write_pass_fail 
    (H-E-Fails 
      (assertEqualToResult 
    (chain 
     (collapse-bind 
      (foo $x)) $a 
     (quote $a)) 
    ((quote 
  (((foo $x)
 
  ({...} ()))
))
))) FAIL 
    {equal_enough_for_test 
      ((quote 
  (input A))
 
    (quote 
     (input B))) 
      ((quote 
  (((foo $10000)
 
  ({...} ()))
))
)}}}


{on_mettalog_error 
  {failed 
  once 

    {write_pass_fail 
      (H-E-Fails 
    (assertEqualToResult 
     (chain 
      (collapse-bind 
       (foo $x)) $a 
      (quote $a)) 
     ((quote 
  (((foo $x)
 
  ({...} ()))
))
))) FAIL 
      {equal_enough_for_test 
    ((quote 
  (input A))
 
     (quote 
      (input B))) 
    ((quote 
  (((foo $10000)
 
  ({...} ()))
))
)}}}}

^  <span class="ansi1 ansi32"
>Call: </span>(259) [user] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [foo, '$VAR'("x")]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[foo, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[foo, _838490], ['{...}', []]]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(260) [user] once(user:write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [foo, '$VAR'("x")]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[foo, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[foo, _838490], ['{...}', []]]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(261) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [foo, '$VAR'("x")]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[foo, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[foo, _838490], ['{...}', []]]]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(261) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [foo, '$VAR'("x")]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[foo, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[foo, _838490], ['{...}', []]]]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(259) [system] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [foo, '$VAR'("x")]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[foo, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[foo, _838490], ['{...}', []]]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(259) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(261) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(261) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(263) [system] setup_call_cleanup('$notrace'(_874614, _874616), once(rtrace:retract(t_l:tracer_reset(_874604))), '$restore_trace'(_874614, _874616))
^  <span class="ansi1 ansi32"
>Call: </span>(264) [system] sig_atomic(system:'$notrace'(_874614, _874616))
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [rtrace] tAt(false, 271, 271, false)

;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.26"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.26</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.45 milliseconds) 

{exec 
  (H-E-Fails 
    (assertEqualToResult 
      (chain 
    (collapse-bind 
     (foo $x)) $a 
    (quote $a)) 
      ((quote 
  (((foo $x)
 
  ({...} ()))
))
)))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    ((quote 
  (input A))
 
      (quote 
    (input B))) 
    ((quote 
  (((foo $10000)
 
  ({...} ()))
))
)}}

</span>
{failed 
 once 

  {write_pass_fail 
    (H-E-Fails 
      (assertEqualToResult 
    (chain 
     (collapse-bind 
      (foo $x)) $a 
     (quote $a)) 
    ((quote 
  (((foo $x)
 
  ({...} ()))
))
))) FAIL 
    {equal_enough_for_test 
      ((quote 
  (input A))
 
    (quote 
     (input B))) 
      ((quote 
  (((foo $10000)
 
  ({...} ()))
))
)}}}


{on_mettalog_error 
  {failed 
  once 

    {write_pass_fail 
      (H-E-Fails 
    (assertEqualToResult 
     (chain 
      (collapse-bind 
       (foo $x)) $a 
      (quote $a)) 
     ((quote 
  (((foo $x)
 
  ({...} ()))
))
))) FAIL 
      {equal_enough_for_test 
    ((quote 
  (input A))
 
     (quote 
      (input B))) 
    ((quote 
  (((foo $10000)
 
  ({...} ()))
))
)}}}}

^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [foo, '$VAR'("x")]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[foo, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[foo, _838490], ['{...}', []]]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] once(user:write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [foo, '$VAR'("x")]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[foo, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[foo, _838490], ['{...}', []]]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [foo, '$VAR'("x")]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[foo, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[foo, _838490], ['{...}', []]]]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(267) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [foo, '$VAR'("x")]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[foo, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[foo, _838490], ['{...}', []]]]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(265) [system] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [foo, '$VAR'("x")]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[foo, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[foo, _838490], ['{...}', []]]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(267) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] setup_call_cleanup('$notrace'(_910980, _910982), once(rtrace:retract(t_l:tracer_reset(_910970))), '$restore_trace'(_910980, _910982))
^  <span class="ansi1 ansi32"
>Call: </span>(270) [system] sig_atomic(system:'$notrace'(_910980, _910982))
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [rtrace] tAt(false, 271, 271, false)

Deterministic: (H-E-Fails 
  (assertEqualToResult 
    (chain 
      (collapse-bind 
    (foo $"x")) $"a" 
      (quote $"a")) 
    ((quote 
  (((foo $"x")
 
  ({...} ()))
))
)))
<span class="ansi38-013099040"
>{exec 
  (H-E-Fails 
    (assertEqualToResult 
      (chain 
    (collapse-bind 
     (eval 
      (foo $x))) $a 
    (quote $a)) 
      ((quote 
  (((bar $x)
 
  ({...} ()))
))
)))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.27"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.27</h3>
; 
; EVAL TEST
; took 0.003 secs. (2.61 milliseconds) 

{exec 
  (H-E-Fails 
    (assertEqualToResult 
      (chain 
    (collapse-bind 
     (eval 
      (foo $x))) $a 
    (quote $a)) 
      ((quote 
  (((bar $x)
 
  ({...} ()))
))
)))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    ((quote 
  (input A))
 
      (quote 
    (input B))) 
    ((quote 
  (((bar $10000)
 
  ({...} ()))
))
)}}

</span>
{failed 
 once 

  {write_pass_fail 
    (H-E-Fails 
      (assertEqualToResult 
    (chain 
     (collapse-bind 
      (eval 
       (foo $x))) $a 
     (quote $a)) 
    ((quote 
  (((bar $x)
 
  ({...} ()))
))
))) FAIL 
    {equal_enough_for_test 
      ((quote 
  (input A))
 
    (quote 
     (input B))) 
      ((quote 
  (((bar $10000)
 
  ({...} ()))
))
)}}}


{on_mettalog_error 
  {failed 
  once 

    {write_pass_fail 
      (H-E-Fails 
    (assertEqualToResult 
     (chain 
      (collapse-bind 
       (eval 
        (foo $x))) $a 
      (quote $a)) 
     ((quote 
  (((bar $x)
 
  ({...} ()))
))
))) FAIL 
      {equal_enough_for_test 
    ((quote 
  (input A))
 
     (quote 
      (input B))) 
    ((quote 
  (((bar $10000)
 
  ({...} ()))
))
)}}}}

^  <span class="ansi1 ansi32"
>Call: </span>(259) [user] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [eval, [foo, '$VAR'("x")]]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[bar, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[bar, _926408], ['{...}', []]]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(260) [user] once(user:write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [eval, [foo, '$VAR'("x")]]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[bar, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[bar, _926408], ['{...}', []]]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(261) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [eval, [foo, '$VAR'("x")]]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[bar, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[bar, _926408], ['{...}', []]]]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(261) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [eval, [foo, '$VAR'("x")]]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[bar, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[bar, _926408], ['{...}', []]]]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(259) [system] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [eval, [foo, '$VAR'("x")]]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[bar, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[bar, _926408], ['{...}', []]]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(259) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(261) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(261) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(263) [system] setup_call_cleanup('$notrace'(_973112, _973114), once(rtrace:retract(t_l:tracer_reset(_973102))), '$restore_trace'(_973112, _973114))
^  <span class="ansi1 ansi32"
>Call: </span>(264) [system] sig_atomic(system:'$notrace'(_973112, _973114))
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [rtrace] tAt(false, 271, 271, false)

;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.28"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.28</h3>
; 
; EVAL TEST
; took 0.003 secs. (2.57 milliseconds) 

{exec 
  (H-E-Fails 
    (assertEqualToResult 
      (chain 
    (collapse-bind 
     (eval 
      (foo $x))) $a 
    (quote $a)) 
      ((quote 
  (((bar $x)
 
  ({...} ()))
))
)))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    ((quote 
  (input A))
 
      (quote 
    (input B))) 
    ((quote 
  (((bar $10000)
 
  ({...} ()))
))
)}}

</span>
{failed 
 once 

  {write_pass_fail 
    (H-E-Fails 
      (assertEqualToResult 
    (chain 
     (collapse-bind 
      (eval 
       (foo $x))) $a 
     (quote $a)) 
    ((quote 
  (((bar $x)
 
  ({...} ()))
))
))) FAIL 
    {equal_enough_for_test 
      ((quote 
  (input A))
 
    (quote 
     (input B))) 
      ((quote 
  (((bar $10000)
 
  ({...} ()))
))
)}}}


{on_mettalog_error 
  {failed 
  once 

    {write_pass_fail 
      (H-E-Fails 
    (assertEqualToResult 
     (chain 
      (collapse-bind 
       (eval 
        (foo $x))) $a 
      (quote $a)) 
     ((quote 
  (((bar $x)
 
  ({...} ()))
))
))) FAIL 
      {equal_enough_for_test 
    ((quote 
  (input A))
 
     (quote 
      (input B))) 
    ((quote 
  (((bar $10000)
 
  ({...} ()))
))
)}}}}

^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [eval, [foo, '$VAR'("x")]]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[bar, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[bar, _926408], ['{...}', []]]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] once(user:write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [eval, [foo, '$VAR'("x")]]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[bar, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[bar, _926408], ['{...}', []]]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [eval, [foo, '$VAR'("x")]]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[bar, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[bar, _926408], ['{...}', []]]]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(267) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [eval, [foo, '$VAR'("x")]]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[bar, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[bar, _926408], ['{...}', []]]]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(265) [system] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [eval, [foo, '$VAR'("x")]]], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[bar, '$VAR'("x")], ['{...}', []]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']], [quote, [input, 'B']]], [[quote, [[[bar, _926408], ['{...}', []]]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(267) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] setup_call_cleanup('$notrace'(_1020046, _1020048), once(rtrace:retract(t_l:tracer_reset(_1020036))), '$restore_trace'(_1020046, _1020048))
^  <span class="ansi1 ansi32"
>Call: </span>(270) [system] sig_atomic(system:'$notrace'(_1020046, _1020048))
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [rtrace] tAt(false, 271, 271, false)

Deterministic: (H-E-Fails 
  (assertEqualToResult 
    (chain 
      (collapse-bind 
    (eval 
     (foo $"x"))) $"a" 
      (quote $"a")) 
    ((quote 
  (((bar $"x")
 
  ({...} ()))
))
)))
<span class="ansi38-013099040"
>{exec 
  (H-E-Fails 
    (assertEqualToResult 
      (chain 
    (collapse-bind 
     (metta 
      (foo $x) %Undefined% &self)) $a 
    (quote $a)) 
      ((quote 
  (((input B)
 
  ({...} 
    ($x <- B)))
 
    ((input A)
 
      ({...} 
    ($x <- A)))))
)))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.29"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.29</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.96 milliseconds) 

{exec 
  (H-E-Fails 
    (assertEqualToResult 
      (chain 
    (collapse-bind 
     (metta 
      (foo $x) %Undefined% &self)) $a 
    (quote $a)) 
      ((quote 
  (((input B)
 
  ({...} 
    ($x <- B)))
 
    ((input A)
 
      ({...} 
    ($x <- A)))))
)))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    ((quote 
  (input A))
) 
    ((quote 
  (((input B)
 
  ({...} 
    ($10000 <- B)))
 
    ((input A)
 
      ({...} 
    ($10000 <- A)))))
)}}

</span>
{failed 
 once 

  {write_pass_fail 
    (H-E-Fails 
      (assertEqualToResult 
    (chain 
     (collapse-bind 
      (metta 
       (foo $x) %Undefined% &self)) $a 
     (quote $a)) 
    ((quote 
  (((input B)
 
  ({...} 
    ($x <- B)))
 
    ((input A)
 
      ({...} 
    ($x <- A)))))
))) FAIL 
    {equal_enough_for_test 
      ((quote 
  (input A))
) 
      ((quote 
  (((input B)
 
  ({...} 
    ($10000 <- B)))
 
    ((input A)
 
      ({...} 
    ($10000 <- A)))))
)}}}


{on_mettalog_error 
  {failed 
  once 

    {write_pass_fail 
      (H-E-Fails 
    (assertEqualToResult 
     (chain 
      (collapse-bind 
       (metta 
        (foo $x) %Undefined% &self)) $a 
      (quote $a)) 
     ((quote 
  (((input B)
 
  ({...} 
    ($x <- B)))
 
    ((input A)
 
      ({...} 
    ($x <- A)))))
))) FAIL 
      {equal_enough_for_test 
    ((quote 
  (input A))
) 
    ((quote 
  (((input B)
 
  ({...} 
    ($10000 <- B)))
 
    ((input A)
 
      ({...} 
    ($10000 <- A)))))
)}}}}

^  <span class="ansi1 ansi32"
>Call: </span>(259) [user] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [metta, [foo, '$VAR'("x")], '%Undefined%', '&self']], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[input, 'B'], ['{...}', ['$VAR'("x"), <-, 'B']]], [[input, 'A'], ['{...}', ['$VAR'("x"), <-, 'A']]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']]], [[quote, [[[input, 'B'], ['{...}', [_1035860, <-, 'B']]], [[input, 'A'], ['{...}', [_1035860, <-, 'A']]]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(260) [user] once(user:write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [metta, [foo, '$VAR'("x")], '%Undefined%', '&self']], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[input, 'B'], ['{...}', ['$VAR'("x"), <-, 'B']]], [[input, 'A'], ['{...}', ['$VAR'("x"), <-, 'A']]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']]], [[quote, [[[input, 'B'], ['{...}', [_1035860, <-, 'B']]], [[input, 'A'], ['{...}', [_1035860, <-, 'A']]]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(261) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [metta, [foo, '$VAR'("x")], '%Undefined%', '&self']], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[input, 'B'], ['{...}', ['$VAR'("x"), <-, 'B']]], [[input, 'A'], ['{...}', ['$VAR'("x"), <-, 'A']]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']]], [[quote, [[[input, 'B'], ['{...}', [_1035860, <-, 'B']]], [[input, 'A'], ['{...}', [_1035860, <-, 'A']]]]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(261) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [metta, [foo, '$VAR'("x")], '%Undefined%', '&self']], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[input, 'B'], ['{...}', ['$VAR'("x"), <-, 'B']]], [[input, 'A'], ['{...}', ['$VAR'("x"), <-, 'A']]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']]], [[quote, [[[input, 'B'], ['{...}', [_1035860, <-, 'B']]], [[input, 'A'], ['{...}', [_1035860, <-, 'A']]]]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(259) [system] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [metta, [foo, '$VAR'("x")], '%Undefined%', '&self']], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[input, 'B'], ['{...}', ['$VAR'("x"), <-, 'B']]], [[input, 'A'], ['{...}', ['$VAR'("x"), <-, 'A']]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']]], [[quote, [[[input, 'B'], ['{...}', [_1035860, <-, 'B']]], [[input, 'A'], ['{...}', [_1035860, <-, 'A']]]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(259) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(261) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(261) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(263) [system] setup_call_cleanup('$notrace'(_1075512, _1075514), once(rtrace:retract(t_l:tracer_reset(_1075502))), '$restore_trace'(_1075512, _1075514))
^  <span class="ansi1 ansi32"
>Call: </span>(264) [system] sig_atomic(system:'$notrace'(_1075512, _1075514))
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [rtrace] tAt(false, 271, 271, false)

;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.30"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.30</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.87 milliseconds) 

{exec 
  (H-E-Fails 
    (assertEqualToResult 
      (chain 
    (collapse-bind 
     (metta 
      (foo $x) %Undefined% &self)) $a 
    (quote $a)) 
      ((quote 
  (((input B)
 
  ({...} 
    ($x <- B)))
 
    ((input A)
 
      ({...} 
    ($x <- A)))))
)))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    ((quote 
  (input A))
) 
    ((quote 
  (((input B)
 
  ({...} 
    ($10000 <- B)))
 
    ((input A)
 
      ({...} 
    ($10000 <- A)))))
)}}

</span>
{failed 
 once 

  {write_pass_fail 
    (H-E-Fails 
      (assertEqualToResult 
    (chain 
     (collapse-bind 
      (metta 
       (foo $x) %Undefined% &self)) $a 
     (quote $a)) 
    ((quote 
  (((input B)
 
  ({...} 
    ($x <- B)))
 
    ((input A)
 
      ({...} 
    ($x <- A)))))
))) FAIL 
    {equal_enough_for_test 
      ((quote 
  (input A))
) 
      ((quote 
  (((input B)
 
  ({...} 
    ($10000 <- B)))
 
    ((input A)
 
      ({...} 
    ($10000 <- A)))))
)}}}


{on_mettalog_error 
  {failed 
  once 

    {write_pass_fail 
      (H-E-Fails 
    (assertEqualToResult 
     (chain 
      (collapse-bind 
       (metta 
        (foo $x) %Undefined% &self)) $a 
      (quote $a)) 
     ((quote 
  (((input B)
 
  ({...} 
    ($x <- B)))
 
    ((input A)
 
      ({...} 
    ($x <- A)))))
))) FAIL 
      {equal_enough_for_test 
    ((quote 
  (input A))
) 
    ((quote 
  (((input B)
 
  ({...} 
    ($10000 <- B)))
 
    ((input A)
 
      ({...} 
    ($10000 <- A)))))
)}}}}

^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [metta, [foo, '$VAR'("x")], '%Undefined%', '&self']], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[input, 'B'], ['{...}', ['$VAR'("x"), <-, 'B']]], [[input, 'A'], ['{...}', ['$VAR'("x"), <-, 'A']]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']]], [[quote, [[[input, 'B'], ['{...}', [_1035860, <-, 'B']]], [[input, 'A'], ['{...}', [_1035860, <-, 'A']]]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] once(user:write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [metta, [foo, '$VAR'("x")], '%Undefined%', '&self']], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[input, 'B'], ['{...}', ['$VAR'("x"), <-, 'B']]], [[input, 'A'], ['{...}', ['$VAR'("x"), <-, 'A']]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']]], [[quote, [[[input, 'B'], ['{...}', [_1035860, <-, 'B']]], [[input, 'A'], ['{...}', [_1035860, <-, 'A']]]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [metta, [foo, '$VAR'("x")], '%Undefined%', '&self']], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[input, 'B'], ['{...}', ['$VAR'("x"), <-, 'B']]], [[input, 'A'], ['{...}', ['$VAR'("x"), <-, 'A']]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']]], [[quote, [[[input, 'B'], ['{...}', [_1035860, <-, 'B']]], [[input, 'A'], ['{...}', [_1035860, <-, 'A']]]]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(267) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [metta, [foo, '$VAR'("x")], '%Undefined%', '&self']], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[input, 'B'], ['{...}', ['$VAR'("x"), <-, 'B']]], [[input, 'A'], ['{...}', ['$VAR'("x"), <-, 'A']]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']]], [[quote, [[[input, 'B'], ['{...}', [_1035860, <-, 'B']]], [[input, 'A'], ['{...}', [_1035860, <-, 'A']]]]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(265) [system] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, [chain, ['collapse-bind', [metta, [foo, '$VAR'("x")], '%Undefined%', '&self']], '$VAR'("a"), [quote, '$VAR'("a")]], [[quote, [[[input, 'B'], ['{...}', ['$VAR'("x"), <-, 'B']]], [[input, 'A'], ['{...}', ['$VAR'("x"), <-, 'A']]]]]]]], 'FAIL', equal_enough_for_test([[quote, [input, 'A']]], [[quote, [[[input, 'B'], ['{...}', [_1035860, <-, 'B']]], [[input, 'A'], ['{...}', [_1035860, <-, 'A']]]]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(267) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] setup_call_cleanup('$notrace'(_1115216, _1115218), once(rtrace:retract(t_l:tracer_reset(_1115206))), '$restore_trace'(_1115216, _1115218))
^  <span class="ansi1 ansi32"
>Call: </span>(270) [system] sig_atomic(system:'$notrace'(_1115216, _1115218))
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [rtrace] tAt(false, 271, 271, false)

Deterministic: (H-E-Fails 
  (assertEqualToResult 
    (chain 
      (collapse-bind 
    (metta 
     (foo $"x") %Undefined% &self)) $"a" 
      (quote $"a")) 
    ((quote 
  (((input B)
 
  ({...} 
    ($"x" <- B)))
 
    ((input A)
 
      ({...} 
    ($"x" <- A)))))
)))
;;;; superpose-bind complements collapse-bind
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (chain 
      (collapse-bind 
    (foo $x)) $a 
      (chain 
    (superpose-bind $a) $b 
    (quote $b))) 
    ((quote 
  (foo $x))
))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.31"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.31</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.93 milliseconds) 

{exec 
  (assertEqualToResult 
    (chain 
      (collapse-bind 
    (foo $x)) $a 
      (chain 
    (superpose-bind $a) $b 
    (quote $b))) 
    ((quote 
  (foo $x))
))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    ((quote input)
 
      (quote A) 
      (quote input) 
      (quote B)) 
    ((quote 
  (foo $10000))
)}}

</span>
Deterministic: ({Error 
  {got 
    ((quote input)
 
      (quote A) 
      (quote input) 
      (quote B))} 
  {expected 
    ((quote 
  (foo $"x"))
)}}
)
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (chain 
      (collapse-bind 
    (eval 
     (foo $x))) $a 
      (chain 
    (superpose-bind $a) $b 
    (quote $b))) 
    ((quote 
  (bar $x))
))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.32"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.32</h3>
; 
; EVAL TEST
; took 0.003 secs. (3.02 milliseconds) 

{exec 
  (assertEqualToResult 
    (chain 
      (collapse-bind 
    (eval 
     (foo $x))) $a 
      (chain 
    (superpose-bind $a) $b 
    (quote $b))) 
    ((quote 
  (bar $x))
))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    ((quote input)
 
      (quote A) 
      (quote input) 
      (quote B)) 
    ((quote 
  (bar $10000))
)}}

</span>
Deterministic: ({Error 
  {got 
    ((quote input)
 
      (quote A) 
      (quote input) 
      (quote B))} 
  {expected 
    ((quote 
  (bar $"x"))
)}}
)
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (chain 
      (collapse-bind 
    (metta 
     (foo $x) %Undefined% &self)) $a 
      (chain 
    (superpose-bind $a) $b 
    (quote $b))) 
    ((quote 
  (input B))
 
      (quote 
    (input A))))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.33"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.33</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.09 milliseconds) 

{exec 
  (assertEqualToResult 
    (chain 
      (collapse-bind 
    (metta 
     (foo $x) %Undefined% &self)) $a 
      (chain 
    (superpose-bind $a) $b 
    (quote $b))) 
    ((quote 
  (input B))
 
      (quote 
    (input A))))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    ((quote input)
 
      (quote A)) 
    ((quote 
  (input B))
 
      (quote 
    (input A)))}}

</span>
Deterministic: ({Error 
  {got 
    ((quote input)
 
      (quote A))} 
  {expected 
    ((quote 
  (input B))
 
      (quote 
    (input A)))}}
)
;;;; metta handles type
<span class="ansi38-255165000"
> (= 
  (foobar) 1)

</span><span class="ansi38-255165000"
> (= 
  (foobar) "a")

</span><span class="ansi38-255165000"
> (= 
  (chain-to-foobar) 
  (foobar))

</span><span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (metta 
      (foobar) Number &self) 
    (1))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.34"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.34</h3>
; 
; EVAL TEST
; took 0.000729 secs. (729.12 microseconds) 

{exec 
  (assertEqualToResult 
    (metta 
      (foobar) Number &self) 
    (1))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (1) 
    (1)}}

</span>
Deterministic: ()
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (metta 
      (foobar) String &self) 
    ("a"))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.35"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.35</h3>
; 
; EVAL TEST
; took 0.000702 secs. (701.54 microseconds) 

{exec 
  (assertEqualToResult 
    (metta 
      (foobar) String &self) 
    ("a"))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    ("a") 
    ("a")}}

</span>
Deterministic: ()
<span class="ansi38-013099040"
>{exec 
  (H-E-Fails 
    (assertEqualToResult 
      (collapse-bind 
    (metta 
     (foobar) $type &self)) 
      ((1 
  ({...} 
    ($type <- Number)))
 
    ("a" 
     ({...} 
      ($type <- String))))))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.36"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.36</h3>
; 
; EVAL TEST
; took 0.000636 secs. (636.38 microseconds) 

{exec 
  (H-E-Fails 
    (assertEqualToResult 
      (collapse-bind 
    (metta 
     (foobar) $type &self)) 
      ((1 
  ({...} 
    ($type <- Number)))
 
    ("a" 
     ({...} 
      ($type <- String))))))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    (1) 
    ((1 
  ({...} 
    ($10000 <- Number)))
 
      ("a" 
    ({...} 
     ($10000 <- String))))}}

</span>
{failed 
 once 

  {write_pass_fail 
    (H-E-Fails 
      (assertEqualToResult 
    (collapse-bind 
     (metta 
      (foobar) $type &self)) 
    ((1 
  ({...} 
    ($type <- Number)))
 
     ("a" 
      ({...} 
       ($type <- String)))))) FAIL 
    {equal_enough_for_test 
      (1) 
      ((1 
  ({...} 
    ($10000 <- Number)))
 
    ("a" 
     ({...} 
      ($10000 <- String))))}}}


{on_mettalog_error 
  {failed 
  once 

    {write_pass_fail 
      (H-E-Fails 
    (assertEqualToResult 
     (collapse-bind 
      (metta 
       (foobar) $type &self)) 
     ((1 
  ({...} 
    ($type <- Number)))
 
      ("a" 
       ({...} 
        ($type <- String)))))) FAIL 
      {equal_enough_for_test 
    (1) 
    ((1 
  ({...} 
    ($10000 <- Number)))
 
     ("a" 
      ({...} 
       ($10000 <- String))))}}}}

^  <span class="ansi1 ansi32"
>Call: </span>(259) [user] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, [foobar], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1398980, <-, 'Number']]], ["a", ['{...}', [_1398980, <-, 'String']]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(260) [user] once(user:write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, [foobar], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1398980, <-, 'Number']]], ["a", ['{...}', [_1398980, <-, 'String']]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(261) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, [foobar], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1398980, <-, 'Number']]], ["a", ['{...}', [_1398980, <-, 'String']]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(261) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, [foobar], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1398980, <-, 'Number']]], ["a", ['{...}', [_1398980, <-, 'String']]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(259) [system] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, [foobar], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1398980, <-, 'Number']]], ["a", ['{...}', [_1398980, <-, 'String']]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(259) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(261) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(261) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(263) [system] setup_call_cleanup('$notrace'(_1425254, _1425256), once(rtrace:retract(t_l:tracer_reset(_1425244))), '$restore_trace'(_1425254, _1425256))
^  <span class="ansi1 ansi32"
>Call: </span>(264) [system] sig_atomic(system:'$notrace'(_1425254, _1425256))
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [rtrace] tAt(false, 271, 271, false)

;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.37"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.37</h3>
; 
; EVAL TEST
; took 0.000715 secs. (714.89 microseconds) 

{exec 
  (H-E-Fails 
    (assertEqualToResult 
      (collapse-bind 
    (metta 
     (foobar) $type &self)) 
      ((1 
  ({...} 
    ($type <- Number)))
 
    ("a" 
     ({...} 
      ($type <- String))))))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    (1) 
    ((1 
  ({...} 
    ($10000 <- Number)))
 
      ("a" 
    ({...} 
     ($10000 <- String))))}}

</span>
{failed 
 once 

  {write_pass_fail 
    (H-E-Fails 
      (assertEqualToResult 
    (collapse-bind 
     (metta 
      (foobar) $type &self)) 
    ((1 
  ({...} 
    ($type <- Number)))
 
     ("a" 
      ({...} 
       ($type <- String)))))) FAIL 
    {equal_enough_for_test 
      (1) 
      ((1 
  ({...} 
    ($10000 <- Number)))
 
    ("a" 
     ({...} 
      ($10000 <- String))))}}}


{on_mettalog_error 
  {failed 
  once 

    {write_pass_fail 
      (H-E-Fails 
    (assertEqualToResult 
     (collapse-bind 
      (metta 
       (foobar) $type &self)) 
     ((1 
  ({...} 
    ($type <- Number)))
 
      ("a" 
       ({...} 
        ($type <- String)))))) FAIL 
      {equal_enough_for_test 
    (1) 
    ((1 
  ({...} 
    ($10000 <- Number)))
 
     ("a" 
      ({...} 
       ($10000 <- String))))}}}}

^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, [foobar], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1398980, <-, 'Number']]], ["a", ['{...}', [_1398980, <-, 'String']]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] once(user:write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, [foobar], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1398980, <-, 'Number']]], ["a", ['{...}', [_1398980, <-, 'String']]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, [foobar], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1398980, <-, 'Number']]], ["a", ['{...}', [_1398980, <-, 'String']]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(267) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, [foobar], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1398980, <-, 'Number']]], ["a", ['{...}', [_1398980, <-, 'String']]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(265) [system] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, [foobar], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1398980, <-, 'Number']]], ["a", ['{...}', [_1398980, <-, 'String']]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(267) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] setup_call_cleanup('$notrace'(_1451772, _1451774), once(rtrace:retract(t_l:tracer_reset(_1451762))), '$restore_trace'(_1451772, _1451774))
^  <span class="ansi1 ansi32"
>Call: </span>(270) [system] sig_atomic(system:'$notrace'(_1451772, _1451774))
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [rtrace] tAt(false, 271, 271, false)

Deterministic: (H-E-Fails 
  (assertEqualToResult 
    (collapse-bind 
      (metta 
    (foobar) $"type" &self)) 
    ((1 
  ({...} 
    ($"type" <- Number)))
 
      ("a" 
    ({...} 
     ($"type" <- String))))))
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (metta 
      (chain-to-foobar) Number &self) 
    (1))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.38"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.38</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.08 milliseconds) 

{exec 
  (assertEqualToResult 
    (metta 
      (chain-to-foobar) Number &self) 
    (1))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (1) 
    (1)}}

</span>
Deterministic: ()
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (metta 
      (chain-to-foobar) String &self) 
    ("a"))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.39"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.39</h3>
; 
; EVAL TEST
; took 0.000988 secs. (988.33 microseconds) 

{exec 
  (assertEqualToResult 
    (metta 
      (chain-to-foobar) String &self) 
    ("a"))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    ("a") 
    ("a")}}

</span>
Deterministic: ()
<span class="ansi38-013099040"
>{exec 
  (H-E-Fails 
    (assertEqualToResult 
      (collapse-bind 
    (metta 
     (chain-to-foobar) $type &self)) 
      ((1 
  ({...} 
    ($type <- Number)))
 
    ("a" 
     ({...} 
      ($type <- String))))))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.40"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.40</h3>
; 
; EVAL TEST
; took 0.000930 secs. (930.22 microseconds) 

{exec 
  (H-E-Fails 
    (assertEqualToResult 
      (collapse-bind 
    (metta 
     (chain-to-foobar) $type &self)) 
      ((1 
  ({...} 
    ($type <- Number)))
 
    ("a" 
     ({...} 
      ($type <- String))))))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    (1) 
    ((1 
  ({...} 
    ($10000 <- Number)))
 
      ("a" 
    ({...} 
     ($10000 <- String))))}}

</span>
{failed 
 once 

  {write_pass_fail 
    (H-E-Fails 
      (assertEqualToResult 
    (collapse-bind 
     (metta 
      (chain-to-foobar) $type &self)) 
    ((1 
  ({...} 
    ($type <- Number)))
 
     ("a" 
      ({...} 
       ($type <- String)))))) FAIL 
    {equal_enough_for_test 
      (1) 
      ((1 
  ({...} 
    ($10000 <- Number)))
 
    ("a" 
     ({...} 
      ($10000 <- String))))}}}


{on_mettalog_error 
  {failed 
  once 

    {write_pass_fail 
      (H-E-Fails 
    (assertEqualToResult 
     (collapse-bind 
      (metta 
       (chain-to-foobar) $type &self)) 
     ((1 
  ({...} 
    ($type <- Number)))
 
      ("a" 
       ({...} 
        ($type <- String)))))) FAIL 
      {equal_enough_for_test 
    (1) 
    ((1 
  ({...} 
    ($10000 <- Number)))
 
     ("a" 
      ({...} 
       ($10000 <- String))))}}}}

^  <span class="ansi1 ansi32"
>Call: </span>(259) [user] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, ['chain-to-foobar'], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1532566, <-, 'Number']]], ["a", ['{...}', [_1532566, <-, 'String']]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(260) [user] once(user:write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, ['chain-to-foobar'], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1532566, <-, 'Number']]], ["a", ['{...}', [_1532566, <-, 'String']]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(261) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, ['chain-to-foobar'], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1532566, <-, 'Number']]], ["a", ['{...}', [_1532566, <-, 'String']]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(261) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, ['chain-to-foobar'], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1532566, <-, 'Number']]], ["a", ['{...}', [_1532566, <-, 'String']]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(259) [system] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, ['chain-to-foobar'], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1532566, <-, 'Number']]], ["a", ['{...}', [_1532566, <-, 'String']]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(259) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(261) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(261) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(263) [system] setup_call_cleanup('$notrace'(_1562390, _1562392), once(rtrace:retract(t_l:tracer_reset(_1562380))), '$restore_trace'(_1562390, _1562392))
^  <span class="ansi1 ansi32"
>Call: </span>(264) [system] sig_atomic(system:'$notrace'(_1562390, _1562392))
^  <span class="ansi1 ansi32"
>Exit: </span>(263) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(263) [rtrace] tAt(false, 271, 271, false)

;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.41"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.41</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.01 milliseconds) 

{exec 
  (H-E-Fails 
    (assertEqualToResult 
      (collapse-bind 
    (metta 
     (chain-to-foobar) $type &self)) 
      ((1 
  ({...} 
    ($type <- Number)))
 
    ("a" 
     ({...} 
      ($type <- String))))))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    (1) 
    ((1 
  ({...} 
    ($10000 <- Number)))
 
      ("a" 
    ({...} 
     ($10000 <- String))))}}

</span>
{failed 
 once 

  {write_pass_fail 
    (H-E-Fails 
      (assertEqualToResult 
    (collapse-bind 
     (metta 
      (chain-to-foobar) $type &self)) 
    ((1 
  ({...} 
    ($type <- Number)))
 
     ("a" 
      ({...} 
       ($type <- String)))))) FAIL 
    {equal_enough_for_test 
      (1) 
      ((1 
  ({...} 
    ($10000 <- Number)))
 
    ("a" 
     ({...} 
      ($10000 <- String))))}}}


{on_mettalog_error 
  {failed 
  once 

    {write_pass_fail 
      (H-E-Fails 
    (assertEqualToResult 
     (collapse-bind 
      (metta 
       (chain-to-foobar) $type &self)) 
     ((1 
  ({...} 
    ($type <- Number)))
 
      ("a" 
       ({...} 
        ($type <- String)))))) FAIL 
      {equal_enough_for_test 
    (1) 
    ((1 
  ({...} 
    ($10000 <- Number)))
 
     ("a" 
      ({...} 
       ($10000 <- String))))}}}}

^  <span class="ansi1 ansi32"
>Call: </span>(265) [user] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, ['chain-to-foobar'], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1532566, <-, 'Number']]], ["a", ['{...}', [_1532566, <-, 'String']]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(266) [user] once(user:write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, ['chain-to-foobar'], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1532566, <-, 'Number']]], ["a", ['{...}', [_1532566, <-, 'String']]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(267) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, ['chain-to-foobar'], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1532566, <-, 'Number']]], ["a", ['{...}', [_1532566, <-, 'String']]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(267) [user] write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, ['chain-to-foobar'], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1532566, <-, 'Number']]], ["a", ['{...}', [_1532566, <-, 'String']]]]))
^  <span class="ansi1 ansi31"
>Fail: </span>(265) [system] call(user:once, user:write_pass_fail(['H-E-Fails', [assertEqualToResult, ['collapse-bind', [metta, ['chain-to-foobar'], '$VAR'("type"), '&self']], [[1, ['{...}', ['$VAR'("type"), <-, 'Number']]], ["a", ['{...}', ['$VAR'("type"), <-, 'String']]]]]], 'FAIL', equal_enough_for_test([1], [[1, ['{...}', [_1532566, <-, 'Number']]], ["a", ['{...}', [_1532566, <-, 'String']]]])))
^  <span class="ansi1 ansi32"
>Call: </span>(265) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(267) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(267) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(269) [system] setup_call_cleanup('$notrace'(_1592444, _1592446), once(rtrace:retract(t_l:tracer_reset(_1592434))), '$restore_trace'(_1592444, _1592446))
^  <span class="ansi1 ansi32"
>Call: </span>(270) [system] sig_atomic(system:'$notrace'(_1592444, _1592446))
^  <span class="ansi1 ansi32"
>Exit: </span>(269) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(269) [rtrace] tAt(false, 271, 271, false)

Deterministic: (H-E-Fails 
  (assertEqualToResult 
    (collapse-bind 
      (metta 
    (chain-to-foobar) $"type" &self)) 
    ((1 
  ({...} 
    ($"type" <- Number)))
 
      ("a" 
    ({...} 
     ($"type" <- String))))))
;;;; Minimal MeTTa interpretation & evaluation step
<span class="ansi38-255165000"
> (= 
  (n/0/0) 
  (n/1/0))

</span><span class="ansi38-255165000"
> (= 
  (n/0/0) 
  (n/1/1))

</span><span class="ansi38-255165000"
> (= 
  (n/1/0) 
  (n/2/0))

</span><span class="ansi38-013099040"
>{exec 
  (assertEqual 
    (chain 
      (n/0/0) $x 
      (quote $x)) 
    (quote 
      (n/0/0)))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.42"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.42</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.40 milliseconds) 

{exec 
  (assertEqual 
    (chain 
      (n/0/0) $x 
      (quote $x)) 
    (quote 
      (n/0/0)))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    ((quote 
  (n/2/0))
 
      (quote 
    (n/1/1))) 
    ((quote 
  (n/0/0))
)}}

</span>
Deterministic: ({Error 
  {got 
    ((quote 
  (n/2/0))
 
      (quote 
    (n/1/1)))} 
  {expected 
    ((quote 
  (n/0/0))
)}}
)
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (chain 
      (eval 
    (n/0/0)) $x 
      (quote $x)) 
    ((quote 
  (n/1/0))
 
      (quote 
    (n/1/1))))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.43"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.43</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.88 milliseconds) 

{exec 
  (assertEqualToResult 
    (chain 
      (eval 
    (n/0/0)) $x 
      (quote $x)) 
    ((quote 
  (n/1/0))
 
      (quote 
    (n/1/1))))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    ((quote 
  (n/2/0))
 
      (quote 
    (n/1/1))) 
    ((quote 
  (n/1/0))
 
      (quote 
    (n/1/1)))}}

</span>
Deterministic: ({Error 
  {got 
    ((quote 
  (n/2/0))
 
      (quote 
    (n/1/1)))} 
  {expected 
    ((quote 
  (n/1/0))
 
      (quote 
    (n/1/1)))}}
)
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (chain 
      (metta 
    (n/0/0) %Undefined% &self) $x 
      (quote $x)) 
    ((quote 
  (n/1/1))
 
      (quote 
    (n/2/0))))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.44"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.44</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.04 milliseconds) 

{exec 
  (assertEqualToResult 
    (chain 
      (metta 
    (n/0/0) %Undefined% &self) $x 
      (quote $x)) 
    ((quote 
  (n/1/1))
 
      (quote 
    (n/2/0))))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    ((quote 
  (n/2/0))
 
      (quote 
    (n/1/1))) 
    ((quote 
  (n/1/1))
 
      (quote 
    (n/2/0)))}}

</span>
Deterministic: ()
<span class="ansi38-013099040"
>{exec 
  (assertEqual 
    (chain 
      (unify 
    ($x b) 
    (a $y) 
    ($x $y) Failed) $v $v) 
    (a b))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.45"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.45</h3>
; 
; EVAL TEST
; took 0.000795 secs. (795.08 microseconds) 

{exec 
  (assertEqual 
    (chain 
      (unify 
    ($x b) 
    (a $y) 
    ($x $y) Failed) $v $v) 
    (a b))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test () 
    ((a b)
)}}

</span>
Deterministic: ({Error 
  {got ()} 
  {expected 
    ((a b)
)}}
)
<span class="ansi38-013099040"
>{exec 
  (assertEqual 
    (chain 
      (chain A $x 
    (p $x)) $y 
      (quote $y)) 
    (quote 
      (p A)))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.46"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.46</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.17 milliseconds) 

{exec 
  (assertEqual 
    (chain 
      (chain A $x 
    (p $x)) $y 
      (quote $y)) 
    (quote 
      (p A)))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    ((quote 
  (p A))
) 
    ((quote 
  (p A))
)}}

</span>
Deterministic: ()
<span class="ansi38-013099040"
>{exec 
  (assertEqual 
    (chain 
      (cons-atom p 
    (q)) $v 
      (quote $v)) 
    (quote 
      (p q)))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.47"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.47</h3>
; 
; EVAL TEST
; took 0.000589 secs. (588.79 microseconds) 

{exec 
  (assertEqual 
    (chain 
      (cons-atom p 
    (q)) $v 
      (quote $v)) 
    (quote 
      (p q)))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    ((quote 
  (p q))
) 
    ((quote 
  (p q))
)}}

</span>
Deterministic: ()
<span class="ansi38-013099040"
>{exec 
  (assertEqual 
    (chain 
      (decons-atom 
    (p q)) $x 
      (quote $x)) 
    (quote 
      (p 
    (q))))}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.48"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.48</h3>
; 
; EVAL TEST
; took 0.000762 secs. (762.49 microseconds) 

{exec 
  (assertEqual 
    (chain 
      (decons-atom 
    (p q)) $x 
      (quote $x)) 
    (quote 
      (p 
    (q))))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    ((quote 
  (p 
    (q)))
) 
    ((quote 
  (p 
    (q)))
)}}

</span>
Deterministic: ()
;;;; function / return, mutate argument via call struct
<span class="ansi38-255165000"
> (= 
  (f1) 
  (function 
    (return ())))

</span><span class="ansi38-255165000"
> (= 
  (f0 $b) 
  (function 
    (chain 
      (eval 
    (f1)) $ 
      (unify $b value 
    (return ()) 
    (return 
     (Error () "Unexpected error"))))))

</span><span class="ansi38-013099040"
>{exec 
  (assertEqual 
    (chain 
      (eval 
    (f0 $a)) $ $a) value)}


</span>
;<h3 id="HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.49"
>;; HYPERON-METTALOG-SANITY.MINIMAL-METTA-TESTS.49</h3>
; 
; EVAL TEST
; took 0.004 secs. (4.02 milliseconds) 

{exec 
  (assertEqual 
    (chain 
      (eval 
    (f0 $a)) $ $a) value)}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test () 
    (value)}}

</span>
Deterministic: ({Error 
  {got ()} 
  {expected 
    (value)}}
)
<span class="ansi32"
>% 17,562,650 inferences, 2.266 CPU in 2.268 seconds (100% CPU, 7750526 Lips)
</span>P;HTML|
;                       { = /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/hyperon-mettalog_sanity/minimal_metta_tests.metta
;                          0 }
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 18
</span><span class="ansi31"
>Failures: 31
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
P;HTML|
;         {is_cmd_option execute halt --halt=true true}
P;HTML|
;          {set_option_value halt true}
P;HTML|
;          {is_cmd_option execute stdin --stdin=tty tty}
P;HTML|
;          {set_option_value stdin tty}
P;HTML|
;          {is_cmd_option execute stdout --stdout=tty tty}
P;HTML|
;           {set_option_value stdout tty}
P;HTML|
;          {is_cmd_option execute stderr --stderr=tty tty}
P;HTML|
;           {set_option_value stderr tty}
P;HTML|
;         {set_option_value compat false}
P;HTML|
;         {set_option_value compatio false}
P;HTML|
;         {set_option_value src_indents false}
P;HTML|
;         {set_option_value devel false}
P;HTML|
;         {set_option_value stack-max 500}
P;HTML|
;         {set_option_value limit inf}
P;HTML|
;         {set_option_value initial-result-count 10}
P;HTML|
;         {set_option_value answer-format show}
P;HTML|
;         {set_option_value repeats true}
P;HTML|
;         {set_option_value time true}
P;HTML|
;         {set_option_value synth-unit-tests false}
P;HTML|
;         {set_option_value optimize true}
P;HTML|
;         {set_option_value transpiler silent}
P;HTML|
;          {set_debug transpiler false}
P;HTML|
;         {set_option_value compile false}
P;HTML|
;         {set_option_value tabling auto}
P;HTML|
;         {set_option_value log false}
P;HTML|
;         {set_option_value output ./}
P;HTML|
;         {set_option_value exeout ./Sav.gitlab.MeTTaLog}
P;HTML|
;         {set_option_value halt false}
P;HTML|
;         {set_option_value trace-length 500}
P;HTML|
;         {set_option_value trace-on-overtime 4.0}
P;HTML|
;          {set_debug overtime 4.0}
P;HTML|
;         {set_option_value trace-on-overflow 1000}
P;HTML|
;          {set_debug overflow 1000}
P;HTML|
;         {set_option_value trace-on-eval false}
P;HTML|
;          {set_debug eval false}
P;HTML|
;         {set_option_value trace-on-load silent}
P;HTML|
;          {set_debug load silent}
P;HTML|
;          {set_debug trace-on-load false}
P;HTML|
;         {set_option_value trace-on-exec false}
P;HTML|
;          {set_debug exec false}
P;HTML|
;         {set_option_value trace-on-error non-type}
P;HTML|
;          {set_debug error non-type}
P;HTML|
;         {set_option_value trace-on-fail false}
P;HTML|
;          {set_debug fail false}
P;HTML|
;         {set_option_value trace-on-test true}
P;HTML|
;          {set_debug test true}
P;HTML|
;         {set_option_value repl-on-error true}
P;HTML|
;         {set_option_value repl-on-fail false}
P;HTML|
;         {set_option_value exit-on-fail false}
P;HTML|
;         {set_option_value repl auto}
P;HTML|
;         {set_option_value prolog false}
P;HTML|
;         {set_option_value exec noskip}
P;HTML|
;         {set_option_value maximum-result-count inf}
P;HTML|
;         {set_option_value html false}
P;HTML|
;         {set_option_value python true}
P;HTML|
;         {set_option_value trace-on-test false}
P;HTML|
;          {set_debug test false}
P;HTML|
;         {set_option_value trace-on-fail false}
P;HTML|
;          {set_debug fail false}
P;HTML|
;         {set_option_value load show}
P;HTML|
;         {set_option_value test true}
[()]
[Empty()]
[()]
[Empty()]
[Empty]
[({Error 
  {got 
    ((quote 1)
)} 
  {expected 
    ((quote 
  (returns-empty))
)}}
)
]
[()]
[({Error 
  {got 
    (())} 
  {expected 
    (1 ())}}
)
, ()]
[()]
[({Error 
  {got 
    (())} 
  {expected 
    (1 ())}}
)
, ()]
[()]
[({Error 
  {got 
    ((quote ())
 
      (quote 1))} 
  {expected 
    ((quote 
  (returns-empty-expression))
)}}
)
]
[({Error 
  {got 
    (NotReducible 1)} 
  {expected 
    (1 
      (returns-not-reducible))}}
)
]
[({Error 
  {got 
    (NotReducible 1)} 
  {expected 
    (1 
      (returns-not-reducible))}}
)
]
[({Error 
  {got 
    (NotReducible)} 
  {expected 
    (1 
      (eval 
    (returns-not-reducible)))}}
)
, ({Error 
  {got 
    (1)} 
  {expected 
    (1 
      (eval 
    (returns-not-reducible)))}}
)
]
[({Error 
  {got 
    (NotReducible)} 
  {expected 
    (1 
      (returns-not-reducible))}}
)
, ({Error 
  {got 
    (1)} 
  {expected 
    (1 
      (returns-not-reducible))}}
)
]
[()]
[({Error 
  {got 
    ((quote NotReducible)
 
      (quote 1))} 
  {expected 
    ((quote 
  (returns-not-reducible))
)}}
)
]
[(H-E-Fails 
  (assertEqualToResult 
    (chain 
      (collapse-bind 
    (foo $10000)) $10001 
      (quote $10001)) 
    ((quote 
  (((foo $10000)
 
  ({...} ()))
))
)))
]
[(H-E-Fails 
  (assertEqualToResult 
    (chain 
      (collapse-bind 
    (eval 
     (foo $10000))) $10001 
      (quote $10001)) 
    ((quote 
  (((bar $10000)
 
  ({...} ()))
))
)))
]
[(H-E-Fails 
  (assertEqualToResult 
    (chain 
      (collapse-bind 
    (metta 
     (foo $10000) %Undefined% &self)) $10001 
      (quote $10001)) 
    ((quote 
  (((input B)
 
  ({...} 
    ($10000 <- B)))
 
    ((input A)
 
      ({...} 
    ($10000 <- A)))))
)))
]
[({Error 
  {got 
    ((quote input)
 
      (quote A) 
      (quote input) 
      (quote B))} 
  {expected 
    ((quote 
  (foo $10000))
)}}
)
]
[({Error 
  {got 
    ((quote input)
 
      (quote A) 
      (quote input) 
      (quote B))} 
  {expected 
    ((quote 
  (bar $10000))
)}}
)
]
[({Error 
  {got 
    ((quote input)
 
      (quote A))} 
  {expected 
    ((quote 
  (input B))
 
      (quote 
    (input A)))}}
)
]
[()]
[()]
[(H-E-Fails 
  (assertEqualToResult 
    (collapse-bind 
      (metta 
    (foobar) $10000 &self)) 
    ((1 
  ({...} 
    ($10000 <- Number)))
 
      ("a" 
    ({...} 
     ($10000 <- String))))))
]
[()]
[()]
[(H-E-Fails 
  (assertEqualToResult 
    (collapse-bind 
      (metta 
    (chain-to-foobar) $10000 &self)) 
    ((1 
  ({...} 
    ($10000 <- Number)))
 
      ("a" 
    ({...} 
     ($10000 <- String))))))
]
[({Error 
  {got 
    ((quote 
  (n/2/0))
 
      (quote 
    (n/1/1)))} 
  {expected 
    ((quote 
  (n/0/0))
)}}
)
]
[({Error 
  {got 
    ((quote 
  (n/2/0))
 
      (quote 
    (n/1/1)))} 
  {expected 
    ((quote 
  (n/1/0))
 
      (quote 
    (n/1/1)))}}
)
]
[()]
[({Error 
  {got ()} 
  {expected 
    ((a b)
)}}
)
]
[()]
[()]
[()]
[({Error 
  {got ()} 
  {expected 
    (value)}}
)
]
P;HTML|
;         {maybe_halt 7}
<span class="ansi31"
>{in 
  {maybe_halt 7} 
  {unwind 
    {halt 7}}}

</span>
Script done on 2024-11-28 15:08:20+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat/' --timeout=40 --html --repl=false  --test "tests/baseline_compat/hyperon-mettalog_sanity/minimal_metta_tests.metta" --halt=true\033[0m
