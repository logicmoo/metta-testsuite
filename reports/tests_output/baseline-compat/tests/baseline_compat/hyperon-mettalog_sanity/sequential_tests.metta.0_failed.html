<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi35 { color: #E850A8; }
.ansi36 { color: #00aaaa; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-12-24 11:36:21+00:00 [COMMAND="timeout --preserve-status --foreground --signal=SIGTERM --kill-after=5s 40 swipl  /home/runner/work/metta-testsuite/metta-testsuite/prolog/metta_lang/metta_interp.pl -- --python=enable -- --timeout=40 --output=./reports/tests_output/baseline-compat/ --html --test tests/baseline_compat/hyperon-mettalog_sanity/sequential_tests.metta --halt=true  --stdin=tty --stdout=tty --stderr=tty" TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;         #(set_debug transpiler false)

P;HTML|
;          #(set_debug overtime 4.0)

P;HTML|
;          #(set_debug overflow 1000)

P;HTML|
;          #(set_debug eval false)

P;HTML|
;          #(set_debug load silent)

P;HTML|
;          #(set_debug trace-on-load false)

P;HTML|
;          #(set_debug exec false)

P;HTML|
;          #(set_debug error non-type)

P;HTML|
;          #(set_debug fail false)

P;HTML|
;          #(set_debug test true)

P;HTML|
;         #(set_debug test false)

P;HTML|
;         #(set_debug fail false)
P;HTML|
;          #(set_debug transpiler false)
P;HTML|
;          #(set_debug overtime 4.0)
P;HTML|
;          #(set_debug overflow 1000)
P;HTML|
;          #(set_debug eval false)
P;HTML|
;          #(set_debug load silent)
P;HTML|
;          #(set_debug trace-on-load false)
P;HTML|
;          #(set_debug exec false)
P;HTML|
;          #(set_debug error non-type)
P;HTML|
;          #(set_debug fail false)
P;HTML|
;          #(set_debug test true)
P;HTML|
;          #(set_debug test false)
P;HTML|
;          #(set_debug fail false)

; #( : user #(load_metta_file &self tests/baseline_compat/hyperon-mettalog_sanity/sequential_tests.metta) )
P;HTML|
;                #(track_load_into_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/sequential_tests.metta)
P;HTML|
;                       #(load_answer_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/sequential_tests.metta.answers /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/sequential_tests.metta)
P;HTML|
;                        #( = 1 "[()]" )
P;HTML|
;                        #( = 2 "[(Error (assertEqualToResult (sequential ((do (foo $x)) (get-state (State 4)))) (4)) " )
P;HTML|
;                         #( = 2 "Expected: [4]" )
P;HTML|
;                         #( = 2 "Got: [(sequential ((do (sequential ((do (State 4)) 2))) 4)), (sequential ((do (sequential ((do (State 4)) 1))) 4)), (sequential ((do (sequential ((do (State 4)) 4))) 4)), (sequential ((do (sequential ((do (State 4)) 3))) 4))]" )
P;HTML|
;                          #( = 3 "Missed result: 4)]" )
P;HTML|
;                          #( = 3 "0.04user 0.01system 0:00.06elapsed 98%CPU (0avgtext+0avgdata 27864maxresident)k" )
P;HTML|
;                          #( = 3 "0inputs+0outputs (0major+3378minor)pagefaults 0swaps" )
P;HTML|
;                        #(load_answer_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/sequential_tests.metta.answers /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/sequential_tests.metta)

;;;; setup
<span class="ansi38-013099040"
>!(bind! &var (new-state 0))

</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-255165000"
> (= (increment)  
  (sequential ((do (change-state! &var (+ 1 (get-state &var)))) (get-state &var))))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(increment, 1, 0, [], 'AnyRet', [], x(doeval, eager), [increment], [sequential, [[do, ['change-state!', '&var', [+, 1, ['get-state', '&var']]]], ['get-state', '&var']]]).

</span><span class="ansi36"
>transpiler_stub_created(increment/1).

</span>; % ######### warning: creating stub for:increment
<span class="ansi36"
>transpiler_stub_created('get-state'/2).

</span>; % ######### warning: creating stub for:'get-state'
<span class="ansi36"
>transpiler_stub_created('change-state!'/3).

</span>; % ######### warning: creating stub for:'change-state!'
<span class="ansi36"
>transpiler_stub_created(do/2).

</span>; % ######### warning: creating stub for:do
<span class="ansi36"
>transpiler_stub_created(sequential/2).

</span>; % ######### warning: creating stub for:sequential
<span class="ansi35"
>A=[B, 'StateMonad', arg('change-state!', 1), C, 'Number', val('&var')].
D=[E, 'StateMonad', arg('get-state', 1), F, 'Number', val('&var')].
G=['Number', arg(+, 2), '%Var', arg('get-state', 0)].
H=['%Var', arg('change-state!', 2), 'Number', arg(+, 0)].
I=['Expression', arg(do, 1), J, 'StateMonad', arg('change-state!', 0)].
K=['%Undefined%', arg(do, 0)].
L=[M, 'StateMonad', arg('get-state', 1), N, 'Number', val('&var')].
O=['%Var', arg('get-state', 0)].
P=['Expression', arg(sequential, 1), val([K, O]), val(list([K, O]))].
Q=['%Undefined%', arg(sequential, 0)].
R=[val(is_p1(true, Q)), val([is_p1, [], Q]), arg(increment, 0)].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>increment</span></span>]</span>, 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>A</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'get-state'</span></span>)</span>, 
        <span class="pl-var"
>B</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>D</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>+</span></span>)</span>, <span class="pl-int"
>1</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>2</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>E</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'change-state!'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>0</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>3</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>F</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>do</span></span>)</span>, 
        <span class="pl-var"
>E</span>]], 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>G</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>H</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'get-state'</span></span>)</span>, 
        <span class="pl-var"
>G</span>]], 
    [ <span class="pl-atom"
>assign</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>8</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>list</span>(<span class="pl-args"
><span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-compound"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-ellipsis"
>...</span></span>)</span>|<span class="pl-ellipsis"
>...</span></span>]</span></span>)</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>J</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>sequential</span></span>)</span>, 
        <span class="pl-var"
>I</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>K</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:[].
lazyArgsList:[].
eagerLazyList:[].
typeProps:[].
finalLazyArgs:[].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-compound"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>increment</span></span>)</span></span>]</span>], 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>C</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>D</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'get-state'</span></span>)</span>, 
        <span class="pl-var"
>C</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>E</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>+</span></span>)</span>, <span class="pl-int"
>1</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>3</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>F</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'change-state!'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>4</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>G</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>do</span></span>)</span>, 
        <span class="pl-var"
>F</span>]], 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>H</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>I</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'get-state'</span></span>)</span>, 
        <span class="pl-var"
>H</span>]], 
    [ <span class="pl-atom"
>assign</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>9</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>list</span>(<span class="pl-args"
><span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-compound"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-ellipsis"
>...</span></span>)</span>|<span class="pl-ellipsis"
>...</span></span>]</span></span>)</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>sequential</span></span>)</span>, 
        <span class="pl-var"
>J</span>]]]].&#13;&#10;

</span><span class="ansi36"
>transpiler_depends_on(increment, 1, 'get-state', 2).

</span>Asserting: transpiler_depends_on(increment,1,'get-state',2)
<span class="ansi36"
>transpiler_depends_on(increment, 1, +, 3).

</span>Asserting: transpiler_depends_on(increment,1,+,3)
<span class="ansi36"
>transpiler_depends_on(increment, 1, 'change-state!', 3).

</span>Asserting: transpiler_depends_on(increment,1,'change-state!',3)
<span class="ansi36"
>transpiler_depends_on(increment, 1, do, 2).

</span>Asserting: transpiler_depends_on(increment,1,do,2)
<span class="ansi36"
>transpiler_depends_on(increment, 1, sequential, 2).

</span>Asserting: transpiler_depends_on(increment,1,sequential,2)
<span class="ansi36"
>A=['%Undefined%', arg(sequential, 0), arg(increment, 0), val(is_p1(true, B)), val([is_p1, [], B])].
C=[D, 'StateMonad', arg('change-state!', 1), E, 'Number', val('&var')].
F=[G, 'StateMonad', arg('get-state', 1), H, 'Number', val('&var')].
I=['Number', arg(+, 2), '%Var', arg('get-state', 0)].
J=['%Var', arg('change-state!', 2), 'Number', arg(+, 0)].
K=['Expression', arg(do, 1), L, 'StateMonad', arg('change-state!', 0)].
M=['%Undefined%', arg(do, 0)].
N=[O, 'StateMonad', arg('get-state', 1), P, 'Number', val('&var')].
Q=['%Var', arg('get-state', 0)].
R=['Expression', arg(sequential, 1), val([M, Q]), val(list([M, Q]))].

mc_0__increment(A) :-
    C='&var',
    F='&var',
    'mc_1__get-state'(F, I),
    'mc_2__+'(1, I, J),
    'mc_2__change-state!'(C, J, K),
    mc_1__do(K, M),
    N='&var',
    'mc_1__get-state'(N, Q),
    R=[M, Q],
    mc_1__sequential(R, A).

</span><span class="ansi36"
>
mc_0__increment(A) :-
    B='&var',
    C='&var',
    'mc_1__get-state'(C, D),
    'mc_2__+'(1, D, E),
    'mc_2__change-state!'(B, E, F),
    mc_1__do(F, G),
    H='&var',
    'mc_1__get-state'(H, I),
    J=[G, I],
    mc_1__sequential(J, A).

</span>
;;;; sequential + do
<span class="ansi38-255165000"
> (= (foo 1)  
  (bar $x))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(foo, 2, 0, ['Any'], 'AnyRet', [x(doeval, eager)], x(doeval, eager), [foo, 1], [bar, _x]).

</span><span class="ansi36"
>transpiler_stub_created(foo/2).

</span>; % ######### warning: creating stub for:foo
<span class="ansi36"
>transpiler_stub_created(bar/2).

</span>; % ######### warning: creating stub for:bar
<span class="ansi35"
>A=[arg(bar, 0)].
'_x'=[arg(bar, 1)].
B=[val(is_p1(true, A)), val([is_p1, [], A]), arg(foo, 0)].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>foo</span>, <span class="pl-int"
>1</span></span>]</span>, 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>bar</span></span>)</span>, 
        <span class="pl-var"
>_x</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:[1].
lazyArgsList:[1-eager].
eagerLazyList:[lazy].
typeProps:[x(doeval, eager)].
finalLazyArgs:[x(doeval, eager)].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>foo</span></span>)</span>, 
      <span class="pl-int"
>1</span>]], 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>bar</span></span>)</span>, 
        <span class="pl-var"
>_x</span>]]]].&#13;&#10;

</span><span class="ansi36"
>transpiler_depends_on(foo, 2, bar, 2).

</span>Asserting: transpiler_depends_on(foo,2,bar,2)
<span class="ansi36"
>A=[arg(bar, 0), arg(foo, 0), val(is_p1(true, B)), val([is_p1, [], B])].
'_x'=[arg(bar, 1)].

mc_1__foo(1, A) :-
    mc_1__bar(_x, A).

</span><span class="ansi36"
>
mc_1__foo(1, A) :-
    mc_1__bar(_x, A).

</span>
<span class="ansi38-255165000"
> (= (foo 2)  
  (bar $x))
</span><span class="ansi38-255165005"
>Retracting stub: mc_1__foo(B,C)
</span><span class="ansi36"
>transpiler_clause_store(foo, 2, 1, ['Any'], 'AnyRet', [x(doeval, eager)], x(doeval, eager), [foo, 2], [bar, _x]).

</span><span class="ansi35"
>A=[arg(bar, 0)].
'_x'=[arg(bar, 1)].
B=[val(is_p1(true, A)), val([is_p1, [], A]), arg(foo, 0)].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>foo</span>, <span class="pl-int"
>2</span></span>]</span>, 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>bar</span></span>)</span>, 
        <span class="pl-var"
>_x</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:[2].
lazyArgsList:[2-eager].
eagerLazyList:[lazy].
typeProps:[x(doeval, eager)].
finalLazyArgs:[x(doeval, eager)].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>foo</span></span>)</span>, 
      <span class="pl-int"
>2</span>]], 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>bar</span></span>)</span>, 
        <span class="pl-var"
>_x</span>]]]].&#13;&#10;

</span><span class="ansi36"
>A=[arg(bar, 0), arg(foo, 0), val(is_p1(true, B)), val([is_p1, [], B])].
'_x'=[arg(bar, 1)].

mc_1__foo(2, A) :-
    mc_1__bar(_x, A).

</span><span class="ansi36"
>
mc_1__foo(2, A) :-
    mc_1__bar(_x, A).

</span>
<span class="ansi38-255165000"
> (= (bar 1)  
  (increment))
</span><span class="ansi38-255165005"
>Retracting stub: mc_1__bar(B,C)
</span><span class="ansi36"
>transpiler_clause_store(bar, 2, 0, ['Any'], 'AnyRet', [x(doeval, eager)], x(doeval, eager), [bar, 1], [increment]).

</span><span class="ansi35"
>A=[arg(increment, 0)].
B=[val(is_p1(true, A)), val([is_p1, [], A]), arg(bar, 0)].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>bar</span>, <span class="pl-int"
>1</span></span>]</span>, 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-compound"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>increment</span></span>)</span></span>]</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:[1].
lazyArgsList:[1-eager].
eagerLazyList:[lazy].
typeProps:[x(doeval, eager)].
finalLazyArgs:[x(doeval, eager)].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>bar</span></span>)</span>, 
      <span class="pl-int"
>1</span>]], 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-compound"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>increment</span></span>)</span></span>]</span>]]].&#13;&#10;

</span><span class="ansi36"
>transpiler_depends_on(bar, 2, increment, 1).

</span>Asserting: transpiler_depends_on(bar,2,increment,1)
<span class="ansi36"
>A=[arg(increment, 0), arg(bar, 0), val(is_p1(true, B)), val([is_p1, [], B])].

mc_1__bar(1, A) :-
    mc_0__increment(A).

</span><span class="ansi36"
>
mc_1__bar(1, A) :-
    mc_0__increment(A).

</span>
<span class="ansi38-255165000"
> (= (bar 2)  
  (increment))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(bar, 2, 1, ['Any'], 'AnyRet', [x(doeval, eager)], x(doeval, eager), [bar, 2], [increment]).

</span><span class="ansi35"
>A=[arg(increment, 0)].
B=[val(is_p1(true, A)), val([is_p1, [], A]), arg(bar, 0)].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>bar</span>, <span class="pl-int"
>2</span></span>]</span>, 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-compound"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>increment</span></span>)</span></span>]</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:[2].
lazyArgsList:[2-eager].
eagerLazyList:[lazy].
typeProps:[x(doeval, eager)].
finalLazyArgs:[x(doeval, eager)].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>bar</span></span>)</span>, 
      <span class="pl-int"
>2</span>]], 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-compound"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>increment</span></span>)</span></span>]</span>]]].&#13;&#10;

</span><span class="ansi36"
>A=[arg(increment, 0), arg(bar, 0), val(is_p1(true, B)), val([is_p1, [], B])].

mc_1__bar(2, A) :-
    mc_0__increment(A).

</span><span class="ansi36"
>
mc_1__bar(2, A) :-
    mc_0__increment(A).

</span>
<span class="ansi38-013099040"
>!(assertEqualToResult (sequential ((do (foo $x)) (get-state &var))) (4))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SEQUENTIAL-TESTS.01"
>;; HYPERON-METTALOG-SANITY.SEQUENTIAL-TESTS.01</h3>
; 
; EVAL TEST
; took 0.005 secs. (5.32 milliseconds) 

!(assertEqualToResult (sequential ((do (foo $x)) (get-state &var))) (4))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      (4) 
      (4)))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;;; sequential order
;;;; if sequential order is not fixed, this test has a 1/132 chance of succeeding (10! / 12!)
<span class="ansi38-013099040"
>!(assertEqualToResult (sequential ((do (change-state! &var 0)) (increment) (increment) (increment) (increment) (increment) (increment) (increment) (increment) (increment) (increment) (get-state &var))) (1 2 3 4 5 6 7 8 9 10 10))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SEQUENTIAL-TESTS.02"
>;; HYPERON-METTALOG-SANITY.SEQUENTIAL-TESTS.02</h3>
; 
; EVAL TEST
; took 0.011 secs. (10.80 milliseconds) 

!(assertEqualToResult (sequential ((do (change-state! &var 0)) (increment) (increment) (increment) (increment) (increment) (increment) (increment) (increment) (increment) (increment) (get-state &var))) (1 2 3 4 5 6 7 8 9 10 10))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      (1 2 3 4 5 6 7 8 9 10 10) 
      (1 2 3 4 5 6 7 8 9 10 10)))
</span>
Deterministic: <span class="ansi33"
>()
</span>P;HTML|
;                #( = /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/sequential_tests.metta 0 )
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 2
</span><span class="ansi32"
>Failures: 0
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
P;HTML|
;          #(set_debug transpiler false)
P;HTML|
;          #(set_debug overtime 4.0)
P;HTML|
;          #(set_debug overflow 1000)
P;HTML|
;          #(set_debug eval false)
P;HTML|
;          #(set_debug load silent)
P;HTML|
;          #(set_debug trace-on-load false)
P;HTML|
;          #(set_debug exec false)
P;HTML|
;          #(set_debug error non-type)
P;HTML|
;          #(set_debug fail false)
P;HTML|
;          #(set_debug test true)
P;HTML|
;          #(set_debug test false)
P;HTML|
;          #(set_debug fail false)
[()]
[()]
[()]
P;HTML|
;           #(maybe_halt 7)
<span class="ansi31"
>#(in #(not_compat_io #(maybe_halt 7)) #(unwind #(halt 7)))
</span>
Script done on 2024-12-24 11:36:30+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat/' --timeout=40 --html --repl=false  --test "tests/baseline_compat/hyperon-mettalog_sanity/sequential_tests.metta" --halt=true\033[0m
