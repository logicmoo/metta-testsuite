<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi35 { color: #E850A8; }
.ansi36 { color: #00aaaa; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-12-24 11:37:21+00:00 [COMMAND="timeout --preserve-status --foreground --signal=SIGTERM --kill-after=5s 40 swipl  /home/runner/work/metta-testsuite/metta-testsuite/prolog/metta_lang/metta_interp.pl -- --python=enable -- --timeout=40 --output=./reports/tests_output/baseline-compat/ --html --test tests/baseline_compat/hyperon-mettalog_sanity/sorting_tests_nats_mw.metta --halt=true  --stdin=tty --stdout=tty --stderr=tty" TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;         #(set_debug transpiler false)

P;HTML|
;          #(set_debug overtime 4.0)

P;HTML|
;          #(set_debug overflow 1000)

P;HTML|
;          #(set_debug eval false)

P;HTML|
;          #(set_debug load silent)

P;HTML|
;          #(set_debug trace-on-load false)

P;HTML|
;          #(set_debug exec false)

P;HTML|
;          #(set_debug error non-type)

P;HTML|
;          #(set_debug fail false)

P;HTML|
;          #(set_debug test true)

P;HTML|
;         #(set_debug test false)

P;HTML|
;         #(set_debug fail false)
P;HTML|
;          #(set_debug transpiler false)
P;HTML|
;          #(set_debug overtime 4.0)
P;HTML|
;          #(set_debug overflow 1000)
P;HTML|
;          #(set_debug eval false)
P;HTML|
;          #(set_debug load silent)
P;HTML|
;          #(set_debug trace-on-load false)
P;HTML|
;          #(set_debug exec false)
P;HTML|
;          #(set_debug error non-type)
P;HTML|
;          #(set_debug fail false)
P;HTML|
;          #(set_debug test true)
P;HTML|
;          #(set_debug test false)
P;HTML|
;          #(set_debug fail false)

; #( : user #(load_metta_file &self tests/baseline_compat/hyperon-mettalog_sanity/sorting_tests_nats_mw.metta) )
P;HTML|
;                #(track_load_into_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/sorting_tests_nats_mw.metta)
P;HTML|
;                       #(load_answer_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/sorting_tests_nats_mw.metta.answers /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/sorting_tests_nats_mw.metta)
P;HTML|
;                        #( = 1 "[(Error (import! GroundingSpace-top sorting_tests.metta) Illegal module name: sorting_tests.metta)]" )
P;HTML|
;                        #( = 2 "0.04user 0.01system 0:00.05elapsed 100%CPU (0avgtext+0avgdata 27452maxresident)k" )
P;HTML|
;                         #( = 2 "0inputs+0outputs (0major+3303minor)pagefaults 0swaps" )
P;HTML|
;                        #(load_answer_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/sorting_tests_nats_mw.metta.answers /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/sorting_tests_nats_mw.metta)

<span class="ansi38-013099040"
>!(import! &self sorting_tests.metta)

</span>P;HTML|
;                                    #(load_answer_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/sorting_tests.metta.answers /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/sorting_tests.metta)
P;HTML|
;                                    #( = 1 "[(\"============ Test insert ============\")]" )
P;HTML|
;                                     #( = 2 "[()]" )
P;HTML|
;                                     #( = 3 "[()]" )
P;HTML|
;                                      #( = 4 "[()]" )
P;HTML|
;                                      #( = 5 "[True]" )
P;HTML|
;                                      #( = 6 "[(\"============ Test sort ============\")]" )
P;HTML|
;                                       #( = 7 "[()]" )
P;HTML|
;                                       #( = 8 "[()]" )
P;HTML|
;                                        #( = 9 "[()]" )
P;HTML|
;                                        #( = 10 "[(\"============ Test elem ============\")]" )
P;HTML|
;                                        #( = 11 "[()]" )
P;HTML|
;                                         #( = 12 "[()]" )
P;HTML|
;                                         #( = 13 "[(\"============ Test uniq ============\")]" )
P;HTML|
;                                         #( = 14 "[()]" )
P;HTML|
;                                         #( = 15 "[()]" )
P;HTML|
;                                         #( = 16 "[(\"============ Test insert_uniq ============\")]" )
P;HTML|
;                                         #( = 17 "[()]" )
P;HTML|
;                                         #( = 18 "[()]" )
P;HTML|
;                                         #( = 19 "[()]" )
P;HTML|
;                                         #( = 20 "0.25user 0.01system 0:00.27elapsed 99%CPU (0avgtext+0avgdata 28380maxresident)k" )
P;HTML|
;                                         #( = 20 "0inputs+0outputs (0major+3503minor)pagefaults 0swaps" )
P;HTML|
;                                    #(load_answer_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/sorting_tests.metta.answers /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/sorting_tests.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Definition of a List data structure with various methods for it. ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Declaration of List data type and constructors
<span class="ansi38-255165000"
> (: List (-> $a Type))
</span><span class="ansi38-255165000"
> (: Nil (List $a))
</span><span class="ansi38-255165000"
> (: Cons (-> $a (List $a) (List $a)))
</span>;;;; Insert an element to a presumably sorted list, remains sorted.
<span class="ansi38-255165000"
> (: insert (-> $a (List $a) (List $a)))
</span><span class="ansi38-255165000"
> (= (insert $x Nil)  
  (Cons $x Nil))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(insert, 3, 0, ['Number', ['List', 'Number']], ['List', 'Number'], [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [insert, _x, 'Nil'], ['Cons', _x, 'Nil']).

</span><span class="ansi36"
>transpiler_stub_created(insert/3).

</span>; % ######### warning: creating stub for:insert
<span class="ansi36"
>transpiler_stub_created('Cons'/3).

</span>; % ######### warning: creating stub for:'Cons'
<span class="ansi35"
>'_x'=['%Var', arg('Cons', 1), arg(insert, 1)].
A=[B, 'List', arg('Cons', 2), C, D, E, val('Nil'), F, G].
H=[I, 'List', arg('Cons', 0)].
J=[val(is_p1(true, H)), val([is_p1, [], H]), K, 'List', arg(insert, 0)].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>insert</span>, <span class="pl-var"
>_x</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>A</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_x'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>0</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:[_x, 'Nil'].
lazyArgsList:[_x-eager, 'Nil'-eager].
eagerLazyList:[eager, lazy].
typeProps:[x(doeval, eager), x(doeval, eager)].
finalLazyArgs:[x(doeval, eager), x(doeval, eager)].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>insert</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_x'</span></span>)</span>, <span class="pl-atom"
>'Nil'</span>]], 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_x'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>]]]].&#13;&#10;

</span><span class="ansi36"
>transpiler_depends_on(insert, 3, 'Cons', 3).

</span>Asserting: transpiler_depends_on(insert,3,'Cons',3)
<span class="ansi36"
>'_x'=['%Var', arg('Cons', 1), arg(insert, 1)].
A=[B, 'List', arg('Cons', 0), C, arg(insert, 0), val(is_p1(true, D)), val([is_p1, [], D]), E].
F=[G, 'List', arg('Cons', 2), H, I, J, val('Nil'), K, L].

mc_2__insert(_x, 'Nil', A) :-
    F='Nil',
    mc_2__Cons(_x, F, A).

</span><span class="ansi36"
>
mc_2__insert(_x, 'Nil', A) :-
    B='Nil',
    mc_2__Cons(_x, B, A).

</span>
<span class="ansi38-255165000"
> (= (insert $x (Cons $head $tail))  
  (if 
    (lessThan $x $head) 
    (Cons $x 
      (Cons $head $tail)) 
    (Cons $head 
      (insert $x $tail))))
</span><span class="ansi38-255165005"
>Retracting stub: mc_2__insert(B,C,D)
</span><span class="ansi36"
>transpiler_clause_store(insert, 3, 1, ['Number', ['List', 'Number']], ['List', 'Number'], [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [insert, _x, ['Cons', _head, _tail]], [if, [lessThan, _x, _head], ['Cons', _x, ['Cons', _head, _tail]], ['Cons', _head, [insert, _x, _tail]]]).

</span><span class="ansi36"
>transpiler_stub_created(lessThan/3).

</span>; % ######### warning: creating stub for:lessThan
<span class="ansi35"
>'_x'=['%Var', arg(insert, 1), arg('Cons', 1), arg(lessThan, 1)].
'_head'=['%Var', arg('Cons', 1), arg(lessThan, 2)].
'_tail'=[A, 'List', arg(insert, 2), B, C, arg('Cons', 2), D].
E=['Bool', arg(lessThan, 0)].
F=[G, 'List', arg('Cons', 2), H, I, arg('Cons', 0)].
J=[K, 'List', arg('Cons', 0)].
L=[M, 'List', arg(insert, 0), N, val(is_p1(true, J)), val([is_p1, [], J]), O].
P=[val([is_p1, [], Q]), val(is_p1(true, Q)), val([is_p1, [], J]), val(is_p1(true, J)), N, R, S, 'List', arg(insert, 0), T, O, val(L), val(U)].
V=[W, 'List', arg('Cons', 2), X, Y, arg(insert, 0)].
Q=[Z, 'List', arg('Cons', 0)].
U=[val(L), O, A1, 'List', arg(insert, 0), R, N, val(is_p1(true, J)), val([is_p1, [], J]), val(is_p1(true, Q)), val([is_p1, [], Q]), T].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>insert</span>, 
    <span class="pl-var"
>_x</span>, 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'Cons'</span>, <span class="pl-var"
>_head</span>|<span class="pl-ellipsis"
>...</span></span>]</span>], 
  [ [ <span class="pl-atom"
>prolog_if</span>, 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>A</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>lessThan</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>_head</span>]], 
        [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>native</span>(<span class="pl-args"
><span class="pl-atom"
>is_True</span></span>)</span>, 
          <span class="pl-var"
>A</span>]], 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>B</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-var"
>_head</span>, <span class="pl-var"
>_tail</span>]], 
        [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>C</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>B</span>]], 
        [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>D</span>, 
          <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>], 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>E</span>|<span class="pl-ellipsis"
>...</span></span>]</span>], 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>F</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>insert</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>_tail</span>]], 
        [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>G</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-var"
>_head</span>, <span class="pl-var"
>F</span>]], 
        [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>H</span>, 
          <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>], 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>E</span>|<span class="pl-ellipsis"
>...</span></span>]</span>]]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:[_x, ['Cons', _head, _tail]].
lazyArgsList:[_x-eager, ['Cons', _head, _tail]-eager].
eagerLazyList:[eager, lazy].
typeProps:[x(doeval, eager), x(doeval, eager)].
finalLazyArgs:[x(doeval, eager), x(doeval, eager)].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>insert</span></span>)</span>, 
      <span class="pl-var"
>_x</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'Cons'</span>, <span class="pl-var"
>_head</span>|<span class="pl-ellipsis"
>...</span></span>]</span>]], 
  [ [ <span class="pl-atom"
>prolog_if</span>, 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>B</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>lessThan</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>_head</span>]], 
        [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>native</span>(<span class="pl-args"
><span class="pl-atom"
>is_True</span></span>)</span>, 
          <span class="pl-var"
>B</span>]], 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>C</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-var"
>_head</span>, <span class="pl-var"
>_tail</span>]], 
        [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>D</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>C</span>]], 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>A</span>|<span class="pl-ellipsis"
>...</span></span>]</span>], 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>E</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>insert</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>_tail</span>]], 
        [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>F</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-var"
>_head</span>, <span class="pl-var"
>E</span>]], 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>A</span>|<span class="pl-ellipsis"
>...</span></span>]</span>]]]].&#13;&#10;

</span><span class="ansi36"
>transpiler_depends_on(insert, 3, lessThan, 3).

</span>Asserting: transpiler_depends_on(insert,3,lessThan,3)
<span class="ansi36"
>'_x'=['%Var', arg(insert, 1), arg('Cons', 1), arg(lessThan, 1)].
'_head'=['%Var', arg('Cons', 1), arg(lessThan, 2)].
'_tail'=[A, 'List', arg(insert, 2), B, C, arg('Cons', 2), D, E, F, G, H].
I=[J, K, L, 'List', arg('Cons', 0), M, N, O, P, Q, arg(insert, 0), R, S, val([is_p1, [], T]), val(is_p1(true, T)), val([is_p1, [], U]), val(is_p1(true, U)), V, W, X, Y, Z, val(A1), val(B1), val(C1), D1, val(E1), F1].
G1=['Bool', arg(lessThan, 0)].
H1=[I1, 'List', arg('Cons', 2), J1, K1, arg('Cons', 0)].
C1=[val(B1), val(A1), Z, Y, X, W, V, val(is_p1(true, U)), val([is_p1, [], U]), val(is_p1(true, T)), val([is_p1, [], T]), L1, 'List', arg(insert, 0), O, N, M1, arg('Cons', 0), D1, S].
N1=[O1, 'List', arg('Cons', 2), P1, Q1, arg(insert, 0)].
E1=[D1, val(C1), val(B1), val(A1), Z, Y, X, W, V, val(is_p1(true, U)), val([is_p1, [], U]), val(is_p1(true, T)), val([is_p1, [], T]), S, R1, 'List', arg(insert, 0), P, O, N, K, J, S1, arg('Cons', 0), F1, R, M].

mc_2__insert(_x, ['Cons', _head, _tail], I) :-
    (   mc_2__lessThan(_x, _head, G1),
        is_True(G1)
    *-> mc_2__Cons(_head, _tail, H1),
        mc_2__Cons(_x, H1, C1),
        I=C1
    ;   mc_2__insert(_x, _tail, N1),
        mc_2__Cons(_head, N1, E1),
        I=E1
    ).

</span><span class="ansi36"
>
mc_2__insert(_x, ['Cons', _head, _tail], A) :-
    (   mc_2__lessThan(_x, _head, B),
        is_True(B)
    *-> mc_2__Cons(_head, _tail, C),
        mc_2__Cons(_x, C, D),
        A=D
    ;   mc_2__insert(_x, _tail, E),
        mc_2__Cons(_head, E, F),
        A=F
    ).

</span>
;;;; Sort a list
<span class="ansi38-255165000"
> (: sort (-> (List $a) (List $a)))
</span><span class="ansi38-255165000"
> (= (sort Nil)  Nil)
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(sort, 2, 0, [['List', A]], ['List', A], [x(doeval, eager)], x(doeval, eager), [sort, 'Nil'], 'Nil').

</span><span class="ansi36"
>transpiler_stub_created(sort/2).

</span>; % ######### warning: creating stub for:sort
<span class="ansi35"
>A=[val(is_p1(true, 'Nil')), val([is_p1, [], 'Nil']), B, 'List', arg(sort, 0)].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>sort</span>, <span class="pl-atom"
>'Nil'</span></span>]</span>, 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:['Nil'].
lazyArgsList:['Nil'-eager].
eagerLazyList:[lazy].
typeProps:[x(doeval, eager)].
finalLazyArgs:[x(doeval, eager)].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>sort</span></span>)</span>, 
      <span class="pl-atom"
>'Nil'</span>]], 
  [ [ assign,  A   ,'Nil' ]]].&#13;&#10;

</span><span class="ansi36"
>A=[B, 'List', C, val('Nil'), D, E, F, arg(sort, 0), val(is_p1(true, 'Nil')), val([is_p1, [], 'Nil']), G].

mc_1__sort('Nil', A) :-
    A='Nil'.

</span><span class="ansi36"
>
mc_1__sort('Nil', A) :-
    A='Nil'.

</span>
<span class="ansi38-255165000"
> (= (sort (Cons $head $tail))  
  (insert $head 
    (sort $tail)))
</span><span class="ansi38-255165005"
>Retracting stub: mc_1__sort(B,C)
</span><span class="ansi36"
>transpiler_clause_store(sort, 2, 1, [['List', A]], ['List', A], [x(doeval, eager)], x(doeval, eager), [sort, ['Cons', _head, _tail]], [insert, _head, [sort, _tail]]).

</span><span class="ansi35"
>'_head'=['%Var', arg(insert, 1)].
'_tail'=[A, 'List', arg(sort, 1), B].
C=[D, 'List', arg(insert, 2), E, F, arg(sort, 0)].
G=[H, 'List', arg(insert, 0)].
I=[val(is_p1(true, G)), val([is_p1, [], G]), J, 'List', arg(sort, 0)].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>sort</span>, 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'Cons'</span>, <span class="pl-var"
>_head</span>|<span class="pl-ellipsis"
>...</span></span>]</span>], 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>sort</span></span>)</span>, 
        <span class="pl-var"
>_tail</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>insert</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_head'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>0</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:[['Cons', _head, _tail]].
lazyArgsList:[['Cons', _head, _tail]-eager].
eagerLazyList:[lazy].
typeProps:[x(doeval, eager)].
finalLazyArgs:[x(doeval, eager)].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>sort</span></span>)</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'Cons'</span>, <span class="pl-var"
>_head</span>|<span class="pl-ellipsis"
>...</span></span>]</span>]], 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>sort</span></span>)</span>, 
        <span class="pl-var"
>_tail</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>insert</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_head'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>]]]].&#13;&#10;

</span><span class="ansi36"
>transpiler_depends_on(sort, 2, insert, 3).

</span>Asserting: transpiler_depends_on(sort,2,insert,3)
<span class="ansi36"
>'_head'=['%Var', arg(insert, 1)].
'_tail'=[A, 'List', arg(sort, 1), B, C, D].
E=[F, 'List', arg(insert, 0), G, arg(sort, 0), val(is_p1(true, H)), val([is_p1, [], H]), I].
J=[K, 'List', arg(insert, 2), L, M, arg(sort, 0)].

mc_1__sort(['Cons', _head, _tail], E) :-
    mc_1__sort(_tail, J),
    mc_2__insert(_head, J, E).

</span><span class="ansi36"
>
mc_1__sort(['Cons', _head, _tail], A) :-
    mc_1__sort(_tail, B),
    mc_2__insert(_head, B, A).

</span>
;;;; Check if an element is in a list (sorted or not)
<span class="ansi38-255165000"
> (: elem (-> $a (List $a) Bool))
</span><span class="ansi38-255165000"
> (= (elem $x Nil)  False)
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(elem, 3, 0, ['Number', ['List', 'Number']], 'Bool', [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [elem, _x, 'Nil'], 'False').

</span><span class="ansi36"
>transpiler_stub_created(elem/3).

</span>; % ######### warning: creating stub for:elem
<span class="ansi35"
>'_x'=['%Var', arg(elem, 1)].
A=[val(is_p1(true, 'False')), val([is_p1, [], 'False']), 'Bool', arg(elem, 0)].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>elem</span>, <span class="pl-var"
>_x</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:[_x, 'Nil'].
lazyArgsList:[_x-eager, 'Nil'-eager].
eagerLazyList:[lazy, lazy].
typeProps:[x(doeval, eager), x(doeval, eager)].
finalLazyArgs:[x(doeval, eager), x(doeval, eager)].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>elem</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_x'</span></span>)</span>, <span class="pl-atom"
>'Nil'</span>]], 
  [ [ assign ,   A   ,'False']]].&#13;&#10;

</span><span class="ansi36"
>'_x'=['%Var', arg(elem, 1)].
A=['Bool', arg(elem, 0), val(is_p1(true, 'False')), val([is_p1, [], 'False'])].

mc_2__elem(_x, 'Nil', A) :-
    A='False'.

</span><span class="ansi36"
>
mc_2__elem(_x, 'Nil', A) :-
    A='False'.

</span>
<span class="ansi38-255165000"
> (= (elem $x (Cons $head $tail))  
  (if 
    (== $x $head) True 
    (elem $x $tail)))
</span><span class="ansi38-255165005"
>Retracting stub: mc_2__elem(B,C,D)
</span><span class="ansi36"
>transpiler_clause_store(elem, 3, 1, ['Number', ['List', 'Number']], 'Bool', [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [elem, _x, ['Cons', _head, _tail]], [if, [==, _x, _head], 'True', [elem, _x, _tail]]).

</span><span class="ansi35"
>'_x'=['%Var', arg(elem, 1), arg(==, 1)].
'_head'=['%Var', arg(==, 2)].
'_tail'=[A, 'List', arg(elem, 2), B].
C=['Bool'].
D=['Bool', arg(elem, 0), val(is_p1(true, 'True')), val([is_p1, [], 'True'])].
E=[val([is_p1, [], F]), val(is_p1(true, F)), val([is_p1, [], 'True']), val(is_p1(true, 'True')), 'Bool', arg(elem, 0), val(D), val(G)].
F=['Bool', arg(elem, 0)].
G=[val(D), 'Bool', arg(elem, 0), val(is_p1(true, 'True')), val([is_p1, [], 'True']), val(is_p1(true, F)), val([is_p1, [], F])].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>elem</span>, 
    <span class="pl-var"
>_x</span>, 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'Cons'</span>, <span class="pl-var"
>_head</span>|<span class="pl-ellipsis"
>...</span></span>]</span>], 
  [ [ <span class="pl-atom"
>prolog_if</span>, 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>A</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>==</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>_head</span>]], 
        [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>native</span>(<span class="pl-args"
><span class="pl-atom"
>is_True</span></span>)</span>, 
          <span class="pl-var"
>A</span>]], 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>B</span>, 
          <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>], 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>C</span>|<span class="pl-ellipsis"
>...</span></span>]</span>], 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>D</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>elem</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>_tail</span>]], 
        [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>E</span>, 
          <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>], 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>C</span>|<span class="pl-ellipsis"
>...</span></span>]</span>]]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:[_x, ['Cons', _head, _tail]].
lazyArgsList:[_x-eager, ['Cons', _head, _tail]-eager].
eagerLazyList:[eager, lazy].
typeProps:[x(doeval, eager), x(doeval, eager)].
finalLazyArgs:[x(doeval, eager), x(doeval, eager)].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>elem</span></span>)</span>, 
      <span class="pl-var"
>_x</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'Cons'</span>, <span class="pl-var"
>_head</span>|<span class="pl-ellipsis"
>...</span></span>]</span>]], 
  [ [ <span class="pl-atom"
>prolog_if</span>, 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>B</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>==</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>_head</span>]], 
        [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>native</span>(<span class="pl-args"
><span class="pl-atom"
>is_True</span></span>)</span>, 
          <span class="pl-var"
>B</span>]], 
      [ [ assign,  C   ,'True'],
        [ assign,  A   ,  C   ]], 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>D</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>elem</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>_tail</span>]], 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>A</span>|<span class="pl-ellipsis"
>...</span></span>]</span>]]]].&#13;&#10;

</span><span class="ansi36"
>transpiler_depends_on(elem, 3, ==, 3).

</span>Asserting: transpiler_depends_on(elem,3,==,3)
<span class="ansi36"
>'_x'=['%Var', arg(elem, 1), arg(==, 1)].
'_head'=['%Var', arg(==, 2)].
'_tail'=[A, 'List', arg(elem, 2), B, C, D].
E=['Bool', arg(elem, 0), val([is_p1, [], F]), val(is_p1(true, F)), val([is_p1, [], 'True']), val(is_p1(true, 'True')), val(G), val(H), val(I), val(J)].
K=['Bool'].
J=[val(H), val(G), val(is_p1(true, 'True')), val([is_p1, [], 'True']), val(is_p1(true, F)), val([is_p1, [], F]), 'Bool', arg(elem, 0)].
I=[val(H), val(G), val(is_p1(true, 'True')), val([is_p1, [], 'True']), val(is_p1(true, F)), val([is_p1, [], F]), 'Bool', arg(elem, 0)].

mc_2__elem(_x, ['Cons', _head, _tail], E) :-
    (   'mc_2__=='(_x, _head, K),
        is_True(K)
    *-> J='True',
        E=J
    ;   mc_2__elem(_x, _tail, I),
        E=I
    ).

</span><span class="ansi36"
>
mc_2__elem(_x, ['Cons', _head, _tail], A) :-
    (   'mc_2__=='(_x, _head, B),
        is_True(B)
    *-> C='True',
        A=C
    ;   mc_2__elem(_x, _tail, D),
        A=D
    ).

</span>
;;;; Remove duplicates from a list
<span class="ansi38-255165000"
> (: uniq_ (-> (List $a) (List $a) (List $a)))
</span><span class="ansi38-255165000"
> (= (uniq_ $acc Nil)  Nil)
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(uniq_, 3, 0, [['List', A], ['List', A]], ['List', A], [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [uniq_, _acc, 'Nil'], 'Nil').

</span><span class="ansi36"
>transpiler_stub_created(uniq_/3).

</span>; % ######### warning: creating stub for:uniq_
<span class="ansi35"
>'_acc'=[A, 'List', arg(uniq_, 1), B].
C=[val(is_p1(true, 'Nil')), val([is_p1, [], 'Nil']), D, 'List', arg(uniq_, 0)].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>uniq_</span>, <span class="pl-var"
>_acc</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:[_acc, 'Nil'].
lazyArgsList:[_acc-eager, 'Nil'-eager].
eagerLazyList:[lazy, lazy].
typeProps:[x(doeval, eager), x(doeval, eager)].
finalLazyArgs:[x(doeval, eager), x(doeval, eager)].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>uniq_</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_acc'</span></span>)</span>, <span class="pl-atom"
>'Nil'</span>]], 
  [ [ assign,  A   ,'Nil' ]]].&#13;&#10;

</span><span class="ansi36"
>'_acc'=[A, 'List', arg(uniq_, 1), B, C, D].
E=[F, 'List', G, val('Nil'), H, I, J, arg(uniq_, 0), val(is_p1(true, 'Nil')), val([is_p1, [], 'Nil']), K].

mc_2__uniq_(_acc, 'Nil', E) :-
    E='Nil'.

</span><span class="ansi36"
>
mc_2__uniq_(_acc, 'Nil', A) :-
    A='Nil'.

</span>
<span class="ansi38-255165000"
> (= (uniq_ $acc (Cons $head $tail))  
  (if 
    (elem $head $acc) 
    (uniq_ $acc $tail) 
    (Cons $head 
      (uniq_ 
        (Cons $head $acc) $tail))))
</span><span class="ansi38-255165005"
>Retracting stub: mc_2__uniq_(B,C,D)
</span><span class="ansi36"
>transpiler_clause_store(uniq_, 3, 1, [['List', A], ['List', A]], ['List', A], [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [uniq_, _acc, ['Cons', _head, _tail]], [if, [elem, _head, _acc], [uniq_, _acc, _tail], ['Cons', _head, [uniq_, ['Cons', _head, _acc], _tail]]]).

</span><span class="ansi35"
>'_acc'=[A, 'List', arg('Cons', 2), B, C, arg(uniq_, 1), D, E, arg(elem, 2), F, G, H].
'_head'=['%Var', arg('Cons', 1), arg(elem, 1)].
'_tail'=[I, 'List', arg(uniq_, 2), J, K, L].
M=['Bool', arg(elem, 0)].
N=[O, 'List', arg(uniq_, 0)].
P=[Q, 'List', arg(uniq_, 0), R, val(is_p1(true, N)), val([is_p1, [], N]), S].
T=[val([is_p1, [], U]), val(is_p1(true, U)), val([is_p1, [], N]), val(is_p1(true, N)), R, V, W, 'List', arg(uniq_, 0), X, S, val(P), val(Y)].
Z=[A1, 'List', arg(uniq_, 1), B1, C1, arg('Cons', 0)].
D1=[E1, 'List', arg('Cons', 2), F1, G1, arg(uniq_, 0)].
U=[H1, 'List', arg('Cons', 0)].
Y=[val(P), S, I1, 'List', arg(uniq_, 0), V, R, val(is_p1(true, N)), val([is_p1, [], N]), val(is_p1(true, U)), val([is_p1, [], U]), X].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>uniq_</span>, 
    <span class="pl-var"
>_acc</span>, 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'Cons'</span>, <span class="pl-var"
>_head</span>|<span class="pl-ellipsis"
>...</span></span>]</span>], 
  [ [ <span class="pl-atom"
>prolog_if</span>, 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>A</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>elem</span></span>)</span>, <span class="pl-var"
>_head</span>, <span class="pl-var"
>_acc</span>]], 
        [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>native</span>(<span class="pl-args"
><span class="pl-atom"
>is_True</span></span>)</span>, 
          <span class="pl-var"
>A</span>]], 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>B</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>uniq_</span></span>)</span>, <span class="pl-var"
>_acc</span>, <span class="pl-var"
>_tail</span>]], 
        [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>C</span>, 
          <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>], 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>D</span>|<span class="pl-ellipsis"
>...</span></span>]</span>], 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>E</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-var"
>_head</span>, <span class="pl-var"
>_acc</span>]], 
        [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>F</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>uniq_</span></span>)</span>, <span class="pl-var"
>E</span>, <span class="pl-var"
>_tail</span>]], 
        [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>G</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-var"
>_head</span>, <span class="pl-var"
>F</span>]], 
        [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>H</span>, 
          <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>], 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>D</span>|<span class="pl-ellipsis"
>...</span></span>]</span>]]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:[_acc, ['Cons', _head, _tail]].
lazyArgsList:[_acc-eager, ['Cons', _head, _tail]-eager].
eagerLazyList:[eager, lazy].
typeProps:[x(doeval, eager), x(doeval, eager)].
finalLazyArgs:[x(doeval, eager), x(doeval, eager)].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>uniq_</span></span>)</span>, 
      <span class="pl-var"
>_acc</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'Cons'</span>, <span class="pl-var"
>_head</span>|<span class="pl-ellipsis"
>...</span></span>]</span>]], 
  [ [ <span class="pl-atom"
>prolog_if</span>, 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>B</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>elem</span></span>)</span>, <span class="pl-var"
>_head</span>, <span class="pl-var"
>_acc</span>]], 
        [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>native</span>(<span class="pl-args"
><span class="pl-atom"
>is_True</span></span>)</span>, 
          <span class="pl-var"
>B</span>]], 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>C</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>uniq_</span></span>)</span>, <span class="pl-var"
>_acc</span>, <span class="pl-var"
>_tail</span>]], 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>A</span>|<span class="pl-ellipsis"
>...</span></span>]</span>], 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>D</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-var"
>_head</span>, <span class="pl-var"
>_acc</span>]], 
        [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>E</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>uniq_</span></span>)</span>, <span class="pl-var"
>D</span>, <span class="pl-var"
>_tail</span>]], 
        [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>F</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-var"
>_head</span>, <span class="pl-var"
>E</span>]], 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>A</span>|<span class="pl-ellipsis"
>...</span></span>]</span>]]]].&#13;&#10;

</span><span class="ansi36"
>transpiler_depends_on(uniq_, 3, elem, 3).

</span>Asserting: transpiler_depends_on(uniq_,3,elem,3)
<span class="ansi36"
>transpiler_depends_on(uniq_, 3, 'Cons', 3).

</span>Asserting: transpiler_depends_on(uniq_,3,'Cons',3)
<span class="ansi36"
>'_acc'=[A, 'List', arg('Cons', 2), B, C, arg(uniq_, 1), D, E, arg(elem, 2), F, G, H, I, J, K, L, M, N, O, P].
'_head'=['%Var', arg('Cons', 1), arg(elem, 1)].
'_tail'=[Q, 'List', arg(uniq_, 2), R, S, T, U, V, W, X].
Y=[Z, 'List', arg('Cons', 0), A1, B1, C1, D1, E1, arg(uniq_, 0), F1, G1, val([is_p1, [], H1]), val(is_p1(true, H1)), val([is_p1, [], I1]), val(is_p1(true, I1)), J1, K1, L1, M1, N1, val(O1), val(P1), val(Q1), R1, val(S1), T1].
U1=['Bool', arg(elem, 0)].
Q1=[val(P1), val(O1), N1, M1, L1, K1, J1, val(is_p1(true, I1)), val([is_p1, [], I1]), val(is_p1(true, H1)), val([is_p1, [], H1]), C1, B1, V1, 'List', arg(uniq_, 0), R1, G1].
W1=[X1, 'List', arg(uniq_, 1), Y1, Z1, arg('Cons', 0)].
A2=[B2, 'List', arg('Cons', 2), C2, D2, arg(uniq_, 0)].
S1=[R1, val(Q1), val(P1), val(O1), N1, M1, L1, K1, J1, val(is_p1(true, I1)), val([is_p1, [], I1]), val(is_p1(true, H1)), val([is_p1, [], H1]), G1, E2, 'List', arg(uniq_, 0), D1, C1, B1, A1, F2, arg('Cons', 0), T1, F1].

mc_2__uniq_(_acc, ['Cons', _head, _tail], Y) :-
    (   mc_2__elem(_head, _acc, U1),
        is_True(U1)
    *-> mc_2__uniq_(_acc, _tail, Q1),
        Y=Q1
    ;   mc_2__Cons(_head, _acc, W1),
        mc_2__uniq_(W1, _tail, A2),
        mc_2__Cons(_head, A2, S1),
        Y=S1
    ).

</span><span class="ansi36"
>
mc_2__uniq_(_acc, ['Cons', _head, _tail], A) :-
    (   mc_2__elem(_head, _acc, B),
        is_True(B)
    *-> mc_2__uniq_(_acc, _tail, C),
        A=C
    ;   mc_2__Cons(_head, _acc, D),
        mc_2__uniq_(D, _tail, E),
        mc_2__Cons(_head, E, F),
        A=F
    ).

</span>
<span class="ansi38-255165000"
> (: uniq (-> (List $a) (List $a)))
</span><span class="ansi38-255165000"
> (= (uniq $l)  
  (uniq_ Nil $l))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(uniq, 2, 0, [['List', A]], ['List', A], [x(doeval, eager)], x(doeval, eager), [uniq, _l], [uniq_, 'Nil', _l]).

</span><span class="ansi36"
>transpiler_stub_created(uniq/2).

</span>; % ######### warning: creating stub for:uniq
<span class="ansi35"
>'_l'=[A, 'List', arg(uniq_, 2), B, C, arg(uniq, 1), D].
E=[F, 'List', arg(uniq_, 1), G, H, I, val('Nil'), J, K].
L=[M, 'List', arg(uniq_, 0)].
N=[val(is_p1(true, L)), val([is_p1, [], L]), O, 'List', arg(uniq, 0)].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>uniq</span>, <span class="pl-var"
>_l</span></span>]</span>, 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>A</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>uniq_</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>0</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_l'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:[_l].
lazyArgsList:[_l-eager].
eagerLazyList:[eager].
typeProps:[x(doeval, eager)].
finalLazyArgs:[x(doeval, eager)].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>uniq</span></span>)</span>, 
      <span class="pl-var"
>_l</span>]], 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>uniq_</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_l'</span></span>)</span>]]]].&#13;&#10;

</span><span class="ansi36"
>transpiler_depends_on(uniq, 2, uniq_, 3).

</span>Asserting: transpiler_depends_on(uniq,2,uniq_,3)
<span class="ansi36"
>'_l'=[A, 'List', arg(uniq_, 2), B, C, arg(uniq, 1), D, E, F, G, H].
I=[J, 'List', arg(uniq_, 0), K, arg(uniq, 0), val(is_p1(true, L)), val([is_p1, [], L]), M].
N=[O, 'List', arg(uniq_, 1), P, Q, R, val('Nil'), S, T].

mc_1__uniq(_l, I) :-
    N='Nil',
    mc_2__uniq_(N, _l, I).

</span><span class="ansi36"
>
mc_1__uniq(_l, A) :-
    B='Nil',
    mc_2__uniq_(B, _l, A).

</span>
;;;; Insert an element in a presumably sorted list without duplicate.
;;;; Only insert if the element is not already in the list as to produce
;;;; a sorted list without duplicate.
<span class="ansi38-255165000"
> (: insert_uniq (-> $a (List $a) (List $a)))
</span><span class="ansi38-255165000"
> (= (insert_uniq $x Nil)  
  (Cons $x Nil))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(insert_uniq, 3, 0, ['Number', ['List', 'Number']], ['List', 'Number'], [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [insert_uniq, _x, 'Nil'], ['Cons', _x, 'Nil']).

</span><span class="ansi36"
>transpiler_stub_created(insert_uniq/3).

</span>; % ######### warning: creating stub for:insert_uniq
<span class="ansi35"
>'_x'=['%Var', arg('Cons', 1), arg(insert_uniq, 1)].
A=[B, 'List', arg('Cons', 2), C, D, E, val('Nil'), F, G].
H=[I, 'List', arg('Cons', 0)].
J=[val(is_p1(true, H)), val([is_p1, [], H]), K, 'List', arg(insert_uniq, 0)].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>insert_uniq</span>, <span class="pl-var"
>_x</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>A</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_x'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>0</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:[_x, 'Nil'].
lazyArgsList:[_x-eager, 'Nil'-eager].
eagerLazyList:[eager, lazy].
typeProps:[x(doeval, eager), x(doeval, eager)].
finalLazyArgs:[x(doeval, eager), x(doeval, eager)].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>insert_uniq</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_x'</span></span>)</span>, <span class="pl-atom"
>'Nil'</span>]], 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_x'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>]]]].&#13;&#10;

</span><span class="ansi36"
>transpiler_depends_on(insert_uniq, 3, 'Cons', 3).

</span>Asserting: transpiler_depends_on(insert_uniq,3,'Cons',3)
<span class="ansi36"
>'_x'=['%Var', arg('Cons', 1), arg(insert_uniq, 1)].
A=[B, 'List', arg('Cons', 0), C, arg(insert_uniq, 0), val(is_p1(true, D)), val([is_p1, [], D]), E].
F=[G, 'List', arg('Cons', 2), H, I, J, val('Nil'), K, L].

mc_2__insert_uniq(_x, 'Nil', A) :-
    F='Nil',
    mc_2__Cons(_x, F, A).

</span><span class="ansi36"
>
mc_2__insert_uniq(_x, 'Nil', A) :-
    B='Nil',
    mc_2__Cons(_x, B, A).

</span>
<span class="ansi38-255165000"
> (= (insert_uniq $x (Cons $head $tail))  
  (if 
    (== $x $head) 
    (Cons $head $tail) 
    (if 
      (lessThan $x $head) 
      (Cons $x 
        (Cons $head $tail)) 
      (Cons $head 
        (insert_uniq $x $tail)))))
</span><span class="ansi38-255165005"
>Retracting stub: mc_2__insert_uniq(B,C,D)
</span><span class="ansi36"
>transpiler_clause_store(insert_uniq, 3, 1, ['Number', ['List', 'Number']], ['List', 'Number'], [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [insert_uniq, _x, ['Cons', _head, _tail]], [if, [==, _x, _head], ['Cons', _head, _tail], [if, [lessThan, _x, _head], ['Cons', _x, ['Cons', _head, _tail]], ['Cons', _head, [insert_uniq, _x, _tail]]]]).

</span><span class="ansi35"
>'_x'=['%Var', arg(insert_uniq, 1), arg('Cons', 1), arg(lessThan, 1), arg(==, 1)].
'_head'=['%Var', arg('Cons', 1), arg(lessThan, 2), arg(==, 2)].
'_tail'=[A, 'List', arg(insert_uniq, 2), B, C, arg('Cons', 2), D, E, F].
G=['Bool'].
H=[I, 'List', arg('Cons', 0)].
J=[K, 'List', arg(insert_uniq, 0), L, val(is_p1(true, H)), val([is_p1, [], H]), M].
N=[val(O), val(P), val(is_p1(true, Q)), val([is_p1, [], Q]), val(is_p1(true, R)), val([is_p1, [], R]), val([is_p1, [], H]), val(is_p1(true, H)), L, S, T, 'List', arg(insert_uniq, 0), U, M, val(J), val(V)].
W=['Bool', arg(lessThan, 0)].
X=[Y, 'List', arg('Cons', 2), Z, A1, arg('Cons', 0)].
Q=[B1, 'List', arg('Cons', 0)].
P=[val(is_p1(true, Q)), val([is_p1, [], Q])].
V=[val(J), M, C1, 'List', arg(insert_uniq, 0), S, L, val(is_p1(true, H)), val([is_p1, [], H]), val([is_p1, [], R]), val(is_p1(true, R)), val([is_p1, [], Q]), val(is_p1(true, Q)), val(P), val(O), U].
D1=[E1, 'List', arg('Cons', 2), F1, G1, arg(insert_uniq, 0)].
R=[H1, 'List', arg('Cons', 0)].
O=[val(P), val(is_p1(true, Q)), val([is_p1, [], Q]), val(is_p1(true, R)), val([is_p1, [], R])].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>insert_uniq</span>, 
    <span class="pl-var"
>_x</span>, 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'Cons'</span>, <span class="pl-var"
>_head</span>|<span class="pl-ellipsis"
>...</span></span>]</span>], 
  [ [ <span class="pl-atom"
>prolog_if</span>, 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>A</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>==</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>_head</span>]], 
        [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>native</span>(<span class="pl-args"
><span class="pl-atom"
>is_True</span></span>)</span>, 
          <span class="pl-var"
>A</span>]], 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>B</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-var"
>_head</span>, <span class="pl-var"
>_tail</span>]], 
        [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>C</span>, 
          <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>], 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>D</span>|<span class="pl-ellipsis"
>...</span></span>]</span>], 
      [ [ <span class="pl-atom"
>prolog_if</span>, 
          [ [ <span class="pl-atom"
>assign</span>, 
              <span class="pl-var"
>E</span>, 
              [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>lessThan</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>_head</span>]], 
            [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>native</span>(<span class="pl-args"
><span class="pl-atom"
>is_True</span></span>)</span>, 
              <span class="pl-var"
>E</span>]], 
          [ [ <span class="pl-atom"
>assign</span>, 
              <span class="pl-var"
>F</span>, 
              [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-var"
>_head</span>, <span class="pl-var"
>_tail</span>]], 
            [ <span class="pl-atom"
>assign</span>, 
              <span class="pl-var"
>G</span>, 
              [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>F</span>]], 
            [ <span class="pl-atom"
>assign</span>, 
              <span class="pl-var"
>H</span>, 
              <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>], 
            <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>I</span>|<span class="pl-ellipsis"
>...</span></span>]</span>], 
          [ [ <span class="pl-atom"
>assign</span>, 
              <span class="pl-var"
>J</span>, 
              [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>insert_uniq</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>_tail</span>]], 
            [ <span class="pl-atom"
>assign</span>, 
              <span class="pl-var"
>K</span>, 
              [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-var"
>_head</span>, <span class="pl-var"
>J</span>]], 
            [ <span class="pl-atom"
>assign</span>, 
              <span class="pl-var"
>L</span>, 
              <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>], 
            <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>I</span>|<span class="pl-ellipsis"
>...</span></span>]</span>]], 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>D</span>|<span class="pl-ellipsis"
>...</span></span>]</span>]]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:[_x, ['Cons', _head, _tail]].
lazyArgsList:[_x-eager, ['Cons', _head, _tail]-eager].
eagerLazyList:[eager, lazy].
typeProps:[x(doeval, eager), x(doeval, eager)].
finalLazyArgs:[x(doeval, eager), x(doeval, eager)].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>insert_uniq</span></span>)</span>, 
      <span class="pl-var"
>_x</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'Cons'</span>, <span class="pl-var"
>_head</span>|<span class="pl-ellipsis"
>...</span></span>]</span>]], 
  [ [ <span class="pl-atom"
>prolog_if</span>, 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>B</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>==</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>_head</span>]], 
        [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>native</span>(<span class="pl-args"
><span class="pl-atom"
>is_True</span></span>)</span>, 
          <span class="pl-var"
>B</span>]], 
      [ [ <span class="pl-atom"
>assign</span>, 
          <span class="pl-var"
>C</span>, 
          [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-var"
>_head</span>, <span class="pl-var"
>_tail</span>]], 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>A</span>|<span class="pl-ellipsis"
>...</span></span>]</span>], 
      [ [ <span class="pl-atom"
>prolog_if</span>, 
          [ [ <span class="pl-atom"
>assign</span>, 
              <span class="pl-var"
>D</span>, 
              [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>lessThan</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>_head</span>]], 
            [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>native</span>(<span class="pl-args"
><span class="pl-atom"
>is_True</span></span>)</span>, 
              <span class="pl-var"
>D</span>]], 
          [ [ <span class="pl-atom"
>assign</span>, 
              <span class="pl-var"
>E</span>, 
              [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-var"
>_head</span>, <span class="pl-var"
>_tail</span>]], 
            [ <span class="pl-atom"
>assign</span>, 
              <span class="pl-var"
>F</span>, 
              [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>E</span>]], 
            <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>G</span>|<span class="pl-ellipsis"
>...</span></span>]</span>], 
          [ [ <span class="pl-atom"
>assign</span>, 
              <span class="pl-var"
>H</span>, 
              [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>insert_uniq</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>_tail</span>]], 
            [ <span class="pl-atom"
>assign</span>, 
              <span class="pl-var"
>I</span>, 
              [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Cons'</span></span>)</span>, <span class="pl-var"
>_head</span>, <span class="pl-var"
>H</span>]], 
            <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>G</span>|<span class="pl-ellipsis"
>...</span></span>]</span>]], 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>A</span>|<span class="pl-ellipsis"
>...</span></span>]</span>]]]].&#13;&#10;

</span><span class="ansi36"
>transpiler_depends_on(insert_uniq, 3, ==, 3).

</span>Asserting: transpiler_depends_on(insert_uniq,3,==,3)
<span class="ansi36"
>transpiler_depends_on(insert_uniq, 3, lessThan, 3).

</span>Asserting: transpiler_depends_on(insert_uniq,3,lessThan,3)
<span class="ansi36"
>'_x'=['%Var', arg(insert_uniq, 1), arg('Cons', 1), arg(lessThan, 1), arg(==, 1)].
'_head'=['%Var', arg('Cons', 1), arg(lessThan, 2), arg(==, 2)].
'_tail'=[A, 'List', arg(insert_uniq, 2), B, C, arg('Cons', 2), D, E, F, G, H, I, J, K, L].
M=[N, val(O), P, val(Q), R, S, T, U, V, W, X, 'List', arg('Cons', 0), Y, Z, A1, B1, C1, arg(insert_uniq, 0), D1, E1, val(F1), val(G1), val(is_p1(true, H1)), val([is_p1, [], H1]), val(is_p1(true, I1)), val([is_p1, [], I1]), val([is_p1, [], J1]), val(is_p1(true, J1)), K1, L1, M1, N1, O1, val(P1), val(Q1), val(R1), S1, val(T1), U1].
V1=['Bool'].
R1=[val(Q1), val(P1), O1, N1, M1, L1, K1, val(is_p1(true, J1)), val([is_p1, [], J1]), val([is_p1, [], I1]), val(is_p1(true, I1)), val([is_p1, [], H1]), val(is_p1(true, H1)), val(G1), val(F1), W1, 'List', arg(insert_uniq, 0), A1, Z, X1, arg('Cons', 0), S1, E1].
Y1=['Bool', arg(lessThan, 0)].
Z1=[A2, 'List', arg('Cons', 2), B2, C2, arg('Cons', 0)].
Q=[R, D2, 'List', arg('Cons', 0), P].
T1=[S1, val(R1), val(Q1), val(P1), O1, N1, M1, L1, K1, val(is_p1(true, J1)), val([is_p1, [], J1]), val([is_p1, [], I1]), val(is_p1(true, I1)), val([is_p1, [], H1]), val(is_p1(true, H1)), val(G1), val(F1), E1, E2, 'List', arg(insert_uniq, 0), B1, A1, Z, W, V, U, T, F2, arg('Cons', 0), U1, S, R, val(Q), P, val(O), N, D1, Y].
G2=[H2, 'List', arg('Cons', 2), I2, J2, arg(insert_uniq, 0)].
O=[P, val(Q), R, U, V, K2, 'List', arg('Cons', 0), N, S].

mc_2__insert_uniq(_x, ['Cons', _head, _tail], M) :-
    (   'mc_2__=='(_x, _head, V1),
        is_True(V1)
    *-> mc_2__Cons(_head, _tail, R1),
        M=R1
    ;   (   mc_2__lessThan(_x, _head, Y1),
            is_True(Y1)
        *-> mc_2__Cons(_head, _tail, Z1),
            mc_2__Cons(_x, Z1, Q),
            T1=Q
        ;   mc_2__insert_uniq(_x, _tail, G2),
            mc_2__Cons(_head, G2, O),
            T1=O
        ),
        M=T1
    ).

</span><span class="ansi36"
>
mc_2__insert_uniq(_x, ['Cons', _head, _tail], A) :-
    (   'mc_2__=='(_x, _head, B),
        is_True(B)
    *-> mc_2__Cons(_head, _tail, C),
        A=C
    ;   (   mc_2__lessThan(_x, _head, D),
            is_True(D)
        *-> mc_2__Cons(_head, _tail, E),
            mc_2__Cons(_x, E, F),
            G=F
        ;   mc_2__insert_uniq(_x, _tail, H),
            mc_2__Cons(_head, H, I),
            G=I
        ),
        A=G
    ).

</span>
<span class="ansi38-255165000"
> (: lessThan (-> Number Number Bool))
</span><span class="ansi38-255165000"
> (= (lessThan $x $y)  
  (< $x $y))
</span><span class="ansi38-255165005"
>Retracting stub: mc_2__lessThan(B,C,D)
</span><span class="ansi36"
>transpiler_clause_store(lessThan, 3, 0, ['Any', 'Any'], 'AnyRet', [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [lessThan, _x, _y], [<, _x, _y]).

</span><span class="ansi35"
>'_x'=['Number', arg(<, 1), arg(lessThan, 1)].
'_y'=['Number', arg(<, 2), arg(lessThan, 2)].
A=['Bool', arg(<, 0)].
B=[val(is_p1(true, A)), val([is_p1, [], A]), 'Bool', arg(lessThan, 0)].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>lessThan</span>, <span class="pl-var"
>_x</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>&lt;</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>_y</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:[_x, _y].
lazyArgsList:[_x-eager, _y-eager].
eagerLazyList:[eager, eager].
typeProps:[x(doeval, eager), x(doeval, eager)].
finalLazyArgs:[x(doeval, eager), x(doeval, eager)].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>lessThan</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_x'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_y'</span></span>)</span>]], 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>&lt;</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>_y</span>]]]].&#13;&#10;

</span><span class="ansi36"
>transpiler_depends_on(lessThan, 3, <, 3).

</span>Asserting: transpiler_depends_on(lessThan,3,<,3)
<span class="ansi36"
>'_x'=['Number', arg(<, 1), arg(lessThan, 1)].
'_y'=['Number', arg(<, 2), arg(lessThan, 2)].
A=['Bool', arg(<, 0), arg(lessThan, 0), val(is_p1(true, B)), val([is_p1, [], B])].

mc_2__lessThan(_x, _y, A) :-
    'mc_2__<'(_x, _y, A).

</span><span class="ansi36"
>
mc_2__lessThan(_x, _y, A) :-
    'mc_2__<'(_x, _y, A).

</span>
;;;; Test insert
<span class="ansi38-013099040"
>!("============ Test insert ============")

</span>
Deterministic: <span class="ansi33"
>("============ Test insert ============")
</span><span class="ansi38-013099040"
>!(assertEqual (insert 1 Nil) (Cons 1 Nil))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS.01"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS.01</h3>
; 
; EVAL TEST
; took 0.000828 secs. (827.97 microseconds) 

!(assertEqual (insert 1 Nil) (Cons 1 Nil))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (Cons 1 Nil)) 
      ( (Cons 1 Nil))))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqual (insert 2 (insert 1 Nil)) (Cons 1 (Cons 2 Nil)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS.02"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS.02</h3>
; 
; EVAL TEST
; took 0.003 secs. (3.16 milliseconds) 

!(assertEqual (insert 2 (insert 1 Nil)) (Cons 1 (Cons 2 Nil)))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (Cons 1 
          (Cons 2 Nil))) 
      ( (Cons 1 
          (Cons 2 Nil)))))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqual (insert 3 (insert 2 (insert 1 Nil))) (Cons 1 (Cons 2 (Cons 3 Nil))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS.03"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS.03</h3>
; 
; EVAL TEST
; took 0.008 secs. (7.67 milliseconds) 

!(assertEqual (insert 3 (insert 2 (insert 1 Nil))) (Cons 1 (Cons 2 (Cons 3 Nil))))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (Cons 1 
          (Cons 2 
            (Cons 3 Nil)))) 
      ( (Cons 1 
          (Cons 2 
            (Cons 3 Nil))))))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(== (Cons 1 Nil) (Cons 1 Nil))

</span>
Deterministic: <span class="ansi33"
>True
</span>;;;; Test sort
<span class="ansi38-013099040"
>!("============ Test sort ============")

</span>
Deterministic: <span class="ansi33"
>("============ Test sort ============")
</span><span class="ansi38-013099040"
>!(assertEqual (sort (Cons 1 Nil)) (Cons 1 Nil))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS.04"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS.04</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.31 milliseconds) 

!(assertEqual (sort (Cons 1 Nil)) (Cons 1 Nil))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (Cons 1 Nil)) 
      ( (Cons 1 Nil))))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqual (sort (Cons 2 (Cons 1 Nil))) (Cons 1 (Cons 2 Nil)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS.05"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS.05</h3>
; 
; EVAL TEST
; took 0.004 secs. (4.25 milliseconds) 

!(assertEqual (sort (Cons 2 (Cons 1 Nil))) (Cons 1 (Cons 2 Nil)))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (Cons 1 
          (Cons 2 Nil))) 
      ( (Cons 1 
          (Cons 2 Nil)))))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqual (sort (Cons 3 (Cons 1 (Cons 2 Nil)))) (Cons 1 (Cons 2 (Cons 3 Nil))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS.06"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS.06</h3>
; 
; EVAL TEST
; took 0.010 secs. (9.60 milliseconds) 

!(assertEqual (sort (Cons 3 (Cons 1 (Cons 2 Nil)))) (Cons 1 (Cons 2 (Cons 3 Nil))))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (Cons 1 
          (Cons 2 
            (Cons 3 Nil)))) 
      ( (Cons 1 
          (Cons 2 
            (Cons 3 Nil))))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;;; Test elem
<span class="ansi38-013099040"
>!("============ Test elem ============")

</span>
Deterministic: <span class="ansi33"
>("============ Test elem ============")
</span><span class="ansi38-013099040"
>!(assertEqual (elem 1 (Cons 3 (Cons 1 (Cons 2 Nil)))) True)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS.07"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS.07</h3>
; 
; EVAL TEST
; took 0.003 secs. (2.63 milliseconds) 

!(assertEqual (elem 1 (Cons 3 (Cons 1 (Cons 2 Nil)))) True)

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      (True) 
      (True)))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqual (elem 5 (Cons 3 (Cons 1 (Cons 2 Nil)))) False)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS.08"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS.08</h3>
; 
; EVAL TEST
; took 0.003 secs. (3.43 milliseconds) 

!(assertEqual (elem 5 (Cons 3 (Cons 1 (Cons 2 Nil)))) False)

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      (False) 
      (False)))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;;; Test uniq
<span class="ansi38-013099040"
>!("============ Test uniq ============")

</span>
Deterministic: <span class="ansi33"
>("============ Test uniq ============")
</span><span class="ansi38-013099040"
>!(assertEqual (uniq (Cons 2 (Cons 3 (Cons 1 (Cons 2 Nil))))) (Cons 2 (Cons 3 (Cons 1 Nil))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS.09"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS.09</h3>
; 
; EVAL TEST
; took 0.016 secs. (16.41 milliseconds) 

!(assertEqual (uniq (Cons 2 (Cons 3 (Cons 1 (Cons 2 Nil))))) (Cons 2 (Cons 3 (Cons 1 Nil))))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (Cons 2 
          (Cons 3 
            (Cons 1 Nil)))) 
      ( (Cons 2 
          (Cons 3 
            (Cons 1 Nil))))))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqual (uniq (Cons 2 (Cons 3 (Cons 3 (Cons 2 Nil))))) (Cons 2 (Cons 3 Nil)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS.10"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS.10</h3>
; 
; EVAL TEST
; took 0.012 secs. (11.92 milliseconds) 

!(assertEqual (uniq (Cons 2 (Cons 3 (Cons 3 (Cons 2 Nil))))) (Cons 2 (Cons 3 Nil)))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (Cons 2 
          (Cons 3 Nil))) 
      ( (Cons 2 
          (Cons 3 Nil)))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;;; Test insert_uniq
<span class="ansi38-013099040"
>!("============ Test insert_uniq ============")

</span>
Deterministic: <span class="ansi33"
>("============ Test insert_uniq ============")
</span><span class="ansi38-013099040"
>!(assertEqual (insert_uniq 2 (insert_uniq 1 Nil)) (Cons 1 (Cons 2 Nil)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS.11"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS.11</h3>
; 
; EVAL TEST
; took 0.004 secs. (4.15 milliseconds) 

!(assertEqual (insert_uniq 2 (insert_uniq 1 Nil)) (Cons 1 (Cons 2 Nil)))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (Cons 1 
          (Cons 2 Nil))) 
      ( (Cons 1 
          (Cons 2 Nil)))))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqual (insert_uniq 3 (insert_uniq 2 (insert_uniq 1 Nil))) (Cons 1 (Cons 2 (Cons 3 Nil))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS.12"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS.12</h3>
; 
; EVAL TEST
; took 0.011 secs. (10.90 milliseconds) 

!(assertEqual (insert_uniq 3 (insert_uniq 2 (insert_uniq 1 Nil))) (Cons 1 (Cons 2 (Cons 3 Nil))))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (Cons 1 
          (Cons 2 
            (Cons 3 Nil)))) 
      ( (Cons 1 
          (Cons 2 
            (Cons 3 Nil))))))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(assertEqual (insert_uniq 2 (insert_uniq 3 (insert_uniq 2 (insert_uniq 1 Nil)))) (Cons 1 (Cons 2 (Cons 3 Nil))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS.13"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS.13</h3>
; 
; EVAL TEST
; took 0.016 secs. (16.46 milliseconds) 

!(assertEqual (insert_uniq 2 (insert_uniq 3 (insert_uniq 2 (insert_uniq 1 Nil)))) (Cons 1 (Cons 2 (Cons 3 Nil))))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (Cons 1 
          (Cons 2 
            (Cons 3 Nil)))) 
      ( (Cons 1 
          (Cons 2 
            (Cons 3 Nil))))))
</span>
Deterministic: <span class="ansi33"
>()
</span>
R(2): <span class="ansi33"
>()
</span>;;;; Define a generic less than operator, lessThan, for Nat.  < cannot be used
;;;; because it is a built-in, its type is hardwired and cannot be
;;;; overloaded.
<span class="ansi38-255165000"
> (: lessThan (-> Nat Nat Bool))
</span><span class="ansi38-255165000"
> (= (lessThan $_124996 Z)  False)
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(lessThan, 3, 1, ['Number', 'Number'], 'Bool', [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [lessThan, A, 'Z'], 'False').

</span><span class="ansi35"
>A=['Nat', 'Number', arg(lessThan, 1)].
B=[val(is_p1(true, 'False')), val([is_p1, [], 'False']), 'Bool', arg(lessThan, 0)].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>lessThan</span>, <span class="pl-var"
>A</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:[A, 'Z'].
lazyArgsList:[A-eager, 'Z'-eager].
eagerLazyList:[lazy, lazy].
typeProps:[x(doeval, eager), x(doeval, eager)].
finalLazyArgs:[x(doeval, eager), x(doeval, eager)].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>lessThan</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-atom"
>'Z'</span>]], 
  [ [ assign ,   A   ,'False']]].&#13;&#10;

</span><span class="ansi36"
>A=['Nat', 'Number', arg(lessThan, 1)].
B=['Bool', arg(lessThan, 0), val(is_p1(true, 'False')), val([is_p1, [], 'False'])].

mc_2__lessThan(A, 'Z', B) :-
    B='False'.

</span><span class="ansi36"
>
mc_2__lessThan(A, 'Z', B) :-
    B='False'.

</span>
<span class="ansi38-255165000"
> (= (lessThan Z (S $_273718))  True)
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(lessThan, 3, 2, ['Number', 'Number'], 'Bool', [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [lessThan, 'Z', ['S', A]], 'True').

</span><span class="ansi35"
>A=[].
B=[val(is_p1(true, 'True')), val([is_p1, [], 'True']), 'Bool', arg(lessThan, 0)].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>lessThan</span>, 
    <span class="pl-atom"
>'Z'</span>, 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'S'</span>, <span class="pl-var"
>A</span></span>]</span>], 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:['Z', ['S', A]].
lazyArgsList:['Z'-eager, ['S', A]-eager].
eagerLazyList:[lazy, lazy].
typeProps:[x(doeval, eager), x(doeval, eager)].
finalLazyArgs:[x(doeval, eager), x(doeval, eager)].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>lessThan</span></span>)</span>, 
      <span class="pl-atom"
>'Z'</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'S'</span>, <span class="pl-var"
>B</span></span>]</span>]], 
  [ [ assign,  A   ,'True']]].&#13;&#10;

</span><span class="ansi36"
>A=[].
B=['Bool', arg(lessThan, 0), val(is_p1(true, 'True')), val([is_p1, [], 'True'])].

mc_2__lessThan('Z', ['S', A], B) :-
    B='True'.

</span><span class="ansi36"
>
mc_2__lessThan('Z', ['S', A], B) :-
    B='True'.

</span>
<span class="ansi38-255165000"
> (= (lessThan (S $x) (S $y))  
  (lessThan $x $y))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(lessThan, 3, 3, ['Number', 'Number'], 'Bool', [x(doeval, eager), x(doeval, eager)], x(doeval, eager), [lessThan, ['S', _x], ['S', _y]], [lessThan, _x, _y]).

</span><span class="ansi35"
>'_x'=['Nat', 'Number', arg(lessThan, 1)].
'_y'=['Nat', 'Number', arg(lessThan, 2)].
A=['Bool', arg(lessThan, 0)].
B=[val(is_p1(true, A)), val([is_p1, [], A]), 'Bool', arg(lessThan, 0)].

</span><span class="ansi32"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>lessThan</span>, 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'S'</span>, <span class="pl-var"
>_x</span></span>]</span>, 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'S'</span>, <span class="pl-var"
>_y</span></span>]</span>], 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>lessThan</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>_y</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>is_p1</span>, []|<span class="pl-ellipsis"
>...</span></span>]</span>]]].&#13;&#10;

</span><span class="ansi36"
>resultEager:eager.
retProps:x(doeval, eager).
finalLazyRet:x(doeval, eager).
finalLazyOnlyRet:eager.
args_list:[['S', _x], ['S', _y]].
lazyArgsList:[['S', _x]-eager, ['S', _y]-eager].
eagerLazyList:[lazy, lazy].
typeProps:[x(doeval, eager), x(doeval, eager)].
finalLazyArgs:[x(doeval, eager), x(doeval, eager)].

</span><span class="ansi33"
>Ast:=======
<span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  [ <span class="pl-atom"
>assign</span>, 
    <span class="pl-var"
>A</span>, 
    [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>lessThan</span></span>)</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'S'</span>, <span class="pl-var"
>_x</span></span>]</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'S'</span>, <span class="pl-var"
>_y</span></span>]</span>]], 
  [ [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>lessThan</span></span>)</span>, <span class="pl-var"
>_x</span>, <span class="pl-var"
>_y</span>]]]].&#13;&#10;

</span><span class="ansi36"
>'_x'=['Nat', 'Number', arg(lessThan, 1)].
'_y'=['Nat', 'Number', arg(lessThan, 2)].
A=['Bool', arg(lessThan, 0), val(is_p1(true, B)), val([is_p1, [], B])].

mc_2__lessThan(['S', _x], ['S', _y], A) :-
    mc_2__lessThan(_x, _y, A).

</span><span class="ansi36"
>
mc_2__lessThan(['S', _x], ['S', _y], A) :-
    mc_2__lessThan(_x, _y, A).

</span>
<span class="ansi38-013099040"
>!("============ Test lessThan ============")

</span>
Deterministic: <span class="ansi33"
>("============ Test lessThan ============")
</span>;;;; Test when the first number is zero
<span class="ansi38-013099040"
>!(assertEqual (lessThan Z (S Z)) True)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.14"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.14</h3>
; 
; EVAL TEST
; took 0.003 secs. (3.12 milliseconds) 

!(assertEqual (lessThan Z (S Z)) True)

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (< Z 
          (S Z)) True) 
      (True)))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((< Z (S Z)) True)) #(expected (True))))
</span>;;;; 0 < 1
<span class="ansi38-013099040"
>!(assertEqual (lessThan Z (S (S Z))) True)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.15"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.15</h3>
; 
; EVAL TEST
; took 0.006 secs. (5.53 milliseconds) 

!(assertEqual (lessThan Z (S (S Z))) True)

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (< Z 
          (S (S Z))) True) 
      (True)))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((< Z (S (S Z))) True)) #(expected (True))))
</span>;;;; 0 < 2
<span class="ansi38-013099040"
>!(assertEqual (lessThan Z Z) False)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.16"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.16</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.72 milliseconds) 

!(assertEqual (lessThan Z Z) False)

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (< Z Z) False) 
      (False)))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((< Z Z) False)) #(expected (False))))
</span>;;;; 0 < 0
;;;; Test when the second number is zero
<span class="ansi38-013099040"
>!(assertEqual (lessThan (S Z) Z) False)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.17"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.17</h3>
; 
; EVAL TEST
; took 0.003 secs. (2.90 milliseconds) 

!(assertEqual (lessThan (S Z) Z) False)

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (< 
          (S Z) Z) False) 
      (False)))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((< (S Z) Z) False)) #(expected (False))))
</span>;;;; 1 < 0
<span class="ansi38-013099040"
>!(assertEqual (lessThan (S (S Z)) Z) False)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.18"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.18</h3>
; 
; EVAL TEST
; took 0.005 secs. (5.41 milliseconds) 

!(assertEqual (lessThan (S (S Z)) Z) False)

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (< 
          (S (S Z)) Z) False) 
      (False)))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((< (S (S Z)) Z) False)) #(expected (False))))
</span>;;;; 2 < 0
;;;; Test when both numbers are the same
<span class="ansi38-013099040"
>!(assertEqual (lessThan (S Z) (S Z)) False)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.19"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.19</h3>
; 
; EVAL TEST
; took 0.006 secs. (5.88 milliseconds) 

!(assertEqual (lessThan (S Z) (S Z)) False)

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (< 
          (S Z) 
          (S Z)) 
        (< Z Z) False) 
      (False)))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((< (S Z) (S Z)) (< Z Z) False)) #(expected (False))))
</span>;;;; 1 < 1
<span class="ansi38-013099040"
>!(assertEqual (lessThan (S (S Z)) (S (S Z))) False)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.20"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.20</h3>
; 
; EVAL TEST
; took 0.016 secs. (15.62 milliseconds) 

!(assertEqual (lessThan (S (S Z)) (S (S Z))) False)

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (< 
          (S (S Z)) 
          (S (S Z))) 
        (< 
          (S Z) 
          (S Z)) 
        (< Z Z) False) 
      (False)))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((< (S (S Z)) (S (S Z))) (< (S Z) (S Z)) (< Z Z) False)) #(expected (False))))
</span>;;;; 2 < 2
<span class="ansi38-013099040"
>!(assertEqual (lessThan (S (S (S Z))) (S (S (S Z)))) False)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.21"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.21</h3>
; 
; EVAL TEST
; took 0.037 secs. (36.70 milliseconds) 

!(assertEqual (lessThan (S (S (S Z))) (S (S (S Z)))) False)

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (< 
          (S (S (S Z))) 
          (S (S (S Z)))) 
        (< 
          (S (S Z)) 
          (S (S Z))) 
        (< 
          (S Z) 
          (S Z)) 
        (< Z Z) False) 
      (False)))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((< (S (S (S Z))) (S (S (S Z)))) (< (S (S Z)) (S (S Z))) (< (S Z) (S Z)) (< Z Z) False)) #(expected (False))))
</span>;;;; 3 < 3
;;;; Test when the first number is smaller
<span class="ansi38-013099040"
>!(assertEqual (lessThan (S Z) (S (S Z))) True)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.22"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.22</h3>
; 
; EVAL TEST
; took 0.010 secs. (10.13 milliseconds) 

!(assertEqual (lessThan (S Z) (S (S Z))) True)

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (< 
          (S Z) 
          (S (S Z))) 
        (< Z 
          (S Z)) True) 
      (True)))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((< (S Z) (S (S Z))) (< Z (S Z)) True)) #(expected (True))))
</span>;;;; 1 < 2
<span class="ansi38-013099040"
>!(assertEqual (lessThan (S (S Z)) (S (S (S Z)))) True)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.23"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.23</h3>
; 
; EVAL TEST
; took 0.025 secs. (25.26 milliseconds) 

!(assertEqual (lessThan (S (S Z)) (S (S (S Z)))) True)

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (< 
          (S (S Z)) 
          (S (S (S Z)))) 
        (< 
          (S Z) 
          (S (S Z))) 
        (< Z 
          (S Z)) True) 
      (True)))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((< (S (S Z)) (S (S (S Z)))) (< (S Z) (S (S Z))) (< Z (S Z)) True)) #(expected (True))))
</span>;;;; 2 < 3
<span class="ansi38-013099040"
>!(assertEqual (lessThan (S Z) (S (S (S Z)))) True)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.24"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.24</h3>
; 
; EVAL TEST
; took 0.017 secs. (17.44 milliseconds) 

!(assertEqual (lessThan (S Z) (S (S (S Z)))) True)

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (< 
          (S Z) 
          (S (S (S Z)))) 
        (< Z 
          (S (S Z))) True) 
      (True)))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((< (S Z) (S (S (S Z)))) (< Z (S (S Z))) True)) #(expected (True))))
</span>;;;; 1 < 3
;;;; Test when the first number is larger
<span class="ansi38-013099040"
>!(assertEqual (lessThan (S (S Z)) (S Z)) False)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.25"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.25</h3>
; 
; EVAL TEST
; took 0.010 secs. (10.25 milliseconds) 

!(assertEqual (lessThan (S (S Z)) (S Z)) False)

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (< 
          (S (S Z)) 
          (S Z)) 
        (< 
          (S Z) Z) False) 
      (False)))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((< (S (S Z)) (S Z)) (< (S Z) Z) False)) #(expected (False))))
</span>;;;; 2 < 1
<span class="ansi38-013099040"
>!(assertEqual (lessThan (S (S (S Z))) (S (S Z))) False)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.26"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.26</h3>
; 
; EVAL TEST
; took 0.026 secs. (25.56 milliseconds) 

!(assertEqual (lessThan (S (S (S Z))) (S (S Z))) False)

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (< 
          (S (S (S Z))) 
          (S (S Z))) 
        (< 
          (S (S Z)) 
          (S Z)) 
        (< 
          (S Z) Z) False) 
      (False)))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((< (S (S (S Z))) (S (S Z))) (< (S (S Z)) (S Z)) (< (S Z) Z) False)) #(expected (False))))
</span>;;;; 3 < 2
<span class="ansi38-013099040"
>!(assertEqual (lessThan (S (S (S (S Z)))) (S (S Z))) False)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.27"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.27</h3>
; 
; EVAL TEST
; took 0.043 secs. (43.18 milliseconds) 

!(assertEqual (lessThan (S (S (S (S Z)))) (S (S Z))) False)

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (< 
          (S (S (S (S Z)))) 
          (S (S Z))) 
        (< 
          (S (S (S Z))) 
          (S Z)) 
        (< 
          (S (S Z)) Z) False) 
      (False)))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((< (S (S (S (S Z)))) (S (S Z))) (< (S (S (S Z))) (S Z)) (< (S (S Z)) Z) False)) #(expected (False))))
</span>;;;; 4 < 2
;;;!(pragma! coerce auto)
;;;; Test insert
<span class="ansi38-013099040"
>!("============ Test insert ============")

</span>
Deterministic: <span class="ansi33"
>("============ Test insert ============")
</span><span class="ansi38-013099040"
>!(assertEqual (insert (S Z) Nil) (Cons (S Z) Nil))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.28"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.28</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.42 milliseconds) 

!(assertEqual (insert (S Z) Nil) (Cons (S Z) Nil))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (Cons 
          (S Z) Nil)) 
      ( (Cons 
          (S Z) Nil))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;;; insert 1 into empty list
<span class="ansi38-013099040"
>!(assertEqual (insert (S (S Z)) (insert (S Z) Nil)) (Cons (S Z) (Cons (S (S Z) Nil))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.29"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.29</h3>
; 
; EVAL TEST
; took 0.022 secs. (21.58 milliseconds) 

!(assertEqual (insert (S (S Z)) (insert (S Z) Nil)) (Cons (S Z) (Cons (S (S Z) Nil))))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (Cons 
          (S (S Z)) 
          (Cons 
            (S Z) Nil)) (Cons (S (S Z)) (Cons (S Z) Nil))) 
      ( (Cons 
          (S Z) 
          (Cons (S (S Z) Nil))))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((Cons (S (S Z)) (Cons (S Z) Nil)) (Cons (S (S Z)) (Cons (S Z) Nil)))) #(expected ((Cons (S Z) (Cons (S (S Z) Nil)))))))
</span>;;;; insert 2, then 1
<span class="ansi38-013099040"
>!(assertEqual (insert (S (S (S Z))) (insert (S (S Z)) (insert (S Z) Nil))) (Cons (S Z) (Cons (S (S Z)) (Cons (S (S (S Z))) Nil))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.30"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.30</h3>
; 
; EVAL TEST
; took 0.120 secs. (119.71 milliseconds) 

!(assertEqual (insert (S (S (S Z))) (insert (S (S Z)) (insert (S Z) Nil))) (Cons (S Z) (Cons (S (S Z)) (Cons (S (S (S Z))) Nil))))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (Cons 
          (S (S (S Z))) 
          (Cons 
            (S (S Z)) 
            (Cons 
              (S Z) Nil))) 
        (Cons 
          (S (S (S Z))) 
          (Cons 
            (S (S Z)) 
            (Cons 
              (S Z) Nil))) 
        (Cons 
          (S (S (S Z))) 
          (Cons 
            (S (S Z)) 
            (Cons 
              (S Z) Nil))) 
        (Cons 
          (S (S (S Z))) 
          (Cons 
            (S (S Z)) 
            (Cons 
              (S Z) Nil))) 
        (Cons 
          (S (S (S Z))) 
          (Cons 
            (S (S Z)) 
            (Cons 
              (S Z) Nil))) 
        (Cons 
          (S (S (S Z))) 
          (Cons 
            (S (S Z)) 
            (Cons 
              (S Z) Nil)))) 
      ( (Cons 
          (S Z) 
          (Cons 
            (S (S Z)) 
            (Cons 
              (S (S (S Z))) Nil))))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))))) #(expected ((Cons (S Z) (Cons (S (S Z)) (Cons (S (S (S Z))) Nil)))))))
</span>;;;; insert 3, then 2, then 1
<span class="ansi38-013099040"
>!(== (Cons (S Z) Nil) (Cons (S Z) Nil))

</span>
Deterministic: <span class="ansi33"
>True
</span>;;;; check structural equality
;;;; Test sort
<span class="ansi38-013099040"
>!("============ Test sort ============")

</span>
Deterministic: <span class="ansi33"
>("============ Test sort ============")
</span><span class="ansi38-013099040"
>!(assertEqual (sort (Cons (S Z) Nil)) (Cons (S Z) Nil))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.31"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.31</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.94 milliseconds) 

!(assertEqual (sort (Cons (S Z) Nil)) (Cons (S Z) Nil))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (Cons 
          (S Z) Nil)) 
      ( (Cons 
          (S Z) Nil))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;;; sort a single-element list
<span class="ansi38-013099040"
>!(assertEqual (sort (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S Z) (Cons (S (S Z) Nil))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.32"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.32</h3>
; 
; EVAL TEST
; took 0.023 secs. (23.25 milliseconds) 

!(assertEqual (sort (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S Z) (Cons (S (S Z) Nil))))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (Cons 
          (S (S Z)) 
          (Cons 
            (S Z) Nil)) (Cons (S (S Z)) (Cons (S Z) Nil))) 
      ( (Cons 
          (S Z) 
          (Cons (S (S Z) Nil))))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((Cons (S (S Z)) (Cons (S Z) Nil)) (Cons (S (S Z)) (Cons (S Z) Nil)))) #(expected ((Cons (S Z) (Cons (S (S Z) Nil)))))))
</span>;;;; sort [2, 1]
<span class="ansi38-013099040"
>!(assertEqual (sort (Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil)))) (Cons (S Z) (Cons (S (S Z)) (Cons (S (S (S Z))) Nil))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.33"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.33</h3>
; 
; EVAL TEST
; took 0.129 secs. (129.19 milliseconds) 

!(assertEqual (sort (Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil)))) (Cons (S Z) (Cons (S (S Z)) (Cons (S (S (S Z))) Nil))))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (Cons 
          (S (S (S Z))) 
          (Cons 
            (S Z) 
            (Cons 
              (S (S Z)) Nil))) 
        (Cons 
          (S (S (S Z))) 
          (Cons 
            (S Z) 
            (Cons 
              (S (S Z)) Nil))) 
        (Cons 
          (S (S (S Z))) 
          (Cons 
            (S Z) 
            (Cons 
              (S (S Z)) Nil))) 
        (Cons 
          (S (S (S Z))) 
          (Cons 
            (S Z) 
            (Cons 
              (S (S Z)) Nil))) 
        (Cons 
          (S (S (S Z))) 
          (Cons 
            (S Z) 
            (Cons 
              (S (S Z)) Nil))) 
        (Cons 
          (S (S (S Z))) 
          (Cons 
            (S Z) 
            (Cons 
              (S (S Z)) Nil)))) 
      ( (Cons 
          (S Z) 
          (Cons 
            (S (S Z)) 
            (Cons 
              (S (S (S Z))) Nil))))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil))) (Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil))) (Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil))) (Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil))) (Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil))) (Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil))))) #(expected ((Cons (S Z) (Cons (S (S Z)) (Cons (S (S (S Z))) Nil)))))))
</span>;;;; sort [3, 1, 2]
;;;; Test elem
<span class="ansi38-013099040"
>!("============ Test elem ============")

</span>
Deterministic: <span class="ansi33"
>("============ Test elem ============")
</span><span class="ansi38-013099040"
>!(assertEqual (elem (S Z) (Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil)))) True)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.34"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.34</h3>
; 
; EVAL TEST
; took 0.008 secs. (7.74 milliseconds) 

!(assertEqual (elem (S Z) (Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil)))) True)

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      (True) 
      (True)))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;;; 1 is in [3, 1, 2]
<span class="ansi38-013099040"
>!(assertEqual (elem (S (S (S (S (S Z))))) (Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil)))) False)

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.35"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.35</h3>
; 
; EVAL TEST
; took 0.031 secs. (31.34 milliseconds) 

!(assertEqual (elem (S (S (S (S (S Z))))) (Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil)))) False)

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      (False) 
      (False)))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;;; 5 is not in [3, 1, 2]
;;;; Test uniq
<span class="ansi38-013099040"
>!("============ Test uniq ============")

</span>
Deterministic: <span class="ansi33"
>("============ Test uniq ============")
</span><span class="ansi38-013099040"
>!(assertEqual (uniq (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil))))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S Z) Nil))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.36"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.36</h3>
; 
; EVAL TEST
; took 0.049 secs. (48.95 milliseconds) 

!(assertEqual (uniq (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil))))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S Z) Nil))))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S Z) Nil)))) 
      ( (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S Z) Nil))))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;;; remove duplicate 2
<span class="ansi38-013099040"
>!(assertEqual (uniq (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S (S Z))) (Cons (S (S Z)) Nil))))) (Cons (S (S Z)) (Cons (S (S (S Z))) Nil)))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.37"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.37</h3>
; 
; EVAL TEST
; took 0.048 secs. (48.39 milliseconds) 

!(assertEqual (uniq (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S (S Z))) (Cons (S (S Z)) Nil))))) (Cons (S (S Z)) (Cons (S (S (S Z))) Nil)))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) Nil))) 
      ( (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) Nil)))))
</span>
Deterministic: <span class="ansi33"
>()
</span>;;;; remove duplicates of 2 and 3
;;;; Test insert_uniq
<span class="ansi38-013099040"
>!("============ Test insert_uniq ============")

</span>
Deterministic: <span class="ansi33"
>("============ Test insert_uniq ============")
</span><span class="ansi38-013099040"
>!(assertEqual (insert_uniq (S (S Z)) (insert_uniq (S Z) Nil)) (Cons (S Z) (Cons (S (S Z) Nil))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.38"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.38</h3>
; 
; EVAL TEST
; took 0.024 secs. (24.42 milliseconds) 

!(assertEqual (insert_uniq (S (S Z)) (insert_uniq (S Z) Nil)) (Cons (S Z) (Cons (S (S Z) Nil))))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (Cons 
          (S (S Z)) 
          (Cons 
            (S Z) Nil)) (Cons (S (S Z)) (Cons (S Z) Nil))) 
      ( (Cons 
          (S Z) 
          (Cons (S (S Z) Nil))))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((Cons (S (S Z)) (Cons (S Z) Nil)) (Cons (S (S Z)) (Cons (S Z) Nil)))) #(expected ((Cons (S Z) (Cons (S (S Z) Nil)))))))
</span>;;;; insert unique 1, then 2
<span class="ansi38-013099040"
>!(assertEqual (insert_uniq (S (S (S Z))) (insert_uniq (S (S Z)) (insert_uniq (S Z) Nil))) (Cons (S Z) (Cons (S (S Z)) (Cons (S (S (S Z))) Nil))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.39"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.39</h3>
; 
; EVAL TEST
; took 0.137 secs. (136.68 milliseconds) 

!(assertEqual (insert_uniq (S (S (S Z))) (insert_uniq (S (S Z)) (insert_uniq (S Z) Nil))) (Cons (S Z) (Cons (S (S Z)) (Cons (S (S (S Z))) Nil))))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (Cons 
          (S (S (S Z))) 
          (Cons 
            (S (S Z)) 
            (Cons 
              (S Z) Nil))) 
        (Cons 
          (S (S (S Z))) 
          (Cons 
            (S (S Z)) 
            (Cons 
              (S Z) Nil))) 
        (Cons 
          (S (S (S Z))) 
          (Cons 
            (S (S Z)) 
            (Cons 
              (S Z) Nil))) 
        (Cons 
          (S (S (S Z))) 
          (Cons 
            (S (S Z)) 
            (Cons 
              (S Z) Nil))) 
        (Cons 
          (S (S (S Z))) 
          (Cons 
            (S (S Z)) 
            (Cons 
              (S Z) Nil))) 
        (Cons 
          (S (S (S Z))) 
          (Cons 
            (S (S Z)) 
            (Cons 
              (S Z) Nil)))) 
      ( (Cons 
          (S Z) 
          (Cons 
            (S (S Z)) 
            (Cons 
              (S (S (S Z))) Nil))))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))))) #(expected ((Cons (S Z) (Cons (S (S Z)) (Cons (S (S (S Z))) Nil)))))))
</span>;;;; insert unique 1, 2, 3
<span class="ansi38-013099040"
>!(assertEqual (insert_uniq (S (S Z)) (insert_uniq (S (S (S Z))) (insert_uniq (S (S Z)) (insert_uniq (S Z) Nil)))) (Cons (S Z) (Cons (S (S Z)) (Cons (S (S (S Z))) Nil))))

</span>
;<h3 id="HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.40"
>;; HYPERON-METTALOG-SANITY.SORTING-TESTS-NATS.40</h3>
; 
; EVAL TEST
; took 0.534 secs. (533.72 milliseconds) 

!(assertEqual (insert_uniq (S (S Z)) (insert_uniq (S (S (S Z))) (insert_uniq (S (S Z)) (insert_uniq (S Z) Nil)))) (Cons (S Z) (Cons (S (S Z)) (Cons (S (S (S Z))) Nil))))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test 
      ( (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil)))) 
        (Cons 
          (S (S Z)) 
          (Cons 
            (S (S (S Z))) 
            (Cons 
              (S (S Z)) 
              (Cons 
                (S Z) Nil))))) 
      ( (Cons 
          (S Z) 
          (Cons 
            (S (S Z)) 
            (Cons 
              (S (S (S Z))) Nil))))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))))) #(expected ((Cons (S Z) (Cons (S (S Z)) (Cons (S (S (S Z))) Nil)))))))
</span>;;;; ensure duplicates are avoided
P;HTML|
;                #( = /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/sorting_tests_nats_mw.metta 0 )
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 19
</span><span class="ansi31"
>Failures: 21
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
P;HTML|
;          #(set_debug transpiler false)
P;HTML|
;          #(set_debug overtime 4.0)
P;HTML|
;          #(set_debug overflow 1000)
P;HTML|
;          #(set_debug eval false)
P;HTML|
;          #(set_debug load silent)
P;HTML|
;          #(set_debug trace-on-load false)
P;HTML|
;          #(set_debug exec false)
P;HTML|
;          #(set_debug error non-type)
P;HTML|
;          #(set_debug fail false)
P;HTML|
;          #(set_debug test true)
P;HTML|
;          #(set_debug test false)
P;HTML|
;          #(set_debug fail false)
[()]
[("============ Test lessThan ============")]
[(#(Error #(got ((< Z (S Z)) True)) #(expected (True))))]
[(#(Error #(got ((< Z (S (S Z))) True)) #(expected (True))))]
[(#(Error #(got ((< Z Z) False)) #(expected (False))))]
[(#(Error #(got ((< (S Z) Z) False)) #(expected (False))))]
[(#(Error #(got ((< (S (S Z)) Z) False)) #(expected (False))))]
[(#(Error #(got ((< (S Z) (S Z)) (< Z Z) False)) #(expected (False))))]
[(#(Error #(got ((< (S (S Z)) (S (S Z))) (< (S Z) (S Z)) (< Z Z) False)) #(expected (False))))]
[(#(Error #(got ((< (S (S (S Z))) (S (S (S Z)))) (< (S (S Z)) (S (S Z))) (< (S Z) (S Z)) (< Z Z) False)) #(expected (False))))]
[(#(Error #(got ((< (S Z) (S (S Z))) (< Z (S Z)) True)) #(expected (True))))]
[(#(Error #(got ((< (S (S Z)) (S (S (S Z)))) (< (S Z) (S (S Z))) (< Z (S Z)) True)) #(expected (True))))]
[(#(Error #(got ((< (S Z) (S (S (S Z)))) (< Z (S (S Z))) True)) #(expected (True))))]
[(#(Error #(got ((< (S (S Z)) (S Z)) (< (S Z) Z) False)) #(expected (False))))]
[(#(Error #(got ((< (S (S (S Z))) (S (S Z))) (< (S (S Z)) (S Z)) (< (S Z) Z) False)) #(expected (False))))]
[(#(Error #(got ((< (S (S (S (S Z)))) (S (S Z))) (< (S (S (S Z))) (S Z)) (< (S (S Z)) Z) False)) #(expected (False))))]
[("============ Test insert ============")]
[()]
[(#(Error #(got ((Cons (S (S Z)) (Cons (S Z) Nil)) (Cons (S (S Z)) (Cons (S Z) Nil)))) #(expected ((Cons (S Z) (Cons (S (S Z) Nil)))))))]
[(#(Error #(got ((Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))))) #(expected ((Cons (S Z) (Cons (S (S Z)) (Cons (S (S (S Z))) Nil)))))))]
[True]
[("============ Test sort ============")]
[()]
[(#(Error #(got ((Cons (S (S Z)) (Cons (S Z) Nil)) (Cons (S (S Z)) (Cons (S Z) Nil)))) #(expected ((Cons (S Z) (Cons (S (S Z) Nil)))))))]
[(#(Error #(got ((Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil))) (Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil))) (Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil))) (Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil))) (Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil))) (Cons (S (S (S Z))) (Cons (S Z) (Cons (S (S Z)) Nil))))) #(expected ((Cons (S Z) (Cons (S (S Z)) (Cons (S (S (S Z))) Nil)))))))]
[("============ Test elem ============")]
[()]
[()]
[("============ Test uniq ============")]
[()]
[()]
[("============ Test insert_uniq ============")]
[(#(Error #(got ((Cons (S (S Z)) (Cons (S Z) Nil)) (Cons (S (S Z)) (Cons (S Z) Nil)))) #(expected ((Cons (S Z) (Cons (S (S Z) Nil)))))))]
[(#(Error #(got ((Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil))))) #(expected ((Cons (S Z) (Cons (S (S Z)) (Cons (S (S (S Z))) Nil)))))))]
[(#(Error #(got ((Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))) (Cons (S (S Z)) (Cons (S (S (S Z))) (Cons (S (S Z)) (Cons (S Z) Nil)))))) #(expected ((Cons (S Z) (Cons (S (S Z)) (Cons (S (S (S Z))) Nil)))))))]
P;HTML|
;           #(maybe_halt 7)
<span class="ansi31"
>#(in #(not_compat_io #(maybe_halt 7)) #(unwind #(halt 7)))
</span>
Script done on 2024-12-24 11:37:37+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat/' --timeout=40 --html --repl=false  --test "tests/baseline_compat/hyperon-mettalog_sanity/sorting_tests_nats_mw.metta" --halt=true\033[0m
