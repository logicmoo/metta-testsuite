<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi31 { color: #aa0000; }
.ansi33 { color: #aa5500; }
.ansi36 { color: #00aaaa; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-12-26 18:51:04+00:00 [COMMAND="timeout --preserve-status --foreground --signal=SIGTERM --kill-after=5s 40 swipl  /home/runner/work/metta-testsuite/metta-testsuite/prolog/metta_lang/metta_interp.pl -- --python=enable -- --timeout=40 --output=./reports/tests_output/baseline-compat/ --html --test tests/baseline_compat/hyperon-mettalog_sanity/synth_buffer/time_synthesize_long.metta --halt=true  --stdin=tty --stdout=tty --stderr=tty" TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;         #(set_debug transpiler false)

P;HTML|
;          #(set_debug overtime 4.0)

P;HTML|
;          #(set_debug overflow 1000)

P;HTML|
;          #(set_debug eval false)

P;HTML|
;          #(set_debug load silent)

P;HTML|
;          #(set_debug trace-on-load false)

P;HTML|
;          #(set_debug exec false)

P;HTML|
;          #(set_debug error non-type)

P;HTML|
;          #(set_debug fail false)

P;HTML|
;          #(set_debug test true)

P;HTML|
;         #(set_debug test false)

P;HTML|
;         #(set_debug fail false)
P;HTML|
;          #(set_debug transpiler false)
P;HTML|
;          #(set_debug overtime 4.0)
P;HTML|
;          #(set_debug overflow 1000)
P;HTML|
;          #(set_debug eval false)
P;HTML|
;          #(set_debug load silent)
P;HTML|
;          #(set_debug trace-on-load false)
P;HTML|
;          #(set_debug exec false)
P;HTML|
;          #(set_debug error non-type)
P;HTML|
;          #(set_debug fail false)
P;HTML|
;          #(set_debug test true)
P;HTML|
;          #(set_debug test false)
P;HTML|
;          #(set_debug fail false)

; #( : user #(load_metta_file &self tests/baseline_compat/hyperon-mettalog_sanity/synth_buffer/time_synthesize_long.metta) )
P;HTML|
;                #(track_load_into_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/synth_buffer/time_synthesize_long.metta)
P;HTML|
;                       #(load_answer_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/synth_buffer/time_synthesize_long.metta.answers /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/synth_buffer/time_synthesize_long.metta)
P;HTML|
;                        #( = 1 "[()]" )
P;HTML|
;                        #( = 2 "[()]" )
P;HTML|
;                         #( = 3 "[()]" )
P;HTML|
;                         #( = 4 "[()]" )
P;HTML|
;                        #(load_answer_file /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/synth_buffer/time_synthesize_long.metta.answers /home/runner/work/metta-testsuite/metta-testsuite/tests/baseline_compat/hyperon-mettalog_sanity/synth_buffer/time_synthesize_long.metta)

;;;;time metta tests/baseline_compat/hyperon-mettalog_sanity/time_synthesize_long.metta
;;;;real    1m1.667s
;;;;user    1m1.635s
;;;;sys     0m0.030s
;;;;time mettalog tests/baseline_compat/hyperon-mettalog_sanity/time_synthesize_long.metta
;;;;real    1m1.667s
;;;;user    1m1.635s
;;;;sys     0m0.030s
;;;; Import modules
;;;; Define Nat
<span class="ansi38-255165000"
> (: Nat Type)
</span><span class="ansi38-255165000"
> (: Z Nat)
</span><span class="ansi38-255165000"
> (: S (-> Nat Nat))
</span>;;;; Enumerate all programs up to a given depth that are consistent with
;;;; the query
;;;;		 using the given axiom non-deterministic functions and rules.
;;;;
;;;; The arguments are:
;;;;
;;;; $query: an Atom under the form (: TERM TYPE).  The atom may contain
;;;;         free variables within TERM and TYPE to form various sort of
;;;;         queries
;;;;		 such as:
;;;;         1. Backward chaining: (: $term (Inheritance $x Mammal))
;;;;         2. Forward chaining: (: ($rule $premise AXIOM) $type)
;;;;         3. Mixed chaining: (: ($rule $premise AXIOM) (Inheritance $x Mammal))
;;;;         4. Type checking: (: TERM TYPE)
;;;;         5. Type inference: (: TERM $type)
;;;;
;;;; $kb: a nullary function to axiom
;;;;		 to non-deterministically pick up
;;;;      an axiom.  An axiom is an Atom of the form (: TERM TYPE).
;;;;
;;;; $rb: a nullary function to rule
;;;;		 to non-deterministically pick up a
;;;;      rule.  A rule is a function mapping premises to conclusion
;;;;		
;;;;      where premises and conclusion have the form (: TERM TYPE).
;;;;
;;;; $depth: a Nat representing the maximum depth of the generated
;;;;         programs.
;;;;
;;;; TODO: recurse over curried rules instead of duplicating code over
;;;; tuples.
<span class="ansi38-255165000"
> (: synthesize (-> $a (-> $kt) (-> $rt) Nat $a))
</span>;;;; Nullary rule (axiom)
<span class="ansi38-255165000"
> (= (synthesize $query $kb $rb $depth)  
  (let $query 
    ($kb) $query))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(synthesize, 5, 0, ['Number', [->, A], [->, B], 'Nat'], 'Number', [x(doeval, eager), x(doeval, eager), x(doeval, eager), x(doeval, eager)], x(doeval, eager), [synthesize, _query, _kb, _rb, _depth], [let, _query, [_kb], _query]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_4__synthesize</span>(<span class="pl-args"
><span class="pl-var"
>_query</span>, <span class="pl-var"
>_kb</span>, <span class="pl-var"
>_rb</span>, <span class="pl-var"
>_depth</span>, <span class="pl-var"
>_query</span></span>)</span>, 
  [ [ <span class="pl-atom"
>assign</span>, <span class="pl-var"
>_query</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>list</span>(<span class="pl-args"
><span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-var"
>_kb</span></span>]</span></span>)</span>]]].&#13;&#10;
mc_4__synthesize(_query, _kb, _rb, _depth, _query) :-
    _query=[_kb].
<span class="ansi36"
>
mc_4__synthesize(_query, _kb, _rb, _depth, _query) :-
    _query=[_kb].

</span>
;;;; Unary rule
<span class="ansi38-255165000"
> (= (synthesize $query $kb $rb (S $k))  
  (let* 
    ( ( (: $ructor 
          (-> $premise $conclusion)) ($rb)) 
      ( (: 
          ($ructor $proof) $conclusion) $query) 
      ( (: $proof $premise) (synthesize (: $proof $premise) $kb $rb $k))) $query))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(synthesize, 5, 1, ['Number', [->, A], [->, B], 'Nat'], 'Number', [x(doeval, eager), x(doeval, eager), x(doeval, eager), x(doeval, eager)], x(doeval, eager), [synthesize, _query, _kb, _rb, ['S', _k]], ['let*', [[[:, _ructor, [->, _premise, _conclusion]], [_rb]], [[:, [_ructor, _proof], _conclusion], _query], [[:, _proof, _premise], [synthesize, [:, _proof, _premise], _kb, _rb, _k]]], _query]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_4__synthesize</span>(<span class="pl-args"
><span class="pl-var"
>_query</span>, <span class="pl-var"
>_kb</span>, <span class="pl-var"
>_rb</span>, <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'S'</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, <span class="pl-var"
>_query</span></span>)</span>, 
  [ [ <span class="pl-atom"
>assign</span>, <span class="pl-var"
>A</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>list</span>(<span class="pl-args"
><span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-var"
>_rb</span></span>]</span></span>)</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      [ <span class="pl-atom"
>:</span>, 
        <span class="pl-var"
>_ructor</span>, 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>-&gt;</span>, <span class="pl-var"
>_premise</span>|<span class="pl-ellipsis"
>...</span></span>]</span>], 
      <span class="pl-var"
>A</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      [ <span class="pl-atom"
>:</span>, 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-var"
>_ructor</span>, <span class="pl-var"
>_proof</span></span>]</span>, 
        <span class="pl-var"
>_conclusion</span>], 
      <span class="pl-var"
>_query</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>synthesize</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_kb'</span></span>)</span>, 
        <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_rb'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_k'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>:</span>, <span class="pl-var"
>_proof</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
      <span class="pl-var"
>C</span>]]].&#13;&#10;
Asserting: transpiler_depends_on(synthesize,5,:,3)
<span class="ansi36"
>transpiler_stub_created((:)/3).

</span>; % ######### warning: creating stub for::
<span class="ansi36"
>
'mc_2__:'(B, C, D) :-
    D=[:, B, C].

</span>mc_4__synthesize(_query, _kb, _rb, ['S', _k], _query) :-
    A=[_rb],
    [:, _ructor, [->, _premise, _conclusion]]=A,
    [:, [_ructor, _proof], _conclusion]=_query,
    'mc_2__:'(_proof, _premise, B),
    mc_4__synthesize(B, _kb, _rb, _k, C),
    [:, _proof, _premise]=C.
<span class="ansi36"
>
mc_4__synthesize(_query, _kb, _rb, ['S', _k], _query) :-
    A=[_rb],
    [:, _ructor, [->, _premise, _conclusion]]=A,
    [:, [_ructor, _proof], _conclusion]=_query,
    'mc_2__:'(_proof, _premise, B),
    mc_4__synthesize(B, _kb, _rb, _k, C),
    [:, _proof, _premise]=C.

</span>
;;;; Binary rule
<span class="ansi38-255165000"
> (= (synthesize $query $kb $rb (S $k))  
  (let* 
    ( ( (: $ructor 
          (-> $premise1 $premise2 $conclusion)) ($rb)) 
      ( (: 
          ($ructor $proof1 $proof2) $conclusion) $query) 
      ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
      ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k))) $query))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(synthesize, 5, 2, ['Number', [->, A], [->, B], 'Nat'], 'Number', [x(doeval, eager), x(doeval, eager), x(doeval, eager), x(doeval, eager)], x(doeval, eager), [synthesize, _query, _kb, _rb, ['S', _k]], ['let*', [[[:, _ructor, [->, _premise1, _premise2, _conclusion]], [_rb]], [[:, [_ructor, _proof1, _proof2], _conclusion], _query], [[:, _proof1, _premise1], [synthesize, [:, _proof1, _premise1], _kb, _rb, _k]], [[:, _proof2, _premise2], [synthesize, [:, _proof2, _premise2], _kb, _rb, _k]]], _query]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_4__synthesize</span>(<span class="pl-args"
><span class="pl-var"
>_query</span>, <span class="pl-var"
>_kb</span>, <span class="pl-var"
>_rb</span>, <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'S'</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, <span class="pl-var"
>_query</span></span>)</span>, 
  [ [ <span class="pl-atom"
>assign</span>, <span class="pl-var"
>A</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>list</span>(<span class="pl-args"
><span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-var"
>_rb</span></span>]</span></span>)</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      [ <span class="pl-atom"
>:</span>, 
        <span class="pl-var"
>_ructor</span>, 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>-&gt;</span>, <span class="pl-var"
>_premise1</span>|<span class="pl-ellipsis"
>...</span></span>]</span>], 
      <span class="pl-var"
>A</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      [ <span class="pl-atom"
>:</span>, 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-var"
>_ructor</span>, <span class="pl-var"
>_proof1</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
        <span class="pl-var"
>_conclusion</span>], 
      <span class="pl-var"
>_query</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof1'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise1'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>synthesize</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_kb'</span></span>)</span>, 
        <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_rb'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_k'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>:</span>, <span class="pl-var"
>_proof1</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
      <span class="pl-var"
>C</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>D</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof2'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise2'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>E</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>synthesize</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>3</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_kb'</span></span>)</span>, 
        <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_rb'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_k'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>:</span>, <span class="pl-var"
>_proof2</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
      <span class="pl-var"
>E</span>]]].&#13;&#10;
mc_4__synthesize(_query, _kb, _rb, ['S', _k], _query) :-
    A=[_rb],
    [:, _ructor, [->, _premise1, _premise2, _conclusion]]=A,
    [:, [_ructor, _proof1, _proof2], _conclusion]=_query,
    'mc_2__:'(_proof1, _premise1, B),
    mc_4__synthesize(B, _kb, _rb, _k, C),
    [:, _proof1, _premise1]=C,
    'mc_2__:'(_proof2, _premise2, D),
    mc_4__synthesize(D, _kb, _rb, _k, E),
    [:, _proof2, _premise2]=E.
<span class="ansi36"
>
mc_4__synthesize(_query, _kb, _rb, ['S', _k], _query) :-
    A=[_rb],
    [:, _ructor, [->, _premise1, _premise2, _conclusion]]=A,
    [:, [_ructor, _proof1, _proof2], _conclusion]=_query,
    'mc_2__:'(_proof1, _premise1, B),
    mc_4__synthesize(B, _kb, _rb, _k, C),
    [:, _proof1, _premise1]=C,
    'mc_2__:'(_proof2, _premise2, D),
    mc_4__synthesize(D, _kb, _rb, _k, E),
    [:, _proof2, _premise2]=E.

</span>
;;;; Trinary rule
<span class="ansi38-255165000"
> (= (synthesize $query $kb $rb (S $k))  
  (let* 
    ( ( (: $ructor 
          (-> $premise1 $premise2 $premise3 $conclusion)) ($rb)) 
      ( (: 
          ($ructor $proof1 $proof2 $proof3) $conclusion) $query) 
      ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
      ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k)) 
      ( (: $proof3 $premise3) (synthesize (: $proof3 $premise3) $kb $rb $k))) $query))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(synthesize, 5, 3, ['Number', [->, A], [->, B], 'Nat'], 'Number', [x(doeval, eager), x(doeval, eager), x(doeval, eager), x(doeval, eager)], x(doeval, eager), [synthesize, _query, _kb, _rb, ['S', _k]], ['let*', [[[:, _ructor, [->, _premise1, _premise2, _premise3, _conclusion]], [_rb]], [[:, [_ructor, _proof1, _proof2, _proof3], _conclusion], _query], [[:, _proof1, _premise1], [synthesize, [:, _proof1, _premise1], _kb, _rb, _k]], [[:, _proof2, _premise2], [synthesize, [:, _proof2, _premise2], _kb, _rb, _k]], [[:, _proof3, _premise3], [synthesize, [:, _proof3, _premise3], _kb, _rb, _k]]], _query]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_4__synthesize</span>(<span class="pl-args"
><span class="pl-var"
>_query</span>, <span class="pl-var"
>_kb</span>, <span class="pl-var"
>_rb</span>, <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'S'</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, <span class="pl-var"
>_query</span></span>)</span>, 
  [ [ <span class="pl-atom"
>assign</span>, <span class="pl-var"
>A</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>list</span>(<span class="pl-args"
><span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-var"
>_rb</span></span>]</span></span>)</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      [ <span class="pl-atom"
>:</span>, 
        <span class="pl-var"
>_ructor</span>, 
        [ <span class="pl-atom"
>-&gt;</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise1'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise2'</span></span>)</span>, 
          <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise3'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_conclusion'</span></span>)</span>]], 
      <span class="pl-var"
>A</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      [ <span class="pl-atom"
>:</span>, 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-var"
>_ructor</span>, <span class="pl-var"
>_proof1</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
        <span class="pl-var"
>_conclusion</span>], 
      <span class="pl-var"
>_query</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof1'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise1'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>synthesize</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_kb'</span></span>)</span>, 
        <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_rb'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_k'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>:</span>, <span class="pl-var"
>_proof1</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
      <span class="pl-var"
>C</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>D</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof2'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise2'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>E</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>synthesize</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>3</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_kb'</span></span>)</span>, 
        <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_rb'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_k'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>:</span>, <span class="pl-var"
>_proof2</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
      <span class="pl-var"
>E</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>F</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof3'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise3'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>G</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>synthesize</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>5</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_kb'</span></span>)</span>, 
        <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_rb'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_k'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>:</span>, <span class="pl-var"
>_proof3</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
      <span class="pl-var"
>G</span>]]].&#13;&#10;
mc_4__synthesize(_query, _kb, _rb, ['S', _k], _query) :-
    A=[_rb],
    [:, _ructor, [->, _premise1, _premise2, _premise3, _conclusion]]=A,
    [:, [_ructor, _proof1, _proof2, _proof3], _conclusion]=_query,
    'mc_2__:'(_proof1, _premise1, B),
    mc_4__synthesize(B, _kb, _rb, _k, C),
    [:, _proof1, _premise1]=C,
    'mc_2__:'(_proof2, _premise2, D),
    mc_4__synthesize(D, _kb, _rb, _k, E),
    [:, _proof2, _premise2]=E,
    'mc_2__:'(_proof3, _premise3, F),
    mc_4__synthesize(F, _kb, _rb, _k, G),
    [:, _proof3, _premise3]=G.
<span class="ansi36"
>
mc_4__synthesize(_query, _kb, _rb, ['S', _k], _query) :-
    A=[_rb],
    [:, _ructor, [->, _premise1, _premise2, _premise3, _conclusion]]=A,
    [:, [_ructor, _proof1, _proof2, _proof3], _conclusion]=_query,
    'mc_2__:'(_proof1, _premise1, B),
    mc_4__synthesize(B, _kb, _rb, _k, C),
    [:, _proof1, _premise1]=C,
    'mc_2__:'(_proof2, _premise2, D),
    mc_4__synthesize(D, _kb, _rb, _k, E),
    [:, _proof2, _premise2]=E,
    'mc_2__:'(_proof3, _premise3, F),
    mc_4__synthesize(F, _kb, _rb, _k, G),
    [:, _proof3, _premise3]=G.

</span>
;;;; Quaternary rule
<span class="ansi38-255165000"
> (= (synthesize $query $kb $rb (S $k))  
  (let* 
    ( ( (: $ructor 
          (-> $premise1 $premise2 $premise3 $premise4 $conclusion)) ($rb)) 
      ( (: 
          ($ructor $proof1 $proof2 $proof3 $proof4) $conclusion) $query) 
      ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
      ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k)) 
      ( (: $proof3 $premise3) (synthesize (: $proof3 $premise3) $kb $rb $k)) 
      ( (: $proof4 $premise4) (synthesize (: $proof4 $premise4) $kb $rb $k))) $query))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(synthesize, 5, 4, ['Number', [->, A], [->, B], 'Nat'], 'Number', [x(doeval, eager), x(doeval, eager), x(doeval, eager), x(doeval, eager)], x(doeval, eager), [synthesize, _query, _kb, _rb, ['S', _k]], ['let*', [[[:, _ructor, [->, _premise1, _premise2, _premise3, _premise4, _conclusion]], [_rb]], [[:, [_ructor, _proof1, _proof2, _proof3, _proof4], _conclusion], _query], [[:, _proof1, _premise1], [synthesize, [:, _proof1, _premise1], _kb, _rb, _k]], [[:, _proof2, _premise2], [synthesize, [:, _proof2, _premise2], _kb, _rb, _k]], [[:, _proof3, _premise3], [synthesize, [:, _proof3, _premise3], _kb, _rb, _k]], [[:, _proof4, _premise4], [synthesize, [:, _proof4, _premise4], _kb, _rb, _k]]], _query]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_4__synthesize</span>(<span class="pl-args"
><span class="pl-var"
>_query</span>, <span class="pl-var"
>_kb</span>, <span class="pl-var"
>_rb</span>, <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'S'</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, <span class="pl-var"
>_query</span></span>)</span>, 
  [ [ <span class="pl-atom"
>assign</span>, <span class="pl-var"
>A</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>list</span>(<span class="pl-args"
><span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-var"
>_rb</span></span>]</span></span>)</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      [ <span class="pl-atom"
>:</span>, 
        <span class="pl-var"
>_ructor</span>, 
        [ <span class="pl-atom"
>-&gt;</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise1'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise2'</span></span>)</span>, 
          <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise3'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise4'</span></span>)</span>, 
          <span class="pl-var"
>_conclusion</span>]], 
      <span class="pl-var"
>A</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      [ <span class="pl-atom"
>:</span>, 
        [ <span class="pl-var"
>_ructor</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof1'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof2'</span></span>)</span>, 
          <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof3'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof4'</span></span>)</span>], 
        <span class="pl-var"
>_conclusion</span>], 
      <span class="pl-var"
>_query</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof1'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise1'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>synthesize</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_kb'</span></span>)</span>, 
        <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_rb'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_k'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>:</span>, <span class="pl-var"
>_proof1</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
      <span class="pl-var"
>C</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>D</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof2'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise2'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>E</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>synthesize</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>3</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_kb'</span></span>)</span>, 
        <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_rb'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_k'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>:</span>, <span class="pl-var"
>_proof2</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
      <span class="pl-var"
>E</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>F</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof3'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise3'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>G</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>synthesize</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>5</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_kb'</span></span>)</span>, 
        <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_rb'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_k'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>:</span>, <span class="pl-var"
>_proof3</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
      <span class="pl-var"
>G</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>H</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof4'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise4'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>I</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>synthesize</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>7</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_kb'</span></span>)</span>, 
        <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_rb'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_k'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>:</span>, <span class="pl-var"
>_proof4</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
      <span class="pl-var"
>I</span>]]].&#13;&#10;
mc_4__synthesize(_query, _kb, _rb, ['S', _k], _query) :-
    A=[_rb],
    [:, _ructor, [->, _premise1, _premise2, _premise3, _premise4, _conclusion]]=A,
    [:, [_ructor, _proof1, _proof2, _proof3, _proof4], _conclusion]=_query,
    'mc_2__:'(_proof1, _premise1, B),
    mc_4__synthesize(B, _kb, _rb, _k, C),
    [:, _proof1, _premise1]=C,
    'mc_2__:'(_proof2, _premise2, D),
    mc_4__synthesize(D, _kb, _rb, _k, E),
    [:, _proof2, _premise2]=E,
    'mc_2__:'(_proof3, _premise3, F),
    mc_4__synthesize(F, _kb, _rb, _k, G),
    [:, _proof3, _premise3]=G,
    'mc_2__:'(_proof4, _premise4, H),
    mc_4__synthesize(H, _kb, _rb, _k, I),
    [:, _proof4, _premise4]=I.
<span class="ansi36"
>
mc_4__synthesize(_query, _kb, _rb, ['S', _k], _query) :-
    A=[_rb],
    [:, _ructor, [->, _premise1, _premise2, _premise3, _premise4, _conclusion]]=A,
    [:, [_ructor, _proof1, _proof2, _proof3, _proof4], _conclusion]=_query,
    'mc_2__:'(_proof1, _premise1, B),
    mc_4__synthesize(B, _kb, _rb, _k, C),
    [:, _proof1, _premise1]=C,
    'mc_2__:'(_proof2, _premise2, D),
    mc_4__synthesize(D, _kb, _rb, _k, E),
    [:, _proof2, _premise2]=E,
    'mc_2__:'(_proof3, _premise3, F),
    mc_4__synthesize(F, _kb, _rb, _k, G),
    [:, _proof3, _premise3]=G,
    'mc_2__:'(_proof4, _premise4, H),
    mc_4__synthesize(H, _kb, _rb, _k, I),
    [:, _proof4, _premise4]=I.

</span>
;;;; Quintenary rule
<span class="ansi38-255165000"
> (= (synthesize $query $kb $rb (S $k))  
  (let* 
    ( ( (: $ructor 
          (-> $premise1 $premise2 $premise3 $premise4 $premise5 $conclusion)) ($rb)) 
      ( (: 
          ($ructor $proof1 $proof2 $proof3 $proof4 $proof5) $conclusion) $query) 
      ( (: $proof1 $premise1) (synthesize (: $proof1 $premise1) $kb $rb $k)) 
      ( (: $proof2 $premise2) (synthesize (: $proof2 $premise2) $kb $rb $k)) 
      ( (: $proof3 $premise3) (synthesize (: $proof3 $premise3) $kb $rb $k)) 
      ( (: $proof4 $premise4) (synthesize (: $proof4 $premise4) $kb $rb $k)) 
      ( (: $proof5 $premise5) (synthesize (: $proof5 $premise5) $kb $rb $k))) $query))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(synthesize, 5, 5, ['Number', [->, A], [->, B], 'Nat'], 'Number', [x(doeval, eager), x(doeval, eager), x(doeval, eager), x(doeval, eager)], x(doeval, eager), [synthesize, _query, _kb, _rb, ['S', _k]], ['let*', [[[:, _ructor, [->, _premise1, _premise2, _premise3, _premise4, _premise5, _conclusion]], [_rb]], [[:, [_ructor, _proof1, _proof2, _proof3, _proof4, _proof5], _conclusion], _query], [[:, _proof1, _premise1], [synthesize, [:, _proof1, _premise1], _kb, _rb, _k]], [[:, _proof2, _premise2], [synthesize, [:, _proof2, _premise2], _kb, _rb, _k]], [[:, _proof3, _premise3], [synthesize, [:, _proof3, _premise3], _kb, _rb, _k]], [[:, _proof4, _premise4], [synthesize, [:, _proof4, _premise4], _kb, _rb, _k]], [[:, _proof5, _premise5], [synthesize, [:, _proof5, _premise5], _kb, _rb, _k]]], _query]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_4__synthesize</span>(<span class="pl-args"
><span class="pl-var"
>_query</span>, <span class="pl-var"
>_kb</span>, <span class="pl-var"
>_rb</span>, <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'S'</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, <span class="pl-var"
>_query</span></span>)</span>, 
  [ [ <span class="pl-atom"
>assign</span>, <span class="pl-var"
>A</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>list</span>(<span class="pl-args"
><span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-var"
>_rb</span></span>]</span></span>)</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      [ <span class="pl-atom"
>:</span>, 
        <span class="pl-var"
>_ructor</span>, 
        [ <span class="pl-atom"
>-&gt;</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise1'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise2'</span></span>)</span>, 
          <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise3'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise4'</span></span>)</span>, 
          <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise5'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_conclusion'</span></span>)</span>]], 
      <span class="pl-var"
>A</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      [ <span class="pl-atom"
>:</span>, 
        [ <span class="pl-var"
>_ructor</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof1'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof2'</span></span>)</span>, 
          <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof3'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof4'</span></span>)</span>, 
          <span class="pl-var"
>_proof5</span>], 
        <span class="pl-var"
>_conclusion</span>], 
      <span class="pl-var"
>_query</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>B</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof1'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise1'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>synthesize</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_kb'</span></span>)</span>, 
        <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_rb'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_k'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>:</span>, <span class="pl-var"
>_proof1</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
      <span class="pl-var"
>C</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>D</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof2'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise2'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>E</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>synthesize</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>3</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_kb'</span></span>)</span>, 
        <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_rb'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_k'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>:</span>, <span class="pl-var"
>_proof2</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
      <span class="pl-var"
>E</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>F</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof3'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise3'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>G</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>synthesize</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>5</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_kb'</span></span>)</span>, 
        <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_rb'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_k'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>:</span>, <span class="pl-var"
>_proof3</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
      <span class="pl-var"
>G</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>H</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof4'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise4'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>I</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>synthesize</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>7</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_kb'</span></span>)</span>, 
        <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_rb'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_k'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>:</span>, <span class="pl-var"
>_proof4</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
      <span class="pl-var"
>I</span>], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>J</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_proof5'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_premise5'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>K</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>synthesize</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>9</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_kb'</span></span>)</span>, 
        <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_rb'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_k'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>:</span>, <span class="pl-var"
>_proof5</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
      <span class="pl-var"
>K</span>]]].&#13;&#10;
mc_4__synthesize(_query, _kb, _rb, ['S', _k], _query) :-
    A=[_rb],
    [:, _ructor, [->, _premise1, _premise2, _premise3, _premise4, _premise5, _conclusion]]=A,
    [:, [_ructor, _proof1, _proof2, _proof3, _proof4, _proof5], _conclusion]=_query,
    'mc_2__:'(_proof1, _premise1, B),
    mc_4__synthesize(B, _kb, _rb, _k, C),
    [:, _proof1, _premise1]=C,
    'mc_2__:'(_proof2, _premise2, D),
    mc_4__synthesize(D, _kb, _rb, _k, E),
    [:, _proof2, _premise2]=E,
    'mc_2__:'(_proof3, _premise3, F),
    mc_4__synthesize(F, _kb, _rb, _k, G),
    [:, _proof3, _premise3]=G,
    'mc_2__:'(_proof4, _premise4, H),
    mc_4__synthesize(H, _kb, _rb, _k, I),
    [:, _proof4, _premise4]=I,
    'mc_2__:'(_proof5, _premise5, J),
    mc_4__synthesize(J, _kb, _rb, _k, K),
    [:, _proof5, _premise5]=K.
<span class="ansi36"
>
mc_4__synthesize(_query, _kb, _rb, ['S', _k], _query) :-
    A=[_rb],
    [:, _ructor, [->, _premise1, _premise2, _premise3, _premise4, _premise5, _conclusion]]=A,
    [:, [_ructor, _proof1, _proof2, _proof3, _proof4, _proof5], _conclusion]=_query,
    'mc_2__:'(_proof1, _premise1, B),
    mc_4__synthesize(B, _kb, _rb, _k, C),
    [:, _proof1, _premise1]=C,
    'mc_2__:'(_proof2, _premise2, D),
    mc_4__synthesize(D, _kb, _rb, _k, E),
    [:, _proof2, _premise2]=E,
    'mc_2__:'(_proof3, _premise3, F),
    mc_4__synthesize(F, _kb, _rb, _k, G),
    [:, _proof3, _premise3]=G,
    'mc_2__:'(_proof4, _premise4, H),
    mc_4__synthesize(H, _kb, _rb, _k, I),
    [:, _proof4, _premise4]=I,
    'mc_2__:'(_proof5, _premise5, J),
    mc_4__synthesize(J, _kb, _rb, _k, K),
    [:, _proof5, _premise5]=K.

</span>
<span class="ansi38-255165000"
> (: kb (-> Atom))
</span><span class="ansi38-255165000"
> (= (kb)  
  (: a A))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(kb, 1, 0, [], 'Atom', [], x(doeval, eager), [kb], [:, a, 'A']).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_0__kb</span>(<span class="pl-args"
><span class="pl-var"
>A</span></span>)</span>, 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>C</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>2</span></span>)</span>]]]].&#13;&#10;
Asserting: transpiler_depends_on(kb,1,:,3)
mc_0__kb(A) :-
    B=a,
    C='A',
    'mc_2__:'(B, C, A).
<span class="ansi36"
>
mc_0__kb(A) :-
    B=a,
    C='A',
    'mc_2__:'(B, C, A).

</span>
<span class="ansi38-255165000"
> (= (kb)  
  (: a B))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(kb, 1, 1, [], 'Atom', [], x(doeval, eager), [kb], [:, a, 'B']).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_0__kb</span>(<span class="pl-args"
><span class="pl-var"
>A</span></span>)</span>, 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>C</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>2</span></span>)</span>]]]].&#13;&#10;
mc_0__kb(A) :-
    B=a,
    C='B',
    'mc_2__:'(B, C, A).
<span class="ansi36"
>
mc_0__kb(A) :-
    B=a,
    C='B',
    'mc_2__:'(B, C, A).

</span>
<span class="ansi38-255165000"
> (= (kb)  
  (: abc 
    (Implication 
      (AndLink A B) C)))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(kb, 1, 2, [], 'Atom', [], x(doeval, eager), [kb], [:, abc, ['Implication', ['AndLink', 'A', 'B'], 'C']]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_0__kb</span>(<span class="pl-args"
><span class="pl-var"
>A</span></span>)</span>, 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>C</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>D</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>E</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'AndLink'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>2</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>3</span></span>)</span>]], 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>F</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>G</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Implication'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>4</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>5</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>6</span></span>)</span>]]]].&#13;&#10;
Asserting: transpiler_depends_on(kb,1,'AndLink',3)
<span class="ansi36"
>transpiler_stub_created('AndLink'/3).

</span>; % ######### warning: creating stub for:'AndLink'
<span class="ansi36"
>
mc_2__AndLink(B, C, D) :-
    D=['AndLink', B, C].

</span>Asserting: transpiler_depends_on(kb,1,'Implication',3)
<span class="ansi36"
>transpiler_stub_created('Implication'/3).

</span>; % ######### warning: creating stub for:'Implication'
<span class="ansi36"
>
mc_2__Implication(B, C, D) :-
    D=['Implication', B, C].

</span>mc_0__kb(A) :-
    B=abc,
    C='A',
    D='B',
    mc_2__AndLink(C, D, E),
    F='C',
    mc_2__Implication(E, F, G),
    'mc_2__:'(B, G, A).
<span class="ansi36"
>
mc_0__kb(A) :-
    B=abc,
    C='A',
    D='B',
    mc_2__AndLink(C, D, E),
    F='C',
    mc_2__Implication(E, F, G),
    'mc_2__:'(B, G, A).

</span>
<span class="ansi38-255165000"
> (= (kb)  
  (: cde 
    (Implication 
      (OrLink C D) E)))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(kb, 1, 3, [], 'Atom', [], x(doeval, eager), [kb], [:, cde, ['Implication', ['OrLink', 'C', 'D'], 'E']]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_0__kb</span>(<span class="pl-args"
><span class="pl-var"
>A</span></span>)</span>, 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>C</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>D</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>E</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'OrLink'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>2</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>3</span></span>)</span>]], 
    <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>F</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>G</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>'Implication'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>4</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>5</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>6</span></span>)</span>]]]].&#13;&#10;
Asserting: transpiler_depends_on(kb,1,'OrLink',3)
<span class="ansi36"
>transpiler_stub_created('OrLink'/3).

</span>; % ######### warning: creating stub for:'OrLink'
<span class="ansi36"
>
mc_2__OrLink(B, C, D) :-
    D=['OrLink', B, C].

</span>mc_0__kb(A) :-
    B=cde,
    C='C',
    D='D',
    mc_2__OrLink(C, D, E),
    F='E',
    mc_2__Implication(E, F, G),
    'mc_2__:'(B, G, A).
<span class="ansi36"
>
mc_0__kb(A) :-
    B=cde,
    C='C',
    D='D',
    mc_2__OrLink(C, D, E),
    F='E',
    mc_2__Implication(E, F, G),
    'mc_2__:'(B, G, A).

</span>
<span class="ansi38-013099040"
>!(assertEqualToResult (kb) ((: abc (Implication (AndLink A B) C)) (: a A) (: a B) (: cde (Implication (OrLink C D) E))))

</span>
;<h3 id="SYNTH-BUFFER.TIME-SYNTHESIZE-LONG.01"
>;; SYNTH-BUFFER.TIME-SYNTHESIZE-LONG.01</h3>
; 
; EVAL TEST
; took 0.003 secs. (2.76 milliseconds) 

!(assertEqualToResult (kb) ((: abc (Implication (AndLink A B) C)) (: a A) (: a B) (: cde (Implication (OrLink C D) E))))

<span class="ansi36"
>  #(loonit_success 
    #(equal_enough_for_test 
      ( (: a A) 
        (: a B) 
        (: abc 
          (Implication 
            (AndLink A B) C)) 
        (: cde 
          (Implication 
            (OrLink C D) E))) 
      ( (: abc 
          (Implication 
            (AndLink A B) C)) 
        (: a A) 
        (: a B) 
        (: cde 
          (Implication 
            (OrLink C D) E)))))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-255165000"
> (: rb (-> Atom))
</span><span class="ansi38-255165000"
> (= (rb)  
  (: ModusPonens 
    (-> 
      (ImplicationLink $p $q) $p $q)))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(rb, 1, 0, [], 'Atom', [], x(doeval, eager), [rb], [:, 'ModusPonens', [->, ['ImplicationLink', _p, _q], _p, _q]]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_0__rb</span>(<span class="pl-args"
><span class="pl-var"
>A</span></span>)</span>, 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      [ <span class="pl-atom"
>-&gt;</span>, 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'ImplicationLink'</span>, <span class="pl-var"
>_p</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_p'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_q'</span></span>)</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>2</span></span>)</span>]]]].&#13;&#10;
Asserting: transpiler_depends_on(rb,1,:,3)
mc_0__rb(A) :-
    B='ModusPonens',
    C=[->, ['ImplicationLink', _p, _q], _p, _q],
    'mc_2__:'(B, C, A).
<span class="ansi36"
>
mc_0__rb(A) :-
    B='ModusPonens',
    C=[->, ['ImplicationLink', _p, _q], _p, _q],
    'mc_2__:'(B, C, A).

</span>
<span class="ansi38-255165000"
> (= (rb)  
  (: Deduction 
    (-> 
      (ImplicationLink $p $q) 
      (ImplicationLink $q $r) 
      (ImplicationLink $p $r))))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(rb, 1, 1, [], 'Atom', [], x(doeval, eager), [rb], [:, 'Deduction', [->, ['ImplicationLink', _p, _q], ['ImplicationLink', _q, _r], ['ImplicationLink', _p, _r]]]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_0__rb</span>(<span class="pl-args"
><span class="pl-var"
>A</span></span>)</span>, 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      [ <span class="pl-atom"
>-&gt;</span>, 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'ImplicationLink'</span>, <span class="pl-var"
>_p</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'ImplicationLink'</span>, <span class="pl-var"
>_q</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'ImplicationLink'</span>, <span class="pl-var"
>_p</span>|<span class="pl-ellipsis"
>...</span></span>]</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>2</span></span>)</span>]]]].&#13;&#10;
mc_0__rb(A) :-
    B='Deduction',
    C=[->, ['ImplicationLink', _p, _q], ['ImplicationLink', _q, _r], ['ImplicationLink', _p, _r]],
    'mc_2__:'(B, C, A).
<span class="ansi36"
>
mc_0__rb(A) :-
    B='Deduction',
    C=[->, ['ImplicationLink', _p, _q], ['ImplicationLink', _q, _r], ['ImplicationLink', _p, _r]],
    'mc_2__:'(B, C, A).

</span>
<span class="ansi38-255165000"
> (= (rb)  
  (: DisjunctiveSyllogism 
    (-> 
      (OrLink $p $q) 
      (NotLink $p) $q)))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(rb, 1, 2, [], 'Atom', [], x(doeval, eager), [rb], [:, 'DisjunctiveSyllogism', [->, ['OrLink', _p, _q], ['NotLink', _p], _q]]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_0__rb</span>(<span class="pl-args"
><span class="pl-var"
>A</span></span>)</span>, 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      [ <span class="pl-atom"
>-&gt;</span>, 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'OrLink'</span>, <span class="pl-var"
>_p</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'NotLink'</span>, <span class="pl-var"
>_p</span></span>]</span>, 
        <span class="pl-var"
>_q</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>2</span></span>)</span>]]]].&#13;&#10;
mc_0__rb(A) :-
    B='DisjunctiveSyllogism',
    C=[->, ['OrLink', _p, _q], ['NotLink', _p], _q],
    'mc_2__:'(B, C, A).
<span class="ansi36"
>
mc_0__rb(A) :-
    B='DisjunctiveSyllogism',
    C=[->, ['OrLink', _p, _q], ['NotLink', _p], _q],
    'mc_2__:'(B, C, A).

</span>
<span class="ansi38-255165000"
> (= (rb)  
  (: DisjunctiveSyllogism 
    (-> 
      (OrLink $p $q) 
      (NotLink $q) $p)))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(rb, 1, 3, [], 'Atom', [], x(doeval, eager), [rb], [:, 'DisjunctiveSyllogism', [->, ['OrLink', _p, _q], ['NotLink', _q], _p]]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_0__rb</span>(<span class="pl-args"
><span class="pl-var"
>A</span></span>)</span>, 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      [ <span class="pl-atom"
>-&gt;</span>, 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'OrLink'</span>, <span class="pl-var"
>_p</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'NotLink'</span>, <span class="pl-var"
>_q</span></span>]</span>, 
        <span class="pl-var"
>_p</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>2</span></span>)</span>]]]].&#13;&#10;
mc_0__rb(A) :-
    B='DisjunctiveSyllogism',
    C=[->, ['OrLink', _p, _q], ['NotLink', _q], _p],
    'mc_2__:'(B, C, A).
<span class="ansi36"
>
mc_0__rb(A) :-
    B='DisjunctiveSyllogism',
    C=[->, ['OrLink', _p, _q], ['NotLink', _q], _p],
    'mc_2__:'(B, C, A).

</span>
<span class="ansi38-255165000"
> (= (rb)  
  (: ConjunctionIntroduction 
    (-> $p $q 
      (AndLink $p $q))))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(rb, 1, 4, [], 'Atom', [], x(doeval, eager), [rb], [:, 'ConjunctionIntroduction', [->, _p, _q, ['AndLink', _p, _q]]]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_0__rb</span>(<span class="pl-args"
><span class="pl-var"
>A</span></span>)</span>, 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      [ <span class="pl-atom"
>-&gt;</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_p'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_q'</span></span>)</span>, 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'AndLink'</span>, <span class="pl-var"
>_p</span>|<span class="pl-ellipsis"
>...</span></span>]</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>2</span></span>)</span>]]]].&#13;&#10;
mc_0__rb(A) :-
    B='ConjunctionIntroduction',
    C=[->, _p, _q, ['AndLink', _p, _q]],
    'mc_2__:'(B, C, A).
<span class="ansi36"
>
mc_0__rb(A) :-
    B='ConjunctionIntroduction',
    C=[->, _p, _q, ['AndLink', _p, _q]],
    'mc_2__:'(B, C, A).

</span>
<span class="ansi38-255165000"
> (= (rb)  
  (: ConjunctionEliminationLeft 
    (-> 
      (AndLink $p $q) $p)))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(rb, 1, 5, [], 'Atom', [], x(doeval, eager), [rb], [:, 'ConjunctionEliminationLeft', [->, ['AndLink', _p, _q], _p]]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_0__rb</span>(<span class="pl-args"
><span class="pl-var"
>A</span></span>)</span>, 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      [ <span class="pl-atom"
>-&gt;</span>, 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'AndLink'</span>, <span class="pl-var"
>_p</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
        <span class="pl-var"
>_p</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>2</span></span>)</span>]]]].&#13;&#10;
mc_0__rb(A) :-
    B='ConjunctionEliminationLeft',
    C=[->, ['AndLink', _p, _q], _p],
    'mc_2__:'(B, C, A).
<span class="ansi36"
>
mc_0__rb(A) :-
    B='ConjunctionEliminationLeft',
    C=[->, ['AndLink', _p, _q], _p],
    'mc_2__:'(B, C, A).

</span>
<span class="ansi38-255165000"
> (= (rb)  
  (: ConjunctionEliminationRight 
    (-> 
      (AndLink $p $q) $q)))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(rb, 1, 6, [], 'Atom', [], x(doeval, eager), [rb], [:, 'ConjunctionEliminationRight', [->, ['AndLink', _p, _q], _q]]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_0__rb</span>(<span class="pl-args"
><span class="pl-var"
>A</span></span>)</span>, 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      [ <span class="pl-atom"
>-&gt;</span>, 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'AndLink'</span>, <span class="pl-var"
>_p</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
        <span class="pl-var"
>_q</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>2</span></span>)</span>]]]].&#13;&#10;
mc_0__rb(A) :-
    B='ConjunctionEliminationRight',
    C=[->, ['AndLink', _p, _q], _q],
    'mc_2__:'(B, C, A).
<span class="ansi36"
>
mc_0__rb(A) :-
    B='ConjunctionEliminationRight',
    C=[->, ['AndLink', _p, _q], _q],
    'mc_2__:'(B, C, A).

</span>
<span class="ansi38-255165000"
> (= (rb)  
  (: DisjunctionIntroduction 
    (-> $p $q 
      (OrLink $p $q))))
</span><span class="ansi38-255165005"
></span><span class="ansi36"
>transpiler_clause_store(rb, 1, 7, [], 'Atom', [], x(doeval, eager), [rb], [:, 'DisjunctionIntroduction', [->, _p, _q, ['OrLink', _p, _q]]]).

</span><span class="pl-functor"
>[ </span>
  <span class="pl-atom"
>=</span>, 
  <span class="pl-compound pl-level-0"
><span class="pl-functor"
>mc_0__rb</span>(<span class="pl-args"
><span class="pl-var"
>A</span></span>)</span>, 
  [ <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>assign</span>, <span class="pl-var"
>B</span>|<span class="pl-ellipsis"
>...</span></span>]</span>, 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>C</span>, 
      [ <span class="pl-atom"
>-&gt;</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_p'</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-atom"
>'_q'</span></span>)</span>, 
        <span class="pl-list"
><span class="pl-functor"
> [ </span><span class="pl-args"
><span class="pl-atom"
>'OrLink'</span>, <span class="pl-var"
>_p</span>|<span class="pl-ellipsis"
>...</span></span>]</span>]], 
    [ <span class="pl-atom"
>assign</span>, 
      <span class="pl-var"
>A</span>, 
      [ <span class="pl-compound pl-level-0"
><span class="pl-functor"
>call</span>(<span class="pl-args"
><span class="pl-atom"
>:</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>1</span></span>)</span>, <span class="pl-compound pl-level-0"
><span class="pl-functor"
>'$VAR'</span>(<span class="pl-args"
><span class="pl-int"
>2</span></span>)</span>]]]].&#13;&#10;
mc_0__rb(A) :-
    B='DisjunctionIntroduction',
    C=[->, _p, _q, ['OrLink', _p, _q]],
    'mc_2__:'(B, C, A).
<span class="ansi36"
>
mc_0__rb(A) :-
    B='DisjunctionIntroduction',
    C=[->, _p, _q, ['OrLink', _p, _q]],
    'mc_2__:'(B, C, A).

</span>
<span class="ansi38-013099040"
>!(assertEqualToResult (synthesize (: $term $type) kb rb (S Z)) ((: abc (Implication (AndLink A B) C)) (: cde (Implication (OrLink C D) E)) (: a A) (: a B) (: (ConjunctionIntroduction abc abc) (AndLink (Implication (AndLink A B) C) (Implication (AndLink A B) C))) (: (ConjunctionIntroduction abc cde) (AndLink (Implication (AndLink A B) C) (Implication (OrLink C D) E))) (: (ConjunctionIntroduction abc a) (AndLink (Implication (AndLink A B) C) A)) (: (ConjunctionIntroduction abc a) (AndLink (Implication (AndLink A B) C) B)) (: (ConjunctionIntroduction cde abc) (AndLink (Implication (OrLink C D) E) (Implication (AndLink A B) C))) (: (ConjunctionIntroduction cde cde) (AndLink (Implication (OrLink C D) E) (Implication (OrLink C D) E))) (: (ConjunctionIntroduction cde a) (AndLink (Implication (OrLink C D) E) A)) (: (ConjunctionIntroduction cde a) (AndLink (Implication (OrLink C D) E) B)) (: (ConjunctionIntroduction a abc) (AndLink A (Implication (AndLink A B) C))) (: (ConjunctionIntroduction a cde) (AndLink A (Implication (OrLink C D) E))) (: (ConjunctionIntroduction a a) (AndLink A A)) (: (ConjunctionIntroduction a a) (AndLink A B)) (: (ConjunctionIntroduction a abc) (AndLink B (Implication (AndLink A B) C))) (: (ConjunctionIntroduction a cde) (AndLink B (Implication (OrLink C D) E))) (: (ConjunctionIntroduction a a) (AndLink B A)) (: (ConjunctionIntroduction a a) (AndLink B B)) (: (DisjunctionIntroduction abc abc) (OrLink (Implication (AndLink A B) C) (Implication (AndLink A B) C))) (: (DisjunctionIntroduction abc cde) (OrLink (Implication (AndLink A B) C) (Implication (OrLink C D) E))) (: (DisjunctionIntroduction abc a) (OrLink (Implication (AndLink A B) C) A)) (: (DisjunctionIntroduction abc a) (OrLink (Implication (AndLink A B) C) B)) (: (DisjunctionIntroduction cde abc) (OrLink (Implication (OrLink C D) E) (Implication (AndLink A B) C))) (: (DisjunctionIntroduction cde cde) (OrLink (Implication (OrLink C D) E) (Implication (OrLink C D) E))) (: (DisjunctionIntroduction cde a) (OrLink (Implication (OrLink C D) E) A)) (: (DisjunctionIntroduction cde a) (OrLink (Implication (OrLink C D) E) B)) (: (DisjunctionIntroduction a abc) (OrLink A (Implication (AndLink A B) C))) (: (DisjunctionIntroduction a cde) (OrLink A (Implication (OrLink C D) E))) (: (DisjunctionIntroduction a a) (OrLink A A)) (: (DisjunctionIntroduction a a) (OrLink A B)) (: (DisjunctionIntroduction a abc) (OrLink B (Implication (AndLink A B) C))) (: (DisjunctionIntroduction a cde) (OrLink B (Implication (OrLink C D) E))) (: (DisjunctionIntroduction a a) (OrLink B A)) (: (DisjunctionIntroduction a a) (OrLink B B))))

</span>
;<h3 id="SYNTH-BUFFER.TIME-SYNTHESIZE-LONG.02"
>;; SYNTH-BUFFER.TIME-SYNTHESIZE-LONG.02</h3>
; 
; EVAL TEST
; took 0.018 secs. (18.12 milliseconds) 

!(assertEqualToResult (synthesize (: $term $type) kb rb (S Z)) ((: abc (Implication (AndLink A B) C)) (: cde (Implication (OrLink C D) E)) (: a A) (: a B) (: (ConjunctionIntroduction abc abc) (AndLink (Implication (AndLink A B) C) (Implication (AndLink A B) C))) (: (ConjunctionIntroduction abc cde) (AndLink (Implication (AndLink A B) C) (Implication (OrLink C D) E))) (: (ConjunctionIntroduction abc a) (AndLink (Implication (AndLink A B) C) A)) (: (ConjunctionIntroduction abc a) (AndLink (Implication (AndLink A B) C) B)) (: (ConjunctionIntroduction cde abc) (AndLink (Implication (OrLink C D) E) (Implication (AndLink A B) C))) (: (ConjunctionIntroduction cde cde) (AndLink (Implication (OrLink C D) E) (Implication (OrLink C D) E))) (: (ConjunctionIntroduction cde a) (AndLink (Implication (OrLink C D) E) A)) (: (ConjunctionIntroduction cde a) (AndLink (Implication (OrLink C D) E) B)) (: (ConjunctionIntroduction a abc) (AndLink A (Implication (AndLink A B) C))) (: (ConjunctionIntroduction a cde) (AndLink A (Implication (OrLink C D) E))) (: (ConjunctionIntroduction a a) (AndLink A A)) (: (ConjunctionIntroduction a a) (AndLink A B)) (: (ConjunctionIntroduction a abc) (AndLink B (Implication (AndLink A B) C))) (: (ConjunctionIntroduction a cde) (AndLink B (Implication (OrLink C D) E))) (: (ConjunctionIntroduction a a) (AndLink B A)) (: (ConjunctionIntroduction a a) (AndLink B B)) (: (DisjunctionIntroduction abc abc) (OrLink (Implication (AndLink A B) C) (Implication (AndLink A B) C))) (: (DisjunctionIntroduction abc cde) (OrLink (Implication (AndLink A B) C) (Implication (OrLink C D) E))) (: (DisjunctionIntroduction abc a) (OrLink (Implication (AndLink A B) C) A)) (: (DisjunctionIntroduction abc a) (OrLink (Implication (AndLink A B) C) B)) (: (DisjunctionIntroduction cde abc) (OrLink (Implication (OrLink C D) E) (Implication (AndLink A B) C))) (: (DisjunctionIntroduction cde cde) (OrLink (Implication (OrLink C D) E) (Implication (OrLink C D) E))) (: (DisjunctionIntroduction cde a) (OrLink (Implication (OrLink C D) E) A)) (: (DisjunctionIntroduction cde a) (OrLink (Implication (OrLink C D) E) B)) (: (DisjunctionIntroduction a abc) (OrLink A (Implication (AndLink A B) C))) (: (DisjunctionIntroduction a cde) (OrLink A (Implication (OrLink C D) E))) (: (DisjunctionIntroduction a a) (OrLink A A)) (: (DisjunctionIntroduction a a) (OrLink A B)) (: (DisjunctionIntroduction a abc) (OrLink B (Implication (AndLink A B) C))) (: (DisjunctionIntroduction a cde) (OrLink B (Implication (OrLink C D) E))) (: (DisjunctionIntroduction a a) (OrLink B A)) (: (DisjunctionIntroduction a a) (OrLink B B))))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test () 
      ( (: abc 
          (Implication 
            (AndLink A B) C)) 
        (: cde 
          (Implication 
            (OrLink C D) E)) 
        (: a A) 
        (: a B) 
        (: 
          (ConjunctionIntroduction abc abc) 
          (AndLink 
            (Implication 
              (AndLink A B) C) 
            (Implication 
              (AndLink A B) C))) 
        (: 
          (ConjunctionIntroduction abc cde) 
          (AndLink 
            (Implication 
              (AndLink A B) C) 
            (Implication 
              (OrLink C D) E))) 
        (: 
          (ConjunctionIntroduction abc a) 
          (AndLink 
            (Implication 
              (AndLink A B) C) A)) 
        (: 
          (ConjunctionIntroduction abc a) 
          (AndLink 
            (Implication 
              (AndLink A B) C) B)) 
        (: 
          (ConjunctionIntroduction cde abc) 
          (AndLink 
            (Implication 
              (OrLink C D) E) 
            (Implication 
              (AndLink A B) C))) 
        (: 
          (ConjunctionIntroduction cde cde) 
          (AndLink 
            (Implication 
              (OrLink C D) E) 
            (Implication 
              (OrLink C D) E))) 
        (: 
          (ConjunctionIntroduction cde a) 
          (AndLink 
            (Implication 
              (OrLink C D) E) A)) 
        (: 
          (ConjunctionIntroduction cde a) 
          (AndLink 
            (Implication 
              (OrLink C D) E) B)) 
        (: 
          (ConjunctionIntroduction a abc) 
          (AndLink A 
            (Implication 
              (AndLink A B) C))) 
        (: 
          (ConjunctionIntroduction a cde) 
          (AndLink A 
            (Implication 
              (OrLink C D) E))) 
        (: 
          (ConjunctionIntroduction a a) 
          (AndLink A A)) 
        (: 
          (ConjunctionIntroduction a a) 
          (AndLink A B)) 
        (: 
          (ConjunctionIntroduction a abc) 
          (AndLink B 
            (Implication 
              (AndLink A B) C))) 
        (: 
          (ConjunctionIntroduction a cde) 
          (AndLink B 
            (Implication 
              (OrLink C D) E))) 
        (: 
          (ConjunctionIntroduction a a) 
          (AndLink B A)) 
        (: 
          (ConjunctionIntroduction a a) 
          (AndLink B B)) 
        (: 
          (DisjunctionIntroduction abc abc) 
          (OrLink 
            (Implication 
              (AndLink A B) C) 
            (Implication 
              (AndLink A B) C))) 
        (: 
          (DisjunctionIntroduction abc cde) 
          (OrLink 
            (Implication 
              (AndLink A B) C) 
            (Implication 
              (OrLink C D) E))) 
        (: 
          (DisjunctionIntroduction abc a) 
          (OrLink 
            (Implication 
              (AndLink A B) C) A)) 
        (: 
          (DisjunctionIntroduction abc a) 
          (OrLink 
            (Implication 
              (AndLink A B) C) B)) 
        (: 
          (DisjunctionIntroduction cde abc) 
          (OrLink 
            (Implication 
              (OrLink C D) E) 
            (Implication 
              (AndLink A B) C))) 
        (: 
          (DisjunctionIntroduction cde cde) 
          (OrLink 
            (Implication 
              (OrLink C D) E) 
            (Implication 
              (OrLink C D) E))) 
        (: 
          (DisjunctionIntroduction cde a) 
          (OrLink 
            (Implication 
              (OrLink C D) E) A)) 
        (: 
          (DisjunctionIntroduction cde a) 
          (OrLink 
            (Implication 
              (OrLink C D) E) B)) 
        (: 
          (DisjunctionIntroduction a abc) 
          (OrLink A 
            (Implication 
              (AndLink A B) C))) 
        (: 
          (DisjunctionIntroduction a cde) 
          (OrLink A 
            (Implication 
              (OrLink C D) E))) 
        (: 
          (DisjunctionIntroduction a a) 
          (OrLink A A)) 
        (: 
          (DisjunctionIntroduction a a) 
          (OrLink A B)) 
        (: 
          (DisjunctionIntroduction a abc) 
          (OrLink B 
            (Implication 
              (AndLink A B) C))) 
        (: 
          (DisjunctionIntroduction a cde) 
          (OrLink B 
            (Implication 
              (OrLink C D) E))) 
        (: 
          (DisjunctionIntroduction a a) 
          (OrLink B A)) 
        (: 
          (DisjunctionIntroduction a a) 
          (OrLink B B)))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ()) #(expected ((: abc (Implication (AndLink A B) C)) (: cde (Implication (OrLink C D) E)) (: a A) (: a B) (: (ConjunctionIntroduction abc abc) (AndLink (Implication (AndLink A B) C) (Implication (AndLink A B) C))) (: (ConjunctionIntroduction abc cde) (AndLink (Implication (AndLink A B) C) (Implication (OrLink C D) E))) (: (ConjunctionIntroduction abc a) (AndLink (Implication (AndLink A B) C) A)) (: (ConjunctionIntroduction abc a) (AndLink (Implication (AndLink A B) C) B)) (: (ConjunctionIntroduction cde abc) (AndLink (Implication (OrLink C D) E) (Implication (AndLink A B) C))) (: (ConjunctionIntroduction cde cde) (AndLink (Implication (OrLink C D) E) (Implication (OrLink C D) E))) (: (ConjunctionIntroduction cde a) (AndLink (Implication (OrLink C D) E) A)) (: (ConjunctionIntroduction cde a) (AndLink (Implication (OrLink C D) E) B)) (: (ConjunctionIntroduction a abc) (AndLink A (Implication (AndLink A B) C))) (: (ConjunctionIntroduction a cde) (AndLink A (Implication (OrLink C D) E))) (: (ConjunctionIntroduction a a) (AndLink A A)) (: (ConjunctionIntroduction a a) (AndLink A B)) (: (ConjunctionIntroduction a abc) (AndLink B (Implication (AndLink A B) C))) (: (ConjunctionIntroduction a cde) (AndLink B (Implication (OrLink C D) E))) (: (ConjunctionIntroduction a a) (AndLink B A)) (: (ConjunctionIntroduction a a) (AndLink B B)) (: (DisjunctionIntroduction abc abc) (OrLink (Implication (AndLink A B) C) (Implication (AndLink A B) C))) (: (DisjunctionIntroduction abc cde) (OrLink (Implication (AndLink A B) C) (Implication (OrLink C D) E))) (: (DisjunctionIntroduction abc a) (OrLink (Implication (AndLink A B) C) A)) (: (DisjunctionIntroduction abc a) (OrLink (Implication (AndLink A B) C) B)) (: (DisjunctionIntroduction cde abc) (OrLink (Implication (OrLink C D) E) (Implication (AndLink A B) C))) (: (DisjunctionIntroduction cde cde) (OrLink (Implication (OrLink C D) E) (Implication (OrLink C D) E))) (: (DisjunctionIntroduction cde a) (OrLink (Implication (OrLink C D) E) A)) (: (DisjunctionIntroduction cde a) (OrLink (Implication (OrLink C D) E) B)) (: (DisjunctionIntroduction a abc) (OrLink A (Implication (AndLink A B) C))) (: (DisjunctionIntroduction a cde) (OrLink A (Implication (OrLink C D) E))) (: (DisjunctionIntroduction a a) (OrLink A A)) (: (DisjunctionIntroduction a a) (OrLink A B)) (: (DisjunctionIntroduction a abc) (OrLink B (Implication (AndLink A B) C))) (: (DisjunctionIntroduction a cde) (OrLink B (Implication (OrLink C D) E))) (: (DisjunctionIntroduction a a) (OrLink B A)) (: (DisjunctionIntroduction a a) (OrLink B B))))))
</span><span class="ansi38-013099040"
>!(assertEqualToResult (synthesize (: $term $type) kb rb Z) ((: a A) (: a B) (: abc (Implication (AndLink A B) C)) (: cde (Implication (OrLink C D) E))))

</span>
;<h3 id="SYNTH-BUFFER.TIME-SYNTHESIZE-LONG.03"
>;; SYNTH-BUFFER.TIME-SYNTHESIZE-LONG.03</h3>
; 
; EVAL TEST
; took 0.003 secs. (3.48 milliseconds) 

!(assertEqualToResult (synthesize (: $term $type) kb rb Z) ((: a A) (: a B) (: abc (Implication (AndLink A B) C)) (: cde (Implication (OrLink C D) E))))

<span class="ansi31"
>  #(loonit_failureR 
    #(equal_enough_for_test () 
      ( (: a A) 
        (: a B) 
        (: abc 
          (Implication 
            (AndLink A B) C)) 
        (: cde 
          (Implication 
            (OrLink C D) E)))))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ()) #(expected ((: a A) (: a B) (: abc (Implication (AndLink A B) C)) (: cde (Implication (OrLink C D) E))))))
</span>;;;; takes about 1 minute on rust

Script done on 2024-12-26 18:51:44+00:00 [COMMAND_EXIT_CODE="143"]

</pre>
</body>

</html>
\033[1;33mCompleted (EXITCODE=143) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat/' --timeout=40 --html --repl=false  --test "tests/baseline_compat/hyperon-mettalog_sanity/synth_buffer/time_synthesize_long.metta" --halt=true\033[0m
