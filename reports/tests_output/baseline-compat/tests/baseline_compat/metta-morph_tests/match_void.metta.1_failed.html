<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi36 { color: #00aaaa; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-12-04 09:56:47+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
P;HTML|
;           #(set_option_value compat false)

P;HTML|
;           #(set_option_value compatio false)

P;HTML|
;           #(set_option_value src_indents false)

P;HTML|
;         #(set_option_value devel false)

P;HTML|
;         #(set_option_value stack-max 500)

P;HTML|
;         #(set_option_value limit inf)

P;HTML|
;         #(set_option_value initial-result-count 10)

P;HTML|
;         #(set_option_value answer-format show)

P;HTML|
;         #(set_option_value repeats true)

P;HTML|
;         #(set_option_value time true)

P;HTML|
;         #(set_option_value synth-unit-tests false)

P;HTML|
;         #(set_option_value optimize true)

P;HTML|
;         #(set_option_value transpiler silent)

P;HTML|
;          #(set_debug transpiler false)

P;HTML|
;         #(set_option_value compile false)

P;HTML|
;         #(set_option_value tabling auto)

P;HTML|
;         #(set_option_value log false)

P;HTML|
;         #(set_option_value output ./)

P;HTML|
;         #(set_option_value exeout ./Sav.gitlab.MeTTaLog)

P;HTML|
;         #(set_option_value halt false)

P;HTML|
;         #(set_option_value trace-length 500)

P;HTML|
;         #(set_option_value trace-on-overtime 4.0)

P;HTML|
;          #(set_debug overtime 4.0)

P;HTML|
;         #(set_option_value trace-on-overflow 1000)

P;HTML|
;          #(set_debug overflow 1000)

P;HTML|
;         #(set_option_value trace-on-eval false)

P;HTML|
;          #(set_debug eval false)

P;HTML|
;         #(set_option_value trace-on-load silent)

P;HTML|
;          #(set_debug load silent)

P;HTML|
;          #(set_debug trace-on-load false)

P;HTML|
;         #(set_option_value trace-on-exec false)

P;HTML|
;          #(set_debug exec false)

P;HTML|
;         #(set_option_value trace-on-error non-type)

P;HTML|
;          #(set_debug error non-type)

P;HTML|
;         #(set_option_value trace-on-fail false)

P;HTML|
;          #(set_debug fail false)

P;HTML|
;         #(set_option_value trace-on-test true)

P;HTML|
;          #(set_debug test true)

P;HTML|
;         #(set_option_value repl-on-error true)

P;HTML|
;         #(set_option_value repl-on-fail false)

P;HTML|
;         #(set_option_value exit-on-fail false)

P;HTML|
;         #(set_option_value repl auto)

P;HTML|
;         #(set_option_value prolog false)

P;HTML|
;         #(set_option_value exec noskip)

P;HTML|
;         #(set_option_value maximum-result-count inf)

P;HTML|
;         #(set_option_value html false)

P;HTML|
;         #(set_option_value python true)

P;HTML|
;         #(set_option_value trace-on-test false)

P;HTML|
;         #(set_debug test false)

P;HTML|
;         #(set_option_value trace-on-fail false)

P;HTML|
;         #(set_debug fail false)

P;HTML|
;         #(set_option_value load show)

P;HTML|
;         #(set_option_value test false)
<span class="ansi32"
>
% 23,950 inferences, 0.005 CPU in 0.005 seconds (100% CPU, 4471314 Lips)
</span>P;HTML|
;          #(is_cmd_option prescan halt --halt=true true)
P;HTML|
;          #(set_option_value halt true)
P;HTML|
;          #(is_cmd_option prescan stdin --stdin=tty tty)
P;HTML|
;           #(set_option_value stdin tty)
P;HTML|
;          #(is_cmd_option prescan stdout --stdout=tty tty)
P;HTML|
;           #(set_option_value stdout tty)
P;HTML|
;          #(is_cmd_option prescan stderr --stderr=tty tty)
P;HTML|
;           #(set_option_value stderr tty)
P;HTML|
;          #(set_option_value compat false)
P;HTML|
;          #(set_option_value compatio false)
P;HTML|
;          #(set_option_value src_indents false)
P;HTML|
;          #(set_option_value devel false)
P;HTML|
;          #(set_option_value stack-max 500)
P;HTML|
;          #(set_option_value limit inf)
P;HTML|
;          #(set_option_value initial-result-count 10)
P;HTML|
;          #(set_option_value answer-format show)
P;HTML|
;          #(set_option_value repeats true)
P;HTML|
;          #(set_option_value time true)
P;HTML|
;          #(set_option_value synth-unit-tests false)
P;HTML|
;          #(set_option_value optimize true)
P;HTML|
;          #(set_option_value transpiler silent)
P;HTML|
;          #(set_debug transpiler false)
P;HTML|
;          #(set_option_value compile false)
P;HTML|
;          #(set_option_value tabling auto)
P;HTML|
;          #(set_option_value log false)
P;HTML|
;          #(set_option_value output ./)
P;HTML|
;          #(set_option_value exeout ./Sav.gitlab.MeTTaLog)
P;HTML|
;          #(set_option_value halt false)
P;HTML|
;          #(set_option_value trace-length 500)
P;HTML|
;          #(set_option_value trace-on-overtime 4.0)
P;HTML|
;          #(set_debug overtime 4.0)
P;HTML|
;          #(set_option_value trace-on-overflow 1000)
P;HTML|
;          #(set_debug overflow 1000)
P;HTML|
;          #(set_option_value trace-on-eval false)
P;HTML|
;          #(set_debug eval false)
P;HTML|
;          #(set_option_value trace-on-load silent)
P;HTML|
;          #(set_debug load silent)
P;HTML|
;          #(set_debug trace-on-load false)
P;HTML|
;          #(set_option_value trace-on-exec false)
P;HTML|
;          #(set_debug exec false)
P;HTML|
;          #(set_option_value trace-on-error non-type)
P;HTML|
;          #(set_debug error non-type)
P;HTML|
;          #(set_option_value trace-on-fail false)
P;HTML|
;          #(set_debug fail false)
P;HTML|
;          #(set_option_value trace-on-test true)
P;HTML|
;          #(set_debug test true)
P;HTML|
;          #(set_option_value repl-on-error true)
P;HTML|
;          #(set_option_value repl-on-fail false)
P;HTML|
;          #(set_option_value exit-on-fail false)
P;HTML|
;          #(set_option_value repl auto)
P;HTML|
;          #(set_option_value prolog false)
P;HTML|
;          #(set_option_value exec noskip)
P;HTML|
;          #(set_option_value maximum-result-count inf)
P;HTML|
;          #(set_option_value html false)
P;HTML|
;          #(set_option_value python true)
P;HTML|
;         #(set_option_value trace-on-test false)
P;HTML|
;          #(set_debug test false)
P;HTML|
;         #(set_option_value trace-on-fail false)
P;HTML|
;          #(set_debug fail false)
P;HTML|
;         #(set_option_value load show)
P;HTML|
;         #(set_option_value test true)
P;HTML|
;        #(is_cmd_option execute python --python=enable enable)
P;HTML|
;         #(set_option_value python enable)
P;HTML|
;        #(is_cmd_option execute timeout --timeout=40 40)
P;HTML|
;         #(set_option_value timeout 40)
P;HTML|
;         #(is_cmd_option execute output --output=./reports/tests_output/baseline-compat/ ./reports/tests_output/baseline-compat/)
P;HTML|
;         #(set_option_value output ./reports/tests_output/baseline-compat/)
P;HTML|
;         #(is_cmd_option execute html --html true)
P;HTML|
;          #(set_option_value html true)
P;HTML|
;         #(is_cmd_option execute test --test true)
P;HTML|
;          #(set_option_value test true)

; #( : user #(load_metta_file &self tests/baseline_compat/metta-morph_tests/match_void.metta) )
P;HTML|
;                       #(track_load_into_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/metta-morph_tests/match_void.metta)
P;HTML|
;                                        #(load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/metta-morph_tests/match_void.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/metta-morph_tests/match_void.metta)
P;HTML|
;                                         #( = 1 "[()]" )
P;HTML|
;                                         #( = 2 "[()]" )
P;HTML|
;                                         #( = 3 "[]" )
P;HTML|
;                                         #( = 4 "[()]" )
P;HTML|
;                                         #( = 5 "[belief1]" )
P;HTML|
;                                         #( = 6 "[]" )
P;HTML|
;                                         #( = 7 "[]" )
P;HTML|
;                                         #( = 8 "[()]" )
P;HTML|
;                                         #( = 9 "[()]" )
P;HTML|
;                                         #( = 10 "[()]" )
P;HTML|
;                                         #( = 11 "[()]" )
P;HTML|
;                                         #( = 12 "[()]" )
P;HTML|
;                                         #( = 13 "[()]" )
P;HTML|
;                                         #( = 14 "0.05user 0.00system 0:00.05elapsed 98%CPU (0avgtext+0avgdata 30820maxresident)k" )
P;HTML|
;                                         #( = 14 "0inputs+0outputs (0major+3667minor)pagefaults 0swaps" )
P;HTML|
;                                        #(load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/metta-morph_tests/match_void.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/metta-morph_tests/match_void.metta)

<span class="ansi38-013099040"
>!(bind! &belief_events (new-space))

</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(bind! &goal_events (new-space))

</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>!(match &belief_events $1 $1)
</span>;; To unit test case:
<span class="ansi38-013099040"
>!(assertEqualToResult (match &belief_events $1 $1) ())

</span>
;<h3 id="METTA-MORPH-TESTS.MATCH-VOID.01"
>;; METTA-MORPH-TESTS.MATCH-VOID.01</h3>
; 
; EVAL TEST
; took 0.070 secs. (70.03 milliseconds) 

!(assertEqualToResult (match &belief_events $1 $1) ())

<span class="ansi31"
>#(loonit_failureR #(equal_enough_for_test ((@doc Any (@desc "The universal type; any value belongs to this type.")) (: Any Type) (@doc Atom (@desc "Type representing any atom.")) (: Atom Type) (@doc LazyEvaluatable (@desc "A type of Atom/Value that hyperon does not implicitly evaluate")) (: LazyEvaluatable Type) (:> Atom LazyEvaluatable) (@doc Bool (@desc "Boolean type of True or False.")) (: Bool Type) (@doc LazyBool (@desc "A LazyEvaluatable that when evaluated returns True or False.")) (: LazyBool Type) (:> LazyBool LazyEvaluatable) (@doc Expression (@desc "Type representing an S-Expression, which is a combination of atoms.")) (: Expression Type) (:> Expression LazyEvaluatable) (@doc Number (@desc "Numeric type, including integers and floating-point numbers.")) (: Number Type) (@doc hyperon::space::DynSpace (@desc "Dynamic space type, representing an Atomspace.")) (: hyperon::space::DynSpace Type) (@doc ReturnType (@desc "Type representing a function's return value.")) (: ReturnType Type) (@doc Symbol (@desc "Type representing a symbol or identifier.")) (: Symbol Type) (@doc StateMonad (@desc "Type representing a state monad, used for encapsulating stateful computations.")) (: StateMonad Type) (@doc Type (@desc "Type representing a type.")) (: Type Type) (@doc True (@desc "Boolean value representing truth.")) (: True Bool) (@doc False (@desc "Boolean value representing falsehood.")) (: False Bool) (@doc %Undefined% (@desc "Special type representing an undefined value or type.")) (: %Undefined% Type) (@doc Variable (@desc "Type representing a variable in the language.")) (: Variable Type) (@doc : (@desc "Type declarion operator")) (@doc <: (@desc "Super Type declarion operator")) (: : %Undefined%) (: if-empty (-> Atom Atom Atom Atom)) (: if-non-empty-expression (-> Atom Atom Atom Atom)) (: if-not-reducible (-> Atom Atom Atom Atom)) (: return (-> Atom ReturnType)) (: switch (-> %Undefined% Expression Atom)) (: unify (-> Atom Atom Atom Atom %Undefined%)) (: get-type (-> Atom Type)) (: get-type0 (-> Atom Atom)) (: get-ftype (-> Atom Atom)) (: pragma! (-> Atom Atom (->))) (: = (-> Atom Atom %Undefined%)) (: match (-> hyperon::space::DynSpace Atom Atom %Undefined%)) (: case (-> Expression Atom Atom)) (: combine (-> $10000 $10000 $10000)) (: import! (-> hyperon::space::DynSpace Atom (->))) (: If (-> Bool Atom Atom Atom)) (: If (-> Bool Atom Atom)) (= (If True $10001)  $10001) (= (If False $10002)  
  (let $10003 0 
    (let $10003 1 $10003))) (= (If $10004 $10005 $10006)  
  (if $10004 $10005 $10006)) (iz predicate-arity MeTTaLog) (@doc predicate-arity (@desc "Specifies the arity (number of arguments) for a given predicate, allowing it to be queriable in the system's match framework. This is particularly useful for enabling built-in functions, such as `size-atom`, to be used as predicates in declarative contexts and run in reverse to compute inputs based on outputs.\n\nFor example:\n  ; Enable the built-in function `size-atom` that takes an atom and returns the size\n    as a predicate with arity 2\n  (add-atom &dyn-space (predicate-arity size-atom 2))\n\n  ; Now `size-atom` can be used as a predicate in pattern matching\n  (match &dyn-space '(size-atom (a b c) $size) \n         (The abc tuple was len $size))\n  ; This pattern will resolve `Size = 3` and execute the action.\n\nAdditionally, by running `size-atom` in reverse, you can compute a new atom based on a desired size:\n  (match &dyn-space '(size-atom $new-atom 4) \n         (The new atom is $new-atom))\n  ; This resolves `$new-atom` to a tuple of size 4, such as ($1 $2 $3 $4).\n\nThis reverse functionality is made possible because predicates can describe relationships, allowing you to infer inputs from outputs.") (@params ((@param "Predicate symbol" "The name of the predicate whose arity is being defined."))) (@return "The number of arguments required for the predicate.")) (: predicate-arity (-> Symbol Number)) (predicate-arity predicate-arity 2) (function-arity predicate-arity 1) (@doc function-arity (@desc "Defines the arity of a function, allowing predicates or built-in facts to also behave as callable functions. This enables procedural-style execution where the last argument of the predicate becomes the function's return value, and the system internally resolves the function using a `match` query. \n\nFor example:\n  ; Declare the built-in predicate `max` with arity 2\n  (predicate-arity max 2)\n\n  ; Enable `max` as a function\n  (add-atom &dyn-space (function-arity max 2))\n\n  ; Define the rules for `max`\n  (add-atom &dyn-space (max $X $Y $X) (<= $X $Y))\n  (add-atom &dyn-space (max $X $Y $Y) (> $X $Y))\n\n  ; Using `max` declaratively as a predicate\n  (match &dyn-space (max (5 10) $max)\n         (The maximum is $max))\n  ; This resolves `$max = 10`.\n\n  ; Using `max` procedurally as a function\n  (max 5 10)\n  ; Returns: 10.\n\n  ; Reverse execution with `max`\n  (max $pair 10)\n  ; Returns: a pair such as (8 10) or (10 5) where the maximum is 10.\n\n  This dual behavior allows predicates to act as functions, bridging procedural and declarative paradigms. By defining `function-arity`, the function automatically resolves using the logic of the associated predicate.") (@params ((@param "Function symbol" "The name of the function or predicate to enable as a callable function."))) (@return "The number of arguments expected by the function.")) (: function-arity (-> Symbol Number)) (predicate-arity function-arity 2) (function-arity function-arity 1) (iz If MeTTa) (@doc If (@desc "Conditional function that evaluates and returns one of the provided atoms based on a boolean condition.") (@params ((@param "Boolean condition") (@param "Atom to return if condition is True") (@param "Atom to return if condition is False (optional)"))) (@return "Either the second or third argument depending on the condition")) (predicate-arity : 2) (= (: $10007 P1)  
  (predicate-arity $10007 1)) (iz SrcPredicate MeTTa) (@doc SrcPredicate (@desc "Type representing a source predicate.")) (: SrcPredicate Type) (iz SrcFunction MeTTa) (@doc SrcFunction (@desc "Type representing a source function.")) (: SrcFunction Type) (iz MeTTaResult MeTTa) (@doc MeTTaResult (@desc "Type representing the result of a MeTTa evaluation.")) (: MeTTaResult Type) (iz NotReducible MeTTaResult) (@doc NotReducible (@desc "Result indicating that an atom cannot be reduced further.")) (: NotReducible MeTTaResult) (iz ValueAtom MeTTa) (@doc ValueAtom (@desc "Type representing a value atom.")) (:> ValueAtom Atom) (iz ForeignObject MeTTa) (@doc ForeignObject (@desc "Type representing a foreign object, such as a Python object.")) (: ForeignObject Type) (:> ValueAtom Grounded) (:> ForeignObject ValueAtom) (iz PyObject MeTTa) (@doc PyObject (@desc "Type representing a Python object.")) (:> PyObject ForeignObject) (:> hyperon::space::DynSpace Grounded) (iz py-list MeTTa) (@doc py-list (@desc "Converts a MeTTa Expression into a Python list and returns it as a PyObject.") (@params ((@param (@desc "A MeTTa List that will be converted into a Python list")))) (@return (@desc "A Python list object that represents the given MeTTa Expression as a PyObject"))) (: py-list (-> Expression PyObject)) (iz py-chain MeTTa) (@doc py-chain (@desc "Chains together a list of Python objects contained in a MeTTa Expression, applying the Python vertical bar | OR operation jointly to all elements.") (@params ((@param (@desc "A MeTTa list of atoms, each embedding a Python object.")))) (@return (@desc "A MeTTa atom which embeds the result of applying the Python OR | operator to all elements of the list."))) (: py-chain (-> Expression PyObject)) (iz py-eval MeTTaLog) (@doc py-eval (@desc "Evaluates a Python expression from a string and returns the result as a PyObject.") (@params ((@param (@desc "A string representing a Python expression that will be evaluated")))) (@return (@desc "The result of evaluating the Python expression as a PyObject"))) (: py-eval (-> String PyObject)) (iz py-exec! MeTTaLog) (@doc py-exec! (@desc "Executes some Python sourcecode from a string !(py-exec! \"import torch\") -> True.  !(py-exec! \"import torche\") -> False. ") (@params ((@param (@type String) (@desc "A string representing a Python sourcecode that will be executed")))) (@return (@desc "The True|False results of executing the Python expression"))) (: py-exec! (-> String Bool)) (iz = MeTTa) (@doc = (@desc "A symbol used to define reduction rules for expressions.") (@params ((@param "Pattern to be matched against expression to be reduced") (@param "Result of reduction or transformation of the first pattern"))) (@return "Not reduced itself unless custom equalities over equalities are added")) (: = (-> $10008 $10008 Atom)) (: = (-> Atom Atom Atom)) (iz ErrorType MeTTa) (@doc ErrorType (@desc "Type of the atom which contains error")) (: ErrorType Type) (iz Error MeTTa) (@doc Error (@desc "Error constructor") (@params ((@param "Atom which contains error") (@param "Error message, can be one of the reserved symbols: BadType, IncorrectNumberOfArguments"))) (@return "Instance of the error atom")) (: Error (-> Atom Atom ErrorType)) (iz return MinimalMeTTa) (@doc return (@desc "Returns value from the (function ...) expression") (@params ((@param "Value to be returned"))) (@return "Passed argument")) (: return (-> $10009 $10009)) (iz function MinimalMeTTa) (@doc function (@desc "Evaluates the argument until it becomes (return <result>). Then (function (return <result>)) is reduced to the <result>.") (@params ((@param "Atom to be evaluated"))) (@return "Result of atom's evaluation")) (: function (-> Atom Atom)) (iz eval MinimalMeTTa) (@doc eval (@desc "Evaluates input Atom, performs one step of the evaluation. Empty results (Empty, ()) are removed from the result set. If no results are produced for a non-grounded function, eval returns NotReducible.") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function"))) (@return "Result of evaluation")) (: eval (-> Atom Atom)) (@doc evalc (@desc "Evaluates input atom, makes one step of the evaluation") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function") (@param "Space to evaluate atom in its context"))) (@return "Result of evaluation")) (: evalc (-> Atom Grounded Atom)) (iz chain MinimalMeTTa) (@doc chain (@desc "Evaluates first argument Atom, binds it to the Variable (second argument) and then evaluates third argument Template with Variable substituted in. When evaluation of the first Atom brings more than a single result, chain returns one instance of the Template expression for each result. The first argument Atom is only evaluated if it is part of the Minimal MeTTa specification; evaluation of non-Minimal MeTTa atoms can be controlled by wrapping in a call to eval (for one evaluation step) or metta (for full evaluation).") (@params ((@param "Atom to be evaluated") (@param "Variable") (@param "Template which will be evaluated at the end with Variable substituted"))) (@return "Result of evaluating third input argument")) (: chain (-> Atom Variable Atom Atom)) (iz unify MeTTa) (@doc unify (@desc "Like Match but allows any sort of container for the first argument. (Match only allows MeTTa spaces.)") (@params ((@param "The collection or space to match") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when found or fourth one otherwise")) (: unify (-> Atom Atom Atom Atom Atom)) (iz if-unify MinimalMeTTaHelper) (@doc if-unify (@desc "Matches two first terms and returns third argument if they are matched and fourth argument otherwise") (@params ((@param "First term to unify with") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when first two atoms are unifiable or fourth one otherwise")) (: if-unify (-> Atom Atom Atom Atom %Undefined%)) (ALT= $10010 $10010) (iz if-unify-or-empty MinimalMeTTaHelper) (@doc if-unify-or-empty (@desc "Attempts to unify two atoms and returns a result. Returns Empty if they cannot be unified.") (@params ((@param "First atom") (@param "Second atom"))) (@return "Unification result or Empty")) (: if-unify-or-empty (-> Atom Atom Atom)) (= (if-unify-or-empty $10011 $10011)  unified) (= (if-unify-or-empty $10012 $10013)  
  (empty)) (iz cons-atom MinimalMeTTa) (@doc cons-atom (@desc "Constructs an expression using two arguments") (@params ((@param "Head of an expression") (@param "Tail of an expression"))) (@return "New expression consisting of the two input arguments")) (: cons-atom (-> Atom Expression Expression)) (iz decons-atom MinimalMeTTa) (@doc decons-atom (@desc "Works as a reverse to cons-atom function. It gets Expression as an input and returns it split into head and tail, e.g. (decons-atom (Cons X Nil)) -> (Cons (X Nil))") (@params ((@param "Expression to be Deconsed"))) (@return "Deconsed expression")) (: decons-atom (-> Expression Expression)) (iz min-atom MeTTa) (@doc min-atom (@desc "Returns atom with minimum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Minimum value in the expression. Error if expression contains non-numeric value or is empty.")) (: min-atom (-> Expression Number)) (= (min-atom $10014)  
  (call-fn! min_list $10014)) (iz max-atom MeTTa) (@doc max-atom (@desc "Returns atom with maximum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Maximum value in the expression. Error if expression contains non-numeric value or is empty.")) (: max-atom (-> Expression Number)) (is-fn-1 max-atom max_list) (iz size-atom MeTTa) (@doc size-atom (@desc "Returns the size of an expression (first argument).") (@params ((@param "Expression to measure the size of"))) (@return "Size of the expression")) (: size-atom (-> Expression Integer)) (is-fn-1 size-atom length) (iz index-atom MeTTa) (@doc index-atom (@desc "Returns atom from an expression (first argument) using index (second argument) or error if index is out of bounds.") (@params ((@param "Expression") (@param "Index"))) (@return "Atom at the specified index in the expression. Error if index is out of bounds.")) (: index-atom (-> Expression Number Atom)) (is-fn-21 index-atom nth0) (iz powi MeTTa) (@doc powi (@desc "Takes base (first argument) and power (second argument) and returns the result of raising the base to the power.") (@params ((@param "Base. Could be a float.") (@param "Power. Must be an integer."))) (@return "Result of base raised to the power")) (= (powi $10015 $10016)  
  (call-fn! pow $10015 $10016)) (==> (is-op-1 $10017 $10018) (is-fn-1 $10017 $10018))) ()))
</span>
Deterministic: <span class="ansi33"
>(#(Error #(got ((@doc Any (@desc "The universal type; any value belongs to this type.")) (: Any Type) (@doc Atom (@desc "Type representing any atom.")) (: Atom Type) (@doc LazyEvaluatable (@desc "A type of Atom/Value that hyperon does not implicitly evaluate")) (: LazyEvaluatable Type) (:> Atom LazyEvaluatable) (@doc Bool (@desc "Boolean type of True or False.")) (: Bool Type) (@doc LazyBool (@desc "A LazyEvaluatable that when evaluated returns True or False.")) (: LazyBool Type) (:> LazyBool LazyEvaluatable) (@doc Expression (@desc "Type representing an S-Expression, which is a combination of atoms.")) (: Expression Type) (:> Expression LazyEvaluatable) (@doc Number (@desc "Numeric type, including integers and floating-point numbers.")) (: Number Type) (@doc hyperon::space::DynSpace (@desc "Dynamic space type, representing an Atomspace.")) (: hyperon::space::DynSpace Type) (@doc ReturnType (@desc "Type representing a function's return value.")) (: ReturnType Type) (@doc Symbol (@desc "Type representing a symbol or identifier.")) (: Symbol Type) (@doc StateMonad (@desc "Type representing a state monad, used for encapsulating stateful computations.")) (: StateMonad Type) (@doc Type (@desc "Type representing a type.")) (: Type Type) (@doc True (@desc "Boolean value representing truth.")) (: True Bool) (@doc False (@desc "Boolean value representing falsehood.")) (: False Bool) (@doc %Undefined% (@desc "Special type representing an undefined value or type.")) (: %Undefined% Type) (@doc Variable (@desc "Type representing a variable in the language.")) (: Variable Type) (@doc : (@desc "Type declarion operator")) (@doc <: (@desc "Super Type declarion operator")) (: : %Undefined%) (: if-empty (-> Atom Atom Atom Atom)) (: if-non-empty-expression (-> Atom Atom Atom Atom)) (: if-not-reducible (-> Atom Atom Atom Atom)) (: return (-> Atom ReturnType)) (: switch (-> %Undefined% Expression Atom)) (: unify (-> Atom Atom Atom Atom %Undefined%)) (: get-type (-> Atom Type)) (: get-type0 (-> Atom Atom)) (: get-ftype (-> Atom Atom)) (: pragma! (-> Atom Atom (->))) (: = (-> Atom Atom %Undefined%)) (: match (-> hyperon::space::DynSpace Atom Atom %Undefined%)) (: case (-> Expression Atom Atom)) (: combine (-> $10000 $10000 $10000)) (: import! (-> hyperon::space::DynSpace Atom (->))) (: If (-> Bool Atom Atom Atom)) (: If (-> Bool Atom Atom)) (= (If True $10001)  $10001) (= (If False $10002)  
  (let $10003 0 
    (let $10003 1 $10003))) (= (If $10004 $10005 $10006)  
  (if $10004 $10005 $10006)) (iz predicate-arity MeTTaLog) (@doc predicate-arity (@desc "Specifies the arity (number of arguments) for a given predicate, allowing it to be queriable in the system's match framework. This is particularly useful for enabling built-in functions, such as `size-atom`, to be used as predicates in declarative contexts and run in reverse to compute inputs based on outputs.\n\nFor example:\n  ; Enable the built-in function `size-atom` that takes an atom and returns the size\n    as a predicate with arity 2\n  (add-atom &dyn-space (predicate-arity size-atom 2))\n\n  ; Now `size-atom` can be used as a predicate in pattern matching\n  (match &dyn-space '(size-atom (a b c) $size) \n         (The abc tuple was len $size))\n  ; This pattern will resolve `Size = 3` and execute the action.\n\nAdditionally, by running `size-atom` in reverse, you can compute a new atom based on a desired size:\n  (match &dyn-space '(size-atom $new-atom 4) \n         (The new atom is $new-atom))\n  ; This resolves `$new-atom` to a tuple of size 4, such as ($1 $2 $3 $4).\n\nThis reverse functionality is made possible because predicates can describe relationships, allowing you to infer inputs from outputs.") (@params ((@param "Predicate symbol" "The name of the predicate whose arity is being defined."))) (@return "The number of arguments required for the predicate.")) (: predicate-arity (-> Symbol Number)) (predicate-arity predicate-arity 2) (function-arity predicate-arity 1) (@doc function-arity (@desc "Defines the arity of a function, allowing predicates or built-in facts to also behave as callable functions. This enables procedural-style execution where the last argument of the predicate becomes the function's return value, and the system internally resolves the function using a `match` query. \n\nFor example:\n  ; Declare the built-in predicate `max` with arity 2\n  (predicate-arity max 2)\n\n  ; Enable `max` as a function\n  (add-atom &dyn-space (function-arity max 2))\n\n  ; Define the rules for `max`\n  (add-atom &dyn-space (max $X $Y $X) (<= $X $Y))\n  (add-atom &dyn-space (max $X $Y $Y) (> $X $Y))\n\n  ; Using `max` declaratively as a predicate\n  (match &dyn-space (max (5 10) $max)\n         (The maximum is $max))\n  ; This resolves `$max = 10`.\n\n  ; Using `max` procedurally as a function\n  (max 5 10)\n  ; Returns: 10.\n\n  ; Reverse execution with `max`\n  (max $pair 10)\n  ; Returns: a pair such as (8 10) or (10 5) where the maximum is 10.\n\n  This dual behavior allows predicates to act as functions, bridging procedural and declarative paradigms. By defining `function-arity`, the function automatically resolves using the logic of the associated predicate.") (@params ((@param "Function symbol" "The name of the function or predicate to enable as a callable function."))) (@return "The number of arguments expected by the function.")) (: function-arity (-> Symbol Number)) (predicate-arity function-arity 2) (function-arity function-arity 1) (iz If MeTTa) (@doc If (@desc "Conditional function that evaluates and returns one of the provided atoms based on a boolean condition.") (@params ((@param "Boolean condition") (@param "Atom to return if condition is True") (@param "Atom to return if condition is False (optional)"))) (@return "Either the second or third argument depending on the condition")) (predicate-arity : 2) (= (: $10007 P1)  
  (predicate-arity $10007 1)) (iz SrcPredicate MeTTa) (@doc SrcPredicate (@desc "Type representing a source predicate.")) (: SrcPredicate Type) (iz SrcFunction MeTTa) (@doc SrcFunction (@desc "Type representing a source function.")) (: SrcFunction Type) (iz MeTTaResult MeTTa) (@doc MeTTaResult (@desc "Type representing the result of a MeTTa evaluation.")) (: MeTTaResult Type) (iz NotReducible MeTTaResult) (@doc NotReducible (@desc "Result indicating that an atom cannot be reduced further.")) (: NotReducible MeTTaResult) (iz ValueAtom MeTTa) (@doc ValueAtom (@desc "Type representing a value atom.")) (:> ValueAtom Atom) (iz ForeignObject MeTTa) (@doc ForeignObject (@desc "Type representing a foreign object, such as a Python object.")) (: ForeignObject Type) (:> ValueAtom Grounded) (:> ForeignObject ValueAtom) (iz PyObject MeTTa) (@doc PyObject (@desc "Type representing a Python object.")) (:> PyObject ForeignObject) (:> hyperon::space::DynSpace Grounded) (iz py-list MeTTa) (@doc py-list (@desc "Converts a MeTTa Expression into a Python list and returns it as a PyObject.") (@params ((@param (@desc "A MeTTa List that will be converted into a Python list")))) (@return (@desc "A Python list object that represents the given MeTTa Expression as a PyObject"))) (: py-list (-> Expression PyObject)) (iz py-chain MeTTa) (@doc py-chain (@desc "Chains together a list of Python objects contained in a MeTTa Expression, applying the Python vertical bar | OR operation jointly to all elements.") (@params ((@param (@desc "A MeTTa list of atoms, each embedding a Python object.")))) (@return (@desc "A MeTTa atom which embeds the result of applying the Python OR | operator to all elements of the list."))) (: py-chain (-> Expression PyObject)) (iz py-eval MeTTaLog) (@doc py-eval (@desc "Evaluates a Python expression from a string and returns the result as a PyObject.") (@params ((@param (@desc "A string representing a Python expression that will be evaluated")))) (@return (@desc "The result of evaluating the Python expression as a PyObject"))) (: py-eval (-> String PyObject)) (iz py-exec! MeTTaLog) (@doc py-exec! (@desc "Executes some Python sourcecode from a string !(py-exec! \"import torch\") -> True.  !(py-exec! \"import torche\") -> False. ") (@params ((@param (@type String) (@desc "A string representing a Python sourcecode that will be executed")))) (@return (@desc "The True|False results of executing the Python expression"))) (: py-exec! (-> String Bool)) (iz = MeTTa) (@doc = (@desc "A symbol used to define reduction rules for expressions.") (@params ((@param "Pattern to be matched against expression to be reduced") (@param "Result of reduction or transformation of the first pattern"))) (@return "Not reduced itself unless custom equalities over equalities are added")) (: = (-> $10008 $10008 Atom)) (: = (-> Atom Atom Atom)) (iz ErrorType MeTTa) (@doc ErrorType (@desc "Type of the atom which contains error")) (: ErrorType Type) (iz Error MeTTa) (@doc Error (@desc "Error constructor") (@params ((@param "Atom which contains error") (@param "Error message, can be one of the reserved symbols: BadType, IncorrectNumberOfArguments"))) (@return "Instance of the error atom")) (: Error (-> Atom Atom ErrorType)) (iz return MinimalMeTTa) (@doc return (@desc "Returns value from the (function ...) expression") (@params ((@param "Value to be returned"))) (@return "Passed argument")) (: return (-> $10009 $10009)) (iz function MinimalMeTTa) (@doc function (@desc "Evaluates the argument until it becomes (return <result>). Then (function (return <result>)) is reduced to the <result>.") (@params ((@param "Atom to be evaluated"))) (@return "Result of atom's evaluation")) (: function (-> Atom Atom)) (iz eval MinimalMeTTa) (@doc eval (@desc "Evaluates input Atom, performs one step of the evaluation. Empty results (Empty, ()) are removed from the result set. If no results are produced for a non-grounded function, eval returns NotReducible.") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function"))) (@return "Result of evaluation")) (: eval (-> Atom Atom)) (@doc evalc (@desc "Evaluates input atom, makes one step of the evaluation") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function") (@param "Space to evaluate atom in its context"))) (@return "Result of evaluation")) (: evalc (-> Atom Grounded Atom)) (iz chain MinimalMeTTa) (@doc chain (@desc "Evaluates first argument Atom, binds it to the Variable (second argument) and then evaluates third argument Template with Variable substituted in. When evaluation of the first Atom brings more than a single result, chain returns one instance of the Template expression for each result. The first argument Atom is only evaluated if it is part of the Minimal MeTTa specification; evaluation of non-Minimal MeTTa atoms can be controlled by wrapping in a call to eval (for one evaluation step) or metta (for full evaluation).") (@params ((@param "Atom to be evaluated") (@param "Variable") (@param "Template which will be evaluated at the end with Variable substituted"))) (@return "Result of evaluating third input argument")) (: chain (-> Atom Variable Atom Atom)) (iz unify MeTTa) (@doc unify (@desc "Like Match but allows any sort of container for the first argument. (Match only allows MeTTa spaces.)") (@params ((@param "The collection or space to match") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when found or fourth one otherwise")) (: unify (-> Atom Atom Atom Atom Atom)) (iz if-unify MinimalMeTTaHelper) (@doc if-unify (@desc "Matches two first terms and returns third argument if they are matched and fourth argument otherwise") (@params ((@param "First term to unify with") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when first two atoms are unifiable or fourth one otherwise")) (: if-unify (-> Atom Atom Atom Atom %Undefined%)) (ALT= $10010 $10010) (iz if-unify-or-empty MinimalMeTTaHelper) (@doc if-unify-or-empty (@desc "Attempts to unify two atoms and returns a result. Returns Empty if they cannot be unified.") (@params ((@param "First atom") (@param "Second atom"))) (@return "Unification result or Empty")) (: if-unify-or-empty (-> Atom Atom Atom)) (= (if-unify-or-empty $10011 $10011)  unified) (= (if-unify-or-empty $10012 $10013)  
  (empty)) (iz cons-atom MinimalMeTTa) (@doc cons-atom (@desc "Constructs an expression using two arguments") (@params ((@param "Head of an expression") (@param "Tail of an expression"))) (@return "New expression consisting of the two input arguments")) (: cons-atom (-> Atom Expression Expression)) (iz decons-atom MinimalMeTTa) (@doc decons-atom (@desc "Works as a reverse to cons-atom function. It gets Expression as an input and returns it split into head and tail, e.g. (decons-atom (Cons X Nil)) -> (Cons (X Nil))") (@params ((@param "Expression to be Deconsed"))) (@return "Deconsed expression")) (: decons-atom (-> Expression Expression)) (iz min-atom MeTTa) (@doc min-atom (@desc "Returns atom with minimum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Minimum value in the expression. Error if expression contains non-numeric value or is empty.")) (: min-atom (-> Expression Number)) (= (min-atom $10014)  
  (call-fn! min_list $10014)) (iz max-atom MeTTa) (@doc max-atom (@desc "Returns atom with maximum value in the expression (first argument). Only numbers are allowed.") (@params ((@param "Expression containing atoms of Number type"))) (@return "Maximum value in the expression. Error if expression contains non-numeric value or is empty.")) (: max-atom (-> Expression Number)) (is-fn-1 max-atom max_list) (iz size-atom MeTTa) (@doc size-atom (@desc "Returns the size of an expression (first argument).") (@params ((@param "Expression to measure the size of"))) (@return "Size of the expression")) (: size-atom (-> Expression Integer)) (is-fn-1 size-atom length) (iz index-atom MeTTa) (@doc index-atom (@desc "Returns atom from an expression (first argument) using index (second argument) or error if index is out of bounds.") (@params ((@param "Expression") (@param "Index"))) (@return "Atom at the specified index in the expression. Error if index is out of bounds.")) (: index-atom (-> Expression Number Atom)) (is-fn-21 index-atom nth0) (iz powi MeTTa) (@doc powi (@desc "Takes base (first argument) and power (second argument) and returns the result of raising the base to the power.") (@params ((@param "Base. Could be a float.") (@param "Power. Must be an integer."))) (@return "Result of base raised to the power")) (= (powi $10015 $10016)  
  (call-fn! pow $10015 $10016)) (==> (is-op-1 $10017 $10018) (is-fn-1 $10017 $10018)))) #(expected ())))
</span><span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>!(add-atom &belief_events belief1)
</span>;; To unit test case:
<span class="ansi38-013099040"
>!(assertEqualToResult (add-atom &belief_events belief1) (()))

</span>
;<h3 id="METTA-MORPH-TESTS.MATCH-VOID.02"
>;; METTA-MORPH-TESTS.MATCH-VOID.02</h3>
<span class="ansi38-255165000"
> belief1
</span>; 
; EVAL TEST
; took 0.000819 secs. (818.88 microseconds) 

!(assertEqualToResult (add-atom &belief_events belief1) (()))

<span class="ansi36"
>#(loonit_success #(equal_enough_for_test (()) (())))
</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-255165009"
>;; In file as:  
</span><span class="ansi1 ansi38-255238088"
>!(match &belief_events $1 $1)
</span>;; To unit test case:
<span class="ansi38-013099040"
>!(assertEqualToResult (match &belief_events $1 $1) (belief1))

</span>
;<h3 id="METTA-MORPH-TESTS.MATCH-VOID.03"
>;; METTA-MORPH-TESTS.MATCH-VOID.03</h3>
; 
; EVAL TEST
; took 0.066 secs. (66.46 milliseconds) 

!(assertEqualToResult (match &belief_events $1 $1) (belief1))


Script done on 2024-12-04 09:57:27+00:00 [COMMAND_EXIT_CODE="143"]

</pre>
</body>

</html>
\033[1;33mCompleted (EXITCODE=143) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat/' --timeout=40 --html --repl=false  --test "tests/baseline_compat/metta-morph_tests/match_void.metta" --halt=true\033[0m
