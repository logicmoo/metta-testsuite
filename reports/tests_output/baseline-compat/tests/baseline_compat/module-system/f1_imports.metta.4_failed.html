<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi36 { color: #00aaaa; }
.ansi90 { color: #7f7f7f; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-11-27 09:23:06+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
^@P;HTML|
;         {set_option_value compat false}

P;HTML|
;         {set_option_value compatio false}

P;HTML|
;         {set_option_value src_indents false}

P;HTML|
;         {set_option_value devel false}

P;HTML|
;         {set_option_value stack-max 500}

P;HTML|
;         {set_option_value limit inf}

P;HTML|
;         {set_option_value initial-result-count 10}

P;HTML|
;         {set_option_value answer-format show}

P;HTML|
;         {set_option_value repeats true}

P;HTML|
;         {set_option_value time true}

P;HTML|
;         {set_option_value synth-unit-tests false}

P;HTML|
;         {set_option_value optimize true}

P;HTML|
;         {set_option_value transpiler silent}

P;HTML|
;          {set_debug transpiler false}

P;HTML|
;         {set_option_value compile false}

P;HTML|
;         {set_option_value tabling auto}

P;HTML|
;         {set_option_value log false}

P;HTML|
;         {set_option_value output ./}

P;HTML|
;         {set_option_value exeout ./Sav.gitlab.MeTTaLog}

P;HTML|
;         {set_option_value halt false}

P;HTML|
;         {set_option_value trace-length 500}

P;HTML|
;         {set_option_value trace-on-overtime 4.0}

P;HTML|
;          {set_debug overtime 4.0}

P;HTML|
;         {set_option_value trace-on-overflow 1000}

P;HTML|
;          {set_debug overflow 1000}

P;HTML|
;         {set_option_value trace-on-eval false}

P;HTML|
;          {set_debug eval false}

P;HTML|
;         {set_option_value trace-on-load silent}

P;HTML|
;          {set_debug load silent}

P;HTML|
;          {set_debug trace-on-load false}

P;HTML|
;         {set_option_value trace-on-exec false}

P;HTML|
;          {set_debug exec false}

P;HTML|
;         {set_option_value trace-on-error non-type}

P;HTML|
;          {set_debug error non-type}

P;HTML|
;         {set_option_value trace-on-fail false}

P;HTML|
;          {set_debug fail false}

P;HTML|
;         {set_option_value trace-on-test true}

P;HTML|
;          {set_debug test true}

P;HTML|
;         {set_option_value repl-on-error true}

P;HTML|
;         {set_option_value repl-on-fail false}

P;HTML|
;         {set_option_value exit-on-fail false}

P;HTML|
;         {set_option_value repl auto}

P;HTML|
;         {set_option_value prolog false}

P;HTML|
;         {set_option_value exec noskip}

P;HTML|
;         {set_option_value maximum-result-count inf}

P;HTML|
;         {set_option_value html false}

P;HTML|
;         {set_option_value python true}

P;HTML|
;         {set_option_value trace-on-test false}

P;HTML|
;         {set_debug test false}

P;HTML|
;         {set_option_value trace-on-fail false}

P;HTML|
;         {set_debug fail false}

P;HTML|
;         {set_option_value load show}

P;HTML|
;         {set_option_value test false}
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta is 90.4K bytes (2.36K lines)
</span><span class="ansi1 ansi90"
>Info: File /home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta is 34 bytes (1 lines)
</span><span class="ansi32"
>% 46,854 inferences, 0.183 CPU in 0.183 seconds (100% CPU, 255766 Lips)
</span>P;HTML|
;          {is_cmd_option prescan halt --halt=true true}
P;HTML|
;          {set_option_value halt true}
P;HTML|
;          {is_cmd_option prescan stdin --stdin=tty tty}
P;HTML|
;           {set_option_value stdin tty}
P;HTML|
;          {is_cmd_option prescan stdout --stdout=tty tty}
P;HTML|
;           {set_option_value stdout tty}
P;HTML|
;          {is_cmd_option prescan stderr --stderr=tty tty}
P;HTML|
;           {set_option_value stderr tty}
P;HTML|
;          {set_option_value compat false}
P;HTML|
;          {set_option_value compatio false}
P;HTML|
;          {set_option_value src_indents false}
P;HTML|
;          {set_option_value devel false}
P;HTML|
;          {set_option_value stack-max 500}
P;HTML|
;          {set_option_value limit inf}
P;HTML|
;          {set_option_value initial-result-count 10}
P;HTML|
;          {set_option_value answer-format show}
P;HTML|
;          {set_option_value repeats true}
P;HTML|
;          {set_option_value time true}
P;HTML|
;          {set_option_value synth-unit-tests false}
P;HTML|
;          {set_option_value optimize true}
P;HTML|
;          {set_option_value transpiler silent}
P;HTML|
;          {set_debug transpiler false}
P;HTML|
;          {set_option_value compile false}
P;HTML|
;          {set_option_value tabling auto}
P;HTML|
;          {set_option_value log false}
P;HTML|
;          {set_option_value output ./}
P;HTML|
;          {set_option_value exeout ./Sav.gitlab.MeTTaLog}
P;HTML|
;          {set_option_value halt false}
P;HTML|
;          {set_option_value trace-length 500}
P;HTML|
;          {set_option_value trace-on-overtime 4.0}
P;HTML|
;          {set_debug overtime 4.0}
P;HTML|
;          {set_option_value trace-on-overflow 1000}
P;HTML|
;          {set_debug overflow 1000}
P;HTML|
;          {set_option_value trace-on-eval false}
P;HTML|
;          {set_debug eval false}
P;HTML|
;          {set_option_value trace-on-load silent}
P;HTML|
;          {set_debug load silent}
P;HTML|
;          {set_debug trace-on-load false}
P;HTML|
;          {set_option_value trace-on-exec false}
P;HTML|
;          {set_debug exec false}
P;HTML|
;          {set_option_value trace-on-error non-type}
P;HTML|
;          {set_debug error non-type}
P;HTML|
;          {set_option_value trace-on-fail false}
P;HTML|
;          {set_debug fail false}
P;HTML|
;          {set_option_value trace-on-test true}
P;HTML|
;          {set_debug test true}
P;HTML|
;          {set_option_value repl-on-error true}
P;HTML|
;          {set_option_value repl-on-fail false}
P;HTML|
;          {set_option_value exit-on-fail false}
P;HTML|
;          {set_option_value repl auto}
P;HTML|
;          {set_option_value prolog false}
P;HTML|
;          {set_option_value exec noskip}
P;HTML|
;          {set_option_value maximum-result-count inf}
P;HTML|
;          {set_option_value html false}
P;HTML|
;          {set_option_value python true}
P;HTML|
;         {set_option_value trace-on-test false}
P;HTML|
;          {set_debug test false}
P;HTML|
;         {set_option_value trace-on-fail false}
P;HTML|
;          {set_debug fail false}
P;HTML|
;         {set_option_value load show}
P;HTML|
;         {set_option_value test true}
P;HTML|
;        {is_cmd_option execute python --python=enable enable}
P;HTML|
;         {set_option_value python enable}
P;HTML|
;        {is_cmd_option execute timeout --timeout=40 40}
P;HTML|
;         {set_option_value timeout 40}
P;HTML|
;         {is_cmd_option execute output --output=./reports/tests_output/baseline-compat/ ./reports/tests_output/baseline-compat/}
P;HTML|
;         {set_option_value output ./reports/tests_output/baseline-compat/}
P;HTML|
;         {is_cmd_option execute html --html true}
P;HTML|
;          {set_option_value html true}
P;HTML|
;         {is_cmd_option execute test --test true}
P;HTML|
;          {set_option_value test true}

; 
{load_metta_file &self tests/baseline_compat/module-system/f1_imports.metta}

P;HTML|
;                       {track_load_into_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta}
P;HTML|
;                                        {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta.answers
;                                           /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta}
P;HTML|
;                                         { = 1 "[()]" }
P;HTML|
;                                         { = 2 "[()]" }
P;HTML|
;                                         { = 3 "[()]" }
P;HTML|
;                                         { = 4 "[()]" }
P;HTML|
;                                         { = 5 "[()]" }
P;HTML|
;                                         { = 6 "[()]" }
P;HTML|
;                                         { = 7 "[()]" }
P;HTML|
;                                         { = 8 "[()]" }
P;HTML|
;                                         { = 9 "[()]" }
P;HTML|
;                                         { = 10 "[()]" }
P;HTML|
;                                         { = 11 "[()]" }
P;HTML|
;                                         { = 12 "[()]" }
P;HTML|
;                                         { = 13 "[()]" }
P;HTML|
;                                         { = 14 "[()]" }
P;HTML|
;                                         { = 15 "[()]" }
P;HTML|
;                                         { = 16 "[()]" }
P;HTML|
;                                         { = 17 "[()]" }
P;HTML|
;                                         { = 18 "[()]" }
P;HTML|
;                                         { = 19 "[()]" }
P;HTML|
;                                         { = 20 "0.19user 0.00system 0:00.20elapsed 100%CPU (0avgtext+0avgdata 35952maxresident)k" }
P;HTML|
;                                         { = 20 "0inputs+0outputs (0major+4794minor)pagefaults 0swaps" }
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta is 5.11K bytes (128 lines)
</span>P;HTML|
;                                        {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta.answers
;                                           /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta}

;;; NOTE: This test won't work outside the test environment because it relies on
;;;  specific atoms in a specific order in the space, and loading the default environment's
;;;  init.metta will break the assumptions in this test
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Even at the very beginning of the script `(get-atoms &self)`
;;; returns two atoms.  One is from the imported stdlib, and the other
;;; is corelib, which was a dependency of stdlib that has been promoted
;;; These atoms are both wrapped spaces, as is `&self`
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>{exec 
  (assertEqual 
    ((let $x 
  (get-atoms &self) 
  (get-type $x))
) 
    (superpose 
      (((get-type &self)
)
 
    ((get-type &self)
))))}


</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.01"
>;; MODULE-SYSTEM.F1-IMPORTS.01</h3>

{failed 
 once 

  {if_or_else 
    {eval = $10000 495 &self 
      (let a b never-happens) $10001} 
    {call eval 
      (let a b never-happens) $10001}}}


{on_mettalog_error 
  {failed 
  once 

    {if_or_else 
      {eval = $10000 495 &self 
    (let a b never-happens) $10001} 
      {call eval 
    (let a b never-happens) $10001}}}}

^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] call(user:once, user:if_or_else(eval(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826), call(eval, [let, a, b, 'never-happens'], _503826)))
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] once(user:if_or_else(eval(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826), call(eval, [let, a, b, 'never-happens'], _503826)))
   <span class="ansi1 ansi32"
>Call: </span>(299) [user] if_or_else(eval(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826), call(eval, [let, a, b, 'never-happens'], _503826))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] eval(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] catch_metta_return(eval_args(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826), _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_args(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_512236, _512238), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_512236, _512238))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_512236, _512238))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_514324, _514326), once(user:nonvar(_503826)), '$restore_trace'(_514324, _514326))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_514324, _514326))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_516412, _516414), once(user:nonvar(_503826)), '$restore_trace'(_516412, _516414))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_516412, _516414))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] setup_call_cleanup('$notrace'(_523568, _523570), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_523568, _523570))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] sig_atomic(system:'$notrace'(_523568, _523570))
^  <span class="ansi1 ansi31"
>Fail: </span>(304) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] eval_00(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] setup_call_cleanup('$notrace'(_528712, _528714), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_528712, _528714))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] sig_atomic(system:'$notrace'(_528712, _528714))
^  <span class="ansi1 ansi31"
>Fail: </span>(305) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] eval_01(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] 495<1
   <span class="ansi1 ansi31"
>Fail: </span>(308) [system] 495<1
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] setup_call_cleanup('$notrace'(_536948, _536950), once(user:(_536924 is 495-1, copy_term([let, a, b, 'never-happens'], _536938))), '$restore_trace'(_536948, _536950))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] sig_atomic(system:'$notrace'(_536948, _536950))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(494 is 495-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] trace_eval(eval_20(=, _502152), e, 494, '&self', [let, a, b, 'never-happens'], _540058)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] must_det_ll((notrace((flag(eval_num, _541112, _541112+1), _541130 is _541112 mod 500, _541148 is 99-494 mod 100, _541172=_541174, option_else('trace-length', _541186, 500), option_else('trace-depth', _541194, 30))), quietly(if_t((nop(stop_rtrace), _541130>_541186), (set_debug(eval, false), _541250 is _541186+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_541250])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_541302)))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] once(user:(notrace((flag(eval_num, _541112, _541112+1), _541130 is _541112 mod 500, _541148 is 99-494 mod 100, _541172=_541174, option_else('trace-length', _541186, 500), option_else('trace-depth', _541194, 30))), quietly(if_t((nop(stop_rtrace), _541130>_541186), (set_debug(eval, false), _541250 is _541186+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_541250])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_541302)))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] setup_call_cleanup('$notrace'(_543348, _543350), once(user:(flag(eval_num, _541112, _541112+1), _541130 is _541112 mod 500, _541148 is 99-494 mod 100, _541172=_541174, option_else('trace-length', _541186, 500), option_else('trace-depth', _541194, 30))), '$restore_trace'(_543348, _543350))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] sig_atomic(system:'$notrace'(_543348, _543350))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2905, 2905+1), 405 is 2905 mod 500, 5 is 99-494 mod 100, _541172=_541172, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 405>500), (set_debug(eval, false), _541250 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_541250])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 405>500), (set_debug(eval, false), _541250 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_541250])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] nop(notrace(no_repeats_var(_541302)))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] nop(notrace(no_repeats_var(_541302)))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] once(user:(notrace((flag(eval_num, 2905, 2905+1), 405 is 2905 mod 500, 5 is 99-494 mod 100, _541172=_541172, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 405>500), (set_debug(eval, false), _541250 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_541250])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_541302)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] must_det_ll(user:(notrace((flag(eval_num, 2905, 2905+1), 405 is 2905 mod 500, 5 is 99-494 mod 100, _541172=_541172, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 405>500), (set_debug(eval, false), _541250 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_541250])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_541302)))))
   <span class="ansi1 ansi32"
>Call: </span>(307) [occurs] occurs:sub_term(_553000, e)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(307) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(308) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(307) [occurs] occurs:sub_term(_553000, e)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _560106=e
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] if_trace((eval;e), (_541172=1, indentq(5, 405, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_563246, _563248), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _541172=1, indentq(5, 405, -->, [e, [let, a, b, 'never-happens']]))), _563204, fbug((_563204-->if_trace((eval;e), (_541172=1, indentq(5, 405, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_563246, _563248))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_563246, _563248))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _541172=1, indentq(5, 405, -->, [e, [let, a, b, 'never-happens']]))), _563204, fbug((_563204-->if_trace((eval;e), (_541172=1, indentq(5, 405, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] if_trace((eval;e), (_541172=1, indentq(5, 405, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _567442=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _569480=(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] (\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] call_cleanup(((call(eval_20(=, _502152), 494, '&self', [let, a, b, 'never-happens'], _540058)*->nb_setarg(1, retval(fail), _540058);fail, trace, call(eval_20(=, _502152), 494, '&self', [let, a, b, 'never-happens'], _540058)), ignore(notrace((\+_540058\=_541302, nb_setarg(1, retval(fail), _540058))))), ignore((_541172==1->ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_20(=, _502152, 494, '&self', [let, a, b, 'never-happens'], _540058)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] setup_call_cleanup('$notrace'(_576888, _576890), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_576888, _576890))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(system:'$notrace'(_576888, _576890))
^  <span class="ansi1 ansi31"
>Fail: </span>(311) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(311) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] once(expand_eval([let, a, b, 'never-happens'], _599232))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] expand_eval([let, a, b, 'never-happens'], _599232)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _605332)
   <span class="ansi1 ansi32"
>Call: </span>(313) [apply] apply:maplist_([a, b, 'never-happens'], _605332, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] expand_eval(a, _607388)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] a=_607388
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(314) [apply] apply:maplist_([b, 'never-happens'], _607390, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] expand_eval(b, _613490)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] b=_613490
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(315) [apply] apply:maplist_(['never-happens'], _613492, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] expand_eval('never-happens', _619592)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] 'never-happens'=_619592
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(316) [apply] apply:maplist_([], _619594, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(314) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] possible_type('&self', a, _636884)
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] possible_type('&self', a, _636884)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] eval_args(=, _636884, 494, '&self', b, _638926)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_640984, _640986), once(user:self_eval(b)), '$restore_trace'(_640984, _640986))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_640984, _640986))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] _638926=b
   <span class="ansi1 ansi32"
>Exit: </span>(311) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] eval_args(=, _636884, 494, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] eval_20(=, _502152, 494, '&self', [let, a, b, 'never-happens'], _540058)
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(309) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] ignore((_541172==1->ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] _541172==1
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] _541172==1
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_654314, _654316), once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)])))))))), '$restore_trace'(_654314, _654316))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_654314, _654316))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] ignore(user:(_541172==1->ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(307) [system] call_cleanup(user:((call(eval_20(=, _502152), 494, '&self', [let, a, b, 'never-happens'], _540058)*->nb_setarg(1, retval(fail), _540058);fail, trace, call(eval_20(=, _502152), 494, '&self', [let, a, b, 'never-happens'], _540058)), ignore(notrace((\+_540058\=_541302, nb_setarg(1, retval(fail), _540058))))), user:ignore((_541172==1->ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(306) [user] trace_eval(eval_20(=, _502152), e, 494, '&self', [let, a, b, 'never-happens'], _540058)
^  <span class="ansi1 ansi31"
>Fail: </span>(303) [user] eval_args(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] call(eval, [let, a, b, 'never-happens'], _503826)
   <span class="ansi1 ansi32"
>Call: </span>(301) [user] eval([let, a, b, 'never-happens'], _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] current_self(_663722)
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] nb_current(self_space, _663722)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(302) [user] eval('&self', [let, a, b, 'never-happens'], _503826)
   <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] catch_metta_return(eval_args(=, _671836, 500, '&self', [let, a, b, 'never-happens'], _503826), _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_args(=, _671836, 500, '&self', [let, a, b, 'never-happens'], _503826)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_674946, _674948), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_674946, _674948))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_674946, _674948))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_677034, _677036), once(user:nonvar(_503826)), '$restore_trace'(_677034, _677036))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_677034, _677036))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_679122, _679124), once(user:nonvar(_503826)), '$restore_trace'(_679122, _679124))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_679122, _679124))
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_686278, _686280), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_686278, _686280))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_686278, _686280))
^  <span class="ansi1 ansi31"
>Fail: </span>(307) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] eval_00(=, _671836, 500, '&self', [let, a, b, 'never-happens'], _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_691422, _691424), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_691422, _691424))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_691422, _691424))
^  <span class="ansi1 ansi31"
>Fail: </span>(308) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] eval_01(=, _671836, 500, '&self', [let, a, b, 'never-happens'], _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_699658, _699660), once(user:(_699634 is 500-1, copy_term([let, a, b, 'never-happens'], _699648))), '$restore_trace'(_699658, _699660))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_699658, _699660))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] trace_eval(eval_20(=, _671836), e, 499, '&self', [let, a, b, 'never-happens'], _702768)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] must_det_ll((notrace((flag(eval_num, _703822, _703822+1), _703840 is _703822 mod 500, _703858 is 99-499 mod 100, _703882=_703884, option_else('trace-length', _703896, 500), option_else('trace-depth', _703904, 30))), quietly(if_t((nop(stop_rtrace), _703840>_703896), (set_debug(eval, false), _703960 is _703896+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_703960])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_704012)))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] once(user:(notrace((flag(eval_num, _703822, _703822+1), _703840 is _703822 mod 500, _703858 is 99-499 mod 100, _703882=_703884, option_else('trace-length', _703896, 500), option_else('trace-depth', _703904, 30))), quietly(if_t((nop(stop_rtrace), _703840>_703896), (set_debug(eval, false), _703960 is _703896+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_703960])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_704012)))))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] setup_call_cleanup('$notrace'(_706058, _706060), once(user:(flag(eval_num, _703822, _703822+1), _703840 is _703822 mod 500, _703858 is 99-499 mod 100, _703882=_703884, option_else('trace-length', _703896, 500), option_else('trace-depth', _703904, 30))), '$restore_trace'(_706058, _706060))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] sig_atomic(system:'$notrace'(_706058, _706060))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2906, 2906+1), 406 is 2906 mod 500, 0 is 99-499 mod 100, _703882=_703882, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 406>500), (set_debug(eval, false), _703960 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_703960])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 406>500), (set_debug(eval, false), _703960 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_703960])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] nop(notrace(no_repeats_var(_704012)))
   <span class="ansi1 ansi32"
>Exit: </span>(313) [user] nop(notrace(no_repeats_var(_704012)))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] once(user:(notrace((flag(eval_num, 2906, 2906+1), 406 is 2906 mod 500, 0 is 99-499 mod 100, _703882=_703882, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 406>500), (set_debug(eval, false), _703960 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_703960])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_704012)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] must_det_ll(user:(notrace((flag(eval_num, 2906, 2906+1), 406 is 2906 mod 500, 0 is 99-499 mod 100, _703882=_703882, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 406>500), (set_debug(eval, false), _703960 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_703960])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_704012)))))
   <span class="ansi1 ansi32"
>Call: </span>(310) [occurs] occurs:sub_term(_715710, e)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(310) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(310) [occurs] occurs:sub_term(_715710, e)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _722816=e
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] if_trace((eval;e), (_703882=1, indentq(0, 406, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_725956, _725958), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _703882=1, indentq(0, 406, -->, [e, [let, a, b, 'never-happens']]))), _725914, fbug((_725914-->if_trace((eval;e), (_703882=1, indentq(0, 406, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_725956, _725958))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_725956, _725958))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _703882=1, indentq(0, 406, -->, [e, [let, a, b, 'never-happens']]))), _725914, fbug((_725914-->if_trace((eval;e), (_703882=1, indentq(0, 406, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_trace((eval;e), (_703882=1, indentq(0, 406, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _730152=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _732190=(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] (\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] call_cleanup(((call(eval_20(=, _671836), 499, '&self', [let, a, b, 'never-happens'], _702768)*->nb_setarg(1, retval(fail), _702768);fail, trace, call(eval_20(=, _671836), 499, '&self', [let, a, b, 'never-happens'], _702768)), ignore(notrace((\+_702768\=_704012, nb_setarg(1, retval(fail), _702768))))), ignore((_703882==1->ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval_20(=, _671836, 499, '&self', [let, a, b, 'never-happens'], _702768)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] setup_call_cleanup('$notrace'(_739598, _739600), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_739598, _739600))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] sig_atomic(system:'$notrace'(_739598, _739600))
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] once(expand_eval([let, a, b, 'never-happens'], _761942))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] expand_eval([let, a, b, 'never-happens'], _761942)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _768042)
   <span class="ansi1 ansi32"
>Call: </span>(316) [apply] apply:maplist_([a, b, 'never-happens'], _768042, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] expand_eval(a, _770098)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] a=_770098
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(317) [apply] apply:maplist_([b, 'never-happens'], _770100, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] expand_eval(b, _776200)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] b=_776200
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(318) [apply] apply:maplist_(['never-happens'], _776202, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] expand_eval('never-happens', _782302)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] 'never-happens'=_782302
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(319) [apply] apply:maplist_([], _782304, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(317) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] possible_type('&self', a, _799594)
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] possible_type('&self', a, _799594)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval_args(=, _799594, 499, '&self', b, _801636)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_803694, _803696), once(user:self_eval(b)), '$restore_trace'(_803694, _803696))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_803694, _803696))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] _801636=b
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] eval_args(=, _799594, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(312) [user] eval_20(=, _671836, 499, '&self', [let, a, b, 'never-happens'], _702768)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(312) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] ignore((_703882==1->ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] _703882==1
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] _703882==1
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_817024, _817026), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)])))))))), '$restore_trace'(_817024, _817026))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_817024, _817026))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] ignore(user:(_703882==1->ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(310) [system] call_cleanup(user:((call(eval_20(=, _671836), 499, '&self', [let, a, b, 'never-happens'], _702768)*->nb_setarg(1, retval(fail), _702768);fail, trace, call(eval_20(=, _671836), 499, '&self', [let, a, b, 'never-happens'], _702768)), ignore(notrace((\+_702768\=_704012, nb_setarg(1, retval(fail), _702768))))), user:ignore((_703882==1->ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] trace_eval(eval_20(=, _671836), e, 499, '&self', [let, a, b, 'never-happens'], _702768)
^  <span class="ansi1 ansi31"
>Fail: </span>(306) [user] eval_args(=, _671836, 500, '&self', [let, a, b, 'never-happens'], _503826)
^  <span class="ansi1 ansi31"
>Fail: </span>(297) [system] call(user:once, user:if_or_else(eval(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826), call(eval, [let, a, b, 'never-happens'], _503826)))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(299) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] setup_call_cleanup('$notrace'(_828486, _828488), once(rtrace:retract(t_l:tracer_reset(_828476))), '$restore_trace'(_828486, _828488))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] sig_atomic(system:'$notrace'(_828486, _828488))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [rtrace] tAt(false, 271, 271, false)
; 
; EVAL TEST
; took 1.084 secs. (1083.52 milliseconds) 

{exec 
  (assertEqual 
    ((let $x 
  (get-atoms &self) 
  (get-type $x))
) 
    (superpose 
      (((get-type &self)
)
 
    ((get-type &self)
))))}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test 
    ((hyperon::space::DynSpace)
 
      (hyperon::space::DynSpace) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (%Undefined%) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (())) 
    ((hyperon::space::DynSpace)
 
      (hyperon::space::DynSpace))}}

</span>
Deterministic: ({Error 
  {got 
    ((hyperon::space::DynSpace)
 
      (hyperon::space::DynSpace) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (%Undefined%) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()))} 
  {expected 
    ((hyperon::space::DynSpace)
 
      (hyperon::space::DynSpace))}}
)
;;; stdlib is already loaded
<span class="ansi38-013099040"
>{exec 
  (assertEqual 
    (if 
      (> 1 2) 1 2) 2)}


</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.02"
>;; MODULE-SYSTEM.F1-IMPORTS.02</h3>
; 
; EVAL TEST
; took 0.000278 secs. (278.34 microseconds) 

{exec 
  (assertEqual 
    (if 
      (> 1 2) 1 2) 2)}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (2) 
    (2)}}

</span>
Deterministic: ()
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Importing the module into new space
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>{exec 
  (import! &m f1_moduleA)}


</span>P;HTML|
;                                         {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta.answers
;                                            /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta}
P;HTML|
;                                         { = 1 "[()]" }
P;HTML|
;                                         { = 2 "[()]" }
P;HTML|
;                                         { = 3 "0.05user 0.00system 0:00.06elapsed 98%CPU (0avgtext+0avgdata 32252maxresident)k" }
P;HTML|
;                                         { = 3 "0inputs+0outputs (0major+3916minor)pagefaults 0swaps" }
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta is 621 bytes (17 lines)
</span>P;HTML|
;                                         {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta.answers
;                                            /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>{exec 
  (import! &self f1_moduleC)}


</span>P;HTML|
;                                         {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers
;                                            /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta}
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta is 292 bytes (9 lines)
</span>P;HTML|
;                                         {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers
;                                            /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g 
  (-> Number))

</span><span class="ansi38-255165000"
> (= 
  (__g) 100)

</span><span class="ansi38-255165000"
> (: g 
  (-> Number Number))

</span><span class="ansi38-255165000"
> (= 
  (g $x) 
  (+ $x 
    (__g)))

</span>
Deterministic: ()
;;; FIXME? stdlib space is not available at importing time -
;;; only tokens / grounded operations work, while symbolic functions
;;; (like `if`) don't work.
;;; FIXME? Exceptions are not caught by `importOp`
<span class="ansi38-013099040"
>{exec 
  (assertEqual 
    (+ 1 2) 3)}


</span>
;<h3 id="MODULE-SYSTEM.F1-MODULEA.03"
>;; MODULE-SYSTEM.F1-MODULEA.03</h3>
; 
; EVAL TEST
; took 0.000233 secs. (232.61 microseconds) 

{exec 
  (assertEqual 
    (+ 1 2) 3)}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (3) 
    (3)}}

</span>
Deterministic: ()
;;; !(assertEqual (if True "S" "F") "S")
<span class="ansi38-255165000"
> (= 
  (dup $x) 
  (if 
    (== $x 0) 
    (+ $x 10) 
    (g $x)))

</span><span class="ansi38-255165000"
> (: f 
  (-> Number Number))

</span><span class="ansi38-255165000"
> (= 
  (f $x) 
  (if 
    (< $x 0) 
    (- 0 $x) 
    (g 
      (+ 1 $x))))

</span>
Last Result(2): ()
;;; Check whether passed expression contains atom for which condition is True
<span class="ansi38-255165000"
> (: contains 
  (-> Expression 
    (-> Atom Bool) Bool))

</span><span class="ansi38-255165000"
> (= 
  (contains $list $condition) 
  (if 
    (== $list ()) False 
    (let $head 
      (car-atom $list) 
      (if 
    ($condition $head) True 
    (let $tail 
     (cdr-atom $list) 
     (contains $tail $condition))))))

</span>;;; Check whether atom is space comparing its type with type of the &self atom
<span class="ansi38-255165000"
> (: is-space 
  (-> Atom Bool))

</span><span class="ansi38-255165000"
> (= 
  (is-space $atom) 
  (let* 
    (($type 
  (get-type $atom))
 
      ($space 
    (get-type &self))) 
    (== $type $space)))

</span>;;; It's first atom is a space
<span class="ansi38-013099040"
>{exec 
  (assertEqual 
    (let $x 
      (collapse 
    (get-atoms &m)) 
      (contains $x is-space)) True)}


</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.04"
>;; MODULE-SYSTEM.F1-IMPORTS.04</h3>

{failed 
 once 

  {if_or_else 
    {eval = $10000 495 &self 
      (let a b never-happens) $10001} 
    {call eval 
      (let a b never-happens) $10001}}}


{on_mettalog_error 
  {failed 
  once 

    {if_or_else 
      {eval = $10000 495 &self 
    (let a b never-happens) $10001} 
      {call eval 
    (let a b never-happens) $10001}}}}

^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] call(user:once, user:if_or_else(eval(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828), call(eval, [let, a, b, 'never-happens'], _297828)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] once(user:if_or_else(eval(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828), call(eval, [let, a, b, 'never-happens'], _297828)))
   <span class="ansi1 ansi32"
>Call: </span>(311) [user] if_or_else(eval(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828), call(eval, [let, a, b, 'never-happens'], _297828))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] catch_metta_return(eval_args(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828), _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_args(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_306238, _306240), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_306238, _306240))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_306238, _306240))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_308326, _308328), once(user:nonvar(_297828)), '$restore_trace'(_308326, _308328))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_308326, _308328))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_310414, _310416), once(user:nonvar(_297828)), '$restore_trace'(_310414, _310416))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_310414, _310416))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_317570, _317572), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_317570, _317572))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_317570, _317572))
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_00(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_322714, _322716), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_322714, _322716))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_322714, _322716))
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] eval_01(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] 495<1
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] 495<1
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_330950, _330952), once(user:(_330926 is 495-1, copy_term([let, a, b, 'never-happens'], _330940))), '$restore_trace'(_330950, _330952))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_330950, _330952))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(494 is 495-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] trace_eval(eval_20(=, _296154), e, 494, '&self', [let, a, b, 'never-happens'], _334060)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] must_det_ll((notrace((flag(eval_num, _335114, _335114+1), _335132 is _335114 mod 500, _335150 is 99-494 mod 100, _335174=_335176, option_else('trace-length', _335188, 500), option_else('trace-depth', _335196, 30))), quietly(if_t((nop(stop_rtrace), _335132>_335188), (set_debug(eval, false), _335252 is _335188+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335252])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335304)))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] once(user:(notrace((flag(eval_num, _335114, _335114+1), _335132 is _335114 mod 500, _335150 is 99-494 mod 100, _335174=_335176, option_else('trace-length', _335188, 500), option_else('trace-depth', _335196, 30))), quietly(if_t((nop(stop_rtrace), _335132>_335188), (set_debug(eval, false), _335252 is _335188+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335252])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335304)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] setup_call_cleanup('$notrace'(_337350, _337352), once(user:(flag(eval_num, _335114, _335114+1), _335132 is _335114 mod 500, _335150 is 99-494 mod 100, _335174=_335176, option_else('trace-length', _335188, 500), option_else('trace-depth', _335196, 30))), '$restore_trace'(_337350, _337352))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] sig_atomic(system:'$notrace'(_337350, _337352))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2090, 2090+1), 90 is 2090 mod 500, 5 is 99-494 mod 100, _335174=_335174, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 90>500), (set_debug(eval, false), _335252 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335252])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 90>500), (set_debug(eval, false), _335252 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335252])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(322) [user] nop(notrace(no_repeats_var(_335304)))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [user] nop(notrace(no_repeats_var(_335304)))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] once(user:(notrace((flag(eval_num, 2090, 2090+1), 90 is 2090 mod 500, 5 is 99-494 mod 100, _335174=_335174, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 90>500), (set_debug(eval, false), _335252 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335252])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335304)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] must_det_ll(user:(notrace((flag(eval_num, 2090, 2090+1), 90 is 2090 mod 500, 5 is 99-494 mod 100, _335174=_335174, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 90>500), (set_debug(eval, false), _335252 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335252])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335304)))))
   <span class="ansi1 ansi32"
>Call: </span>(319) [occurs] occurs:sub_term(_347002, e)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [occurs] occurs:sub_term(_347002, e)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _354108=e
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] if_trace((eval;e), (_335174=1, indentq(5, 90, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_357248, _357250), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _335174=1, indentq(5, 90, -->, [e, [let, a, b, 'never-happens']]))), _357206, fbug((_357206-->if_trace((eval;e), (_335174=1, indentq(5, 90, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_357248, _357250))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_357248, _357250))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _335174=1, indentq(5, 90, -->, [e, [let, a, b, 'never-happens']]))), _357206, fbug((_357206-->if_trace((eval;e), (_335174=1, indentq(5, 90, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] if_trace((eval;e), (_335174=1, indentq(5, 90, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _361444=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _363482=(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] (\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] call_cleanup(((call(eval_20(=, _296154), 494, '&self', [let, a, b, 'never-happens'], _334060)*->nb_setarg(1, retval(fail), _334060);fail, trace, call(eval_20(=, _296154), 494, '&self', [let, a, b, 'never-happens'], _334060)), ignore(notrace((\+_334060\=_335304, nb_setarg(1, retval(fail), _334060))))), ignore((_335174==1->ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] eval_20(=, _296154, 494, '&self', [let, a, b, 'never-happens'], _334060)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_370890, _370892), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_370890, _370892))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_370890, _370892))
^  <span class="ansi1 ansi31"
>Fail: </span>(323) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] once(expand_eval([let, a, b, 'never-happens'], _393234))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] expand_eval([let, a, b, 'never-happens'], _393234)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _399334)
   <span class="ansi1 ansi32"
>Call: </span>(325) [apply] apply:maplist_([a, b, 'never-happens'], _399334, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] expand_eval(a, _401390)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] a=_401390
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(326) [apply] apply:maplist_([b, 'never-happens'], _401392, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] expand_eval(b, _407492)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] b=_407492
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(327) [apply] apply:maplist_(['never-happens'], _407494, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] expand_eval('never-happens', _413594)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] 'never-happens'=_413594
   <span class="ansi1 ansi32"
>Exit: </span>(329) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(328) [apply] apply:maplist_([], _413596, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] possible_type('&self', a, _430886)
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] possible_type('&self', a, _430886)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] eval_args(=, _430886, 494, '&self', b, _432928)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_434986, _434988), once(user:self_eval(b)), '$restore_trace'(_434986, _434988))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_434986, _434988))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _432928=b
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] eval_args(=, _430886, 494, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] eval_20(=, _296154, 494, '&self', [let, a, b, 'never-happens'], _334060)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] ignore((_335174==1->ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _335174==1
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] _335174==1
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_448316, _448318), once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)])))))))), '$restore_trace'(_448316, _448318))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_448316, _448318))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] ignore(user:(_335174==1->ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [system] call_cleanup(user:((call(eval_20(=, _296154), 494, '&self', [let, a, b, 'never-happens'], _334060)*->nb_setarg(1, retval(fail), _334060);fail, trace, call(eval_20(=, _296154), 494, '&self', [let, a, b, 'never-happens'], _334060)), ignore(notrace((\+_334060\=_335304, nb_setarg(1, retval(fail), _334060))))), user:ignore((_335174==1->ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] trace_eval(eval_20(=, _296154), e, 494, '&self', [let, a, b, 'never-happens'], _334060)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] eval_args(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] call(eval, [let, a, b, 'never-happens'], _297828)
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval([let, a, b, 'never-happens'], _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] current_self(_457724)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nb_current(self_space, _457724)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(314) [user] eval('&self', [let, a, b, 'never-happens'], _297828)
   <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] catch_metta_return(eval_args(=, _465838, 500, '&self', [let, a, b, 'never-happens'], _297828), _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] eval_args(=, _465838, 500, '&self', [let, a, b, 'never-happens'], _297828)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_468948, _468950), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_468948, _468950))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_468948, _468950))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_471036, _471038), once(user:nonvar(_297828)), '$restore_trace'(_471036, _471038))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_471036, _471038))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_473124, _473126), once(user:nonvar(_297828)), '$restore_trace'(_473124, _473126))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_473124, _473126))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_480280, _480282), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_480280, _480282))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_480280, _480282))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_00(=, _465838, 500, '&self', [let, a, b, 'never-happens'], _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_485424, _485426), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_485424, _485426))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_485424, _485426))
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] eval_01(=, _465838, 500, '&self', [let, a, b, 'never-happens'], _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_493660, _493662), once(user:(_493636 is 500-1, copy_term([let, a, b, 'never-happens'], _493650))), '$restore_trace'(_493660, _493662))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_493660, _493662))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] trace_eval(eval_20(=, _465838), e, 499, '&self', [let, a, b, 'never-happens'], _496770)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] must_det_ll((notrace((flag(eval_num, _497824, _497824+1), _497842 is _497824 mod 500, _497860 is 99-499 mod 100, _497884=_497886, option_else('trace-length', _497898, 500), option_else('trace-depth', _497906, 30))), quietly(if_t((nop(stop_rtrace), _497842>_497898), (set_debug(eval, false), _497962 is _497898+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497962])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_498014)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] once(user:(notrace((flag(eval_num, _497824, _497824+1), _497842 is _497824 mod 500, _497860 is 99-499 mod 100, _497884=_497886, option_else('trace-length', _497898, 500), option_else('trace-depth', _497906, 30))), quietly(if_t((nop(stop_rtrace), _497842>_497898), (set_debug(eval, false), _497962 is _497898+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497962])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_498014)))))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] setup_call_cleanup('$notrace'(_500060, _500062), once(user:(flag(eval_num, _497824, _497824+1), _497842 is _497824 mod 500, _497860 is 99-499 mod 100, _497884=_497886, option_else('trace-length', _497898, 500), option_else('trace-depth', _497906, 30))), '$restore_trace'(_500060, _500062))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] sig_atomic(system:'$notrace'(_500060, _500062))
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2091, 2091+1), 91 is 2091 mod 500, 0 is 99-499 mod 100, _497884=_497884, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 91>500), (set_debug(eval, false), _497962 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497962])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 91>500), (set_debug(eval, false), _497962 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497962])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(325) [user] nop(notrace(no_repeats_var(_498014)))
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] nop(notrace(no_repeats_var(_498014)))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] once(user:(notrace((flag(eval_num, 2091, 2091+1), 91 is 2091 mod 500, 0 is 99-499 mod 100, _497884=_497884, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 91>500), (set_debug(eval, false), _497962 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497962])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_498014)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] must_det_ll(user:(notrace((flag(eval_num, 2091, 2091+1), 91 is 2091 mod 500, 0 is 99-499 mod 100, _497884=_497884, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 91>500), (set_debug(eval, false), _497962 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497962])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_498014)))))
   <span class="ansi1 ansi32"
>Call: </span>(322) [occurs] occurs:sub_term(_509712, e)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(322) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [occurs] occurs:sub_term(_509712, e)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _516818=e
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] if_trace((eval;e), (_497884=1, indentq(0, 91, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_519958, _519960), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _497884=1, indentq(0, 91, -->, [e, [let, a, b, 'never-happens']]))), _519916, fbug((_519916-->if_trace((eval;e), (_497884=1, indentq(0, 91, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_519958, _519960))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_519958, _519960))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _497884=1, indentq(0, 91, -->, [e, [let, a, b, 'never-happens']]))), _519916, fbug((_519916-->if_trace((eval;e), (_497884=1, indentq(0, 91, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] if_trace((eval;e), (_497884=1, indentq(0, 91, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _524154=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _526192=(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] (\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] call_cleanup(((call(eval_20(=, _465838), 499, '&self', [let, a, b, 'never-happens'], _496770)*->nb_setarg(1, retval(fail), _496770);fail, trace, call(eval_20(=, _465838), 499, '&self', [let, a, b, 'never-happens'], _496770)), ignore(notrace((\+_496770\=_498014, nb_setarg(1, retval(fail), _496770))))), ignore((_497884==1->ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] eval_20(=, _465838, 499, '&self', [let, a, b, 'never-happens'], _496770)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] setup_call_cleanup('$notrace'(_533600, _533602), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_533600, _533602))
^  <span class="ansi1 ansi32"
>Call: </span>(329) [system] sig_atomic(system:'$notrace'(_533600, _533602))
^  <span class="ansi1 ansi31"
>Fail: </span>(326) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] once(expand_eval([let, a, b, 'never-happens'], _555944))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] expand_eval([let, a, b, 'never-happens'], _555944)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _562044)
   <span class="ansi1 ansi32"
>Call: </span>(328) [apply] apply:maplist_([a, b, 'never-happens'], _562044, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] expand_eval(a, _564100)
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] a=_564100
   <span class="ansi1 ansi32"
>Exit: </span>(330) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(329) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(329) [apply] apply:maplist_([b, 'never-happens'], _564102, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] expand_eval(b, _570202)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] b=_570202
   <span class="ansi1 ansi32"
>Exit: </span>(331) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(330) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(330) [apply] apply:maplist_(['never-happens'], _570204, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] expand_eval('never-happens', _576304)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] 'never-happens'=_576304
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(331) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(331) [apply] apply:maplist_([], _576306, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(331) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(330) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(329) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] possible_type('&self', a, _593596)
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [user] possible_type('&self', a, _593596)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] eval_args(=, _593596, 499, '&self', b, _595638)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] setup_call_cleanup('$notrace'(_597696, _597698), once(user:self_eval(b)), '$restore_trace'(_597696, _597698))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] sig_atomic(system:'$notrace'(_597696, _597698))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _595638=b
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [user] eval_args(=, _593596, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(324) [user] eval_20(=, _465838, 499, '&self', [let, a, b, 'never-happens'], _496770)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] ignore((_497884==1->ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _497884==1
   <span class="ansi1 ansi31"
>Fail: </span>(326) [system] _497884==1
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] setup_call_cleanup('$notrace'(_611026, _611028), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)])))))))), '$restore_trace'(_611026, _611028))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] sig_atomic(system:'$notrace'(_611026, _611028))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] ignore(user:(_497884==1->ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(322) [system] call_cleanup(user:((call(eval_20(=, _465838), 499, '&self', [let, a, b, 'never-happens'], _496770)*->nb_setarg(1, retval(fail), _496770);fail, trace, call(eval_20(=, _465838), 499, '&self', [let, a, b, 'never-happens'], _496770)), ignore(notrace((\+_496770\=_498014, nb_setarg(1, retval(fail), _496770))))), user:ignore((_497884==1->ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] trace_eval(eval_20(=, _465838), e, 499, '&self', [let, a, b, 'never-happens'], _496770)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] eval_args(=, _465838, 500, '&self', [let, a, b, 'never-happens'], _297828)
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [system] call(user:once, user:if_or_else(eval(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828), call(eval, [let, a, b, 'never-happens'], _297828)))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] setup_call_cleanup('$notrace'(_622488, _622490), once(rtrace:retract(t_l:tracer_reset(_622478))), '$restore_trace'(_622488, _622490))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(system:'$notrace'(_622488, _622490))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [rtrace] tAt(false, 271, 271, false)
<span class="ansi1 ansi90"
>Info: Processing progress: 100% </span>[4] current_output closed; set to user_output
<span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta progress.
</span><span class="ansi1 ansi90"
>Info: Processing progress: 100% </span>[5] current_output closed; set to user_output
<span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta progress.
</span><span class="ansi1 ansi90"
>Info: Processing progress: 100% </span><span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta progress.
</span><span class="ansi1 ansi90"
>Info: Processing progress: 100% </span><span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta progress.
</span><span class="ansi1 ansi90"
>Info: Processing progress: 100% </span><span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta progress.
</span>; 
; EVAL TEST
; took 14.88 seconds.

{exec 
  (assertEqual 
    (let $x 
      (collapse 
    (get-atoms &m)) 
      (contains $x is-space)) True)}


<span class="ansi31"
>{loonit_failureR 
  {equal_enough_for_test () 
    (True)}}

</span>
Deterministic: ({Error 
  {got ()} 
  {expected 
    (True)}}
)
;;; FIXME? Now, it is moduleC space.
;;;        Should it be `stdlib` atom for a separately imported space
;;; !(let $x (collapse (get-atoms &m)) (car-atom $x))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Without additional means like `(&m.f 2)` notation or `(interpret &m (f 2))`,
;;; we cannot execute functions from the separate space - we can only use `match`.
;;; Although `&m` imports another space with definition of `g`, it is not reduced
;;; because it is not defined in the context of `&self`. This is the expected
;;; behavior, but it shows that this way of importing spaces is not too useful
;;; for importing modules with functions.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>{exec 
  (assertEqual 
    (match &m 
      (= 
    (f 2) $x) $x) 
    (g 3))}


</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.05"
>;; MODULE-SYSTEM.F1-IMPORTS.05</h3>
; 
; EVAL TEST
; took 0.004 secs. (3.75 milliseconds) 

{exec 
  (assertEqual 
    (match &m 
      (= 
    (f 2) $x) $x) 
    (g 3))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    ((g 3)
) 
    ((g 3)
)}}

</span>
Deterministic: ()
;;; Importing the same space into `&self` should break nothing
;;; TODO? If stdlib space would be in `&m`, which should check that it is not
;;; there anymore since in should be removed after importing it to `&self`
<span class="ansi38-013099040"
>{exec 
  (import! &self f1_moduleA)}


</span>P;HTML|
;                                         {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta.answers
;                                            /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta}
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta is 621 bytes (17 lines)
</span>P;HTML|
;                                         {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta.answers
;                                            /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>{exec 
  (import! &self f1_moduleC)}


</span>P;HTML|
;                                         {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers
;                                            /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta}
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta is 292 bytes (9 lines)
</span>P;HTML|
;                                         {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers
;                                            /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g 
  (-> Number))

</span><span class="ansi38-255165000"
> (= 
  (__g) 100)

</span><span class="ansi38-255165000"
> (: g 
  (-> Number Number))

</span><span class="ansi38-255165000"
> (= 
  (g $x) 
  (+ $x 
    (__g)))

</span>
Deterministic: ()
;;; FIXME? stdlib space is not available at importing time -
;;; only tokens / grounded operations work, while symbolic functions
;;; (like `if`) don't work.
;;; FIXME? Exceptions are not caught by `importOp`
<span class="ansi38-013099040"
>{exec 
  (assertEqual 
    (+ 1 2) 3)}


</span>
;<h3 id="MODULE-SYSTEM.F1-MODULEA.06"
>;; MODULE-SYSTEM.F1-MODULEA.06</h3>
; 
; EVAL TEST
; took 0.000231 secs. (230.56 microseconds) 

{exec 
  (assertEqual 
    (+ 1 2) 3)}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (3) 
    (3)}}

</span>
Deterministic: ()
;;; !(assertEqual (if True "S" "F") "S")
<span class="ansi38-255165000"
> (= 
  (dup $x) 
  (if 
    (== $x 0) 
    (+ $x 10) 
    (g $x)))

</span><span class="ansi38-255165000"
> (: f 
  (-> Number Number))

</span><span class="ansi38-255165000"
> (= 
  (f $x) 
  (if 
    (< $x 0) 
    (- 0 $x) 
    (g 
      (+ 1 $x))))

</span>
Last Result(2): ()
;;; Now indirectly imported `g` works and `f` fully works
<span class="ansi38-013099040"
>{exec 
  (assertEqual 
    (g 2) 102)}


</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.07"
>;; MODULE-SYSTEM.F1-IMPORTS.07</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.01 milliseconds) 

{exec 
  (assertEqual 
    (g 2) 102)}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (102) 
    (102)}}

</span>
Deterministic: ()
<span class="ansi38-013099040"
>{exec 
  (assertEqual 
    (f 2) 103)}


</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.08"
>;; MODULE-SYSTEM.F1-IMPORTS.08</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.41 milliseconds) 

{exec 
  (assertEqual 
    (f 2) 103)}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (103) 
    (103)}}

</span>
Deterministic: ()
;;; `&self` contains 4 grounded sub-spaces now:
;;; - stdlib
;;; - corelib
;;; - moduleA itself, which is the same as &m
;;; - moduleC imported by moduleA and removed from A after its import to &self
;;; Check whether atom is &m
<span class="ansi38-255165000"
> (: is-m 
  (-> Atom Bool))

</span><span class="ansi38-255165000"
> (= 
  (is-m $atom) 
  (== $atom &m))

</span>;;; Assert that the &self space contains the same space as &m, which we imported from moduleA
;;; TODO: Comparing spaces like this doesn't work because the source module is the same, but a specialized
;;;   clone of the dependent space without transitive-dependencies was created during the import process.
;;;   Ideally, we can rework importing so that a special space copy isn't created, and then comparing
;;;   spaces will work again.  But, In my opinion comparing spaces is not a good way to check to see if a
;;;   module has been loaded.  I believe a better solution is accessor operations for loaded & imported modules
;;;
;;;!(assertEqual
;;;  (let $a (collapse (get-atoms &self)) (contains $a is-m))
;;;  True)
;;; Check that the &self space contains the corelib child space
;;; Note: corelib doesn't import any modules into itself, so no space copy is needed
<span class="ansi38-013099040"
>{exec 
  (import! &corelib corelib)}


</span>
Deterministic: ()<span class="ansi38-255165000"
> (: is-corelib 
  (-> Atom Bool))

</span><span class="ansi38-255165000"
> (= 
  (is-corelib $atom) 
  (== $atom &corelib))

</span><span class="ansi38-013099040"
>{exec 
  (assertEqual 
    (let $a 
      (collapse 
    (get-atoms &self)) 
      (contains $a is-corelib)) True)}


</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.09"
>;; MODULE-SYSTEM.F1-IMPORTS.09</h3>

{failed 
 once 

  {if_or_else 
    {eval = $10000 495 &self 
      (let a b never-happens) $10001} 
    {call eval 
      (let a b never-happens) $10001}}}


{on_mettalog_error 
  {failed 
  once 

    {if_or_else 
      {eval = $10000 495 &self 
    (let a b never-happens) $10001} 
      {call eval 
    (let a b never-happens) $10001}}}}

^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] call(user:once, user:if_or_else(eval(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788), call(eval, [let, a, b, 'never-happens'], _297788)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] once(user:if_or_else(eval(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788), call(eval, [let, a, b, 'never-happens'], _297788)))
   <span class="ansi1 ansi32"
>Call: </span>(311) [user] if_or_else(eval(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788), call(eval, [let, a, b, 'never-happens'], _297788))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] catch_metta_return(eval_args(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788), _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_args(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_306198, _306200), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_306198, _306200))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_306198, _306200))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_308286, _308288), once(user:nonvar(_297788)), '$restore_trace'(_308286, _308288))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_308286, _308288))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_310374, _310376), once(user:nonvar(_297788)), '$restore_trace'(_310374, _310376))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_310374, _310376))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_317530, _317532), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_317530, _317532))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_317530, _317532))
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_00(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_322674, _322676), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_322674, _322676))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_322674, _322676))
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] eval_01(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] 495<1
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] 495<1
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_330910, _330912), once(user:(_330886 is 495-1, copy_term([let, a, b, 'never-happens'], _330900))), '$restore_trace'(_330910, _330912))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_330910, _330912))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(494 is 495-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] trace_eval(eval_20(=, _296114), e, 494, '&self', [let, a, b, 'never-happens'], _334020)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] must_det_ll((notrace((flag(eval_num, _335074, _335074+1), _335092 is _335074 mod 500, _335110 is 99-494 mod 100, _335134=_335136, option_else('trace-length', _335148, 500), option_else('trace-depth', _335156, 30))), quietly(if_t((nop(stop_rtrace), _335092>_335148), (set_debug(eval, false), _335212 is _335148+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335212])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335264)))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] once(user:(notrace((flag(eval_num, _335074, _335074+1), _335092 is _335074 mod 500, _335110 is 99-494 mod 100, _335134=_335136, option_else('trace-length', _335148, 500), option_else('trace-depth', _335156, 30))), quietly(if_t((nop(stop_rtrace), _335092>_335148), (set_debug(eval, false), _335212 is _335148+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335212])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335264)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] setup_call_cleanup('$notrace'(_337310, _337312), once(user:(flag(eval_num, _335074, _335074+1), _335092 is _335074 mod 500, _335110 is 99-494 mod 100, _335134=_335136, option_else('trace-length', _335148, 500), option_else('trace-depth', _335156, 30))), '$restore_trace'(_337310, _337312))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] sig_atomic(system:'$notrace'(_337310, _337312))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2098, 2098+1), 98 is 2098 mod 500, 5 is 99-494 mod 100, _335134=_335134, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 98>500), (set_debug(eval, false), _335212 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335212])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 98>500), (set_debug(eval, false), _335212 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335212])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(322) [user] nop(notrace(no_repeats_var(_335264)))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [user] nop(notrace(no_repeats_var(_335264)))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] once(user:(notrace((flag(eval_num, 2098, 2098+1), 98 is 2098 mod 500, 5 is 99-494 mod 100, _335134=_335134, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 98>500), (set_debug(eval, false), _335212 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335212])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335264)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] must_det_ll(user:(notrace((flag(eval_num, 2098, 2098+1), 98 is 2098 mod 500, 5 is 99-494 mod 100, _335134=_335134, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 98>500), (set_debug(eval, false), _335212 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335212])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335264)))))
   <span class="ansi1 ansi32"
>Call: </span>(319) [occurs] occurs:sub_term(_346962, e)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [occurs] occurs:sub_term(_346962, e)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _354068=e
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] if_trace((eval;e), (_335134=1, indentq(5, 98, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_357208, _357210), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _335134=1, indentq(5, 98, -->, [e, [let, a, b, 'never-happens']]))), _357166, fbug((_357166-->if_trace((eval;e), (_335134=1, indentq(5, 98, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_357208, _357210))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_357208, _357210))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _335134=1, indentq(5, 98, -->, [e, [let, a, b, 'never-happens']]))), _357166, fbug((_357166-->if_trace((eval;e), (_335134=1, indentq(5, 98, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] if_trace((eval;e), (_335134=1, indentq(5, 98, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _361404=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _363442=(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] (\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] call_cleanup(((call(eval_20(=, _296114), 494, '&self', [let, a, b, 'never-happens'], _334020)*->nb_setarg(1, retval(fail), _334020);fail, trace, call(eval_20(=, _296114), 494, '&self', [let, a, b, 'never-happens'], _334020)), ignore(notrace((\+_334020\=_335264, nb_setarg(1, retval(fail), _334020))))), ignore((_335134==1->ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] eval_20(=, _296114, 494, '&self', [let, a, b, 'never-happens'], _334020)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_370850, _370852), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_370850, _370852))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_370850, _370852))
^  <span class="ansi1 ansi31"
>Fail: </span>(323) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] once(expand_eval([let, a, b, 'never-happens'], _393194))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] expand_eval([let, a, b, 'never-happens'], _393194)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _399294)
   <span class="ansi1 ansi32"
>Call: </span>(325) [apply] apply:maplist_([a, b, 'never-happens'], _399294, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] expand_eval(a, _401350)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] a=_401350
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(326) [apply] apply:maplist_([b, 'never-happens'], _401352, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] expand_eval(b, _407452)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] b=_407452
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(327) [apply] apply:maplist_(['never-happens'], _407454, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] expand_eval('never-happens', _413554)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] 'never-happens'=_413554
   <span class="ansi1 ansi32"
>Exit: </span>(329) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(328) [apply] apply:maplist_([], _413556, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] possible_type('&self', a, _430846)
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] possible_type('&self', a, _430846)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] eval_args(=, _430846, 494, '&self', b, _432888)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_434946, _434948), once(user:self_eval(b)), '$restore_trace'(_434946, _434948))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_434946, _434948))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _432888=b
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] eval_args(=, _430846, 494, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] eval_20(=, _296114, 494, '&self', [let, a, b, 'never-happens'], _334020)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] ignore((_335134==1->ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _335134==1
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] _335134==1
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_448276, _448278), once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)])))))))), '$restore_trace'(_448276, _448278))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_448276, _448278))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] ignore(user:(_335134==1->ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [system] call_cleanup(user:((call(eval_20(=, _296114), 494, '&self', [let, a, b, 'never-happens'], _334020)*->nb_setarg(1, retval(fail), _334020);fail, trace, call(eval_20(=, _296114), 494, '&self', [let, a, b, 'never-happens'], _334020)), ignore(notrace((\+_334020\=_335264, nb_setarg(1, retval(fail), _334020))))), user:ignore((_335134==1->ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] trace_eval(eval_20(=, _296114), e, 494, '&self', [let, a, b, 'never-happens'], _334020)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] eval_args(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] call(eval, [let, a, b, 'never-happens'], _297788)
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval([let, a, b, 'never-happens'], _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] current_self(_457684)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nb_current(self_space, _457684)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(314) [user] eval('&self', [let, a, b, 'never-happens'], _297788)
   <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] catch_metta_return(eval_args(=, _465798, 500, '&self', [let, a, b, 'never-happens'], _297788), _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] eval_args(=, _465798, 500, '&self', [let, a, b, 'never-happens'], _297788)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_468908, _468910), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_468908, _468910))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_468908, _468910))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_470996, _470998), once(user:nonvar(_297788)), '$restore_trace'(_470996, _470998))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_470996, _470998))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_473084, _473086), once(user:nonvar(_297788)), '$restore_trace'(_473084, _473086))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_473084, _473086))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_480240, _480242), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_480240, _480242))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_480240, _480242))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_00(=, _465798, 500, '&self', [let, a, b, 'never-happens'], _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_485384, _485386), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_485384, _485386))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_485384, _485386))
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] eval_01(=, _465798, 500, '&self', [let, a, b, 'never-happens'], _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_493620, _493622), once(user:(_493596 is 500-1, copy_term([let, a, b, 'never-happens'], _493610))), '$restore_trace'(_493620, _493622))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_493620, _493622))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] trace_eval(eval_20(=, _465798), e, 499, '&self', [let, a, b, 'never-happens'], _496730)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] must_det_ll((notrace((flag(eval_num, _497784, _497784+1), _497802 is _497784 mod 500, _497820 is 99-499 mod 100, _497844=_497846, option_else('trace-length', _497858, 500), option_else('trace-depth', _497866, 30))), quietly(if_t((nop(stop_rtrace), _497802>_497858), (set_debug(eval, false), _497922 is _497858+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497922])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_497974)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] once(user:(notrace((flag(eval_num, _497784, _497784+1), _497802 is _497784 mod 500, _497820 is 99-499 mod 100, _497844=_497846, option_else('trace-length', _497858, 500), option_else('trace-depth', _497866, 30))), quietly(if_t((nop(stop_rtrace), _497802>_497858), (set_debug(eval, false), _497922 is _497858+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497922])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_497974)))))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] setup_call_cleanup('$notrace'(_500020, _500022), once(user:(flag(eval_num, _497784, _497784+1), _497802 is _497784 mod 500, _497820 is 99-499 mod 100, _497844=_497846, option_else('trace-length', _497858, 500), option_else('trace-depth', _497866, 30))), '$restore_trace'(_500020, _500022))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] sig_atomic(system:'$notrace'(_500020, _500022))
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2099, 2099+1), 99 is 2099 mod 500, 0 is 99-499 mod 100, _497844=_497844, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 99>500), (set_debug(eval, false), _497922 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497922])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 99>500), (set_debug(eval, false), _497922 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497922])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(325) [user] nop(notrace(no_repeats_var(_497974)))
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] nop(notrace(no_repeats_var(_497974)))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] once(user:(notrace((flag(eval_num, 2099, 2099+1), 99 is 2099 mod 500, 0 is 99-499 mod 100, _497844=_497844, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 99>500), (set_debug(eval, false), _497922 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497922])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_497974)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] must_det_ll(user:(notrace((flag(eval_num, 2099, 2099+1), 99 is 2099 mod 500, 0 is 99-499 mod 100, _497844=_497844, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 99>500), (set_debug(eval, false), _497922 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497922])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_497974)))))
   <span class="ansi1 ansi32"
>Call: </span>(322) [occurs] occurs:sub_term(_509672, e)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(322) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [occurs] occurs:sub_term(_509672, e)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _516778=e
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] if_trace((eval;e), (_497844=1, indentq(0, 99, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_519918, _519920), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _497844=1, indentq(0, 99, -->, [e, [let, a, b, 'never-happens']]))), _519876, fbug((_519876-->if_trace((eval;e), (_497844=1, indentq(0, 99, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_519918, _519920))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_519918, _519920))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _497844=1, indentq(0, 99, -->, [e, [let, a, b, 'never-happens']]))), _519876, fbug((_519876-->if_trace((eval;e), (_497844=1, indentq(0, 99, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] if_trace((eval;e), (_497844=1, indentq(0, 99, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _524114=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _526152=(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] (\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] call_cleanup(((call(eval_20(=, _465798), 499, '&self', [let, a, b, 'never-happens'], _496730)*->nb_setarg(1, retval(fail), _496730);fail, trace, call(eval_20(=, _465798), 499, '&self', [let, a, b, 'never-happens'], _496730)), ignore(notrace((\+_496730\=_497974, nb_setarg(1, retval(fail), _496730))))), ignore((_497844==1->ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] eval_20(=, _465798, 499, '&self', [let, a, b, 'never-happens'], _496730)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] setup_call_cleanup('$notrace'(_533560, _533562), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_533560, _533562))
^  <span class="ansi1 ansi32"
>Call: </span>(329) [system] sig_atomic(system:'$notrace'(_533560, _533562))
^  <span class="ansi1 ansi31"
>Fail: </span>(326) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] once(expand_eval([let, a, b, 'never-happens'], _555904))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] expand_eval([let, a, b, 'never-happens'], _555904)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _562004)
   <span class="ansi1 ansi32"
>Call: </span>(328) [apply] apply:maplist_([a, b, 'never-happens'], _562004, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] expand_eval(a, _564060)
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] a=_564060
   <span class="ansi1 ansi32"
>Exit: </span>(330) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(329) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(329) [apply] apply:maplist_([b, 'never-happens'], _564062, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] expand_eval(b, _570162)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] b=_570162
   <span class="ansi1 ansi32"
>Exit: </span>(331) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(330) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(330) [apply] apply:maplist_(['never-happens'], _570164, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] expand_eval('never-happens', _576264)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] 'never-happens'=_576264
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(331) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(331) [apply] apply:maplist_([], _576266, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(331) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(330) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(329) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] possible_type('&self', a, _593556)
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [user] possible_type('&self', a, _593556)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] eval_args(=, _593556, 499, '&self', b, _595598)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] setup_call_cleanup('$notrace'(_597656, _597658), once(user:self_eval(b)), '$restore_trace'(_597656, _597658))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] sig_atomic(system:'$notrace'(_597656, _597658))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _595598=b
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [user] eval_args(=, _593556, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(324) [user] eval_20(=, _465798, 499, '&self', [let, a, b, 'never-happens'], _496730)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] ignore((_497844==1->ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _497844==1
   <span class="ansi1 ansi31"
>Fail: </span>(326) [system] _497844==1
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] setup_call_cleanup('$notrace'(_610986, _610988), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)])))))))), '$restore_trace'(_610986, _610988))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] sig_atomic(system:'$notrace'(_610986, _610988))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] ignore(user:(_497844==1->ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(322) [system] call_cleanup(user:((call(eval_20(=, _465798), 499, '&self', [let, a, b, 'never-happens'], _496730)*->nb_setarg(1, retval(fail), _496730);fail, trace, call(eval_20(=, _465798), 499, '&self', [let, a, b, 'never-happens'], _496730)), ignore(notrace((\+_496730\=_497974, nb_setarg(1, retval(fail), _496730))))), user:ignore((_497844==1->ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] trace_eval(eval_20(=, _465798), e, 499, '&self', [let, a, b, 'never-happens'], _496730)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] eval_args(=, _465798, 500, '&self', [let, a, b, 'never-happens'], _297788)
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [system] call(user:once, user:if_or_else(eval(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788), call(eval, [let, a, b, 'never-happens'], _297788)))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] setup_call_cleanup('$notrace'(_622448, _622450), once(rtrace:retract(t_l:tracer_reset(_622438))), '$restore_trace'(_622448, _622450))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(system:'$notrace'(_622448, _622450))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [rtrace] tAt(false, 271, 271, false)
; 
; EVAL TEST
; took 6.30 seconds.

{exec 
  (assertEqual 
    (let $a 
      (collapse 
    (get-atoms &self)) 
      (contains $a is-corelib)) True)}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (True) 
    (True)}}

</span>
Deterministic: ()
;;; Let's check that `if` from stdlib is not duplicated and gives only one result
<span class="ansi38-013099040"
>{exec 
  (assertEqual 
    (if 
      (> 1 2) 1 2) 2)}


</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.10"
>;; MODULE-SYSTEM.F1-IMPORTS.10</h3>
; 
; EVAL TEST
; took 0.000249 secs. (248.78 microseconds) 

{exec 
  (assertEqual 
    (if 
      (> 1 2) 1 2) 2)}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (2) 
    (2)}}

</span>
Deterministic: ()
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Let's import one more module into `&self` with a diamond dependence
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>{exec 
  (import! &self f1_moduleB)}


</span>P;HTML|
;                                         {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta.answers
;                                            /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta}
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta is 282 bytes (7 lines)
</span>P;HTML|
;                                         {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta.answers
;                                            /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>{exec 
  (import! &self f1_moduleC)}


</span>P;HTML|
;                                         {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers
;                                            /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta}
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta is 292 bytes (9 lines)
</span>P;HTML|
;                                         {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers
;                                            /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g 
  (-> Number))

</span><span class="ansi38-255165000"
> (= 
  (__g) 100)

</span><span class="ansi38-255165000"
> (: g 
  (-> Number Number))

</span><span class="ansi38-255165000"
> (= 
  (g $x) 
  (+ $x 
    (__g)))

</span>
Deterministic: ()<span class="ansi38-255165000"
> (= 
  (dup $x) 
  (if 
    (== $x 0) 
    (g $x) 
    (+ $x 10)))

</span>
Last Result(2): ()
;;; `g` from moduleC imported via two paths as well as `f`, which uses `g`,
;;; are not duplicated and produce deterministic results
<span class="ansi38-013099040"
>{exec 
  (assertEqual 
    (g 2) 102)}


</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.11"
>;; MODULE-SYSTEM.F1-IMPORTS.11</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.20 milliseconds) 

{exec 
  (assertEqual 
    (g 2) 102)}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (102) 
    (102)}}

</span>
Deterministic: ()
<span class="ansi38-013099040"
>{exec 
  (assertEqual 
    (f 2) 103)}


</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.12"
>;; MODULE-SYSTEM.F1-IMPORTS.12</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.40 milliseconds) 

{exec 
  (assertEqual 
    (f 2) 103)}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (103) 
    (103)}}

</span>
Deterministic: ()
;;; Function declared in different imported modules will still produce
;;; non-deterministic results
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (dup 2) 
    (12 102))}


</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.13"
>;; MODULE-SYSTEM.F1-IMPORTS.13</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.15 milliseconds) 

{exec 
  (assertEqualToResult 
    (dup 2) 
    (12 102))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (102 12) 
    (12 102)}}

</span>
Deterministic: ()
;;; Let's import f1_moduleB once more. Such import should be ignored and
;;; thus f, g and dup should remain unchanged.
<span class="ansi38-013099040"
>{exec 
  (import! &self f1_moduleB)}


</span>P;HTML|
;                                         {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta.answers
;                                            /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta}
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta is 282 bytes (7 lines)
</span>P;HTML|
;                                         {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta.answers
;                                            /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>{exec 
  (import! &self f1_moduleC)}


</span>P;HTML|
;                                         {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers
;                                            /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta}
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta is 292 bytes (9 lines)
</span>P;HTML|
;                                         {load_answer_file /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers
;                                            /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g 
  (-> Number))

</span><span class="ansi38-255165000"
> (= 
  (__g) 100)

</span><span class="ansi38-255165000"
> (: g 
  (-> Number Number))

</span><span class="ansi38-255165000"
> (= 
  (g $x) 
  (+ $x 
    (__g)))

</span>
Deterministic: ()<span class="ansi38-255165000"
> (= 
  (dup $x) 
  (if 
    (== $x 0) 
    (g $x) 
    (+ $x 10)))

</span>
Last Result(2): ()
<span class="ansi38-013099040"
>{exec 
  (assertEqual 
    (g 2) 102)}


</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.14"
>;; MODULE-SYSTEM.F1-IMPORTS.14</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.17 milliseconds) 

{exec 
  (assertEqual 
    (g 2) 102)}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (102) 
    (102)}}

</span>
Deterministic: ()
<span class="ansi38-013099040"
>{exec 
  (assertEqual 
    (f 2) 103)}


</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.15"
>;; MODULE-SYSTEM.F1-IMPORTS.15</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.54 milliseconds) 

{exec 
  (assertEqual 
    (f 2) 103)}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (103) 
    (103)}}

</span>
Deterministic: ()
<span class="ansi38-013099040"
>{exec 
  (assertEqualToResult 
    (dup 2) 
    (12 102))}


</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.16"
>;; MODULE-SYSTEM.F1-IMPORTS.16</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.44 milliseconds) 

{exec 
  (assertEqualToResult 
    (dup 2) 
    (12 102))}


<span class="ansi36"
>{loonit_success 
  {equal_enough_for_test 
    (102 12) 
    (12 102)}}

</span>
Deterministic: ()<span class="ansi32"
>
% 79,415,559 inferences, 22.649 CPU in 22.674 seconds (100% CPU, 3506429 Lips)
</span>P;HTML|
;                       { = /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta
;                          0 }
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 14
</span><span class="ansi31"
>Failures: 2
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
P;HTML|
;         {is_cmd_option execute halt --halt=true true}
P;HTML|
;          {set_option_value halt true}
P;HTML|
;          {is_cmd_option execute stdin --stdin=tty tty}
P;HTML|
;          {set_option_value stdin tty}
P;HTML|
;          {is_cmd_option execute stdout --stdout=tty tty}
P;HTML|
;           {set_option_value stdout tty}
P;HTML|
;          {is_cmd_option execute stderr --stderr=tty tty}
P;HTML|
;           {set_option_value stderr tty}
P;HTML|
;         {set_option_value compat false}
P;HTML|
;         {set_option_value compatio false}
P;HTML|
;         {set_option_value src_indents false}
P;HTML|
;         {set_option_value devel false}
P;HTML|
;         {set_option_value stack-max 500}
P;HTML|
;         {set_option_value limit inf}
P;HTML|
;         {set_option_value initial-result-count 10}
P;HTML|
;         {set_option_value answer-format show}
P;HTML|
;         {set_option_value repeats true}
P;HTML|
;         {set_option_value time true}
P;HTML|
;         {set_option_value synth-unit-tests false}
P;HTML|
;         {set_option_value optimize true}
P;HTML|
;         {set_option_value transpiler silent}
P;HTML|
;          {set_debug transpiler false}
P;HTML|
;         {set_option_value compile false}
P;HTML|
;         {set_option_value tabling auto}
P;HTML|
;         {set_option_value log false}
P;HTML|
;         {set_option_value output ./}
P;HTML|
;         {set_option_value exeout ./Sav.gitlab.MeTTaLog}
P;HTML|
;         {set_option_value halt false}
P;HTML|
;         {set_option_value trace-length 500}
P;HTML|
;         {set_option_value trace-on-overtime 4.0}
P;HTML|
;          {set_debug overtime 4.0}
P;HTML|
;         {set_option_value trace-on-overflow 1000}
P;HTML|
;          {set_debug overflow 1000}
P;HTML|
;         {set_option_value trace-on-eval false}
P;HTML|
;          {set_debug eval false}
P;HTML|
;         {set_option_value trace-on-load silent}
P;HTML|
;          {set_debug load silent}
P;HTML|
;          {set_debug trace-on-load false}
P;HTML|
;         {set_option_value trace-on-exec false}
P;HTML|
;          {set_debug exec false}
P;HTML|
;         {set_option_value trace-on-error non-type}
P;HTML|
;          {set_debug error non-type}
P;HTML|
;         {set_option_value trace-on-fail false}
P;HTML|
;          {set_debug fail false}
P;HTML|
;         {set_option_value trace-on-test true}
P;HTML|
;          {set_debug test true}
P;HTML|
;         {set_option_value repl-on-error true}
P;HTML|
;         {set_option_value repl-on-fail false}
P;HTML|
;         {set_option_value exit-on-fail false}
P;HTML|
;         {set_option_value repl auto}
P;HTML|
;         {set_option_value prolog false}
P;HTML|
;         {set_option_value exec noskip}
P;HTML|
;         {set_option_value maximum-result-count inf}
P;HTML|
;         {set_option_value html false}
P;HTML|
;         {set_option_value python true}
P;HTML|
;         {set_option_value trace-on-test false}
P;HTML|
;          {set_debug test false}
P;HTML|
;         {set_option_value trace-on-fail false}
P;HTML|
;          {set_debug fail false}
P;HTML|
;         {set_option_value load show}
P;HTML|
;         {set_option_value test true}
[({Error 
  {got 
    ((hyperon::space::DynSpace)
 
      (hyperon::space::DynSpace) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (()) 
      (DocInformal) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (%Undefined%) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (DocInformal) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()) 
      (()))} 
  {expected 
    ((hyperon::space::DynSpace)
 
      (hyperon::space::DynSpace))}}
)
]
[()]
[()]
[({Error 
  {got ()} 
  {expected 
    (True)}}
)
]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
P;HTML|
;         {maybe_halt 7}
<span class="ansi31"
>{in 
  {maybe_halt 7} 
  {unwind 
    {halt 7}}}

</span>
Script done on 2024-11-27 09:23:37+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat/' --timeout=40 --html --repl=false  --test "tests/baseline_compat/module-system/f1_imports.metta" --halt=true\033[0m
