<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi36 { color: #00aaaa; }
.ansi90 { color: #7f7f7f; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-11-26 19:51:03+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
^@P;HTML|
;           (set_option_value  compat false)

P;HTML|
;           (set_option_value  compatio false)

P;HTML|
;           (set_option_value  src_indents false)

P;HTML|
;         (set_option_value  devel false)

P;HTML|
;         (set_option_value  stack-max 500)

P;HTML|
;         (set_option_value  limit inf)

P;HTML|
;         (set_option_value  initial-result-count 10)

P;HTML|
;         (set_option_value  answer-format show)

P;HTML|
;         (set_option_value  repeats true)

P;HTML|
;         (set_option_value  time true)

P;HTML|
;         (set_option_value  synth-unit-tests false)

P;HTML|
;         (set_option_value  optimize true)

P;HTML|
;         (set_option_value  transpiler silent)

P;HTML|
;          (set_debug  transpiler false)

P;HTML|
;         (set_option_value  compile false)

P;HTML|
;         (set_option_value  tabling auto)

P;HTML|
;         (set_option_value  log false)

P;HTML|
;         (set_option_value  output ./)

P;HTML|
;         (set_option_value  exeout ./Sav.gitlab.MeTTaLog)

P;HTML|
;         (set_option_value  halt false)

P;HTML|
;         (set_option_value  trace-length 500)

P;HTML|
;         (set_option_value  trace-on-overtime 4.0)

P;HTML|
;          (set_debug  overtime 4.0)

P;HTML|
;         (set_option_value  trace-on-overflow 1000)

P;HTML|
;          (set_debug  overflow 1000)

P;HTML|
;         (set_option_value  trace-on-eval false)

P;HTML|
;          (set_debug  eval false)

P;HTML|
;         (set_option_value  trace-on-load silent)

P;HTML|
;          (set_debug  load silent)

P;HTML|
;          (set_debug  trace-on-load false)

P;HTML|
;         (set_option_value  trace-on-exec false)

P;HTML|
;          (set_debug  exec false)

P;HTML|
;         (set_option_value  trace-on-error non-type)

P;HTML|
;          (set_debug  error non-type)

P;HTML|
;         (set_option_value  trace-on-fail false)

P;HTML|
;          (set_debug  fail false)

P;HTML|
;         (set_option_value  trace-on-test true)

P;HTML|
;          (set_debug  test true)

P;HTML|
;         (set_option_value  repl-on-error true)

P;HTML|
;         (set_option_value  repl-on-fail false)

P;HTML|
;         (set_option_value  exit-on-fail false)

P;HTML|
;         (set_option_value  repl auto)

P;HTML|
;         (set_option_value  prolog false)

P;HTML|
;         (set_option_value  exec noskip)

P;HTML|
;         (set_option_value  maximum-result-count inf)

P;HTML|
;         (set_option_value  html false)

P;HTML|
;         (set_option_value  python true)

P;HTML|
;         (set_option_value  trace-on-test false)

P;HTML|
;         (set_debug  test false)

P;HTML|
;         (set_option_value  trace-on-fail false)

P;HTML|
;         (set_debug  fail false)

P;HTML|
;         (set_option_value  load show)

P;HTML|
;         (set_option_value  test false)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta is 86.6K bytes (2.29K lines)
</span><span class="ansi1 ansi90"
>Info: File /home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta is 34 bytes (1 lines)
</span><span class="ansi32"
>% 45,046 inferences, 0.173 CPU in 0.173 seconds (100% CPU, 260790 Lips)
</span>P;HTML|
;          (is_cmd_option  prescan halt --halt=true true)
P;HTML|
;          (set_option_value  halt true)
P;HTML|
;          (is_cmd_option  prescan stdin --stdin=tty tty)
P;HTML|
;           (set_option_value  stdin tty)
P;HTML|
;          (is_cmd_option  prescan stdout --stdout=tty tty)
P;HTML|
;           (set_option_value  stdout tty)
P;HTML|
;          (is_cmd_option  prescan stderr --stderr=tty tty)
P;HTML|
;           (set_option_value  stderr tty)
P;HTML|
;          (set_option_value  compat false)
P;HTML|
;          (set_option_value  compatio false)
P;HTML|
;          (set_option_value  src_indents false)
P;HTML|
;          (set_option_value  devel false)
P;HTML|
;          (set_option_value  stack-max 500)
P;HTML|
;          (set_option_value  limit inf)
P;HTML|
;          (set_option_value  initial-result-count 10)
P;HTML|
;          (set_option_value  answer-format show)
P;HTML|
;          (set_option_value  repeats true)
P;HTML|
;          (set_option_value  time true)
P;HTML|
;          (set_option_value  synth-unit-tests false)
P;HTML|
;          (set_option_value  optimize true)
P;HTML|
;          (set_option_value  transpiler silent)
P;HTML|
;          (set_debug  transpiler false)
P;HTML|
;          (set_option_value  compile false)
P;HTML|
;          (set_option_value  tabling auto)
P;HTML|
;          (set_option_value  log false)
P;HTML|
;          (set_option_value  output ./)
P;HTML|
;          (set_option_value  exeout ./Sav.gitlab.MeTTaLog)
P;HTML|
;          (set_option_value  halt false)
P;HTML|
;          (set_option_value  trace-length 500)
P;HTML|
;          (set_option_value  trace-on-overtime 4.0)
P;HTML|
;          (set_debug  overtime 4.0)
P;HTML|
;          (set_option_value  trace-on-overflow 1000)
P;HTML|
;          (set_debug  overflow 1000)
P;HTML|
;          (set_option_value  trace-on-eval false)
P;HTML|
;          (set_debug  eval false)
P;HTML|
;          (set_option_value  trace-on-load silent)
P;HTML|
;          (set_debug  load silent)
P;HTML|
;          (set_debug  trace-on-load false)
P;HTML|
;          (set_option_value  trace-on-exec false)
P;HTML|
;          (set_debug  exec false)
P;HTML|
;          (set_option_value  trace-on-error non-type)
P;HTML|
;          (set_debug  error non-type)
P;HTML|
;          (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;          (set_option_value  trace-on-test true)
P;HTML|
;          (set_debug  test true)
P;HTML|
;          (set_option_value  repl-on-error true)
P;HTML|
;          (set_option_value  repl-on-fail false)
P;HTML|
;          (set_option_value  exit-on-fail false)
P;HTML|
;          (set_option_value  repl auto)
P;HTML|
;          (set_option_value  prolog false)
P;HTML|
;          (set_option_value  exec noskip)
P;HTML|
;          (set_option_value  maximum-result-count inf)
P;HTML|
;          (set_option_value  html false)
P;HTML|
;          (set_option_value  python true)
P;HTML|
;         (set_option_value  trace-on-test false)
P;HTML|
;          (set_debug  test false)
P;HTML|
;         (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;         (set_option_value  load show)
P;HTML|
;         (set_option_value  test true)
P;HTML|
;        (is_cmd_option  execute python --python=enable enable)
P;HTML|
;         (set_option_value  python enable)
P;HTML|
;        (is_cmd_option  execute timeout --timeout=40 40)
P;HTML|
;         (set_option_value  timeout 40)
P;HTML|
;         (is_cmd_option  execute output --output=./reports/tests_output/baseline-compat/ ./reports/tests_output/baseline-compat/)
P;HTML|
;         (set_option_value  output ./reports/tests_output/baseline-compat/)
P;HTML|
;         (is_cmd_option  execute html --html true)
P;HTML|
;          (set_option_value  html true)
P;HTML|
;         (is_cmd_option  execute test --test true)
P;HTML|
;          (set_option_value  test true)

; (load_metta_file  &self tests/baseline_compat/module-system/f1_imports.metta)
P;HTML|
;                       (track_load_into_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta)
P;HTML|
;                                        (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta)
P;HTML|
;                                         (= 1  "[()]")
P;HTML|
;                                         (= 2  "[()]")
P;HTML|
;                                         (= 3  "[()]")
P;HTML|
;                                         (= 4  "[()]")
P;HTML|
;                                         (= 5  "[()]")
P;HTML|
;                                         (= 6  "[()]")
P;HTML|
;                                         (= 7  "[()]")
P;HTML|
;                                         (= 8  "[()]")
P;HTML|
;                                         (= 9  "[()]")
P;HTML|
;                                         (= 10  "[()]")
P;HTML|
;                                         (= 11  "[()]")
P;HTML|
;                                         (= 12  "[()]")
P;HTML|
;                                         (= 13  "[()]")
P;HTML|
;                                         (= 14  "[()]")
P;HTML|
;                                         (= 15  "[()]")
P;HTML|
;                                         (= 16  "[()]")
P;HTML|
;                                         (= 17  "[()]")
P;HTML|
;                                         (= 18  "[()]")
P;HTML|
;                                         (= 19  "[()]")
P;HTML|
;                                         (= 20  "0.19user 0.00system 0:00.20elapsed 100%CPU (0avgtext+0avgdata 35952maxresident)k")
P;HTML|
;                                         (= 20  "0inputs+0outputs (0major+4794minor)pagefaults 0swaps")
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta is 5.11K bytes (128 lines)
</span>P;HTML|
;                                        (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta)

;;; NOTE: This test won't work outside the test environment because it relies on
;;;  specific atoms in a specific order in the space, and loading the default environment's
;;;  init.metta will break the assumptions in this test
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Even at the very beginning of the script `(get-atoms &self)`
;;; returns two atoms.  One is from the imported stdlib, and the other
;;; is corelib, which was a dependency of stdlib that has been promoted
;;; These atoms are both wrapped spaces, as is `&self`
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(assertEqual ((let $x (get-atoms &self) (get-type $x))) (superpose (((get-type &self)) ((get-type &self)))))

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.01"
>;; MODULE-SYSTEM.F1-IMPORTS.01</h3>

(failed  once (if_or_else  (eval  = $_569436 495 &self (let a b never-happens) $_571110) (call  eval (let a b never-happens) $_571110)))


(on_mettalog_error  (failed  once (if_or_else  (eval  = $_569436 495 &self (let a b never-happens) $_571110) (call  eval (let a b never-happens) $_571110))))

^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] call(user:once, user:if_or_else(eval(=, _569436, 495, '&self', [let, a, b, 'never-happens'], _571110), call(eval, [let, a, b, 'never-happens'], _571110)))
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] once(user:if_or_else(eval(=, _569436, 495, '&self', [let, a, b, 'never-happens'], _571110), call(eval, [let, a, b, 'never-happens'], _571110)))
   <span class="ansi1 ansi32"
>Call: </span>(299) [user] if_or_else(eval(=, _569436, 495, '&self', [let, a, b, 'never-happens'], _571110), call(eval, [let, a, b, 'never-happens'], _571110))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] eval(=, _569436, 495, '&self', [let, a, b, 'never-happens'], _571110)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] catch_metta_return(eval_args(=, _569436, 495, '&self', [let, a, b, 'never-happens'], _571110), _571110)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_args(=, _569436, 495, '&self', [let, a, b, 'never-happens'], _571110)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_579520, _579522), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_579520, _579522))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_579520, _579522))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_581608, _581610), once(user:nonvar(_571110)), '$restore_trace'(_581608, _581610))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_581608, _581610))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_583696, _583698), once(user:nonvar(_571110)), '$restore_trace'(_583696, _583698))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_583696, _583698))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] setup_call_cleanup('$notrace'(_590852, _590854), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_590852, _590854))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] sig_atomic(system:'$notrace'(_590852, _590854))
^  <span class="ansi1 ansi31"
>Fail: </span>(304) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] eval_00(=, _569436, 495, '&self', [let, a, b, 'never-happens'], _571110)
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] setup_call_cleanup('$notrace'(_595996, _595998), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_595996, _595998))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] sig_atomic(system:'$notrace'(_595996, _595998))
^  <span class="ansi1 ansi31"
>Fail: </span>(305) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] eval_01(=, _569436, 495, '&self', [let, a, b, 'never-happens'], _571110)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] 495<1
   <span class="ansi1 ansi31"
>Fail: </span>(308) [system] 495<1
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] setup_call_cleanup('$notrace'(_604232, _604234), once(user:(_604208 is 495-1, copy_term([let, a, b, 'never-happens'], _604222))), '$restore_trace'(_604232, _604234))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] sig_atomic(system:'$notrace'(_604232, _604234))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(494 is 495-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] trace_eval(eval_20(=, _569436), e, 494, '&self', [let, a, b, 'never-happens'], _607342)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] must_det_ll((notrace((flag(eval_num, _608396, _608396+1), _608414 is _608396 mod 500, _608432 is 99-494 mod 100, _608456=_608458, option_else('trace-length', _608470, 500), option_else('trace-depth', _608478, 30))), quietly(if_t((nop(stop_rtrace), _608414>_608470), (set_debug(eval, false), _608534 is _608470+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608534])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_608586)))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] once(user:(notrace((flag(eval_num, _608396, _608396+1), _608414 is _608396 mod 500, _608432 is 99-494 mod 100, _608456=_608458, option_else('trace-length', _608470, 500), option_else('trace-depth', _608478, 30))), quietly(if_t((nop(stop_rtrace), _608414>_608470), (set_debug(eval, false), _608534 is _608470+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608534])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_608586)))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] setup_call_cleanup('$notrace'(_610632, _610634), once(user:(flag(eval_num, _608396, _608396+1), _608414 is _608396 mod 500, _608432 is 99-494 mod 100, _608456=_608458, option_else('trace-length', _608470, 500), option_else('trace-depth', _608478, 30))), '$restore_trace'(_610632, _610634))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] sig_atomic(system:'$notrace'(_610632, _610634))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2903, 2903+1), 403 is 2903 mod 500, 5 is 99-494 mod 100, _608456=_608456, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 403>500), (set_debug(eval, false), _608534 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608534])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 403>500), (set_debug(eval, false), _608534 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608534])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] nop(notrace(no_repeats_var(_608586)))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] nop(notrace(no_repeats_var(_608586)))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] once(user:(notrace((flag(eval_num, 2903, 2903+1), 403 is 2903 mod 500, 5 is 99-494 mod 100, _608456=_608456, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 403>500), (set_debug(eval, false), _608534 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608534])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_608586)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] must_det_ll(user:(notrace((flag(eval_num, 2903, 2903+1), 403 is 2903 mod 500, 5 is 99-494 mod 100, _608456=_608456, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 403>500), (set_debug(eval, false), _608534 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608534])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_608586)))))
   <span class="ansi1 ansi32"
>Call: </span>(307) [occurs] occurs:sub_term(_620284, e)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(307) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(308) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(307) [occurs] occurs:sub_term(_620284, e)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _627390=e
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] if_trace((eval;e), (_608456=1, indentq(5, 403, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_630530, _630532), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _608456=1, indentq(5, 403, -->, [e, [let, a, b, 'never-happens']]))), _630488, fbug((_630488-->if_trace((eval;e), (_608456=1, indentq(5, 403, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_630530, _630532))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_630530, _630532))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _608456=1, indentq(5, 403, -->, [e, [let, a, b, 'never-happens']]))), _630488, fbug((_630488-->if_trace((eval;e), (_608456=1, indentq(5, 403, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] if_trace((eval;e), (_608456=1, indentq(5, 403, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _634726=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _636764=(\+ \+ (flag(eval_num, _636784, _636784+1), (retval(fail)\=@=retval(fail), nonvar(_607342)->indentq(5, _636784, <--, [e, _607342]);indentq(5, _636784, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] (\+ \+ (flag(eval_num, _636784, _636784+1), (retval(fail)\=@=retval(fail), nonvar(_607342)->indentq(5, _636784, <--, [e, _607342]);indentq(5, _636784, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _636784, _636784+1), (retval(fail)\=@=retval(fail), nonvar(_607342)->indentq(5, _636784, <--, [e, _607342]);indentq(5, _636784, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] call_cleanup(((call(eval_20(=, _569436), 494, '&self', [let, a, b, 'never-happens'], _607342)*->nb_setarg(1, retval(fail), _607342);fail, trace, call(eval_20(=, _569436), 494, '&self', [let, a, b, 'never-happens'], _607342)), ignore(notrace((\+_607342\=_608586, nb_setarg(1, retval(fail), _607342))))), ignore((_608456==1->ignore(\+ \+ (flag(eval_num, _636784, _636784+1), (retval(fail)\=@=retval(fail), nonvar(_607342)->indentq(5, _636784, <--, [e, _607342]);indentq(5, _636784, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636784, _636784+1), (retval(fail)\=@=retval(fail), nonvar(_607342)->indentq(5, _636784, <--, [e, _607342]);indentq(5, _636784, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_20(=, _569436, 494, '&self', [let, a, b, 'never-happens'], _607342)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] setup_call_cleanup('$notrace'(_644172, _644174), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_644172, _644174))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(system:'$notrace'(_644172, _644174))
^  <span class="ansi1 ansi31"
>Fail: </span>(311) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(311) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] once(expand_eval([let, a, b, 'never-happens'], _666516))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] expand_eval([let, a, b, 'never-happens'], _666516)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _672616)
   <span class="ansi1 ansi32"
>Call: </span>(313) [apply] apply:maplist_([a, b, 'never-happens'], _672616, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] expand_eval(a, _674672)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] a=_674672
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(314) [apply] apply:maplist_([b, 'never-happens'], _674674, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] expand_eval(b, _680774)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] b=_680774
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(315) [apply] apply:maplist_(['never-happens'], _680776, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] expand_eval('never-happens', _686876)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] 'never-happens'=_686876
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(316) [apply] apply:maplist_([], _686878, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(314) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] possible_type('&self', a, _704168)
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] possible_type('&self', a, _704168)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] eval_args(=, _704168, 494, '&self', b, _706210)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_708268, _708270), once(user:self_eval(b)), '$restore_trace'(_708268, _708270))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_708268, _708270))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] _706210=b
   <span class="ansi1 ansi32"
>Exit: </span>(311) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] eval_args(=, _704168, 494, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] eval_20(=, _569436, 494, '&self', [let, a, b, 'never-happens'], _607342)
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(309) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] ignore((_608456==1->ignore(\+ \+ (flag(eval_num, _636784, _636784+1), (retval(fail)\=@=retval(fail), nonvar(_607342)->indentq(5, _636784, <--, [e, _607342]);indentq(5, _636784, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636784, _636784+1), (retval(fail)\=@=retval(fail), nonvar(_607342)->indentq(5, _636784, <--, [e, _607342]);indentq(5, _636784, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] _608456==1
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] _608456==1
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_721598, _721600), once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636784, _636784+1), (retval(fail)\=@=retval(fail), nonvar(_607342)->indentq(5, _636784, <--, [e, _607342]);indentq(5, _636784, <--, [e, retval(fail)])))))))), '$restore_trace'(_721598, _721600))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_721598, _721600))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636784, _636784+1), (retval(fail)\=@=retval(fail), nonvar(_607342)->indentq(5, _636784, <--, [e, _607342]);indentq(5, _636784, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] ignore(user:(_608456==1->ignore(\+ \+ (flag(eval_num, _636784, _636784+1), (retval(fail)\=@=retval(fail), nonvar(_607342)->indentq(5, _636784, <--, [e, _607342]);indentq(5, _636784, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636784, _636784+1), (retval(fail)\=@=retval(fail), nonvar(_607342)->indentq(5, _636784, <--, [e, _607342]);indentq(5, _636784, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(307) [system] call_cleanup(user:((call(eval_20(=, _569436), 494, '&self', [let, a, b, 'never-happens'], _607342)*->nb_setarg(1, retval(fail), _607342);fail, trace, call(eval_20(=, _569436), 494, '&self', [let, a, b, 'never-happens'], _607342)), ignore(notrace((\+_607342\=_608586, nb_setarg(1, retval(fail), _607342))))), user:ignore((_608456==1->ignore(\+ \+ (flag(eval_num, _636784, _636784+1), (retval(fail)\=@=retval(fail), nonvar(_607342)->indentq(5, _636784, <--, [e, _607342]);indentq(5, _636784, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636784, _636784+1), (retval(fail)\=@=retval(fail), nonvar(_607342)->indentq(5, _636784, <--, [e, _607342]);indentq(5, _636784, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(306) [user] trace_eval(eval_20(=, _569436), e, 494, '&self', [let, a, b, 'never-happens'], _607342)
^  <span class="ansi1 ansi31"
>Fail: </span>(303) [user] eval_args(=, _569436, 495, '&self', [let, a, b, 'never-happens'], _571110)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] call(eval, [let, a, b, 'never-happens'], _571110)
   <span class="ansi1 ansi32"
>Call: </span>(301) [user] eval([let, a, b, 'never-happens'], _571110)
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] current_self(_731006)
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] nb_current(self_space, _731006)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(302) [user] eval('&self', [let, a, b, 'never-happens'], _571110)
   <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _571110)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] catch_metta_return(eval_args(=, _739120, 500, '&self', [let, a, b, 'never-happens'], _571110), _571110)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_args(=, _739120, 500, '&self', [let, a, b, 'never-happens'], _571110)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_742230, _742232), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_742230, _742232))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_742230, _742232))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_744318, _744320), once(user:nonvar(_571110)), '$restore_trace'(_744318, _744320))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_744318, _744320))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_746406, _746408), once(user:nonvar(_571110)), '$restore_trace'(_746406, _746408))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_746406, _746408))
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_753562, _753564), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_753562, _753564))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_753562, _753564))
^  <span class="ansi1 ansi31"
>Fail: </span>(307) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] eval_00(=, _739120, 500, '&self', [let, a, b, 'never-happens'], _571110)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_758706, _758708), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_758706, _758708))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_758706, _758708))
^  <span class="ansi1 ansi31"
>Fail: </span>(308) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] eval_01(=, _739120, 500, '&self', [let, a, b, 'never-happens'], _571110)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_766942, _766944), once(user:(_766918 is 500-1, copy_term([let, a, b, 'never-happens'], _766932))), '$restore_trace'(_766942, _766944))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_766942, _766944))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] trace_eval(eval_20(=, _739120), e, 499, '&self', [let, a, b, 'never-happens'], _770052)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] must_det_ll((notrace((flag(eval_num, _771106, _771106+1), _771124 is _771106 mod 500, _771142 is 99-499 mod 100, _771166=_771168, option_else('trace-length', _771180, 500), option_else('trace-depth', _771188, 30))), quietly(if_t((nop(stop_rtrace), _771124>_771180), (set_debug(eval, false), _771244 is _771180+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771244])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_771296)))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] once(user:(notrace((flag(eval_num, _771106, _771106+1), _771124 is _771106 mod 500, _771142 is 99-499 mod 100, _771166=_771168, option_else('trace-length', _771180, 500), option_else('trace-depth', _771188, 30))), quietly(if_t((nop(stop_rtrace), _771124>_771180), (set_debug(eval, false), _771244 is _771180+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771244])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_771296)))))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] setup_call_cleanup('$notrace'(_773342, _773344), once(user:(flag(eval_num, _771106, _771106+1), _771124 is _771106 mod 500, _771142 is 99-499 mod 100, _771166=_771168, option_else('trace-length', _771180, 500), option_else('trace-depth', _771188, 30))), '$restore_trace'(_773342, _773344))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] sig_atomic(system:'$notrace'(_773342, _773344))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2904, 2904+1), 404 is 2904 mod 500, 0 is 99-499 mod 100, _771166=_771166, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 404>500), (set_debug(eval, false), _771244 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771244])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 404>500), (set_debug(eval, false), _771244 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771244])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] nop(notrace(no_repeats_var(_771296)))
   <span class="ansi1 ansi32"
>Exit: </span>(313) [user] nop(notrace(no_repeats_var(_771296)))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] once(user:(notrace((flag(eval_num, 2904, 2904+1), 404 is 2904 mod 500, 0 is 99-499 mod 100, _771166=_771166, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 404>500), (set_debug(eval, false), _771244 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771244])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_771296)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] must_det_ll(user:(notrace((flag(eval_num, 2904, 2904+1), 404 is 2904 mod 500, 0 is 99-499 mod 100, _771166=_771166, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 404>500), (set_debug(eval, false), _771244 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771244])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_771296)))))
   <span class="ansi1 ansi32"
>Call: </span>(310) [occurs] occurs:sub_term(_782994, e)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(310) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(310) [occurs] occurs:sub_term(_782994, e)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _790100=e
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] if_trace((eval;e), (_771166=1, indentq(0, 404, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_793240, _793242), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _771166=1, indentq(0, 404, -->, [e, [let, a, b, 'never-happens']]))), _793198, fbug((_793198-->if_trace((eval;e), (_771166=1, indentq(0, 404, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_793240, _793242))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_793240, _793242))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _771166=1, indentq(0, 404, -->, [e, [let, a, b, 'never-happens']]))), _793198, fbug((_793198-->if_trace((eval;e), (_771166=1, indentq(0, 404, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_trace((eval;e), (_771166=1, indentq(0, 404, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _797436=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _799474=(\+ \+ (flag(eval_num, _799494, _799494+1), (retval(fail)\=@=retval(fail), nonvar(_770052)->indentq(0, _799494, <--, [e, _770052]);indentq(0, _799494, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] (\+ \+ (flag(eval_num, _799494, _799494+1), (retval(fail)\=@=retval(fail), nonvar(_770052)->indentq(0, _799494, <--, [e, _770052]);indentq(0, _799494, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _799494, _799494+1), (retval(fail)\=@=retval(fail), nonvar(_770052)->indentq(0, _799494, <--, [e, _770052]);indentq(0, _799494, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] call_cleanup(((call(eval_20(=, _739120), 499, '&self', [let, a, b, 'never-happens'], _770052)*->nb_setarg(1, retval(fail), _770052);fail, trace, call(eval_20(=, _739120), 499, '&self', [let, a, b, 'never-happens'], _770052)), ignore(notrace((\+_770052\=_771296, nb_setarg(1, retval(fail), _770052))))), ignore((_771166==1->ignore(\+ \+ (flag(eval_num, _799494, _799494+1), (retval(fail)\=@=retval(fail), nonvar(_770052)->indentq(0, _799494, <--, [e, _770052]);indentq(0, _799494, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799494, _799494+1), (retval(fail)\=@=retval(fail), nonvar(_770052)->indentq(0, _799494, <--, [e, _770052]);indentq(0, _799494, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval_20(=, _739120, 499, '&self', [let, a, b, 'never-happens'], _770052)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] setup_call_cleanup('$notrace'(_806882, _806884), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_806882, _806884))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] sig_atomic(system:'$notrace'(_806882, _806884))
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] once(expand_eval([let, a, b, 'never-happens'], _829226))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] expand_eval([let, a, b, 'never-happens'], _829226)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _835326)
   <span class="ansi1 ansi32"
>Call: </span>(316) [apply] apply:maplist_([a, b, 'never-happens'], _835326, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] expand_eval(a, _837382)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] a=_837382
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(317) [apply] apply:maplist_([b, 'never-happens'], _837384, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] expand_eval(b, _843484)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] b=_843484
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(318) [apply] apply:maplist_(['never-happens'], _843486, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] expand_eval('never-happens', _849586)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] 'never-happens'=_849586
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(319) [apply] apply:maplist_([], _849588, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(317) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] possible_type('&self', a, _866878)
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] possible_type('&self', a, _866878)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval_args(=, _866878, 499, '&self', b, _868920)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_870978, _870980), once(user:self_eval(b)), '$restore_trace'(_870978, _870980))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_870978, _870980))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] _868920=b
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] eval_args(=, _866878, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(312) [user] eval_20(=, _739120, 499, '&self', [let, a, b, 'never-happens'], _770052)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(312) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] ignore((_771166==1->ignore(\+ \+ (flag(eval_num, _799494, _799494+1), (retval(fail)\=@=retval(fail), nonvar(_770052)->indentq(0, _799494, <--, [e, _770052]);indentq(0, _799494, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799494, _799494+1), (retval(fail)\=@=retval(fail), nonvar(_770052)->indentq(0, _799494, <--, [e, _770052]);indentq(0, _799494, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] _771166==1
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] _771166==1
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_884308, _884310), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799494, _799494+1), (retval(fail)\=@=retval(fail), nonvar(_770052)->indentq(0, _799494, <--, [e, _770052]);indentq(0, _799494, <--, [e, retval(fail)])))))))), '$restore_trace'(_884308, _884310))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_884308, _884310))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799494, _799494+1), (retval(fail)\=@=retval(fail), nonvar(_770052)->indentq(0, _799494, <--, [e, _770052]);indentq(0, _799494, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] ignore(user:(_771166==1->ignore(\+ \+ (flag(eval_num, _799494, _799494+1), (retval(fail)\=@=retval(fail), nonvar(_770052)->indentq(0, _799494, <--, [e, _770052]);indentq(0, _799494, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799494, _799494+1), (retval(fail)\=@=retval(fail), nonvar(_770052)->indentq(0, _799494, <--, [e, _770052]);indentq(0, _799494, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(310) [system] call_cleanup(user:((call(eval_20(=, _739120), 499, '&self', [let, a, b, 'never-happens'], _770052)*->nb_setarg(1, retval(fail), _770052);fail, trace, call(eval_20(=, _739120), 499, '&self', [let, a, b, 'never-happens'], _770052)), ignore(notrace((\+_770052\=_771296, nb_setarg(1, retval(fail), _770052))))), user:ignore((_771166==1->ignore(\+ \+ (flag(eval_num, _799494, _799494+1), (retval(fail)\=@=retval(fail), nonvar(_770052)->indentq(0, _799494, <--, [e, _770052]);indentq(0, _799494, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799494, _799494+1), (retval(fail)\=@=retval(fail), nonvar(_770052)->indentq(0, _799494, <--, [e, _770052]);indentq(0, _799494, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] trace_eval(eval_20(=, _739120), e, 499, '&self', [let, a, b, 'never-happens'], _770052)
^  <span class="ansi1 ansi31"
>Fail: </span>(306) [user] eval_args(=, _739120, 500, '&self', [let, a, b, 'never-happens'], _571110)
^  <span class="ansi1 ansi31"
>Fail: </span>(297) [system] call(user:once, user:if_or_else(eval(=, _569436, 495, '&self', [let, a, b, 'never-happens'], _571110), call(eval, [let, a, b, 'never-happens'], _571110)))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(299) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] setup_call_cleanup('$notrace'(_895770, _895772), once(rtrace:retract(t_l:tracer_reset(_895760))), '$restore_trace'(_895770, _895772))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] sig_atomic(system:'$notrace'(_895770, _895772))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [rtrace] tAt(false, 271, 271, false)
; 
; EVAL TEST
; took 1.061 secs. (1061.36 milliseconds) 

!(assertEqual ((let $x (get-atoms &self) (get-type $x))) (superpose (((get-type &self)) ((get-type &self)))))

<span class="ansi31"
>(loonit_failureR  (equal_enough_for_test  ((hyperon::space::DynSpace) (hyperon::space::DynSpace) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (())) ((hyperon::space::DynSpace) (hyperon::space::DynSpace))))
</span>
Deterministic: ((Error  (got  ((hyperon::space::DynSpace) (hyperon::space::DynSpace) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()))) (expected  ((hyperon::space::DynSpace) (hyperon::space::DynSpace)))))
;;; stdlib is already loaded
<span class="ansi38-013099040"
>!(assertEqual (if (> 1 2) 1 2) 2)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.02"
>;; MODULE-SYSTEM.F1-IMPORTS.02</h3>
; 
; EVAL TEST
; took 0.000267 secs. (266.76 microseconds) 

!(assertEqual (if (> 1 2) 1 2) 2)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (2) (2)))
</span>
Deterministic: ()
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Importing the module into new space
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &m f1_moduleA)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta)
P;HTML|
;                                         (= 1  "[()]")
P;HTML|
;                                         (= 2  "[()]")
P;HTML|
;                                         (= 3  "0.05user 0.00system 0:00.06elapsed 98%CPU (0avgtext+0avgdata 32252maxresident)k")
P;HTML|
;                                         (= 3  "0inputs+0outputs (0major+3916minor)pagefaults 0swaps")
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta is 621 bytes (17 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta is 292 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Number))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()
;;; FIXME? stdlib space is not available at importing time -
;;; only tokens / grounded operations work, while symbolic functions
;;; (like `if`) don't work.
;;; FIXME? Exceptions are not caught by `importOp`
<span class="ansi38-013099040"
>!(assertEqual (+ 1 2) 3)

</span>
;<h3 id="MODULE-SYSTEM.F1-MODULEA.03"
>;; MODULE-SYSTEM.F1-MODULEA.03</h3>
; 
; EVAL TEST
; took 0.000234 secs. (234.19 microseconds) 

!(assertEqual (+ 1 2) 3)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (3) (3)))
</span>
Deterministic: ()
;;; !(assertEqual (if True "S" "F") "S")
<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (+ $x 10) (g $x)))
</span><span class="ansi38-255165000"
> (: f (-> Number Number))
</span><span class="ansi38-255165000"
> (= (f $x) (if (< $x 0) (- 0 $x) (g (+ 1 $x))))
</span>
Last Result(2): ()
;;; Check whether passed expression contains atom for which condition is True
<span class="ansi38-255165000"
> (: contains (-> Expression (-> Atom Bool) Bool))
</span><span class="ansi38-255165000"
> (= (contains $list $condition) (if (== $list ()) False (let $head (car-atom $list) (if ($condition $head) True (let $tail (cdr-atom $list) (contains $tail $condition))))))
</span>;;; Check whether atom is space comparing its type with type of the &self atom
<span class="ansi38-255165000"
> (: is-space (-> Atom Bool))
</span><span class="ansi38-255165000"
> (= (is-space $atom) (let* (($type (get-type $atom)) ($space (get-type &self))) (== $type $space)))
</span>;;; It's first atom is a space
<span class="ansi38-013099040"
>!(assertEqual (let $x (collapse (get-atoms &m)) (contains $x is-space)) True)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.04"
>;; MODULE-SYSTEM.F1-IMPORTS.04</h3>

(failed  once (if_or_else  (eval  = $_336734 495 &self (let a b never-happens) $_338408) (call  eval (let a b never-happens) $_338408)))


(on_mettalog_error  (failed  once (if_or_else  (eval  = $_336734 495 &self (let a b never-happens) $_338408) (call  eval (let a b never-happens) $_338408))))

^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] call(user:once, user:if_or_else(eval(=, _336734, 495, '&self', [let, a, b, 'never-happens'], _338408), call(eval, [let, a, b, 'never-happens'], _338408)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] once(user:if_or_else(eval(=, _336734, 495, '&self', [let, a, b, 'never-happens'], _338408), call(eval, [let, a, b, 'never-happens'], _338408)))
   <span class="ansi1 ansi32"
>Call: </span>(311) [user] if_or_else(eval(=, _336734, 495, '&self', [let, a, b, 'never-happens'], _338408), call(eval, [let, a, b, 'never-happens'], _338408))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval(=, _336734, 495, '&self', [let, a, b, 'never-happens'], _338408)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] catch_metta_return(eval_args(=, _336734, 495, '&self', [let, a, b, 'never-happens'], _338408), _338408)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_args(=, _336734, 495, '&self', [let, a, b, 'never-happens'], _338408)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_346818, _346820), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_346818, _346820))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_346818, _346820))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_348906, _348908), once(user:nonvar(_338408)), '$restore_trace'(_348906, _348908))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_348906, _348908))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_350994, _350996), once(user:nonvar(_338408)), '$restore_trace'(_350994, _350996))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_350994, _350996))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_358150, _358152), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_358150, _358152))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_358150, _358152))
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_00(=, _336734, 495, '&self', [let, a, b, 'never-happens'], _338408)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_363294, _363296), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_363294, _363296))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_363294, _363296))
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] eval_01(=, _336734, 495, '&self', [let, a, b, 'never-happens'], _338408)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] 495<1
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] 495<1
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_371530, _371532), once(user:(_371506 is 495-1, copy_term([let, a, b, 'never-happens'], _371520))), '$restore_trace'(_371530, _371532))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_371530, _371532))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(494 is 495-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] trace_eval(eval_20(=, _336734), e, 494, '&self', [let, a, b, 'never-happens'], _374640)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] must_det_ll((notrace((flag(eval_num, _375694, _375694+1), _375712 is _375694 mod 500, _375730 is 99-494 mod 100, _375754=_375756, option_else('trace-length', _375768, 500), option_else('trace-depth', _375776, 30))), quietly(if_t((nop(stop_rtrace), _375712>_375768), (set_debug(eval, false), _375832 is _375768+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375832])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_375884)))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] once(user:(notrace((flag(eval_num, _375694, _375694+1), _375712 is _375694 mod 500, _375730 is 99-494 mod 100, _375754=_375756, option_else('trace-length', _375768, 500), option_else('trace-depth', _375776, 30))), quietly(if_t((nop(stop_rtrace), _375712>_375768), (set_debug(eval, false), _375832 is _375768+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375832])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_375884)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] setup_call_cleanup('$notrace'(_377930, _377932), once(user:(flag(eval_num, _375694, _375694+1), _375712 is _375694 mod 500, _375730 is 99-494 mod 100, _375754=_375756, option_else('trace-length', _375768, 500), option_else('trace-depth', _375776, 30))), '$restore_trace'(_377930, _377932))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] sig_atomic(system:'$notrace'(_377930, _377932))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2077, 2077+1), 77 is 2077 mod 500, 5 is 99-494 mod 100, _375754=_375754, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 77>500), (set_debug(eval, false), _375832 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375832])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 77>500), (set_debug(eval, false), _375832 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375832])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(322) [user] nop(notrace(no_repeats_var(_375884)))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [user] nop(notrace(no_repeats_var(_375884)))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] once(user:(notrace((flag(eval_num, 2077, 2077+1), 77 is 2077 mod 500, 5 is 99-494 mod 100, _375754=_375754, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 77>500), (set_debug(eval, false), _375832 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375832])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_375884)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] must_det_ll(user:(notrace((flag(eval_num, 2077, 2077+1), 77 is 2077 mod 500, 5 is 99-494 mod 100, _375754=_375754, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 77>500), (set_debug(eval, false), _375832 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375832])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_375884)))))
   <span class="ansi1 ansi32"
>Call: </span>(319) [occurs] occurs:sub_term(_387582, e)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [occurs] occurs:sub_term(_387582, e)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _394688=e
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] if_trace((eval;e), (_375754=1, indentq(5, 77, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_397828, _397830), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _375754=1, indentq(5, 77, -->, [e, [let, a, b, 'never-happens']]))), _397786, fbug((_397786-->if_trace((eval;e), (_375754=1, indentq(5, 77, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_397828, _397830))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_397828, _397830))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _375754=1, indentq(5, 77, -->, [e, [let, a, b, 'never-happens']]))), _397786, fbug((_397786-->if_trace((eval;e), (_375754=1, indentq(5, 77, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] if_trace((eval;e), (_375754=1, indentq(5, 77, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _402024=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _404062=(\+ \+ (flag(eval_num, _404082, _404082+1), (retval(fail)\=@=retval(fail), nonvar(_374640)->indentq(5, _404082, <--, [e, _374640]);indentq(5, _404082, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] (\+ \+ (flag(eval_num, _404082, _404082+1), (retval(fail)\=@=retval(fail), nonvar(_374640)->indentq(5, _404082, <--, [e, _374640]);indentq(5, _404082, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _404082, _404082+1), (retval(fail)\=@=retval(fail), nonvar(_374640)->indentq(5, _404082, <--, [e, _374640]);indentq(5, _404082, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] call_cleanup(((call(eval_20(=, _336734), 494, '&self', [let, a, b, 'never-happens'], _374640)*->nb_setarg(1, retval(fail), _374640);fail, trace, call(eval_20(=, _336734), 494, '&self', [let, a, b, 'never-happens'], _374640)), ignore(notrace((\+_374640\=_375884, nb_setarg(1, retval(fail), _374640))))), ignore((_375754==1->ignore(\+ \+ (flag(eval_num, _404082, _404082+1), (retval(fail)\=@=retval(fail), nonvar(_374640)->indentq(5, _404082, <--, [e, _374640]);indentq(5, _404082, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404082, _404082+1), (retval(fail)\=@=retval(fail), nonvar(_374640)->indentq(5, _404082, <--, [e, _374640]);indentq(5, _404082, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] eval_20(=, _336734, 494, '&self', [let, a, b, 'never-happens'], _374640)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_411470, _411472), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_411470, _411472))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_411470, _411472))
^  <span class="ansi1 ansi31"
>Fail: </span>(323) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] once(expand_eval([let, a, b, 'never-happens'], _433814))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] expand_eval([let, a, b, 'never-happens'], _433814)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _439914)
   <span class="ansi1 ansi32"
>Call: </span>(325) [apply] apply:maplist_([a, b, 'never-happens'], _439914, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] expand_eval(a, _441970)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] a=_441970
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(326) [apply] apply:maplist_([b, 'never-happens'], _441972, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] expand_eval(b, _448072)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] b=_448072
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(327) [apply] apply:maplist_(['never-happens'], _448074, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] expand_eval('never-happens', _454174)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] 'never-happens'=_454174
   <span class="ansi1 ansi32"
>Exit: </span>(329) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(328) [apply] apply:maplist_([], _454176, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] possible_type('&self', a, _471466)
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] possible_type('&self', a, _471466)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] eval_args(=, _471466, 494, '&self', b, _473508)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_475566, _475568), once(user:self_eval(b)), '$restore_trace'(_475566, _475568))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_475566, _475568))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _473508=b
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] eval_args(=, _471466, 494, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] eval_20(=, _336734, 494, '&self', [let, a, b, 'never-happens'], _374640)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] ignore((_375754==1->ignore(\+ \+ (flag(eval_num, _404082, _404082+1), (retval(fail)\=@=retval(fail), nonvar(_374640)->indentq(5, _404082, <--, [e, _374640]);indentq(5, _404082, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404082, _404082+1), (retval(fail)\=@=retval(fail), nonvar(_374640)->indentq(5, _404082, <--, [e, _374640]);indentq(5, _404082, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _375754==1
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] _375754==1
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_488896, _488898), once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404082, _404082+1), (retval(fail)\=@=retval(fail), nonvar(_374640)->indentq(5, _404082, <--, [e, _374640]);indentq(5, _404082, <--, [e, retval(fail)])))))))), '$restore_trace'(_488896, _488898))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_488896, _488898))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404082, _404082+1), (retval(fail)\=@=retval(fail), nonvar(_374640)->indentq(5, _404082, <--, [e, _374640]);indentq(5, _404082, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] ignore(user:(_375754==1->ignore(\+ \+ (flag(eval_num, _404082, _404082+1), (retval(fail)\=@=retval(fail), nonvar(_374640)->indentq(5, _404082, <--, [e, _374640]);indentq(5, _404082, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404082, _404082+1), (retval(fail)\=@=retval(fail), nonvar(_374640)->indentq(5, _404082, <--, [e, _374640]);indentq(5, _404082, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [system] call_cleanup(user:((call(eval_20(=, _336734), 494, '&self', [let, a, b, 'never-happens'], _374640)*->nb_setarg(1, retval(fail), _374640);fail, trace, call(eval_20(=, _336734), 494, '&self', [let, a, b, 'never-happens'], _374640)), ignore(notrace((\+_374640\=_375884, nb_setarg(1, retval(fail), _374640))))), user:ignore((_375754==1->ignore(\+ \+ (flag(eval_num, _404082, _404082+1), (retval(fail)\=@=retval(fail), nonvar(_374640)->indentq(5, _404082, <--, [e, _374640]);indentq(5, _404082, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404082, _404082+1), (retval(fail)\=@=retval(fail), nonvar(_374640)->indentq(5, _404082, <--, [e, _374640]);indentq(5, _404082, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] trace_eval(eval_20(=, _336734), e, 494, '&self', [let, a, b, 'never-happens'], _374640)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] eval_args(=, _336734, 495, '&self', [let, a, b, 'never-happens'], _338408)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] call(eval, [let, a, b, 'never-happens'], _338408)
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval([let, a, b, 'never-happens'], _338408)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] current_self(_498304)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nb_current(self_space, _498304)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(314) [user] eval('&self', [let, a, b, 'never-happens'], _338408)
   <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _338408)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] catch_metta_return(eval_args(=, _506418, 500, '&self', [let, a, b, 'never-happens'], _338408), _338408)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] eval_args(=, _506418, 500, '&self', [let, a, b, 'never-happens'], _338408)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_509528, _509530), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_509528, _509530))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_509528, _509530))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_511616, _511618), once(user:nonvar(_338408)), '$restore_trace'(_511616, _511618))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_511616, _511618))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_513704, _513706), once(user:nonvar(_338408)), '$restore_trace'(_513704, _513706))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_513704, _513706))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_520860, _520862), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_520860, _520862))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_520860, _520862))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_00(=, _506418, 500, '&self', [let, a, b, 'never-happens'], _338408)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_526004, _526006), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_526004, _526006))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_526004, _526006))
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] eval_01(=, _506418, 500, '&self', [let, a, b, 'never-happens'], _338408)
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_534240, _534242), once(user:(_534216 is 500-1, copy_term([let, a, b, 'never-happens'], _534230))), '$restore_trace'(_534240, _534242))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_534240, _534242))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] trace_eval(eval_20(=, _506418), e, 499, '&self', [let, a, b, 'never-happens'], _537350)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] must_det_ll((notrace((flag(eval_num, _538404, _538404+1), _538422 is _538404 mod 500, _538440 is 99-499 mod 100, _538464=_538466, option_else('trace-length', _538478, 500), option_else('trace-depth', _538486, 30))), quietly(if_t((nop(stop_rtrace), _538422>_538478), (set_debug(eval, false), _538542 is _538478+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538542])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_538594)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] once(user:(notrace((flag(eval_num, _538404, _538404+1), _538422 is _538404 mod 500, _538440 is 99-499 mod 100, _538464=_538466, option_else('trace-length', _538478, 500), option_else('trace-depth', _538486, 30))), quietly(if_t((nop(stop_rtrace), _538422>_538478), (set_debug(eval, false), _538542 is _538478+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538542])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_538594)))))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] setup_call_cleanup('$notrace'(_540640, _540642), once(user:(flag(eval_num, _538404, _538404+1), _538422 is _538404 mod 500, _538440 is 99-499 mod 100, _538464=_538466, option_else('trace-length', _538478, 500), option_else('trace-depth', _538486, 30))), '$restore_trace'(_540640, _540642))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] sig_atomic(system:'$notrace'(_540640, _540642))
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2078, 2078+1), 78 is 2078 mod 500, 0 is 99-499 mod 100, _538464=_538464, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _538542 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538542])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _538542 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538542])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(325) [user] nop(notrace(no_repeats_var(_538594)))
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] nop(notrace(no_repeats_var(_538594)))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] once(user:(notrace((flag(eval_num, 2078, 2078+1), 78 is 2078 mod 500, 0 is 99-499 mod 100, _538464=_538464, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _538542 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538542])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_538594)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] must_det_ll(user:(notrace((flag(eval_num, 2078, 2078+1), 78 is 2078 mod 500, 0 is 99-499 mod 100, _538464=_538464, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _538542 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538542])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_538594)))))
   <span class="ansi1 ansi32"
>Call: </span>(322) [occurs] occurs:sub_term(_550292, e)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(322) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [occurs] occurs:sub_term(_550292, e)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _557398=e
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] if_trace((eval;e), (_538464=1, indentq(0, 78, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_560538, _560540), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _538464=1, indentq(0, 78, -->, [e, [let, a, b, 'never-happens']]))), _560496, fbug((_560496-->if_trace((eval;e), (_538464=1, indentq(0, 78, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_560538, _560540))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_560538, _560540))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _538464=1, indentq(0, 78, -->, [e, [let, a, b, 'never-happens']]))), _560496, fbug((_560496-->if_trace((eval;e), (_538464=1, indentq(0, 78, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] if_trace((eval;e), (_538464=1, indentq(0, 78, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _564734=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _566772=(\+ \+ (flag(eval_num, _566792, _566792+1), (retval(fail)\=@=retval(fail), nonvar(_537350)->indentq(0, _566792, <--, [e, _537350]);indentq(0, _566792, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] (\+ \+ (flag(eval_num, _566792, _566792+1), (retval(fail)\=@=retval(fail), nonvar(_537350)->indentq(0, _566792, <--, [e, _537350]);indentq(0, _566792, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _566792, _566792+1), (retval(fail)\=@=retval(fail), nonvar(_537350)->indentq(0, _566792, <--, [e, _537350]);indentq(0, _566792, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] call_cleanup(((call(eval_20(=, _506418), 499, '&self', [let, a, b, 'never-happens'], _537350)*->nb_setarg(1, retval(fail), _537350);fail, trace, call(eval_20(=, _506418), 499, '&self', [let, a, b, 'never-happens'], _537350)), ignore(notrace((\+_537350\=_538594, nb_setarg(1, retval(fail), _537350))))), ignore((_538464==1->ignore(\+ \+ (flag(eval_num, _566792, _566792+1), (retval(fail)\=@=retval(fail), nonvar(_537350)->indentq(0, _566792, <--, [e, _537350]);indentq(0, _566792, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566792, _566792+1), (retval(fail)\=@=retval(fail), nonvar(_537350)->indentq(0, _566792, <--, [e, _537350]);indentq(0, _566792, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] eval_20(=, _506418, 499, '&self', [let, a, b, 'never-happens'], _537350)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] setup_call_cleanup('$notrace'(_574180, _574182), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_574180, _574182))
^  <span class="ansi1 ansi32"
>Call: </span>(329) [system] sig_atomic(system:'$notrace'(_574180, _574182))
^  <span class="ansi1 ansi31"
>Fail: </span>(326) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] once(expand_eval([let, a, b, 'never-happens'], _596524))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] expand_eval([let, a, b, 'never-happens'], _596524)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _602624)
   <span class="ansi1 ansi32"
>Call: </span>(328) [apply] apply:maplist_([a, b, 'never-happens'], _602624, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] expand_eval(a, _604680)
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] a=_604680
   <span class="ansi1 ansi32"
>Exit: </span>(330) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(329) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(329) [apply] apply:maplist_([b, 'never-happens'], _604682, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] expand_eval(b, _610782)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] b=_610782
   <span class="ansi1 ansi32"
>Exit: </span>(331) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(330) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(330) [apply] apply:maplist_(['never-happens'], _610784, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] expand_eval('never-happens', _616884)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] 'never-happens'=_616884
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(331) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(331) [apply] apply:maplist_([], _616886, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(331) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(330) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(329) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] possible_type('&self', a, _634176)
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [user] possible_type('&self', a, _634176)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] eval_args(=, _634176, 499, '&self', b, _636218)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] setup_call_cleanup('$notrace'(_638276, _638278), once(user:self_eval(b)), '$restore_trace'(_638276, _638278))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] sig_atomic(system:'$notrace'(_638276, _638278))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _636218=b
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [user] eval_args(=, _634176, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(324) [user] eval_20(=, _506418, 499, '&self', [let, a, b, 'never-happens'], _537350)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] ignore((_538464==1->ignore(\+ \+ (flag(eval_num, _566792, _566792+1), (retval(fail)\=@=retval(fail), nonvar(_537350)->indentq(0, _566792, <--, [e, _537350]);indentq(0, _566792, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566792, _566792+1), (retval(fail)\=@=retval(fail), nonvar(_537350)->indentq(0, _566792, <--, [e, _537350]);indentq(0, _566792, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _538464==1
   <span class="ansi1 ansi31"
>Fail: </span>(326) [system] _538464==1
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] setup_call_cleanup('$notrace'(_651606, _651608), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566792, _566792+1), (retval(fail)\=@=retval(fail), nonvar(_537350)->indentq(0, _566792, <--, [e, _537350]);indentq(0, _566792, <--, [e, retval(fail)])))))))), '$restore_trace'(_651606, _651608))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] sig_atomic(system:'$notrace'(_651606, _651608))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566792, _566792+1), (retval(fail)\=@=retval(fail), nonvar(_537350)->indentq(0, _566792, <--, [e, _537350]);indentq(0, _566792, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] ignore(user:(_538464==1->ignore(\+ \+ (flag(eval_num, _566792, _566792+1), (retval(fail)\=@=retval(fail), nonvar(_537350)->indentq(0, _566792, <--, [e, _537350]);indentq(0, _566792, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566792, _566792+1), (retval(fail)\=@=retval(fail), nonvar(_537350)->indentq(0, _566792, <--, [e, _537350]);indentq(0, _566792, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(322) [system] call_cleanup(user:((call(eval_20(=, _506418), 499, '&self', [let, a, b, 'never-happens'], _537350)*->nb_setarg(1, retval(fail), _537350);fail, trace, call(eval_20(=, _506418), 499, '&self', [let, a, b, 'never-happens'], _537350)), ignore(notrace((\+_537350\=_538594, nb_setarg(1, retval(fail), _537350))))), user:ignore((_538464==1->ignore(\+ \+ (flag(eval_num, _566792, _566792+1), (retval(fail)\=@=retval(fail), nonvar(_537350)->indentq(0, _566792, <--, [e, _537350]);indentq(0, _566792, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566792, _566792+1), (retval(fail)\=@=retval(fail), nonvar(_537350)->indentq(0, _566792, <--, [e, _537350]);indentq(0, _566792, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] trace_eval(eval_20(=, _506418), e, 499, '&self', [let, a, b, 'never-happens'], _537350)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] eval_args(=, _506418, 500, '&self', [let, a, b, 'never-happens'], _338408)
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [system] call(user:once, user:if_or_else(eval(=, _336734, 495, '&self', [let, a, b, 'never-happens'], _338408), call(eval, [let, a, b, 'never-happens'], _338408)))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] setup_call_cleanup('$notrace'(_663068, _663070), once(rtrace:retract(t_l:tracer_reset(_663058))), '$restore_trace'(_663068, _663070))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(system:'$notrace'(_663068, _663070))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [rtrace] tAt(false, 271, 271, false)
<span class="ansi1 ansi90"
>Info: Processing progress: 100% </span>[4] current_output closed; set to user_output
<span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta progress.
</span><span class="ansi1 ansi90"
>Info: Processing progress: 100% </span>[5] current_output closed; set to user_output
<span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta progress.
</span><span class="ansi1 ansi90"
>Info: Processing progress: 100% </span><span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta progress.
</span><span class="ansi1 ansi90"
>Info: Processing progress: 100% </span><span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta progress.
</span><span class="ansi1 ansi90"
>Info: Processing progress: 100% </span><span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta progress.
</span>; 
; EVAL TEST
; took 14.88 seconds.

!(assertEqual (let $x (collapse (get-atoms &m)) (contains $x is-space)) True)

<span class="ansi31"
>(loonit_failureR  (equal_enough_for_test  () (True)))
</span>
Deterministic: ((Error  (got  ()) (expected  (True))))
;;; FIXME? Now, it is moduleC space.
;;;        Should it be `stdlib` atom for a separately imported space
;;; !(let $x (collapse (get-atoms &m)) (car-atom $x))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Without additional means like `(&m.f 2)` notation or `(interpret &m (f 2))`,
;;; we cannot execute functions from the separate space - we can only use `match`.
;;; Although `&m` imports another space with definition of `g`, it is not reduced
;;; because it is not defined in the context of `&self`. This is the expected
;;; behavior, but it shows that this way of importing spaces is not too useful
;;; for importing modules with functions.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(assertEqual (match &m (= (f 2) $x) $x) (g 3))

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.05"
>;; MODULE-SYSTEM.F1-IMPORTS.05</h3>
; 
; EVAL TEST
; took 0.004 secs. (3.87 milliseconds) 

!(assertEqual (match &m (= (f 2) $x) $x) (g 3))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  ((g 3)) ((g 3))))
</span>
Deterministic: ()
;;; Importing the same space into `&self` should break nothing
;;; TODO? If stdlib space would be in `&m`, which should check that it is not
;;; there anymore since in should be removed after importing it to `&self`
<span class="ansi38-013099040"
>!(import! &self f1_moduleA)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta is 621 bytes (17 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta is 292 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Number))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()
;;; FIXME? stdlib space is not available at importing time -
;;; only tokens / grounded operations work, while symbolic functions
;;; (like `if`) don't work.
;;; FIXME? Exceptions are not caught by `importOp`
<span class="ansi38-013099040"
>!(assertEqual (+ 1 2) 3)

</span>
;<h3 id="MODULE-SYSTEM.F1-MODULEA.06"
>;; MODULE-SYSTEM.F1-MODULEA.06</h3>
; 
; EVAL TEST
; took 0.000206 secs. (205.87 microseconds) 

!(assertEqual (+ 1 2) 3)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (3) (3)))
</span>
Deterministic: ()
;;; !(assertEqual (if True "S" "F") "S")
<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (+ $x 10) (g $x)))
</span><span class="ansi38-255165000"
> (: f (-> Number Number))
</span><span class="ansi38-255165000"
> (= (f $x) (if (< $x 0) (- 0 $x) (g (+ 1 $x))))
</span>
Last Result(2): ()
;;; Now indirectly imported `g` works and `f` fully works
<span class="ansi38-013099040"
>!(assertEqual (g 2) 102)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.07"
>;; MODULE-SYSTEM.F1-IMPORTS.07</h3>
; 
; EVAL TEST
; took 0.000919 secs. (918.73 microseconds) 

!(assertEqual (g 2) 102)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102) (102)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (f 2) 103)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.08"
>;; MODULE-SYSTEM.F1-IMPORTS.08</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.62 milliseconds) 

!(assertEqual (f 2) 103)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (103) (103)))
</span>
Deterministic: ()
;;; `&self` contains 4 grounded sub-spaces now:
;;; - stdlib
;;; - corelib
;;; - moduleA itself, which is the same as &m
;;; - moduleC imported by moduleA and removed from A after its import to &self
;;; Check whether atom is &m
<span class="ansi38-255165000"
> (: is-m (-> Atom Bool))
</span><span class="ansi38-255165000"
> (= (is-m $atom) (== $atom &m))
</span>;;; Assert that the &self space contains the same space as &m, which we imported from moduleA
;;; TODO: Comparing spaces like this doesn't work because the source module is the same, but a specialized
;;;   clone of the dependent space without transitive-dependencies was created during the import process.
;;;   Ideally, we can rework importing so that a special space copy isn't created, and then comparing
;;;   spaces will work again.  But, In my opinion comparing spaces is not a good way to check to see if a
;;;   module has been loaded.  I believe a better solution is accessor operations for loaded & imported modules
;;;
;;;!(assertEqual
;;;  (let $a (collapse (get-atoms &self)) (contains $a is-m))
;;;  True)
;;; Check that the &self space contains the corelib child space
;;; Note: corelib doesn't import any modules into itself, so no space copy is needed
<span class="ansi38-013099040"
>!(import! &corelib corelib)

</span>
Deterministic: ()<span class="ansi38-255165000"
> (: is-corelib (-> Atom Bool))
</span><span class="ansi38-255165000"
> (= (is-corelib $atom) (== $atom &corelib))
</span><span class="ansi38-013099040"
>!(assertEqual (let $a (collapse (get-atoms &self)) (contains $a is-corelib)) True)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.09"
>;; MODULE-SYSTEM.F1-IMPORTS.09</h3>

(failed  once (if_or_else  (eval  = $_336694 495 &self (let a b never-happens) $_338368) (call  eval (let a b never-happens) $_338368)))


(on_mettalog_error  (failed  once (if_or_else  (eval  = $_336694 495 &self (let a b never-happens) $_338368) (call  eval (let a b never-happens) $_338368))))

^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] call(user:once, user:if_or_else(eval(=, _336694, 495, '&self', [let, a, b, 'never-happens'], _338368), call(eval, [let, a, b, 'never-happens'], _338368)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] once(user:if_or_else(eval(=, _336694, 495, '&self', [let, a, b, 'never-happens'], _338368), call(eval, [let, a, b, 'never-happens'], _338368)))
   <span class="ansi1 ansi32"
>Call: </span>(311) [user] if_or_else(eval(=, _336694, 495, '&self', [let, a, b, 'never-happens'], _338368), call(eval, [let, a, b, 'never-happens'], _338368))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval(=, _336694, 495, '&self', [let, a, b, 'never-happens'], _338368)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] catch_metta_return(eval_args(=, _336694, 495, '&self', [let, a, b, 'never-happens'], _338368), _338368)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_args(=, _336694, 495, '&self', [let, a, b, 'never-happens'], _338368)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_346778, _346780), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_346778, _346780))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_346778, _346780))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_348866, _348868), once(user:nonvar(_338368)), '$restore_trace'(_348866, _348868))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_348866, _348868))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_350954, _350956), once(user:nonvar(_338368)), '$restore_trace'(_350954, _350956))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_350954, _350956))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_358110, _358112), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_358110, _358112))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_358110, _358112))
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_00(=, _336694, 495, '&self', [let, a, b, 'never-happens'], _338368)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_363254, _363256), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_363254, _363256))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_363254, _363256))
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] eval_01(=, _336694, 495, '&self', [let, a, b, 'never-happens'], _338368)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] 495<1
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] 495<1
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_371490, _371492), once(user:(_371466 is 495-1, copy_term([let, a, b, 'never-happens'], _371480))), '$restore_trace'(_371490, _371492))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_371490, _371492))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(494 is 495-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] trace_eval(eval_20(=, _336694), e, 494, '&self', [let, a, b, 'never-happens'], _374600)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] must_det_ll((notrace((flag(eval_num, _375654, _375654+1), _375672 is _375654 mod 500, _375690 is 99-494 mod 100, _375714=_375716, option_else('trace-length', _375728, 500), option_else('trace-depth', _375736, 30))), quietly(if_t((nop(stop_rtrace), _375672>_375728), (set_debug(eval, false), _375792 is _375728+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375792])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_375844)))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] once(user:(notrace((flag(eval_num, _375654, _375654+1), _375672 is _375654 mod 500, _375690 is 99-494 mod 100, _375714=_375716, option_else('trace-length', _375728, 500), option_else('trace-depth', _375736, 30))), quietly(if_t((nop(stop_rtrace), _375672>_375728), (set_debug(eval, false), _375792 is _375728+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375792])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_375844)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] setup_call_cleanup('$notrace'(_377890, _377892), once(user:(flag(eval_num, _375654, _375654+1), _375672 is _375654 mod 500, _375690 is 99-494 mod 100, _375714=_375716, option_else('trace-length', _375728, 500), option_else('trace-depth', _375736, 30))), '$restore_trace'(_377890, _377892))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] sig_atomic(system:'$notrace'(_377890, _377892))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2085, 2085+1), 85 is 2085 mod 500, 5 is 99-494 mod 100, _375714=_375714, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 85>500), (set_debug(eval, false), _375792 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375792])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 85>500), (set_debug(eval, false), _375792 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375792])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(322) [user] nop(notrace(no_repeats_var(_375844)))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [user] nop(notrace(no_repeats_var(_375844)))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] once(user:(notrace((flag(eval_num, 2085, 2085+1), 85 is 2085 mod 500, 5 is 99-494 mod 100, _375714=_375714, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 85>500), (set_debug(eval, false), _375792 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375792])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_375844)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] must_det_ll(user:(notrace((flag(eval_num, 2085, 2085+1), 85 is 2085 mod 500, 5 is 99-494 mod 100, _375714=_375714, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 85>500), (set_debug(eval, false), _375792 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375792])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_375844)))))
   <span class="ansi1 ansi32"
>Call: </span>(319) [occurs] occurs:sub_term(_387542, e)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [occurs] occurs:sub_term(_387542, e)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _394648=e
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] if_trace((eval;e), (_375714=1, indentq(5, 85, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_397788, _397790), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _375714=1, indentq(5, 85, -->, [e, [let, a, b, 'never-happens']]))), _397746, fbug((_397746-->if_trace((eval;e), (_375714=1, indentq(5, 85, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_397788, _397790))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_397788, _397790))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _375714=1, indentq(5, 85, -->, [e, [let, a, b, 'never-happens']]))), _397746, fbug((_397746-->if_trace((eval;e), (_375714=1, indentq(5, 85, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] if_trace((eval;e), (_375714=1, indentq(5, 85, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _401984=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _404022=(\+ \+ (flag(eval_num, _404042, _404042+1), (retval(fail)\=@=retval(fail), nonvar(_374600)->indentq(5, _404042, <--, [e, _374600]);indentq(5, _404042, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] (\+ \+ (flag(eval_num, _404042, _404042+1), (retval(fail)\=@=retval(fail), nonvar(_374600)->indentq(5, _404042, <--, [e, _374600]);indentq(5, _404042, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _404042, _404042+1), (retval(fail)\=@=retval(fail), nonvar(_374600)->indentq(5, _404042, <--, [e, _374600]);indentq(5, _404042, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] call_cleanup(((call(eval_20(=, _336694), 494, '&self', [let, a, b, 'never-happens'], _374600)*->nb_setarg(1, retval(fail), _374600);fail, trace, call(eval_20(=, _336694), 494, '&self', [let, a, b, 'never-happens'], _374600)), ignore(notrace((\+_374600\=_375844, nb_setarg(1, retval(fail), _374600))))), ignore((_375714==1->ignore(\+ \+ (flag(eval_num, _404042, _404042+1), (retval(fail)\=@=retval(fail), nonvar(_374600)->indentq(5, _404042, <--, [e, _374600]);indentq(5, _404042, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404042, _404042+1), (retval(fail)\=@=retval(fail), nonvar(_374600)->indentq(5, _404042, <--, [e, _374600]);indentq(5, _404042, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] eval_20(=, _336694, 494, '&self', [let, a, b, 'never-happens'], _374600)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_411430, _411432), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_411430, _411432))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_411430, _411432))
^  <span class="ansi1 ansi31"
>Fail: </span>(323) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] once(expand_eval([let, a, b, 'never-happens'], _433774))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] expand_eval([let, a, b, 'never-happens'], _433774)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _439874)
   <span class="ansi1 ansi32"
>Call: </span>(325) [apply] apply:maplist_([a, b, 'never-happens'], _439874, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] expand_eval(a, _441930)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] a=_441930
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(326) [apply] apply:maplist_([b, 'never-happens'], _441932, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] expand_eval(b, _448032)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] b=_448032
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(327) [apply] apply:maplist_(['never-happens'], _448034, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] expand_eval('never-happens', _454134)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] 'never-happens'=_454134
   <span class="ansi1 ansi32"
>Exit: </span>(329) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(328) [apply] apply:maplist_([], _454136, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] possible_type('&self', a, _471426)
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] possible_type('&self', a, _471426)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] eval_args(=, _471426, 494, '&self', b, _473468)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_475526, _475528), once(user:self_eval(b)), '$restore_trace'(_475526, _475528))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_475526, _475528))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _473468=b
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] eval_args(=, _471426, 494, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] eval_20(=, _336694, 494, '&self', [let, a, b, 'never-happens'], _374600)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] ignore((_375714==1->ignore(\+ \+ (flag(eval_num, _404042, _404042+1), (retval(fail)\=@=retval(fail), nonvar(_374600)->indentq(5, _404042, <--, [e, _374600]);indentq(5, _404042, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404042, _404042+1), (retval(fail)\=@=retval(fail), nonvar(_374600)->indentq(5, _404042, <--, [e, _374600]);indentq(5, _404042, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _375714==1
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] _375714==1
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_488856, _488858), once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404042, _404042+1), (retval(fail)\=@=retval(fail), nonvar(_374600)->indentq(5, _404042, <--, [e, _374600]);indentq(5, _404042, <--, [e, retval(fail)])))))))), '$restore_trace'(_488856, _488858))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_488856, _488858))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404042, _404042+1), (retval(fail)\=@=retval(fail), nonvar(_374600)->indentq(5, _404042, <--, [e, _374600]);indentq(5, _404042, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] ignore(user:(_375714==1->ignore(\+ \+ (flag(eval_num, _404042, _404042+1), (retval(fail)\=@=retval(fail), nonvar(_374600)->indentq(5, _404042, <--, [e, _374600]);indentq(5, _404042, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404042, _404042+1), (retval(fail)\=@=retval(fail), nonvar(_374600)->indentq(5, _404042, <--, [e, _374600]);indentq(5, _404042, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [system] call_cleanup(user:((call(eval_20(=, _336694), 494, '&self', [let, a, b, 'never-happens'], _374600)*->nb_setarg(1, retval(fail), _374600);fail, trace, call(eval_20(=, _336694), 494, '&self', [let, a, b, 'never-happens'], _374600)), ignore(notrace((\+_374600\=_375844, nb_setarg(1, retval(fail), _374600))))), user:ignore((_375714==1->ignore(\+ \+ (flag(eval_num, _404042, _404042+1), (retval(fail)\=@=retval(fail), nonvar(_374600)->indentq(5, _404042, <--, [e, _374600]);indentq(5, _404042, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404042, _404042+1), (retval(fail)\=@=retval(fail), nonvar(_374600)->indentq(5, _404042, <--, [e, _374600]);indentq(5, _404042, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] trace_eval(eval_20(=, _336694), e, 494, '&self', [let, a, b, 'never-happens'], _374600)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] eval_args(=, _336694, 495, '&self', [let, a, b, 'never-happens'], _338368)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] call(eval, [let, a, b, 'never-happens'], _338368)
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval([let, a, b, 'never-happens'], _338368)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] current_self(_498264)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nb_current(self_space, _498264)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(314) [user] eval('&self', [let, a, b, 'never-happens'], _338368)
   <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _338368)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] catch_metta_return(eval_args(=, _506378, 500, '&self', [let, a, b, 'never-happens'], _338368), _338368)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] eval_args(=, _506378, 500, '&self', [let, a, b, 'never-happens'], _338368)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_509488, _509490), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_509488, _509490))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_509488, _509490))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_511576, _511578), once(user:nonvar(_338368)), '$restore_trace'(_511576, _511578))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_511576, _511578))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_513664, _513666), once(user:nonvar(_338368)), '$restore_trace'(_513664, _513666))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_513664, _513666))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_520820, _520822), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_520820, _520822))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_520820, _520822))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_00(=, _506378, 500, '&self', [let, a, b, 'never-happens'], _338368)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_525964, _525966), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_525964, _525966))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_525964, _525966))
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] eval_01(=, _506378, 500, '&self', [let, a, b, 'never-happens'], _338368)
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_534200, _534202), once(user:(_534176 is 500-1, copy_term([let, a, b, 'never-happens'], _534190))), '$restore_trace'(_534200, _534202))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_534200, _534202))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] trace_eval(eval_20(=, _506378), e, 499, '&self', [let, a, b, 'never-happens'], _537310)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] must_det_ll((notrace((flag(eval_num, _538364, _538364+1), _538382 is _538364 mod 500, _538400 is 99-499 mod 100, _538424=_538426, option_else('trace-length', _538438, 500), option_else('trace-depth', _538446, 30))), quietly(if_t((nop(stop_rtrace), _538382>_538438), (set_debug(eval, false), _538502 is _538438+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538502])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_538554)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] once(user:(notrace((flag(eval_num, _538364, _538364+1), _538382 is _538364 mod 500, _538400 is 99-499 mod 100, _538424=_538426, option_else('trace-length', _538438, 500), option_else('trace-depth', _538446, 30))), quietly(if_t((nop(stop_rtrace), _538382>_538438), (set_debug(eval, false), _538502 is _538438+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538502])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_538554)))))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] setup_call_cleanup('$notrace'(_540600, _540602), once(user:(flag(eval_num, _538364, _538364+1), _538382 is _538364 mod 500, _538400 is 99-499 mod 100, _538424=_538426, option_else('trace-length', _538438, 500), option_else('trace-depth', _538446, 30))), '$restore_trace'(_540600, _540602))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] sig_atomic(system:'$notrace'(_540600, _540602))
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2086, 2086+1), 86 is 2086 mod 500, 0 is 99-499 mod 100, _538424=_538424, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 86>500), (set_debug(eval, false), _538502 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538502])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 86>500), (set_debug(eval, false), _538502 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538502])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(325) [user] nop(notrace(no_repeats_var(_538554)))
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] nop(notrace(no_repeats_var(_538554)))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] once(user:(notrace((flag(eval_num, 2086, 2086+1), 86 is 2086 mod 500, 0 is 99-499 mod 100, _538424=_538424, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 86>500), (set_debug(eval, false), _538502 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538502])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_538554)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] must_det_ll(user:(notrace((flag(eval_num, 2086, 2086+1), 86 is 2086 mod 500, 0 is 99-499 mod 100, _538424=_538424, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 86>500), (set_debug(eval, false), _538502 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538502])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_538554)))))
   <span class="ansi1 ansi32"
>Call: </span>(322) [occurs] occurs:sub_term(_550252, e)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(322) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [occurs] occurs:sub_term(_550252, e)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _557358=e
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] if_trace((eval;e), (_538424=1, indentq(0, 86, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_560498, _560500), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _538424=1, indentq(0, 86, -->, [e, [let, a, b, 'never-happens']]))), _560456, fbug((_560456-->if_trace((eval;e), (_538424=1, indentq(0, 86, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_560498, _560500))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_560498, _560500))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _538424=1, indentq(0, 86, -->, [e, [let, a, b, 'never-happens']]))), _560456, fbug((_560456-->if_trace((eval;e), (_538424=1, indentq(0, 86, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] if_trace((eval;e), (_538424=1, indentq(0, 86, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _564694=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _566732=(\+ \+ (flag(eval_num, _566752, _566752+1), (retval(fail)\=@=retval(fail), nonvar(_537310)->indentq(0, _566752, <--, [e, _537310]);indentq(0, _566752, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] (\+ \+ (flag(eval_num, _566752, _566752+1), (retval(fail)\=@=retval(fail), nonvar(_537310)->indentq(0, _566752, <--, [e, _537310]);indentq(0, _566752, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _566752, _566752+1), (retval(fail)\=@=retval(fail), nonvar(_537310)->indentq(0, _566752, <--, [e, _537310]);indentq(0, _566752, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] call_cleanup(((call(eval_20(=, _506378), 499, '&self', [let, a, b, 'never-happens'], _537310)*->nb_setarg(1, retval(fail), _537310);fail, trace, call(eval_20(=, _506378), 499, '&self', [let, a, b, 'never-happens'], _537310)), ignore(notrace((\+_537310\=_538554, nb_setarg(1, retval(fail), _537310))))), ignore((_538424==1->ignore(\+ \+ (flag(eval_num, _566752, _566752+1), (retval(fail)\=@=retval(fail), nonvar(_537310)->indentq(0, _566752, <--, [e, _537310]);indentq(0, _566752, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566752, _566752+1), (retval(fail)\=@=retval(fail), nonvar(_537310)->indentq(0, _566752, <--, [e, _537310]);indentq(0, _566752, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] eval_20(=, _506378, 499, '&self', [let, a, b, 'never-happens'], _537310)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] setup_call_cleanup('$notrace'(_574140, _574142), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_574140, _574142))
^  <span class="ansi1 ansi32"
>Call: </span>(329) [system] sig_atomic(system:'$notrace'(_574140, _574142))
^  <span class="ansi1 ansi31"
>Fail: </span>(326) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] once(expand_eval([let, a, b, 'never-happens'], _596484))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] expand_eval([let, a, b, 'never-happens'], _596484)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _602584)
   <span class="ansi1 ansi32"
>Call: </span>(328) [apply] apply:maplist_([a, b, 'never-happens'], _602584, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] expand_eval(a, _604640)
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] a=_604640
   <span class="ansi1 ansi32"
>Exit: </span>(330) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(329) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(329) [apply] apply:maplist_([b, 'never-happens'], _604642, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] expand_eval(b, _610742)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] b=_610742
   <span class="ansi1 ansi32"
>Exit: </span>(331) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(330) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(330) [apply] apply:maplist_(['never-happens'], _610744, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] expand_eval('never-happens', _616844)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] 'never-happens'=_616844
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(331) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(331) [apply] apply:maplist_([], _616846, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(331) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(330) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(329) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] possible_type('&self', a, _634136)
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [user] possible_type('&self', a, _634136)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] eval_args(=, _634136, 499, '&self', b, _636178)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] setup_call_cleanup('$notrace'(_638236, _638238), once(user:self_eval(b)), '$restore_trace'(_638236, _638238))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] sig_atomic(system:'$notrace'(_638236, _638238))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _636178=b
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [user] eval_args(=, _634136, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(324) [user] eval_20(=, _506378, 499, '&self', [let, a, b, 'never-happens'], _537310)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] ignore((_538424==1->ignore(\+ \+ (flag(eval_num, _566752, _566752+1), (retval(fail)\=@=retval(fail), nonvar(_537310)->indentq(0, _566752, <--, [e, _537310]);indentq(0, _566752, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566752, _566752+1), (retval(fail)\=@=retval(fail), nonvar(_537310)->indentq(0, _566752, <--, [e, _537310]);indentq(0, _566752, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _538424==1
   <span class="ansi1 ansi31"
>Fail: </span>(326) [system] _538424==1
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] setup_call_cleanup('$notrace'(_651566, _651568), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566752, _566752+1), (retval(fail)\=@=retval(fail), nonvar(_537310)->indentq(0, _566752, <--, [e, _537310]);indentq(0, _566752, <--, [e, retval(fail)])))))))), '$restore_trace'(_651566, _651568))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] sig_atomic(system:'$notrace'(_651566, _651568))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566752, _566752+1), (retval(fail)\=@=retval(fail), nonvar(_537310)->indentq(0, _566752, <--, [e, _537310]);indentq(0, _566752, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] ignore(user:(_538424==1->ignore(\+ \+ (flag(eval_num, _566752, _566752+1), (retval(fail)\=@=retval(fail), nonvar(_537310)->indentq(0, _566752, <--, [e, _537310]);indentq(0, _566752, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566752, _566752+1), (retval(fail)\=@=retval(fail), nonvar(_537310)->indentq(0, _566752, <--, [e, _537310]);indentq(0, _566752, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(322) [system] call_cleanup(user:((call(eval_20(=, _506378), 499, '&self', [let, a, b, 'never-happens'], _537310)*->nb_setarg(1, retval(fail), _537310);fail, trace, call(eval_20(=, _506378), 499, '&self', [let, a, b, 'never-happens'], _537310)), ignore(notrace((\+_537310\=_538554, nb_setarg(1, retval(fail), _537310))))), user:ignore((_538424==1->ignore(\+ \+ (flag(eval_num, _566752, _566752+1), (retval(fail)\=@=retval(fail), nonvar(_537310)->indentq(0, _566752, <--, [e, _537310]);indentq(0, _566752, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566752, _566752+1), (retval(fail)\=@=retval(fail), nonvar(_537310)->indentq(0, _566752, <--, [e, _537310]);indentq(0, _566752, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] trace_eval(eval_20(=, _506378), e, 499, '&self', [let, a, b, 'never-happens'], _537310)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] eval_args(=, _506378, 500, '&self', [let, a, b, 'never-happens'], _338368)
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [system] call(user:once, user:if_or_else(eval(=, _336694, 495, '&self', [let, a, b, 'never-happens'], _338368), call(eval, [let, a, b, 'never-happens'], _338368)))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] setup_call_cleanup('$notrace'(_663028, _663030), once(rtrace:retract(t_l:tracer_reset(_663018))), '$restore_trace'(_663028, _663030))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(system:'$notrace'(_663028, _663030))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [rtrace] tAt(false, 271, 271, false)
; 
; EVAL TEST
; took 6.34 seconds.

!(assertEqual (let $a (collapse (get-atoms &self)) (contains $a is-corelib)) True)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (True) (True)))
</span>
Deterministic: ()
;;; Let's check that `if` from stdlib is not duplicated and gives only one result
<span class="ansi38-013099040"
>!(assertEqual (if (> 1 2) 1 2) 2)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.10"
>;; MODULE-SYSTEM.F1-IMPORTS.10</h3>
; 
; EVAL TEST
; took 0.000269 secs. (269.48 microseconds) 

!(assertEqual (if (> 1 2) 1 2) 2)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (2) (2)))
</span>
Deterministic: ()
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Let's import one more module into `&self` with a diamond dependence
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleB)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta is 282 bytes (7 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta is 292 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Number))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (g $x) (+ $x 10)))
</span>
Last Result(2): ()
;;; `g` from moduleC imported via two paths as well as `f`, which uses `g`,
;;; are not duplicated and produce deterministic results
<span class="ansi38-013099040"
>!(assertEqual (g 2) 102)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.11"
>;; MODULE-SYSTEM.F1-IMPORTS.11</h3>
; 
; EVAL TEST
; took 0.000841 secs. (841.35 microseconds) 

!(assertEqual (g 2) 102)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102) (102)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (f 2) 103)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.12"
>;; MODULE-SYSTEM.F1-IMPORTS.12</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.65 milliseconds) 

!(assertEqual (f 2) 103)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (103) (103)))
</span>
Deterministic: ()
;;; Function declared in different imported modules will still produce
;;; non-deterministic results
<span class="ansi38-013099040"
>!(assertEqualToResult (dup 2) (12 102))

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.13"
>;; MODULE-SYSTEM.F1-IMPORTS.13</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.27 milliseconds) 

!(assertEqualToResult (dup 2) (12 102))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102 12) (12 102)))
</span>
Deterministic: ()
;;; Let's import f1_moduleB once more. Such import should be ignored and
;;; thus f, g and dup should remain unchanged.
<span class="ansi38-013099040"
>!(import! &self f1_moduleB)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta is 282 bytes (7 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta is 292 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Number))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (g $x) (+ $x 10)))
</span>
Last Result(2): ()
<span class="ansi38-013099040"
>!(assertEqual (g 2) 102)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.14"
>;; MODULE-SYSTEM.F1-IMPORTS.14</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.14 milliseconds) 

!(assertEqual (g 2) 102)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102) (102)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (f 2) 103)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.15"
>;; MODULE-SYSTEM.F1-IMPORTS.15</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.42 milliseconds) 

!(assertEqual (f 2) 103)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (103) (103)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqualToResult (dup 2) (12 102))

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.16"
>;; MODULE-SYSTEM.F1-IMPORTS.16</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.22 milliseconds) 

!(assertEqualToResult (dup 2) (12 102))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102 12) (12 102)))
</span>
Deterministic: ()<span class="ansi32"
>
% 78,700,461 inferences, 22.703 CPU in 22.727 seconds (100% CPU, 3466592 Lips)
</span>P;HTML|
;                       (= /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta  0)
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 14
</span><span class="ansi31"
>Failures: 2
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
P;HTML|
;         (is_cmd_option  execute halt --halt=true true)
P;HTML|
;          (set_option_value  halt true)
P;HTML|
;          (is_cmd_option  execute stdin --stdin=tty tty)
P;HTML|
;          (set_option_value  stdin tty)
P;HTML|
;          (is_cmd_option  execute stdout --stdout=tty tty)
P;HTML|
;           (set_option_value  stdout tty)
P;HTML|
;          (is_cmd_option  execute stderr --stderr=tty tty)
P;HTML|
;           (set_option_value  stderr tty)
P;HTML|
;         (set_option_value  compat false)
P;HTML|
;         (set_option_value  compatio false)
P;HTML|
;         (set_option_value  src_indents false)
P;HTML|
;         (set_option_value  devel false)
P;HTML|
;         (set_option_value  stack-max 500)
P;HTML|
;         (set_option_value  limit inf)
P;HTML|
;         (set_option_value  initial-result-count 10)
P;HTML|
;         (set_option_value  answer-format show)
P;HTML|
;         (set_option_value  repeats true)
P;HTML|
;         (set_option_value  time true)
P;HTML|
;         (set_option_value  synth-unit-tests false)
P;HTML|
;         (set_option_value  optimize true)
P;HTML|
;         (set_option_value  transpiler silent)
P;HTML|
;          (set_debug  transpiler false)
P;HTML|
;         (set_option_value  compile false)
P;HTML|
;         (set_option_value  tabling auto)
P;HTML|
;         (set_option_value  log false)
P;HTML|
;         (set_option_value  output ./)
P;HTML|
;         (set_option_value  exeout ./Sav.gitlab.MeTTaLog)
P;HTML|
;         (set_option_value  halt false)
P;HTML|
;         (set_option_value  trace-length 500)
P;HTML|
;         (set_option_value  trace-on-overtime 4.0)
P;HTML|
;          (set_debug  overtime 4.0)
P;HTML|
;         (set_option_value  trace-on-overflow 1000)
P;HTML|
;          (set_debug  overflow 1000)
P;HTML|
;         (set_option_value  trace-on-eval false)
P;HTML|
;          (set_debug  eval false)
P;HTML|
;         (set_option_value  trace-on-load silent)
P;HTML|
;          (set_debug  load silent)
P;HTML|
;          (set_debug  trace-on-load false)
P;HTML|
;         (set_option_value  trace-on-exec false)
P;HTML|
;          (set_debug  exec false)
P;HTML|
;         (set_option_value  trace-on-error non-type)
P;HTML|
;          (set_debug  error non-type)
P;HTML|
;         (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;         (set_option_value  trace-on-test true)
P;HTML|
;          (set_debug  test true)
P;HTML|
;         (set_option_value  repl-on-error true)
P;HTML|
;         (set_option_value  repl-on-fail false)
P;HTML|
;         (set_option_value  exit-on-fail false)
P;HTML|
;         (set_option_value  repl auto)
P;HTML|
;         (set_option_value  prolog false)
P;HTML|
;         (set_option_value  exec noskip)
P;HTML|
;         (set_option_value  maximum-result-count inf)
P;HTML|
;         (set_option_value  html false)
P;HTML|
;         (set_option_value  python true)
P;HTML|
;         (set_option_value  trace-on-test false)
P;HTML|
;          (set_debug  test false)
P;HTML|
;         (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;         (set_option_value  load show)
P;HTML|
;         (set_option_value  test true)
[((Error  (got  ((hyperon::space::DynSpace) (hyperon::space::DynSpace) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()))) (expected  ((hyperon::space::DynSpace) (hyperon::space::DynSpace)))))]
[()]
[()]
[((Error  (got  ()) (expected  (True))))]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
P;HTML|
;         (maybe_halt  7)
<span class="ansi31"
>(in  (maybe_halt  7) (unwind  (halt  7)))
</span>
Script done on 2024-11-26 19:51:34+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat/' --timeout=40 --html --repl=false  --test "tests/baseline_compat/module-system/f1_imports.metta" --halt=true\033[0m
