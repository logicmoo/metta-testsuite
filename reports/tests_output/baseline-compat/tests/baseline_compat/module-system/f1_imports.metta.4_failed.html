<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi36 { color: #00aaaa; }
.ansi90 { color: #7f7f7f; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-11-29 10:48:49+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
^@P;HTML|
;           (set_option_value  compat false)

P;HTML|
;           (set_option_value  compatio false)

P;HTML|
;           (set_option_value  src_indents false)

P;HTML|
;         (set_option_value  devel false)

P;HTML|
;         (set_option_value  stack-max 500)

P;HTML|
;         (set_option_value  limit inf)

P;HTML|
;         (set_option_value  initial-result-count 10)

P;HTML|
;         (set_option_value  answer-format show)

P;HTML|
;         (set_option_value  repeats true)

P;HTML|
;         (set_option_value  time true)

P;HTML|
;         (set_option_value  synth-unit-tests false)

P;HTML|
;         (set_option_value  optimize true)

P;HTML|
;         (set_option_value  transpiler silent)

P;HTML|
;          (set_debug  transpiler false)

P;HTML|
;         (set_option_value  compile false)

P;HTML|
;         (set_option_value  tabling auto)

P;HTML|
;         (set_option_value  log false)

P;HTML|
;         (set_option_value  output ./)

P;HTML|
;         (set_option_value  exeout ./Sav.gitlab.MeTTaLog)

P;HTML|
;         (set_option_value  halt false)

P;HTML|
;         (set_option_value  trace-length 500)

P;HTML|
;         (set_option_value  trace-on-overtime 4.0)

P;HTML|
;          (set_debug  overtime 4.0)

P;HTML|
;         (set_option_value  trace-on-overflow 1000)

P;HTML|
;          (set_debug  overflow 1000)

P;HTML|
;         (set_option_value  trace-on-eval false)

P;HTML|
;          (set_debug  eval false)

P;HTML|
;         (set_option_value  trace-on-load silent)

P;HTML|
;          (set_debug  load silent)

P;HTML|
;          (set_debug  trace-on-load false)

P;HTML|
;         (set_option_value  trace-on-exec false)

P;HTML|
;          (set_debug  exec false)

P;HTML|
;         (set_option_value  trace-on-error non-type)

P;HTML|
;          (set_debug  error non-type)

P;HTML|
;         (set_option_value  trace-on-fail false)

P;HTML|
;          (set_debug  fail false)

P;HTML|
;         (set_option_value  trace-on-test true)

P;HTML|
;          (set_debug  test true)

P;HTML|
;         (set_option_value  repl-on-error true)

P;HTML|
;         (set_option_value  repl-on-fail false)

P;HTML|
;         (set_option_value  exit-on-fail false)

P;HTML|
;         (set_option_value  repl auto)

P;HTML|
;         (set_option_value  prolog false)

P;HTML|
;         (set_option_value  exec noskip)

P;HTML|
;         (set_option_value  maximum-result-count inf)

P;HTML|
;         (set_option_value  html false)

P;HTML|
;         (set_option_value  python true)

P;HTML|
;         (set_option_value  trace-on-test false)

P;HTML|
;         (set_debug  test false)

P;HTML|
;         (set_option_value  trace-on-fail false)

P;HTML|
;         (set_debug  fail false)

P;HTML|
;         (set_option_value  load show)

P;HTML|
;         (set_option_value  test false)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta is 89.7K bytes (2.35K lines)
</span><span class="ansi1 ansi90"
>Info: File /home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta is 33 bytes (1 lines)
</span><span class="ansi32"
>% 46,854 inferences, 0.177 CPU in 0.177 seconds (100% CPU, 265180 Lips)
</span>P;HTML|
;          (is_cmd_option  prescan halt --halt=true true)
P;HTML|
;          (set_option_value  halt true)
P;HTML|
;          (is_cmd_option  prescan stdin --stdin=tty tty)
P;HTML|
;           (set_option_value  stdin tty)
P;HTML|
;          (is_cmd_option  prescan stdout --stdout=tty tty)
P;HTML|
;           (set_option_value  stdout tty)
P;HTML|
;          (is_cmd_option  prescan stderr --stderr=tty tty)
P;HTML|
;           (set_option_value  stderr tty)
P;HTML|
;          (set_option_value  compat false)
P;HTML|
;          (set_option_value  compatio false)
P;HTML|
;          (set_option_value  src_indents false)
P;HTML|
;          (set_option_value  devel false)
P;HTML|
;          (set_option_value  stack-max 500)
P;HTML|
;          (set_option_value  limit inf)
P;HTML|
;          (set_option_value  initial-result-count 10)
P;HTML|
;          (set_option_value  answer-format show)
P;HTML|
;          (set_option_value  repeats true)
P;HTML|
;          (set_option_value  time true)
P;HTML|
;          (set_option_value  synth-unit-tests false)
P;HTML|
;          (set_option_value  optimize true)
P;HTML|
;          (set_option_value  transpiler silent)
P;HTML|
;          (set_debug  transpiler false)
P;HTML|
;          (set_option_value  compile false)
P;HTML|
;          (set_option_value  tabling auto)
P;HTML|
;          (set_option_value  log false)
P;HTML|
;          (set_option_value  output ./)
P;HTML|
;          (set_option_value  exeout ./Sav.gitlab.MeTTaLog)
P;HTML|
;          (set_option_value  halt false)
P;HTML|
;          (set_option_value  trace-length 500)
P;HTML|
;          (set_option_value  trace-on-overtime 4.0)
P;HTML|
;          (set_debug  overtime 4.0)
P;HTML|
;          (set_option_value  trace-on-overflow 1000)
P;HTML|
;          (set_debug  overflow 1000)
P;HTML|
;          (set_option_value  trace-on-eval false)
P;HTML|
;          (set_debug  eval false)
P;HTML|
;          (set_option_value  trace-on-load silent)
P;HTML|
;          (set_debug  load silent)
P;HTML|
;          (set_debug  trace-on-load false)
P;HTML|
;          (set_option_value  trace-on-exec false)
P;HTML|
;          (set_debug  exec false)
P;HTML|
;          (set_option_value  trace-on-error non-type)
P;HTML|
;          (set_debug  error non-type)
P;HTML|
;          (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;          (set_option_value  trace-on-test true)
P;HTML|
;          (set_debug  test true)
P;HTML|
;          (set_option_value  repl-on-error true)
P;HTML|
;          (set_option_value  repl-on-fail false)
P;HTML|
;          (set_option_value  exit-on-fail false)
P;HTML|
;          (set_option_value  repl auto)
P;HTML|
;          (set_option_value  prolog false)
P;HTML|
;          (set_option_value  exec noskip)
P;HTML|
;          (set_option_value  maximum-result-count inf)
P;HTML|
;          (set_option_value  html false)
P;HTML|
;          (set_option_value  python true)
P;HTML|
;         (set_option_value  trace-on-test false)
P;HTML|
;          (set_debug  test false)
P;HTML|
;         (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;         (set_option_value  load show)
P;HTML|
;         (set_option_value  test true)
P;HTML|
;        (is_cmd_option  execute python --python=enable enable)
P;HTML|
;         (set_option_value  python enable)
P;HTML|
;        (is_cmd_option  execute timeout --timeout=40 40)
P;HTML|
;         (set_option_value  timeout 40)
P;HTML|
;         (is_cmd_option  execute output --output=./reports/tests_output/baseline-compat/ ./reports/tests_output/baseline-compat/)
P;HTML|
;         (set_option_value  output ./reports/tests_output/baseline-compat/)
P;HTML|
;         (is_cmd_option  execute html --html true)
P;HTML|
;          (set_option_value  html true)
P;HTML|
;         (is_cmd_option  execute test --test true)
P;HTML|
;          (set_option_value  test true)

; (load_metta_file  &self tests/baseline_compat/module-system/f1_imports.metta)
P;HTML|
;                       (track_load_into_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta)
P;HTML|
;                                        (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta)
P;HTML|
;                                         (= 1  "[()]")
P;HTML|
;                                         (= 2  "[()]")
P;HTML|
;                                         (= 3  "[()]")
P;HTML|
;                                         (= 4  "[()]")
P;HTML|
;                                         (= 5  "[()]")
P;HTML|
;                                         (= 6  "[()]")
P;HTML|
;                                         (= 7  "[()]")
P;HTML|
;                                         (= 8  "[()]")
P;HTML|
;                                         (= 9  "[()]")
P;HTML|
;                                         (= 10  "[()]")
P;HTML|
;                                         (= 11  "[()]")
P;HTML|
;                                         (= 12  "[()]")
P;HTML|
;                                         (= 13  "[()]")
P;HTML|
;                                         (= 14  "[()]")
P;HTML|
;                                         (= 15  "[()]")
P;HTML|
;                                         (= 16  "[()]")
P;HTML|
;                                         (= 17  "[()]")
P;HTML|
;                                         (= 18  "[()]")
P;HTML|
;                                         (= 19  "[()]")
P;HTML|
;                                         (= 20  "0.19user 0.00system 0:00.20elapsed 100%CPU (0avgtext+0avgdata 35952maxresident)k")
P;HTML|
;                                         (= 20  "0inputs+0outputs (0major+4794minor)pagefaults 0swaps")
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta is 5.11K bytes (128 lines)
</span>P;HTML|
;                                        (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta)

;;; NOTE: This test won't work outside the test environment because it relies on
;;;  specific atoms in a specific order in the space, and loading the default environment's
;;;  init.metta will break the assumptions in this test
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Even at the very beginning of the script `(get-atoms &self)`
;;; returns two atoms.  One is from the imported stdlib, and the other
;;; is corelib, which was a dependency of stdlib that has been promoted
;;; These atoms are both wrapped spaces, as is `&self`
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(assertEqual ((let $x (get-atoms &self) (get-type $x))) (superpose (((get-type &self)) ((get-type &self)))))

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.01"
>;; MODULE-SYSTEM.F1-IMPORTS.01</h3>

(failed  once (if_or_else  (eval  = $_502152 495 &self (let a b never-happens) $_503826) (call  eval (let a b never-happens) $_503826)))


(on_mettalog_error  (failed  once (if_or_else  (eval  = $_502152 495 &self (let a b never-happens) $_503826) (call  eval (let a b never-happens) $_503826))))

^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] call(user:once, user:if_or_else(eval(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826), call(eval, [let, a, b, 'never-happens'], _503826)))
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] once(user:if_or_else(eval(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826), call(eval, [let, a, b, 'never-happens'], _503826)))
   <span class="ansi1 ansi32"
>Call: </span>(299) [user] if_or_else(eval(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826), call(eval, [let, a, b, 'never-happens'], _503826))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] eval(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] catch_metta_return(eval_args(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826), _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_args(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_512236, _512238), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_512236, _512238))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_512236, _512238))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_514324, _514326), once(user:nonvar(_503826)), '$restore_trace'(_514324, _514326))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_514324, _514326))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_516412, _516414), once(user:nonvar(_503826)), '$restore_trace'(_516412, _516414))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_516412, _516414))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] setup_call_cleanup('$notrace'(_523568, _523570), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_523568, _523570))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] sig_atomic(system:'$notrace'(_523568, _523570))
^  <span class="ansi1 ansi31"
>Fail: </span>(304) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] eval_00(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] setup_call_cleanup('$notrace'(_528712, _528714), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_528712, _528714))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] sig_atomic(system:'$notrace'(_528712, _528714))
^  <span class="ansi1 ansi31"
>Fail: </span>(305) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] eval_01(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] 495<1
   <span class="ansi1 ansi31"
>Fail: </span>(308) [system] 495<1
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] setup_call_cleanup('$notrace'(_536948, _536950), once(user:(_536924 is 495-1, copy_term([let, a, b, 'never-happens'], _536938))), '$restore_trace'(_536948, _536950))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] sig_atomic(system:'$notrace'(_536948, _536950))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(494 is 495-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] trace_eval(eval_20(=, _502152), e, 494, '&self', [let, a, b, 'never-happens'], _540058)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] must_det_ll((notrace((flag(eval_num, _541112, _541112+1), _541130 is _541112 mod 500, _541148 is 99-494 mod 100, _541172=_541174, option_else('trace-length', _541186, 500), option_else('trace-depth', _541194, 30))), quietly(if_t((nop(stop_rtrace), _541130>_541186), (set_debug(eval, false), _541250 is _541186+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_541250])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_541302)))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] once(user:(notrace((flag(eval_num, _541112, _541112+1), _541130 is _541112 mod 500, _541148 is 99-494 mod 100, _541172=_541174, option_else('trace-length', _541186, 500), option_else('trace-depth', _541194, 30))), quietly(if_t((nop(stop_rtrace), _541130>_541186), (set_debug(eval, false), _541250 is _541186+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_541250])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_541302)))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] setup_call_cleanup('$notrace'(_543348, _543350), once(user:(flag(eval_num, _541112, _541112+1), _541130 is _541112 mod 500, _541148 is 99-494 mod 100, _541172=_541174, option_else('trace-length', _541186, 500), option_else('trace-depth', _541194, 30))), '$restore_trace'(_543348, _543350))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] sig_atomic(system:'$notrace'(_543348, _543350))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2880, 2880+1), 380 is 2880 mod 500, 5 is 99-494 mod 100, _541172=_541172, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 380>500), (set_debug(eval, false), _541250 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_541250])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 380>500), (set_debug(eval, false), _541250 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_541250])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] nop(notrace(no_repeats_var(_541302)))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] nop(notrace(no_repeats_var(_541302)))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] once(user:(notrace((flag(eval_num, 2880, 2880+1), 380 is 2880 mod 500, 5 is 99-494 mod 100, _541172=_541172, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 380>500), (set_debug(eval, false), _541250 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_541250])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_541302)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] must_det_ll(user:(notrace((flag(eval_num, 2880, 2880+1), 380 is 2880 mod 500, 5 is 99-494 mod 100, _541172=_541172, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 380>500), (set_debug(eval, false), _541250 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_541250])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_541302)))))
   <span class="ansi1 ansi32"
>Call: </span>(307) [occurs] occurs:sub_term(_553000, e)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(307) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(308) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(307) [occurs] occurs:sub_term(_553000, e)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _560106=e
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] if_trace((eval;e), (_541172=1, indentq(5, 380, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_563246, _563248), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _541172=1, indentq(5, 380, -->, [e, [let, a, b, 'never-happens']]))), _563204, fbug((_563204-->if_trace((eval;e), (_541172=1, indentq(5, 380, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_563246, _563248))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_563246, _563248))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _541172=1, indentq(5, 380, -->, [e, [let, a, b, 'never-happens']]))), _563204, fbug((_563204-->if_trace((eval;e), (_541172=1, indentq(5, 380, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] if_trace((eval;e), (_541172=1, indentq(5, 380, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _567442=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _569480=(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] (\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] call_cleanup(((call(eval_20(=, _502152), 494, '&self', [let, a, b, 'never-happens'], _540058)*->nb_setarg(1, retval(fail), _540058);fail, trace, call(eval_20(=, _502152), 494, '&self', [let, a, b, 'never-happens'], _540058)), ignore(notrace((\+_540058\=_541302, nb_setarg(1, retval(fail), _540058))))), ignore((_541172==1->ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_20(=, _502152, 494, '&self', [let, a, b, 'never-happens'], _540058)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] setup_call_cleanup('$notrace'(_576888, _576890), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_576888, _576890))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(system:'$notrace'(_576888, _576890))
^  <span class="ansi1 ansi31"
>Fail: </span>(311) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(311) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] once(expand_eval([let, a, b, 'never-happens'], _599232))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] expand_eval([let, a, b, 'never-happens'], _599232)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _605332)
   <span class="ansi1 ansi32"
>Call: </span>(313) [apply] apply:maplist_([a, b, 'never-happens'], _605332, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] expand_eval(a, _607388)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] a=_607388
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(314) [apply] apply:maplist_([b, 'never-happens'], _607390, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] expand_eval(b, _613490)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] b=_613490
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(315) [apply] apply:maplist_(['never-happens'], _613492, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] expand_eval('never-happens', _619592)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] 'never-happens'=_619592
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(316) [apply] apply:maplist_([], _619594, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(314) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] possible_type('&self', a, _636884)
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] possible_type('&self', a, _636884)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] eval_args(=, _636884, 494, '&self', b, _638926)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_640984, _640986), once(user:self_eval(b)), '$restore_trace'(_640984, _640986))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_640984, _640986))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] _638926=b
   <span class="ansi1 ansi32"
>Exit: </span>(311) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] eval_args(=, _636884, 494, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] eval_20(=, _502152, 494, '&self', [let, a, b, 'never-happens'], _540058)
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(309) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] ignore((_541172==1->ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] _541172==1
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] _541172==1
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_654314, _654316), once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)])))))))), '$restore_trace'(_654314, _654316))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_654314, _654316))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] ignore(user:(_541172==1->ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(307) [system] call_cleanup(user:((call(eval_20(=, _502152), 494, '&self', [let, a, b, 'never-happens'], _540058)*->nb_setarg(1, retval(fail), _540058);fail, trace, call(eval_20(=, _502152), 494, '&self', [let, a, b, 'never-happens'], _540058)), ignore(notrace((\+_540058\=_541302, nb_setarg(1, retval(fail), _540058))))), user:ignore((_541172==1->ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _569500, _569500+1), (retval(fail)\=@=retval(fail), nonvar(_540058)->indentq(5, _569500, <--, [e, _540058]);indentq(5, _569500, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(306) [user] trace_eval(eval_20(=, _502152), e, 494, '&self', [let, a, b, 'never-happens'], _540058)
^  <span class="ansi1 ansi31"
>Fail: </span>(303) [user] eval_args(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] call(eval, [let, a, b, 'never-happens'], _503826)
   <span class="ansi1 ansi32"
>Call: </span>(301) [user] eval([let, a, b, 'never-happens'], _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] current_self(_663722)
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] nb_current(self_space, _663722)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(302) [user] eval('&self', [let, a, b, 'never-happens'], _503826)
   <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] catch_metta_return(eval_args(=, _671836, 500, '&self', [let, a, b, 'never-happens'], _503826), _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_args(=, _671836, 500, '&self', [let, a, b, 'never-happens'], _503826)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_674946, _674948), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_674946, _674948))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_674946, _674948))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_677034, _677036), once(user:nonvar(_503826)), '$restore_trace'(_677034, _677036))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_677034, _677036))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_679122, _679124), once(user:nonvar(_503826)), '$restore_trace'(_679122, _679124))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_679122, _679124))
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_686278, _686280), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_686278, _686280))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_686278, _686280))
^  <span class="ansi1 ansi31"
>Fail: </span>(307) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] eval_00(=, _671836, 500, '&self', [let, a, b, 'never-happens'], _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_691422, _691424), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_691422, _691424))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_691422, _691424))
^  <span class="ansi1 ansi31"
>Fail: </span>(308) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] eval_01(=, _671836, 500, '&self', [let, a, b, 'never-happens'], _503826)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_699658, _699660), once(user:(_699634 is 500-1, copy_term([let, a, b, 'never-happens'], _699648))), '$restore_trace'(_699658, _699660))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_699658, _699660))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] trace_eval(eval_20(=, _671836), e, 499, '&self', [let, a, b, 'never-happens'], _702768)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] must_det_ll((notrace((flag(eval_num, _703822, _703822+1), _703840 is _703822 mod 500, _703858 is 99-499 mod 100, _703882=_703884, option_else('trace-length', _703896, 500), option_else('trace-depth', _703904, 30))), quietly(if_t((nop(stop_rtrace), _703840>_703896), (set_debug(eval, false), _703960 is _703896+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_703960])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_704012)))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] once(user:(notrace((flag(eval_num, _703822, _703822+1), _703840 is _703822 mod 500, _703858 is 99-499 mod 100, _703882=_703884, option_else('trace-length', _703896, 500), option_else('trace-depth', _703904, 30))), quietly(if_t((nop(stop_rtrace), _703840>_703896), (set_debug(eval, false), _703960 is _703896+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_703960])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_704012)))))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] setup_call_cleanup('$notrace'(_706058, _706060), once(user:(flag(eval_num, _703822, _703822+1), _703840 is _703822 mod 500, _703858 is 99-499 mod 100, _703882=_703884, option_else('trace-length', _703896, 500), option_else('trace-depth', _703904, 30))), '$restore_trace'(_706058, _706060))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] sig_atomic(system:'$notrace'(_706058, _706060))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2881, 2881+1), 381 is 2881 mod 500, 0 is 99-499 mod 100, _703882=_703882, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 381>500), (set_debug(eval, false), _703960 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_703960])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 381>500), (set_debug(eval, false), _703960 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_703960])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] nop(notrace(no_repeats_var(_704012)))
   <span class="ansi1 ansi32"
>Exit: </span>(313) [user] nop(notrace(no_repeats_var(_704012)))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] once(user:(notrace((flag(eval_num, 2881, 2881+1), 381 is 2881 mod 500, 0 is 99-499 mod 100, _703882=_703882, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 381>500), (set_debug(eval, false), _703960 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_703960])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_704012)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] must_det_ll(user:(notrace((flag(eval_num, 2881, 2881+1), 381 is 2881 mod 500, 0 is 99-499 mod 100, _703882=_703882, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 381>500), (set_debug(eval, false), _703960 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_703960])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_704012)))))
   <span class="ansi1 ansi32"
>Call: </span>(310) [occurs] occurs:sub_term(_715710, e)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(310) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(310) [occurs] occurs:sub_term(_715710, e)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _722816=e
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] if_trace((eval;e), (_703882=1, indentq(0, 381, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_725956, _725958), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _703882=1, indentq(0, 381, -->, [e, [let, a, b, 'never-happens']]))), _725914, fbug((_725914-->if_trace((eval;e), (_703882=1, indentq(0, 381, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_725956, _725958))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_725956, _725958))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _703882=1, indentq(0, 381, -->, [e, [let, a, b, 'never-happens']]))), _725914, fbug((_725914-->if_trace((eval;e), (_703882=1, indentq(0, 381, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_trace((eval;e), (_703882=1, indentq(0, 381, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _730152=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _732190=(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] (\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] call_cleanup(((call(eval_20(=, _671836), 499, '&self', [let, a, b, 'never-happens'], _702768)*->nb_setarg(1, retval(fail), _702768);fail, trace, call(eval_20(=, _671836), 499, '&self', [let, a, b, 'never-happens'], _702768)), ignore(notrace((\+_702768\=_704012, nb_setarg(1, retval(fail), _702768))))), ignore((_703882==1->ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval_20(=, _671836, 499, '&self', [let, a, b, 'never-happens'], _702768)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] setup_call_cleanup('$notrace'(_739598, _739600), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_739598, _739600))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] sig_atomic(system:'$notrace'(_739598, _739600))
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] once(expand_eval([let, a, b, 'never-happens'], _761942))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] expand_eval([let, a, b, 'never-happens'], _761942)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _768042)
   <span class="ansi1 ansi32"
>Call: </span>(316) [apply] apply:maplist_([a, b, 'never-happens'], _768042, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] expand_eval(a, _770098)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] a=_770098
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(317) [apply] apply:maplist_([b, 'never-happens'], _770100, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] expand_eval(b, _776200)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] b=_776200
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(318) [apply] apply:maplist_(['never-happens'], _776202, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] expand_eval('never-happens', _782302)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] 'never-happens'=_782302
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(319) [apply] apply:maplist_([], _782304, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(317) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] possible_type('&self', a, _799594)
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] possible_type('&self', a, _799594)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval_args(=, _799594, 499, '&self', b, _801636)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_803694, _803696), once(user:self_eval(b)), '$restore_trace'(_803694, _803696))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_803694, _803696))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] _801636=b
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] eval_args(=, _799594, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(312) [user] eval_20(=, _671836, 499, '&self', [let, a, b, 'never-happens'], _702768)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(312) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] ignore((_703882==1->ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] _703882==1
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] _703882==1
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_817024, _817026), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)])))))))), '$restore_trace'(_817024, _817026))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_817024, _817026))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] ignore(user:(_703882==1->ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(310) [system] call_cleanup(user:((call(eval_20(=, _671836), 499, '&self', [let, a, b, 'never-happens'], _702768)*->nb_setarg(1, retval(fail), _702768);fail, trace, call(eval_20(=, _671836), 499, '&self', [let, a, b, 'never-happens'], _702768)), ignore(notrace((\+_702768\=_704012, nb_setarg(1, retval(fail), _702768))))), user:ignore((_703882==1->ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _732210, _732210+1), (retval(fail)\=@=retval(fail), nonvar(_702768)->indentq(0, _732210, <--, [e, _702768]);indentq(0, _732210, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] trace_eval(eval_20(=, _671836), e, 499, '&self', [let, a, b, 'never-happens'], _702768)
^  <span class="ansi1 ansi31"
>Fail: </span>(306) [user] eval_args(=, _671836, 500, '&self', [let, a, b, 'never-happens'], _503826)
^  <span class="ansi1 ansi31"
>Fail: </span>(297) [system] call(user:once, user:if_or_else(eval(=, _502152, 495, '&self', [let, a, b, 'never-happens'], _503826), call(eval, [let, a, b, 'never-happens'], _503826)))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(299) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] setup_call_cleanup('$notrace'(_828486, _828488), once(rtrace:retract(t_l:tracer_reset(_828476))), '$restore_trace'(_828486, _828488))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] sig_atomic(system:'$notrace'(_828486, _828488))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [rtrace] tAt(false, 271, 271, false)
; 
; EVAL TEST
; took 1.001 secs. (1000.96 milliseconds) 

!(assertEqual ((let $x (get-atoms &self) (get-type $x))) (superpose (((get-type &self)) ((get-type &self)))))

<span class="ansi31"
>(loonit_failureR  (equal_enough_for_test  ((hyperon::space::DynSpace) (hyperon::space::DynSpace) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (()) (DocInformal) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (())) ((hyperon::space::DynSpace) (hyperon::space::DynSpace))))
</span>
Deterministic: ((Error  (got  ((hyperon::space::DynSpace) (hyperon::space::DynSpace) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (()) (DocInformal) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()))) (expected  ((hyperon::space::DynSpace) (hyperon::space::DynSpace)))))
;;; stdlib is already loaded
<span class="ansi38-013099040"
>!(assertEqual (if (> 1 2) 1 2) 2)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.02"
>;; MODULE-SYSTEM.F1-IMPORTS.02</h3>
; 
; EVAL TEST
; took 0.000250 secs. (250.35 microseconds) 

!(assertEqual (if (> 1 2) 1 2) 2)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (2) (2)))
</span>
Deterministic: ()
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Importing the module into new space
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &m f1_moduleA)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta)
P;HTML|
;                                         (= 1  "[()]")
P;HTML|
;                                         (= 2  "[()]")
P;HTML|
;                                         (= 3  "0.05user 0.00system 0:00.06elapsed 98%CPU (0avgtext+0avgdata 32252maxresident)k")
P;HTML|
;                                         (= 3  "0inputs+0outputs (0major+3916minor)pagefaults 0swaps")
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta is 621 bytes (17 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta is 292 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Number))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()
;;; FIXME? stdlib space is not available at importing time -
;;; only tokens / grounded operations work, while symbolic functions
;;; (like `if`) don't work.
;;; FIXME? Exceptions are not caught by `importOp`
<span class="ansi38-013099040"
>!(assertEqual (+ 1 2) 3)

</span>
;<h3 id="MODULE-SYSTEM.F1-MODULEA.03"
>;; MODULE-SYSTEM.F1-MODULEA.03</h3>
; 
; EVAL TEST
; took 0.000185 secs. (184.88 microseconds) 

!(assertEqual (+ 1 2) 3)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (3) (3)))
</span>
Deterministic: ()
;;; !(assertEqual (if True "S" "F") "S")
<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (+ $x 10) (g $x)))
</span><span class="ansi38-255165000"
> (: f (-> Number Number))
</span><span class="ansi38-255165000"
> (= (f $x) (if (< $x 0) (- 0 $x) (g (+ 1 $x))))
</span>
Last Result(2): ()
;;; Check whether passed expression contains atom for which condition is True
<span class="ansi38-255165000"
> (: contains (-> Expression (-> Atom Bool) Bool))
</span><span class="ansi38-255165000"
> (= (contains $list $condition) (if (== $list ()) False (let $head (car-atom $list) (if ($condition $head) True (let $tail (cdr-atom $list) (contains $tail $condition))))))
</span>;;; Check whether atom is space comparing its type with type of the &self atom
<span class="ansi38-255165000"
> (: is-space (-> Atom Bool))
</span><span class="ansi38-255165000"
> (= (is-space $atom) (let* (($type (get-type $atom)) ($space (get-type &self))) (== $type $space)))
</span>;;; It's first atom is a space
<span class="ansi38-013099040"
>!(assertEqual (let $x (collapse (get-atoms &m)) (contains $x is-space)) True)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.04"
>;; MODULE-SYSTEM.F1-IMPORTS.04</h3>

(failed  once (if_or_else  (eval  = $_296154 495 &self (let a b never-happens) $_297828) (call  eval (let a b never-happens) $_297828)))


(on_mettalog_error  (failed  once (if_or_else  (eval  = $_296154 495 &self (let a b never-happens) $_297828) (call  eval (let a b never-happens) $_297828))))

^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] call(user:once, user:if_or_else(eval(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828), call(eval, [let, a, b, 'never-happens'], _297828)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] once(user:if_or_else(eval(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828), call(eval, [let, a, b, 'never-happens'], _297828)))
   <span class="ansi1 ansi32"
>Call: </span>(311) [user] if_or_else(eval(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828), call(eval, [let, a, b, 'never-happens'], _297828))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] catch_metta_return(eval_args(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828), _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_args(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_306238, _306240), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_306238, _306240))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_306238, _306240))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_308326, _308328), once(user:nonvar(_297828)), '$restore_trace'(_308326, _308328))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_308326, _308328))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_310414, _310416), once(user:nonvar(_297828)), '$restore_trace'(_310414, _310416))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_310414, _310416))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_317570, _317572), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_317570, _317572))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_317570, _317572))
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_00(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_322714, _322716), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_322714, _322716))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_322714, _322716))
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] eval_01(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] 495<1
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] 495<1
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_330950, _330952), once(user:(_330926 is 495-1, copy_term([let, a, b, 'never-happens'], _330940))), '$restore_trace'(_330950, _330952))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_330950, _330952))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(494 is 495-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] trace_eval(eval_20(=, _296154), e, 494, '&self', [let, a, b, 'never-happens'], _334060)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] must_det_ll((notrace((flag(eval_num, _335114, _335114+1), _335132 is _335114 mod 500, _335150 is 99-494 mod 100, _335174=_335176, option_else('trace-length', _335188, 500), option_else('trace-depth', _335196, 30))), quietly(if_t((nop(stop_rtrace), _335132>_335188), (set_debug(eval, false), _335252 is _335188+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335252])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335304)))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] once(user:(notrace((flag(eval_num, _335114, _335114+1), _335132 is _335114 mod 500, _335150 is 99-494 mod 100, _335174=_335176, option_else('trace-length', _335188, 500), option_else('trace-depth', _335196, 30))), quietly(if_t((nop(stop_rtrace), _335132>_335188), (set_debug(eval, false), _335252 is _335188+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335252])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335304)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] setup_call_cleanup('$notrace'(_337350, _337352), once(user:(flag(eval_num, _335114, _335114+1), _335132 is _335114 mod 500, _335150 is 99-494 mod 100, _335174=_335176, option_else('trace-length', _335188, 500), option_else('trace-depth', _335196, 30))), '$restore_trace'(_337350, _337352))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] sig_atomic(system:'$notrace'(_337350, _337352))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2078, 2078+1), 78 is 2078 mod 500, 5 is 99-494 mod 100, _335174=_335174, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _335252 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335252])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _335252 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335252])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(322) [user] nop(notrace(no_repeats_var(_335304)))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [user] nop(notrace(no_repeats_var(_335304)))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] once(user:(notrace((flag(eval_num, 2078, 2078+1), 78 is 2078 mod 500, 5 is 99-494 mod 100, _335174=_335174, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _335252 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335252])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335304)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] must_det_ll(user:(notrace((flag(eval_num, 2078, 2078+1), 78 is 2078 mod 500, 5 is 99-494 mod 100, _335174=_335174, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 78>500), (set_debug(eval, false), _335252 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335252])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335304)))))
   <span class="ansi1 ansi32"
>Call: </span>(319) [occurs] occurs:sub_term(_347002, e)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [occurs] occurs:sub_term(_347002, e)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _354108=e
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] if_trace((eval;e), (_335174=1, indentq(5, 78, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_357248, _357250), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _335174=1, indentq(5, 78, -->, [e, [let, a, b, 'never-happens']]))), _357206, fbug((_357206-->if_trace((eval;e), (_335174=1, indentq(5, 78, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_357248, _357250))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_357248, _357250))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _335174=1, indentq(5, 78, -->, [e, [let, a, b, 'never-happens']]))), _357206, fbug((_357206-->if_trace((eval;e), (_335174=1, indentq(5, 78, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] if_trace((eval;e), (_335174=1, indentq(5, 78, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _361444=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _363482=(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] (\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] call_cleanup(((call(eval_20(=, _296154), 494, '&self', [let, a, b, 'never-happens'], _334060)*->nb_setarg(1, retval(fail), _334060);fail, trace, call(eval_20(=, _296154), 494, '&self', [let, a, b, 'never-happens'], _334060)), ignore(notrace((\+_334060\=_335304, nb_setarg(1, retval(fail), _334060))))), ignore((_335174==1->ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] eval_20(=, _296154, 494, '&self', [let, a, b, 'never-happens'], _334060)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_370890, _370892), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_370890, _370892))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_370890, _370892))
^  <span class="ansi1 ansi31"
>Fail: </span>(323) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] once(expand_eval([let, a, b, 'never-happens'], _393234))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] expand_eval([let, a, b, 'never-happens'], _393234)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _399334)
   <span class="ansi1 ansi32"
>Call: </span>(325) [apply] apply:maplist_([a, b, 'never-happens'], _399334, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] expand_eval(a, _401390)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] a=_401390
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(326) [apply] apply:maplist_([b, 'never-happens'], _401392, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] expand_eval(b, _407492)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] b=_407492
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(327) [apply] apply:maplist_(['never-happens'], _407494, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] expand_eval('never-happens', _413594)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] 'never-happens'=_413594
   <span class="ansi1 ansi32"
>Exit: </span>(329) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(328) [apply] apply:maplist_([], _413596, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] possible_type('&self', a, _430886)
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] possible_type('&self', a, _430886)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] eval_args(=, _430886, 494, '&self', b, _432928)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_434986, _434988), once(user:self_eval(b)), '$restore_trace'(_434986, _434988))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_434986, _434988))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _432928=b
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] eval_args(=, _430886, 494, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] eval_20(=, _296154, 494, '&self', [let, a, b, 'never-happens'], _334060)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] ignore((_335174==1->ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _335174==1
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] _335174==1
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_448316, _448318), once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)])))))))), '$restore_trace'(_448316, _448318))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_448316, _448318))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] ignore(user:(_335174==1->ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [system] call_cleanup(user:((call(eval_20(=, _296154), 494, '&self', [let, a, b, 'never-happens'], _334060)*->nb_setarg(1, retval(fail), _334060);fail, trace, call(eval_20(=, _296154), 494, '&self', [let, a, b, 'never-happens'], _334060)), ignore(notrace((\+_334060\=_335304, nb_setarg(1, retval(fail), _334060))))), user:ignore((_335174==1->ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363502, _363502+1), (retval(fail)\=@=retval(fail), nonvar(_334060)->indentq(5, _363502, <--, [e, _334060]);indentq(5, _363502, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] trace_eval(eval_20(=, _296154), e, 494, '&self', [let, a, b, 'never-happens'], _334060)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] eval_args(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] call(eval, [let, a, b, 'never-happens'], _297828)
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval([let, a, b, 'never-happens'], _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] current_self(_457724)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nb_current(self_space, _457724)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(314) [user] eval('&self', [let, a, b, 'never-happens'], _297828)
   <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] catch_metta_return(eval_args(=, _465838, 500, '&self', [let, a, b, 'never-happens'], _297828), _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] eval_args(=, _465838, 500, '&self', [let, a, b, 'never-happens'], _297828)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_468948, _468950), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_468948, _468950))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_468948, _468950))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_471036, _471038), once(user:nonvar(_297828)), '$restore_trace'(_471036, _471038))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_471036, _471038))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_473124, _473126), once(user:nonvar(_297828)), '$restore_trace'(_473124, _473126))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_473124, _473126))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_480280, _480282), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_480280, _480282))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_480280, _480282))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_00(=, _465838, 500, '&self', [let, a, b, 'never-happens'], _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_485424, _485426), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_485424, _485426))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_485424, _485426))
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] eval_01(=, _465838, 500, '&self', [let, a, b, 'never-happens'], _297828)
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_493660, _493662), once(user:(_493636 is 500-1, copy_term([let, a, b, 'never-happens'], _493650))), '$restore_trace'(_493660, _493662))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_493660, _493662))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] trace_eval(eval_20(=, _465838), e, 499, '&self', [let, a, b, 'never-happens'], _496770)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] must_det_ll((notrace((flag(eval_num, _497824, _497824+1), _497842 is _497824 mod 500, _497860 is 99-499 mod 100, _497884=_497886, option_else('trace-length', _497898, 500), option_else('trace-depth', _497906, 30))), quietly(if_t((nop(stop_rtrace), _497842>_497898), (set_debug(eval, false), _497962 is _497898+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497962])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_498014)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] once(user:(notrace((flag(eval_num, _497824, _497824+1), _497842 is _497824 mod 500, _497860 is 99-499 mod 100, _497884=_497886, option_else('trace-length', _497898, 500), option_else('trace-depth', _497906, 30))), quietly(if_t((nop(stop_rtrace), _497842>_497898), (set_debug(eval, false), _497962 is _497898+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497962])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_498014)))))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] setup_call_cleanup('$notrace'(_500060, _500062), once(user:(flag(eval_num, _497824, _497824+1), _497842 is _497824 mod 500, _497860 is 99-499 mod 100, _497884=_497886, option_else('trace-length', _497898, 500), option_else('trace-depth', _497906, 30))), '$restore_trace'(_500060, _500062))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] sig_atomic(system:'$notrace'(_500060, _500062))
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2079, 2079+1), 79 is 2079 mod 500, 0 is 99-499 mod 100, _497884=_497884, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _497962 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497962])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _497962 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497962])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(325) [user] nop(notrace(no_repeats_var(_498014)))
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] nop(notrace(no_repeats_var(_498014)))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] once(user:(notrace((flag(eval_num, 2079, 2079+1), 79 is 2079 mod 500, 0 is 99-499 mod 100, _497884=_497884, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _497962 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497962])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_498014)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] must_det_ll(user:(notrace((flag(eval_num, 2079, 2079+1), 79 is 2079 mod 500, 0 is 99-499 mod 100, _497884=_497884, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 79>500), (set_debug(eval, false), _497962 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497962])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_498014)))))
   <span class="ansi1 ansi32"
>Call: </span>(322) [occurs] occurs:sub_term(_509712, e)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(322) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [occurs] occurs:sub_term(_509712, e)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _516818=e
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] if_trace((eval;e), (_497884=1, indentq(0, 79, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_519958, _519960), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _497884=1, indentq(0, 79, -->, [e, [let, a, b, 'never-happens']]))), _519916, fbug((_519916-->if_trace((eval;e), (_497884=1, indentq(0, 79, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_519958, _519960))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_519958, _519960))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _497884=1, indentq(0, 79, -->, [e, [let, a, b, 'never-happens']]))), _519916, fbug((_519916-->if_trace((eval;e), (_497884=1, indentq(0, 79, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] if_trace((eval;e), (_497884=1, indentq(0, 79, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _524154=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _526192=(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] (\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] call_cleanup(((call(eval_20(=, _465838), 499, '&self', [let, a, b, 'never-happens'], _496770)*->nb_setarg(1, retval(fail), _496770);fail, trace, call(eval_20(=, _465838), 499, '&self', [let, a, b, 'never-happens'], _496770)), ignore(notrace((\+_496770\=_498014, nb_setarg(1, retval(fail), _496770))))), ignore((_497884==1->ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] eval_20(=, _465838, 499, '&self', [let, a, b, 'never-happens'], _496770)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] setup_call_cleanup('$notrace'(_533600, _533602), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_533600, _533602))
^  <span class="ansi1 ansi32"
>Call: </span>(329) [system] sig_atomic(system:'$notrace'(_533600, _533602))
^  <span class="ansi1 ansi31"
>Fail: </span>(326) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] once(expand_eval([let, a, b, 'never-happens'], _555944))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] expand_eval([let, a, b, 'never-happens'], _555944)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _562044)
   <span class="ansi1 ansi32"
>Call: </span>(328) [apply] apply:maplist_([a, b, 'never-happens'], _562044, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] expand_eval(a, _564100)
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] a=_564100
   <span class="ansi1 ansi32"
>Exit: </span>(330) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(329) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(329) [apply] apply:maplist_([b, 'never-happens'], _564102, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] expand_eval(b, _570202)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] b=_570202
   <span class="ansi1 ansi32"
>Exit: </span>(331) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(330) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(330) [apply] apply:maplist_(['never-happens'], _570204, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] expand_eval('never-happens', _576304)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] 'never-happens'=_576304
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(331) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(331) [apply] apply:maplist_([], _576306, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(331) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(330) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(329) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] possible_type('&self', a, _593596)
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [user] possible_type('&self', a, _593596)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] eval_args(=, _593596, 499, '&self', b, _595638)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] setup_call_cleanup('$notrace'(_597696, _597698), once(user:self_eval(b)), '$restore_trace'(_597696, _597698))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] sig_atomic(system:'$notrace'(_597696, _597698))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _595638=b
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [user] eval_args(=, _593596, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(324) [user] eval_20(=, _465838, 499, '&self', [let, a, b, 'never-happens'], _496770)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] ignore((_497884==1->ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _497884==1
   <span class="ansi1 ansi31"
>Fail: </span>(326) [system] _497884==1
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] setup_call_cleanup('$notrace'(_611026, _611028), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)])))))))), '$restore_trace'(_611026, _611028))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] sig_atomic(system:'$notrace'(_611026, _611028))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] ignore(user:(_497884==1->ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(322) [system] call_cleanup(user:((call(eval_20(=, _465838), 499, '&self', [let, a, b, 'never-happens'], _496770)*->nb_setarg(1, retval(fail), _496770);fail, trace, call(eval_20(=, _465838), 499, '&self', [let, a, b, 'never-happens'], _496770)), ignore(notrace((\+_496770\=_498014, nb_setarg(1, retval(fail), _496770))))), user:ignore((_497884==1->ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526212, _526212+1), (retval(fail)\=@=retval(fail), nonvar(_496770)->indentq(0, _526212, <--, [e, _496770]);indentq(0, _526212, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] trace_eval(eval_20(=, _465838), e, 499, '&self', [let, a, b, 'never-happens'], _496770)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] eval_args(=, _465838, 500, '&self', [let, a, b, 'never-happens'], _297828)
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [system] call(user:once, user:if_or_else(eval(=, _296154, 495, '&self', [let, a, b, 'never-happens'], _297828), call(eval, [let, a, b, 'never-happens'], _297828)))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] setup_call_cleanup('$notrace'(_622488, _622490), once(rtrace:retract(t_l:tracer_reset(_622478))), '$restore_trace'(_622488, _622490))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(system:'$notrace'(_622488, _622490))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [rtrace] tAt(false, 271, 271, false)
<span class="ansi1 ansi90"
>Info: Processing progress: 100% </span>[4] current_output closed; set to user_output
<span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta progress.
</span><span class="ansi1 ansi90"
>Info: Processing progress: 100% </span>[5] current_output closed; set to user_output
<span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/src/canary/corelib.metta progress.
</span><span class="ansi1 ansi90"
>Info: Processing progress: 100% </span><span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta progress.
</span><span class="ansi1 ansi90"
>Info: Processing progress: 100% </span><span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta progress.
</span><span class="ansi1 ansi90"
>Info: Processing progress: 100% </span><span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta progress.
</span>; 
; EVAL TEST
; took 13.80 seconds.

!(assertEqual (let $x (collapse (get-atoms &m)) (contains $x is-space)) True)

<span class="ansi31"
>(loonit_failureR  (equal_enough_for_test  () (True)))
</span>
Deterministic: ((Error  (got  ()) (expected  (True))))
;;; FIXME? Now, it is moduleC space.
;;;        Should it be `stdlib` atom for a separately imported space
;;; !(let $x (collapse (get-atoms &m)) (car-atom $x))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Without additional means like `(&m.f 2)` notation or `(interpret &m (f 2))`,
;;; we cannot execute functions from the separate space - we can only use `match`.
;;; Although `&m` imports another space with definition of `g`, it is not reduced
;;; because it is not defined in the context of `&self`. This is the expected
;;; behavior, but it shows that this way of importing spaces is not too useful
;;; for importing modules with functions.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(assertEqual (match &m (= (f 2) $x) $x) (g 3))

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.05"
>;; MODULE-SYSTEM.F1-IMPORTS.05</h3>
; 
; EVAL TEST
; took 0.003 secs. (3.44 milliseconds) 

!(assertEqual (match &m (= (f 2) $x) $x) (g 3))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  ((g 3)) ((g 3))))
</span>
Deterministic: ()
;;; Importing the same space into `&self` should break nothing
;;; TODO? If stdlib space would be in `&m`, which should check that it is not
;;; there anymore since in should be removed after importing it to `&self`
<span class="ansi38-013099040"
>!(import! &self f1_moduleA)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta is 621 bytes (17 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta is 292 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Number))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()
;;; FIXME? stdlib space is not available at importing time -
;;; only tokens / grounded operations work, while symbolic functions
;;; (like `if`) don't work.
;;; FIXME? Exceptions are not caught by `importOp`
<span class="ansi38-013099040"
>!(assertEqual (+ 1 2) 3)

</span>
;<h3 id="MODULE-SYSTEM.F1-MODULEA.06"
>;; MODULE-SYSTEM.F1-MODULEA.06</h3>
; 
; EVAL TEST
; took 0.000180 secs. (180.39 microseconds) 

!(assertEqual (+ 1 2) 3)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (3) (3)))
</span>
Deterministic: ()
;;; !(assertEqual (if True "S" "F") "S")
<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (+ $x 10) (g $x)))
</span><span class="ansi38-255165000"
> (: f (-> Number Number))
</span><span class="ansi38-255165000"
> (= (f $x) (if (< $x 0) (- 0 $x) (g (+ 1 $x))))
</span>
Last Result(2): ()
;;; Now indirectly imported `g` works and `f` fully works
<span class="ansi38-013099040"
>!(assertEqual (g 2) 102)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.07"
>;; MODULE-SYSTEM.F1-IMPORTS.07</h3>
; 
; EVAL TEST
; took 0.000787 secs. (787.42 microseconds) 

!(assertEqual (g 2) 102)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102) (102)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (f 2) 103)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.08"
>;; MODULE-SYSTEM.F1-IMPORTS.08</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.32 milliseconds) 

!(assertEqual (f 2) 103)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (103) (103)))
</span>
Deterministic: ()
;;; `&self` contains 4 grounded sub-spaces now:
;;; - stdlib
;;; - corelib
;;; - moduleA itself, which is the same as &m
;;; - moduleC imported by moduleA and removed from A after its import to &self
;;; Check whether atom is &m
<span class="ansi38-255165000"
> (: is-m (-> Atom Bool))
</span><span class="ansi38-255165000"
> (= (is-m $atom) (== $atom &m))
</span>;;; Assert that the &self space contains the same space as &m, which we imported from moduleA
;;; TODO: Comparing spaces like this doesn't work because the source module is the same, but a specialized
;;;   clone of the dependent space without transitive-dependencies was created during the import process.
;;;   Ideally, we can rework importing so that a special space copy isn't created, and then comparing
;;;   spaces will work again.  But, In my opinion comparing spaces is not a good way to check to see if a
;;;   module has been loaded.  I believe a better solution is accessor operations for loaded & imported modules
;;;
;;;!(assertEqual
;;;  (let $a (collapse (get-atoms &self)) (contains $a is-m))
;;;  True)
;;; Check that the &self space contains the corelib child space
;;; Note: corelib doesn't import any modules into itself, so no space copy is needed
<span class="ansi38-013099040"
>!(import! &corelib corelib)

</span>
Deterministic: ()<span class="ansi38-255165000"
> (: is-corelib (-> Atom Bool))
</span><span class="ansi38-255165000"
> (= (is-corelib $atom) (== $atom &corelib))
</span><span class="ansi38-013099040"
>!(assertEqual (let $a (collapse (get-atoms &self)) (contains $a is-corelib)) True)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.09"
>;; MODULE-SYSTEM.F1-IMPORTS.09</h3>

(failed  once (if_or_else  (eval  = $_296114 495 &self (let a b never-happens) $_297788) (call  eval (let a b never-happens) $_297788)))


(on_mettalog_error  (failed  once (if_or_else  (eval  = $_296114 495 &self (let a b never-happens) $_297788) (call  eval (let a b never-happens) $_297788))))

^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] call(user:once, user:if_or_else(eval(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788), call(eval, [let, a, b, 'never-happens'], _297788)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] once(user:if_or_else(eval(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788), call(eval, [let, a, b, 'never-happens'], _297788)))
   <span class="ansi1 ansi32"
>Call: </span>(311) [user] if_or_else(eval(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788), call(eval, [let, a, b, 'never-happens'], _297788))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] catch_metta_return(eval_args(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788), _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_args(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_306198, _306200), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_306198, _306200))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_306198, _306200))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_308286, _308288), once(user:nonvar(_297788)), '$restore_trace'(_308286, _308288))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_308286, _308288))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_310374, _310376), once(user:nonvar(_297788)), '$restore_trace'(_310374, _310376))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_310374, _310376))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_317530, _317532), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_317530, _317532))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_317530, _317532))
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_00(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_322674, _322676), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_322674, _322676))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_322674, _322676))
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] eval_01(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] 495<1
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] 495<1
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_330910, _330912), once(user:(_330886 is 495-1, copy_term([let, a, b, 'never-happens'], _330900))), '$restore_trace'(_330910, _330912))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_330910, _330912))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(494 is 495-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] trace_eval(eval_20(=, _296114), e, 494, '&self', [let, a, b, 'never-happens'], _334020)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] must_det_ll((notrace((flag(eval_num, _335074, _335074+1), _335092 is _335074 mod 500, _335110 is 99-494 mod 100, _335134=_335136, option_else('trace-length', _335148, 500), option_else('trace-depth', _335156, 30))), quietly(if_t((nop(stop_rtrace), _335092>_335148), (set_debug(eval, false), _335212 is _335148+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335212])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335264)))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] once(user:(notrace((flag(eval_num, _335074, _335074+1), _335092 is _335074 mod 500, _335110 is 99-494 mod 100, _335134=_335136, option_else('trace-length', _335148, 500), option_else('trace-depth', _335156, 30))), quietly(if_t((nop(stop_rtrace), _335092>_335148), (set_debug(eval, false), _335212 is _335148+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335212])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335264)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] setup_call_cleanup('$notrace'(_337310, _337312), once(user:(flag(eval_num, _335074, _335074+1), _335092 is _335074 mod 500, _335110 is 99-494 mod 100, _335134=_335136, option_else('trace-length', _335148, 500), option_else('trace-depth', _335156, 30))), '$restore_trace'(_337310, _337312))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] sig_atomic(system:'$notrace'(_337310, _337312))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2086, 2086+1), 86 is 2086 mod 500, 5 is 99-494 mod 100, _335134=_335134, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 86>500), (set_debug(eval, false), _335212 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335212])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 86>500), (set_debug(eval, false), _335212 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335212])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(322) [user] nop(notrace(no_repeats_var(_335264)))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [user] nop(notrace(no_repeats_var(_335264)))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] once(user:(notrace((flag(eval_num, 2086, 2086+1), 86 is 2086 mod 500, 5 is 99-494 mod 100, _335134=_335134, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 86>500), (set_debug(eval, false), _335212 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335212])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335264)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] must_det_ll(user:(notrace((flag(eval_num, 2086, 2086+1), 86 is 2086 mod 500, 5 is 99-494 mod 100, _335134=_335134, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 86>500), (set_debug(eval, false), _335212 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_335212])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_335264)))))
   <span class="ansi1 ansi32"
>Call: </span>(319) [occurs] occurs:sub_term(_346962, e)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [occurs] occurs:sub_term(_346962, e)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _354068=e
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] if_trace((eval;e), (_335134=1, indentq(5, 86, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_357208, _357210), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _335134=1, indentq(5, 86, -->, [e, [let, a, b, 'never-happens']]))), _357166, fbug((_357166-->if_trace((eval;e), (_335134=1, indentq(5, 86, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_357208, _357210))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_357208, _357210))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _335134=1, indentq(5, 86, -->, [e, [let, a, b, 'never-happens']]))), _357166, fbug((_357166-->if_trace((eval;e), (_335134=1, indentq(5, 86, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] if_trace((eval;e), (_335134=1, indentq(5, 86, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _361404=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _363442=(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] (\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] call_cleanup(((call(eval_20(=, _296114), 494, '&self', [let, a, b, 'never-happens'], _334020)*->nb_setarg(1, retval(fail), _334020);fail, trace, call(eval_20(=, _296114), 494, '&self', [let, a, b, 'never-happens'], _334020)), ignore(notrace((\+_334020\=_335264, nb_setarg(1, retval(fail), _334020))))), ignore((_335134==1->ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] eval_20(=, _296114, 494, '&self', [let, a, b, 'never-happens'], _334020)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_370850, _370852), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_370850, _370852))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_370850, _370852))
^  <span class="ansi1 ansi31"
>Fail: </span>(323) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] once(expand_eval([let, a, b, 'never-happens'], _393194))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] expand_eval([let, a, b, 'never-happens'], _393194)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _399294)
   <span class="ansi1 ansi32"
>Call: </span>(325) [apply] apply:maplist_([a, b, 'never-happens'], _399294, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] expand_eval(a, _401350)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] a=_401350
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(326) [apply] apply:maplist_([b, 'never-happens'], _401352, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] expand_eval(b, _407452)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] b=_407452
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(327) [apply] apply:maplist_(['never-happens'], _407454, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] expand_eval('never-happens', _413554)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] 'never-happens'=_413554
   <span class="ansi1 ansi32"
>Exit: </span>(329) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(328) [apply] apply:maplist_([], _413556, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] possible_type('&self', a, _430846)
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] possible_type('&self', a, _430846)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] eval_args(=, _430846, 494, '&self', b, _432888)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_434946, _434948), once(user:self_eval(b)), '$restore_trace'(_434946, _434948))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_434946, _434948))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _432888=b
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] eval_args(=, _430846, 494, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] eval_20(=, _296114, 494, '&self', [let, a, b, 'never-happens'], _334020)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] ignore((_335134==1->ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _335134==1
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] _335134==1
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_448276, _448278), once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)])))))))), '$restore_trace'(_448276, _448278))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_448276, _448278))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] ignore(user:(_335134==1->ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [system] call_cleanup(user:((call(eval_20(=, _296114), 494, '&self', [let, a, b, 'never-happens'], _334020)*->nb_setarg(1, retval(fail), _334020);fail, trace, call(eval_20(=, _296114), 494, '&self', [let, a, b, 'never-happens'], _334020)), ignore(notrace((\+_334020\=_335264, nb_setarg(1, retval(fail), _334020))))), user:ignore((_335134==1->ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _363462, _363462+1), (retval(fail)\=@=retval(fail), nonvar(_334020)->indentq(5, _363462, <--, [e, _334020]);indentq(5, _363462, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] trace_eval(eval_20(=, _296114), e, 494, '&self', [let, a, b, 'never-happens'], _334020)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] eval_args(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] call(eval, [let, a, b, 'never-happens'], _297788)
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval([let, a, b, 'never-happens'], _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] current_self(_457684)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nb_current(self_space, _457684)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(314) [user] eval('&self', [let, a, b, 'never-happens'], _297788)
   <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] catch_metta_return(eval_args(=, _465798, 500, '&self', [let, a, b, 'never-happens'], _297788), _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] eval_args(=, _465798, 500, '&self', [let, a, b, 'never-happens'], _297788)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_468908, _468910), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_468908, _468910))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_468908, _468910))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_470996, _470998), once(user:nonvar(_297788)), '$restore_trace'(_470996, _470998))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_470996, _470998))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_473084, _473086), once(user:nonvar(_297788)), '$restore_trace'(_473084, _473086))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_473084, _473086))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_480240, _480242), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_480240, _480242))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_480240, _480242))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_00(=, _465798, 500, '&self', [let, a, b, 'never-happens'], _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_485384, _485386), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_485384, _485386))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_485384, _485386))
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] eval_01(=, _465798, 500, '&self', [let, a, b, 'never-happens'], _297788)
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_493620, _493622), once(user:(_493596 is 500-1, copy_term([let, a, b, 'never-happens'], _493610))), '$restore_trace'(_493620, _493622))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_493620, _493622))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] trace_eval(eval_20(=, _465798), e, 499, '&self', [let, a, b, 'never-happens'], _496730)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] must_det_ll((notrace((flag(eval_num, _497784, _497784+1), _497802 is _497784 mod 500, _497820 is 99-499 mod 100, _497844=_497846, option_else('trace-length', _497858, 500), option_else('trace-depth', _497866, 30))), quietly(if_t((nop(stop_rtrace), _497802>_497858), (set_debug(eval, false), _497922 is _497858+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497922])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_497974)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] once(user:(notrace((flag(eval_num, _497784, _497784+1), _497802 is _497784 mod 500, _497820 is 99-499 mod 100, _497844=_497846, option_else('trace-length', _497858, 500), option_else('trace-depth', _497866, 30))), quietly(if_t((nop(stop_rtrace), _497802>_497858), (set_debug(eval, false), _497922 is _497858+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497922])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_497974)))))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] setup_call_cleanup('$notrace'(_500020, _500022), once(user:(flag(eval_num, _497784, _497784+1), _497802 is _497784 mod 500, _497820 is 99-499 mod 100, _497844=_497846, option_else('trace-length', _497858, 500), option_else('trace-depth', _497866, 30))), '$restore_trace'(_500020, _500022))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] sig_atomic(system:'$notrace'(_500020, _500022))
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2087, 2087+1), 87 is 2087 mod 500, 0 is 99-499 mod 100, _497844=_497844, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 87>500), (set_debug(eval, false), _497922 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497922])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 87>500), (set_debug(eval, false), _497922 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497922])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(325) [user] nop(notrace(no_repeats_var(_497974)))
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] nop(notrace(no_repeats_var(_497974)))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] once(user:(notrace((flag(eval_num, 2087, 2087+1), 87 is 2087 mod 500, 0 is 99-499 mod 100, _497844=_497844, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 87>500), (set_debug(eval, false), _497922 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497922])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_497974)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] must_det_ll(user:(notrace((flag(eval_num, 2087, 2087+1), 87 is 2087 mod 500, 0 is 99-499 mod 100, _497844=_497844, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 87>500), (set_debug(eval, false), _497922 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_497922])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_497974)))))
   <span class="ansi1 ansi32"
>Call: </span>(322) [occurs] occurs:sub_term(_509672, e)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(322) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [occurs] occurs:sub_term(_509672, e)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _516778=e
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] if_trace((eval;e), (_497844=1, indentq(0, 87, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_519918, _519920), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _497844=1, indentq(0, 87, -->, [e, [let, a, b, 'never-happens']]))), _519876, fbug((_519876-->if_trace((eval;e), (_497844=1, indentq(0, 87, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_519918, _519920))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_519918, _519920))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _497844=1, indentq(0, 87, -->, [e, [let, a, b, 'never-happens']]))), _519876, fbug((_519876-->if_trace((eval;e), (_497844=1, indentq(0, 87, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] if_trace((eval;e), (_497844=1, indentq(0, 87, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _524114=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _526152=(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] (\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] call_cleanup(((call(eval_20(=, _465798), 499, '&self', [let, a, b, 'never-happens'], _496730)*->nb_setarg(1, retval(fail), _496730);fail, trace, call(eval_20(=, _465798), 499, '&self', [let, a, b, 'never-happens'], _496730)), ignore(notrace((\+_496730\=_497974, nb_setarg(1, retval(fail), _496730))))), ignore((_497844==1->ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] eval_20(=, _465798, 499, '&self', [let, a, b, 'never-happens'], _496730)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] setup_call_cleanup('$notrace'(_533560, _533562), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_533560, _533562))
^  <span class="ansi1 ansi32"
>Call: </span>(329) [system] sig_atomic(system:'$notrace'(_533560, _533562))
^  <span class="ansi1 ansi31"
>Fail: </span>(326) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] once(expand_eval([let, a, b, 'never-happens'], _555904))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] expand_eval([let, a, b, 'never-happens'], _555904)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _562004)
   <span class="ansi1 ansi32"
>Call: </span>(328) [apply] apply:maplist_([a, b, 'never-happens'], _562004, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] expand_eval(a, _564060)
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] a=_564060
   <span class="ansi1 ansi32"
>Exit: </span>(330) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(329) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(329) [apply] apply:maplist_([b, 'never-happens'], _564062, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] expand_eval(b, _570162)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] b=_570162
   <span class="ansi1 ansi32"
>Exit: </span>(331) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(330) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(330) [apply] apply:maplist_(['never-happens'], _570164, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] expand_eval('never-happens', _576264)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] 'never-happens'=_576264
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(331) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(331) [apply] apply:maplist_([], _576266, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(331) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(330) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(329) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] possible_type('&self', a, _593556)
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [user] possible_type('&self', a, _593556)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] eval_args(=, _593556, 499, '&self', b, _595598)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] setup_call_cleanup('$notrace'(_597656, _597658), once(user:self_eval(b)), '$restore_trace'(_597656, _597658))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] sig_atomic(system:'$notrace'(_597656, _597658))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _595598=b
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [user] eval_args(=, _593556, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(324) [user] eval_20(=, _465798, 499, '&self', [let, a, b, 'never-happens'], _496730)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] ignore((_497844==1->ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _497844==1
   <span class="ansi1 ansi31"
>Fail: </span>(326) [system] _497844==1
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] setup_call_cleanup('$notrace'(_610986, _610988), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)])))))))), '$restore_trace'(_610986, _610988))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] sig_atomic(system:'$notrace'(_610986, _610988))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] ignore(user:(_497844==1->ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(322) [system] call_cleanup(user:((call(eval_20(=, _465798), 499, '&self', [let, a, b, 'never-happens'], _496730)*->nb_setarg(1, retval(fail), _496730);fail, trace, call(eval_20(=, _465798), 499, '&self', [let, a, b, 'never-happens'], _496730)), ignore(notrace((\+_496730\=_497974, nb_setarg(1, retval(fail), _496730))))), user:ignore((_497844==1->ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _526172, _526172+1), (retval(fail)\=@=retval(fail), nonvar(_496730)->indentq(0, _526172, <--, [e, _496730]);indentq(0, _526172, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] trace_eval(eval_20(=, _465798), e, 499, '&self', [let, a, b, 'never-happens'], _496730)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] eval_args(=, _465798, 500, '&self', [let, a, b, 'never-happens'], _297788)
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [system] call(user:once, user:if_or_else(eval(=, _296114, 495, '&self', [let, a, b, 'never-happens'], _297788), call(eval, [let, a, b, 'never-happens'], _297788)))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] setup_call_cleanup('$notrace'(_622448, _622450), once(rtrace:retract(t_l:tracer_reset(_622438))), '$restore_trace'(_622448, _622450))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(system:'$notrace'(_622448, _622450))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [rtrace] tAt(false, 271, 271, false)
; 
; EVAL TEST
; took 5.84 seconds.

!(assertEqual (let $a (collapse (get-atoms &self)) (contains $a is-corelib)) True)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (True) (True)))
</span>
Deterministic: ()
;;; Let's check that `if` from stdlib is not duplicated and gives only one result
<span class="ansi38-013099040"
>!(assertEqual (if (> 1 2) 1 2) 2)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.10"
>;; MODULE-SYSTEM.F1-IMPORTS.10</h3>
; 
; EVAL TEST
; took 0.000256 secs. (256.49 microseconds) 

!(assertEqual (if (> 1 2) 1 2) 2)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (2) (2)))
</span>
Deterministic: ()
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Let's import one more module into `&self` with a diamond dependence
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleB)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta is 282 bytes (7 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta is 292 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Number))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (g $x) (+ $x 10)))
</span>
Last Result(2): ()
;;; `g` from moduleC imported via two paths as well as `f`, which uses `g`,
;;; are not duplicated and produce deterministic results
<span class="ansi38-013099040"
>!(assertEqual (g 2) 102)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.11"
>;; MODULE-SYSTEM.F1-IMPORTS.11</h3>
; 
; EVAL TEST
; took 0.000748 secs. (747.91 microseconds) 

!(assertEqual (g 2) 102)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102) (102)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (f 2) 103)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.12"
>;; MODULE-SYSTEM.F1-IMPORTS.12</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.57 milliseconds) 

!(assertEqual (f 2) 103)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (103) (103)))
</span>
Deterministic: ()
;;; Function declared in different imported modules will still produce
;;; non-deterministic results
<span class="ansi38-013099040"
>!(assertEqualToResult (dup 2) (12 102))

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.13"
>;; MODULE-SYSTEM.F1-IMPORTS.13</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.06 milliseconds) 

!(assertEqualToResult (dup 2) (12 102))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102 12) (12 102)))
</span>
Deterministic: ()
;;; Let's import f1_moduleB once more. Such import should be ignored and
;;; thus f, g and dup should remain unchanged.
<span class="ansi38-013099040"
>!(import! &self f1_moduleB)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta is 282 bytes (7 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta is 292 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Number))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (g $x) (+ $x 10)))
</span>
Last Result(2): ()
<span class="ansi38-013099040"
>!(assertEqual (g 2) 102)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.14"
>;; MODULE-SYSTEM.F1-IMPORTS.14</h3>
; 
; EVAL TEST
; took 0.000919 secs. (919.49 microseconds) 

!(assertEqual (g 2) 102)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102) (102)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (f 2) 103)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.15"
>;; MODULE-SYSTEM.F1-IMPORTS.15</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.38 milliseconds) 

!(assertEqual (f 2) 103)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (103) (103)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqualToResult (dup 2) (12 102))

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.16"
>;; MODULE-SYSTEM.F1-IMPORTS.16</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.11 milliseconds) 

!(assertEqualToResult (dup 2) (12 102))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102 12) (12 102)))
</span>
Deterministic: ()<span class="ansi32"
>
% 78,837,323 inferences, 21.038 CPU in 21.058 seconds (100% CPU, 3747465 Lips)
</span>P;HTML|
;                       (= /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta  0)
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 14
</span><span class="ansi31"
>Failures: 2
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
P;HTML|
;         (is_cmd_option  execute halt --halt=true true)
P;HTML|
;          (set_option_value  halt true)
P;HTML|
;          (is_cmd_option  execute stdin --stdin=tty tty)
P;HTML|
;          (set_option_value  stdin tty)
P;HTML|
;          (is_cmd_option  execute stdout --stdout=tty tty)
P;HTML|
;           (set_option_value  stdout tty)
P;HTML|
;          (is_cmd_option  execute stderr --stderr=tty tty)
P;HTML|
;           (set_option_value  stderr tty)
P;HTML|
;         (set_option_value  compat false)
P;HTML|
;         (set_option_value  compatio false)
P;HTML|
;         (set_option_value  src_indents false)
P;HTML|
;         (set_option_value  devel false)
P;HTML|
;         (set_option_value  stack-max 500)
P;HTML|
;         (set_option_value  limit inf)
P;HTML|
;         (set_option_value  initial-result-count 10)
P;HTML|
;         (set_option_value  answer-format show)
P;HTML|
;         (set_option_value  repeats true)
P;HTML|
;         (set_option_value  time true)
P;HTML|
;         (set_option_value  synth-unit-tests false)
P;HTML|
;         (set_option_value  optimize true)
P;HTML|
;         (set_option_value  transpiler silent)
P;HTML|
;          (set_debug  transpiler false)
P;HTML|
;         (set_option_value  compile false)
P;HTML|
;         (set_option_value  tabling auto)
P;HTML|
;         (set_option_value  log false)
P;HTML|
;         (set_option_value  output ./)
P;HTML|
;         (set_option_value  exeout ./Sav.gitlab.MeTTaLog)
P;HTML|
;         (set_option_value  halt false)
P;HTML|
;         (set_option_value  trace-length 500)
P;HTML|
;         (set_option_value  trace-on-overtime 4.0)
P;HTML|
;          (set_debug  overtime 4.0)
P;HTML|
;         (set_option_value  trace-on-overflow 1000)
P;HTML|
;          (set_debug  overflow 1000)
P;HTML|
;         (set_option_value  trace-on-eval false)
P;HTML|
;          (set_debug  eval false)
P;HTML|
;         (set_option_value  trace-on-load silent)
P;HTML|
;          (set_debug  load silent)
P;HTML|
;          (set_debug  trace-on-load false)
P;HTML|
;         (set_option_value  trace-on-exec false)
P;HTML|
;          (set_debug  exec false)
P;HTML|
;         (set_option_value  trace-on-error non-type)
P;HTML|
;          (set_debug  error non-type)
P;HTML|
;         (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;         (set_option_value  trace-on-test true)
P;HTML|
;          (set_debug  test true)
P;HTML|
;         (set_option_value  repl-on-error true)
P;HTML|
;         (set_option_value  repl-on-fail false)
P;HTML|
;         (set_option_value  exit-on-fail false)
P;HTML|
;         (set_option_value  repl auto)
P;HTML|
;         (set_option_value  prolog false)
P;HTML|
;         (set_option_value  exec noskip)
P;HTML|
;         (set_option_value  maximum-result-count inf)
P;HTML|
;         (set_option_value  html false)
P;HTML|
;         (set_option_value  python true)
P;HTML|
;         (set_option_value  trace-on-test false)
P;HTML|
;          (set_debug  test false)
P;HTML|
;         (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;         (set_option_value  load show)
P;HTML|
;         (set_option_value  test true)
[((Error  (got  ((hyperon::space::DynSpace) (hyperon::space::DynSpace) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (()) (DocInformal) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()))) (expected  ((hyperon::space::DynSpace) (hyperon::space::DynSpace)))))]
[()]
[()]
[((Error  (got  ()) (expected  (True))))]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
P;HTML|
;         (maybe_halt  7)
<span class="ansi31"
>(in  (maybe_halt  7) (unwind  (halt  7)))
</span>
Script done on 2024-11-29 10:49:18+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat/' --timeout=40 --html --repl=false  --test "tests/baseline_compat/module-system/f1_imports.metta" --halt=true\033[0m
