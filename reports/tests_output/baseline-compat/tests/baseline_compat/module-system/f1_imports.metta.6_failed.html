<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi36 { color: #00aaaa; }
.ansi90 { color: #7f7f7f; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2024-11-22 00:40:44+00:00 [TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]
^@P;HTML|
;           (set_option_value  compat false)

P;HTML|
;           (set_option_value  compatio false)

P;HTML|
;           (set_option_value  src_indents false)

P;HTML|
;         (set_option_value  devel false)

P;HTML|
;         (set_option_value  stack-max 500)

P;HTML|
;         (set_option_value  limit inf)

P;HTML|
;         (set_option_value  initial-result-count 10)

P;HTML|
;         (set_option_value  answer-format show)

P;HTML|
;         (set_option_value  repeats true)

P;HTML|
;         (set_option_value  time true)

P;HTML|
;         (set_option_value  synth-unit-tests false)

P;HTML|
;         (set_option_value  optimize true)

P;HTML|
;         (set_option_value  transpiler silent)

P;HTML|
;          (set_debug  transpiler false)

P;HTML|
;         (set_option_value  compile false)

P;HTML|
;         (set_option_value  tabling auto)

P;HTML|
;         (set_option_value  log false)

P;HTML|
;         (set_option_value  output ./)

P;HTML|
;         (set_option_value  exeout ./Sav.gitlab.MeTTaLog)

P;HTML|
;         (set_option_value  halt false)

P;HTML|
;         (set_option_value  trace-length 500)

P;HTML|
;         (set_option_value  trace-on-overtime 4.0)

P;HTML|
;          (set_debug  overtime 4.0)

P;HTML|
;         (set_option_value  trace-on-overflow 1000)

P;HTML|
;          (set_debug  overflow 1000)

P;HTML|
;         (set_option_value  trace-on-eval false)

P;HTML|
;          (set_debug  eval false)

P;HTML|
;         (set_option_value  trace-on-load silent)

P;HTML|
;          (set_debug  load silent)

P;HTML|
;          (set_debug  trace-on-load false)

P;HTML|
;         (set_option_value  trace-on-exec false)

P;HTML|
;          (set_debug  exec false)

P;HTML|
;         (set_option_value  trace-on-error non-type)

P;HTML|
;          (set_debug  error non-type)

P;HTML|
;         (set_option_value  trace-on-fail false)

P;HTML|
;          (set_debug  fail false)

P;HTML|
;         (set_option_value  trace-on-test true)

P;HTML|
;          (set_debug  test true)

P;HTML|
;         (set_option_value  repl-on-error true)

P;HTML|
;         (set_option_value  repl-on-fail false)

P;HTML|
;         (set_option_value  exit-on-fail false)

P;HTML|
;         (set_option_value  repl auto)

P;HTML|
;         (set_option_value  prolog false)

P;HTML|
;         (set_option_value  exec noskip)

P;HTML|
;         (set_option_value  maximum-result-count inf)

P;HTML|
;         (set_option_value  html false)

P;HTML|
;         (set_option_value  python true)

P;HTML|
;         (set_option_value  trace-on-test false)

P;HTML|
;         (set_debug  test false)

P;HTML|
;         (set_option_value  trace-on-fail false)

P;HTML|
;         (set_debug  fail false)

P;HTML|
;         (set_option_value  load show)

P;HTML|
;         (set_option_value  test false)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta is 86.4K bytes (2.29K lines)
</span>P;HTML|
;          (is_cmd_option  prescan halt --halt=true true)
P;HTML|
;          (set_option_value  halt true)
P;HTML|
;          (is_cmd_option  prescan stdin --stdin=tty tty)
P;HTML|
;           (set_option_value  stdin tty)
P;HTML|
;          (is_cmd_option  prescan stdout --stdout=tty tty)
P;HTML|
;           (set_option_value  stdout tty)
P;HTML|
;          (is_cmd_option  prescan stderr --stderr=tty tty)
P;HTML|
;           (set_option_value  stderr tty)
P;HTML|
;          (set_option_value  compat false)
P;HTML|
;          (set_option_value  compatio false)
P;HTML|
;          (set_option_value  src_indents false)
P;HTML|
;          (set_option_value  devel false)
P;HTML|
;          (set_option_value  stack-max 500)
P;HTML|
;          (set_option_value  limit inf)
P;HTML|
;          (set_option_value  initial-result-count 10)
P;HTML|
;          (set_option_value  answer-format show)
P;HTML|
;          (set_option_value  repeats true)
P;HTML|
;          (set_option_value  time true)
P;HTML|
;          (set_option_value  synth-unit-tests false)
P;HTML|
;          (set_option_value  optimize true)
P;HTML|
;          (set_option_value  transpiler silent)
P;HTML|
;          (set_debug  transpiler false)
P;HTML|
;          (set_option_value  compile false)
P;HTML|
;          (set_option_value  tabling auto)
P;HTML|
;          (set_option_value  log false)
P;HTML|
;          (set_option_value  output ./)
P;HTML|
;          (set_option_value  exeout ./Sav.gitlab.MeTTaLog)
P;HTML|
;          (set_option_value  halt false)
P;HTML|
;          (set_option_value  trace-length 500)
P;HTML|
;          (set_option_value  trace-on-overtime 4.0)
P;HTML|
;          (set_debug  overtime 4.0)
P;HTML|
;          (set_option_value  trace-on-overflow 1000)
P;HTML|
;          (set_debug  overflow 1000)
P;HTML|
;          (set_option_value  trace-on-eval false)
P;HTML|
;          (set_debug  eval false)
P;HTML|
;          (set_option_value  trace-on-load silent)
P;HTML|
;          (set_debug  load silent)
P;HTML|
;          (set_debug  trace-on-load false)
P;HTML|
;          (set_option_value  trace-on-exec false)
P;HTML|
;          (set_debug  exec false)
P;HTML|
;          (set_option_value  trace-on-error non-type)
P;HTML|
;          (set_debug  error non-type)
P;HTML|
;          (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;          (set_option_value  trace-on-test true)
P;HTML|
;          (set_debug  test true)
P;HTML|
;          (set_option_value  repl-on-error true)
P;HTML|
;          (set_option_value  repl-on-fail false)
P;HTML|
;          (set_option_value  exit-on-fail false)
P;HTML|
;          (set_option_value  repl auto)
P;HTML|
;          (set_option_value  prolog false)
P;HTML|
;          (set_option_value  exec noskip)
P;HTML|
;          (set_option_value  maximum-result-count inf)
P;HTML|
;          (set_option_value  html false)
P;HTML|
;          (set_option_value  python true)
P;HTML|
;         (set_option_value  trace-on-test false)
P;HTML|
;          (set_debug  test false)
P;HTML|
;         (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;         (set_option_value  load show)
P;HTML|
;         (set_option_value  test true)
P;HTML|
;        (is_cmd_option  execute python --python=enable enable)
P;HTML|
;         (set_option_value  python enable)
P;HTML|
;        (is_cmd_option  execute timeout --timeout=40 40)
P;HTML|
;         (set_option_value  timeout 40)
P;HTML|
;         (is_cmd_option  execute output --output=./reports/tests_output/baseline-compat/ ./reports/tests_output/baseline-compat/)
P;HTML|
;         (set_option_value  output ./reports/tests_output/baseline-compat/)
P;HTML|
;         (is_cmd_option  execute html --html true)
P;HTML|
;          (set_option_value  html true)
P;HTML|
;         (is_cmd_option  execute test --test true)
P;HTML|
;          (set_option_value  test true)

; (load_metta_file  &self tests/baseline_compat/module-system/f1_imports.metta)
P;HTML|
;                       (track_load_into_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta)
P;HTML|
;                                        (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta)
P;HTML|
;                                         (= 1  "[()]")
P;HTML|
;                                         (= 2  "[()]")
P;HTML|
;                                         (= 3  "[()]")
P;HTML|
;                                         (= 4  "[()]")
P;HTML|
;                                         (= 5  "[()]")
P;HTML|
;                                         (= 6  "[()]")
P;HTML|
;                                         (= 7  "[()]")
P;HTML|
;                                         (= 8  "[()]")
P;HTML|
;                                         (= 9  "[()]")
P;HTML|
;                                         (= 10  "[()]")
P;HTML|
;                                         (= 11  "[()]")
P;HTML|
;                                         (= 12  "[()]")
P;HTML|
;                                         (= 13  "[()]")
P;HTML|
;                                         (= 14  "[()]")
P;HTML|
;                                         (= 15  "[()]")
P;HTML|
;                                         (= 16  "[()]")
P;HTML|
;                                         (= 17  "[()]")
P;HTML|
;                                         (= 18  "[()]")
P;HTML|
;                                         (= 19  "[()]")
P;HTML|
;                                         (= 20  "0.19user 0.00system 0:00.20elapsed 100%CPU (0avgtext+0avgdata 35952maxresident)k")
P;HTML|
;                                         (= 20  "0inputs+0outputs (0major+4794minor)pagefaults 0swaps")
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta is 5.11K bytes (128 lines)
</span>P;HTML|
;                                        (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta)

;;; NOTE: This test won't work outside the test environment because it relies on
;;;  specific atoms in a specific order in the space, and loading the default environment's
;;;  init.metta will break the assumptions in this test
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Even at the very beginning of the script `(get-atoms &self)`
;;; returns two atoms.  One is from the imported stdlib, and the other
;;; is corelib, which was a dependency of stdlib that has been promoted
;;; These atoms are both wrapped spaces, as is `&self`
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(assertEqual ((let $x (get-atoms &self) (get-type $x))) (superpose (((get-type &self)) ((get-type &self)))))

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.01"
>;; MODULE-SYSTEM.F1-IMPORTS.01</h3>

(failed  once (if_or_else  (eval  = $_569434 495 &self (let a b never-happens) $_571108) (call  eval (let a b never-happens) $_571108)))


(on_mettalog_error  (failed  once (if_or_else  (eval  = $_569434 495 &self (let a b never-happens) $_571108) (call  eval (let a b never-happens) $_571108))))

^  <span class="ansi1 ansi32"
>Call: </span>(297) [user] call(user:once, user:if_or_else(eval(=, _569434, 495, '&self', [let, a, b, 'never-happens'], _571108), call(eval, [let, a, b, 'never-happens'], _571108)))
^  <span class="ansi1 ansi32"
>Call: </span>(298) [user] once(user:if_or_else(eval(=, _569434, 495, '&self', [let, a, b, 'never-happens'], _571108), call(eval, [let, a, b, 'never-happens'], _571108)))
   <span class="ansi1 ansi32"
>Call: </span>(299) [user] if_or_else(eval(=, _569434, 495, '&self', [let, a, b, 'never-happens'], _571108), call(eval, [let, a, b, 'never-happens'], _571108))
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] eval(=, _569434, 495, '&self', [let, a, b, 'never-happens'], _571108)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [user] catch_metta_return(eval_args(=, _569434, 495, '&self', [let, a, b, 'never-happens'], _571108), _571108)
^  <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_args(=, _569434, 495, '&self', [let, a, b, 'never-happens'], _571108)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_579518, _579520), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_579518, _579520))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_579518, _579520))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_581606, _581608), once(user:nonvar(_571108)), '$restore_trace'(_581606, _581608))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_581606, _581608))
^  <span class="ansi1 ansi32"
>Call: </span>(305) [system] setup_call_cleanup('$notrace'(_583694, _583696), once(user:nonvar(_571108)), '$restore_trace'(_583694, _583696))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] sig_atomic(system:'$notrace'(_583694, _583696))
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(304) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(304) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(306) [system] setup_call_cleanup('$notrace'(_590850, _590852), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_590850, _590852))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] sig_atomic(system:'$notrace'(_590850, _590852))
^  <span class="ansi1 ansi31"
>Fail: </span>(304) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] eval_00(=, _569434, 495, '&self', [let, a, b, 'never-happens'], _571108)
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] setup_call_cleanup('$notrace'(_595994, _595996), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_595994, _595996))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] sig_atomic(system:'$notrace'(_595994, _595996))
^  <span class="ansi1 ansi31"
>Fail: </span>(305) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(305) [user] eval_01(=, _569434, 495, '&self', [let, a, b, 'never-happens'], _571108)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] 495<1
   <span class="ansi1 ansi31"
>Fail: </span>(308) [system] 495<1
^  <span class="ansi1 ansi32"
>Exit: </span>(306) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [system] setup_call_cleanup('$notrace'(_604230, _604232), once(user:(_604206 is 495-1, copy_term([let, a, b, 'never-happens'], _604220))), '$restore_trace'(_604230, _604232))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] sig_atomic(system:'$notrace'(_604230, _604232))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(494 is 495-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] trace_eval(eval_20(=, _569434), e, 494, '&self', [let, a, b, 'never-happens'], _607340)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] must_det_ll((notrace((flag(eval_num, _608394, _608394+1), _608412 is _608394 mod 500, _608430 is 99-494 mod 100, _608454=_608456, option_else('trace-length', _608468, 500), option_else('trace-depth', _608476, 30))), quietly(if_t((nop(stop_rtrace), _608412>_608468), (set_debug(eval, false), _608532 is _608468+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608532])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_608584)))))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] once(user:(notrace((flag(eval_num, _608394, _608394+1), _608412 is _608394 mod 500, _608430 is 99-494 mod 100, _608454=_608456, option_else('trace-length', _608468, 500), option_else('trace-depth', _608476, 30))), quietly(if_t((nop(stop_rtrace), _608412>_608468), (set_debug(eval, false), _608532 is _608468+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608532])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_608584)))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] setup_call_cleanup('$notrace'(_610630, _610632), once(user:(flag(eval_num, _608394, _608394+1), _608412 is _608394 mod 500, _608430 is 99-494 mod 100, _608454=_608456, option_else('trace-length', _608468, 500), option_else('trace-depth', _608476, 30))), '$restore_trace'(_610630, _610632))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] sig_atomic(system:'$notrace'(_610630, _610632))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2896, 2896+1), 396 is 2896 mod 500, 5 is 99-494 mod 100, _608454=_608454, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 396>500), (set_debug(eval, false), _608532 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608532])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 396>500), (set_debug(eval, false), _608532 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608532])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(310) [user] nop(notrace(no_repeats_var(_608584)))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [user] nop(notrace(no_repeats_var(_608584)))
^  <span class="ansi1 ansi32"
>Exit: </span>(308) [system] once(user:(notrace((flag(eval_num, 2896, 2896+1), 396 is 2896 mod 500, 5 is 99-494 mod 100, _608454=_608454, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 396>500), (set_debug(eval, false), _608532 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608532])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_608584)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] must_det_ll(user:(notrace((flag(eval_num, 2896, 2896+1), 396 is 2896 mod 500, 5 is 99-494 mod 100, _608454=_608454, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 396>500), (set_debug(eval, false), _608532 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_608532])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_608584)))))
   <span class="ansi1 ansi32"
>Call: </span>(307) [occurs] occurs:sub_term(_620282, e)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(307) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(308) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(308) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(307) [occurs] occurs:sub_term(_620282, e)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _627388=e
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] if_trace((eval;e), (_608454=1, indentq(5, 396, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_630528, _630530), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _608454=1, indentq(5, 396, -->, [e, [let, a, b, 'never-happens']]))), _630486, fbug((_630486-->if_trace((eval;e), (_608454=1, indentq(5, 396, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_630528, _630530))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_630528, _630530))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _608454=1, indentq(5, 396, -->, [e, [let, a, b, 'never-happens']]))), _630486, fbug((_630486-->if_trace((eval;e), (_608454=1, indentq(5, 396, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(307) [user] if_trace((eval;e), (_608454=1, indentq(5, 396, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _634724=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] _636762=(\+ \+ (flag(eval_num, _636782, _636782+1), (retval(fail)\=@=retval(fail), nonvar(_607340)->indentq(5, _636782, <--, [e, _607340]);indentq(5, _636782, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] (\+ \+ (flag(eval_num, _636782, _636782+1), (retval(fail)\=@=retval(fail), nonvar(_607340)->indentq(5, _636782, <--, [e, _607340]);indentq(5, _636782, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _636782, _636782+1), (retval(fail)\=@=retval(fail), nonvar(_607340)->indentq(5, _636782, <--, [e, _607340]);indentq(5, _636782, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] call_cleanup(((call(eval_20(=, _569434), 494, '&self', [let, a, b, 'never-happens'], _607340)*->nb_setarg(1, retval(fail), _607340);fail, trace, call(eval_20(=, _569434), 494, '&self', [let, a, b, 'never-happens'], _607340)), ignore(notrace((\+_607340\=_608584, nb_setarg(1, retval(fail), _607340))))), ignore((_608454==1->ignore(\+ \+ (flag(eval_num, _636782, _636782+1), (retval(fail)\=@=retval(fail), nonvar(_607340)->indentq(5, _636782, <--, [e, _607340]);indentq(5, _636782, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636782, _636782+1), (retval(fail)\=@=retval(fail), nonvar(_607340)->indentq(5, _636782, <--, [e, _607340]);indentq(5, _636782, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] eval_20(=, _569434, 494, '&self', [let, a, b, 'never-happens'], _607340)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] setup_call_cleanup('$notrace'(_644170, _644172), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_644170, _644172))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(system:'$notrace'(_644170, _644172))
^  <span class="ansi1 ansi31"
>Fail: </span>(311) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(311) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] once(expand_eval([let, a, b, 'never-happens'], _666514))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] expand_eval([let, a, b, 'never-happens'], _666514)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(312) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _672614)
   <span class="ansi1 ansi32"
>Call: </span>(313) [apply] apply:maplist_([a, b, 'never-happens'], _672614, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] expand_eval(a, _674670)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] a=_674670
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(314) [apply] apply:maplist_([b, 'never-happens'], _674672, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] expand_eval(b, _680772)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] b=_680772
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(315) [apply] apply:maplist_(['never-happens'], _680774, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] expand_eval('never-happens', _686874)
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(317) [system] 'never-happens'=_686874
   <span class="ansi1 ansi32"
>Exit: </span>(317) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(316) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(316) [apply] apply:maplist_([], _686876, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(314) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] possible_type('&self', a, _704166)
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] possible_type('&self', a, _704166)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] eval_args(=, _704166, 494, '&self', b, _706208)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_708266, _708268), once(user:self_eval(b)), '$restore_trace'(_708266, _708268))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_708266, _708268))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] _706208=b
   <span class="ansi1 ansi32"
>Exit: </span>(311) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] eval_args(=, _704166, 494, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] eval_20(=, _569434, 494, '&self', [let, a, b, 'never-happens'], _607340)
   <span class="ansi1 ansi32"
>Call: </span>(309) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(309) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] ignore((_608454==1->ignore(\+ \+ (flag(eval_num, _636782, _636782+1), (retval(fail)\=@=retval(fail), nonvar(_607340)->indentq(5, _636782, <--, [e, _607340]);indentq(5, _636782, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636782, _636782+1), (retval(fail)\=@=retval(fail), nonvar(_607340)->indentq(5, _636782, <--, [e, _607340]);indentq(5, _636782, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] _608454==1
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] _608454==1
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_721596, _721598), once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636782, _636782+1), (retval(fail)\=@=retval(fail), nonvar(_607340)->indentq(5, _636782, <--, [e, _607340]);indentq(5, _636782, <--, [e, retval(fail)])))))))), '$restore_trace'(_721596, _721598))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_721596, _721598))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636782, _636782+1), (retval(fail)\=@=retval(fail), nonvar(_607340)->indentq(5, _636782, <--, [e, _607340]);indentq(5, _636782, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [system] ignore(user:(_608454==1->ignore(\+ \+ (flag(eval_num, _636782, _636782+1), (retval(fail)\=@=retval(fail), nonvar(_607340)->indentq(5, _636782, <--, [e, _607340]);indentq(5, _636782, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636782, _636782+1), (retval(fail)\=@=retval(fail), nonvar(_607340)->indentq(5, _636782, <--, [e, _607340]);indentq(5, _636782, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(307) [system] call_cleanup(user:((call(eval_20(=, _569434), 494, '&self', [let, a, b, 'never-happens'], _607340)*->nb_setarg(1, retval(fail), _607340);fail, trace, call(eval_20(=, _569434), 494, '&self', [let, a, b, 'never-happens'], _607340)), ignore(notrace((\+_607340\=_608584, nb_setarg(1, retval(fail), _607340))))), user:ignore((_608454==1->ignore(\+ \+ (flag(eval_num, _636782, _636782+1), (retval(fail)\=@=retval(fail), nonvar(_607340)->indentq(5, _636782, <--, [e, _607340]);indentq(5, _636782, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _636782, _636782+1), (retval(fail)\=@=retval(fail), nonvar(_607340)->indentq(5, _636782, <--, [e, _607340]);indentq(5, _636782, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(306) [user] trace_eval(eval_20(=, _569434), e, 494, '&self', [let, a, b, 'never-happens'], _607340)
^  <span class="ansi1 ansi31"
>Fail: </span>(303) [user] eval_args(=, _569434, 495, '&self', [let, a, b, 'never-happens'], _571108)
^  <span class="ansi1 ansi32"
>Call: </span>(300) [user] call(eval, [let, a, b, 'never-happens'], _571108)
   <span class="ansi1 ansi32"
>Call: </span>(301) [user] eval([let, a, b, 'never-happens'], _571108)
^  <span class="ansi1 ansi32"
>Call: </span>(302) [user] current_self(_731004)
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] nb_current(self_space, _731004)
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(303) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(303) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(302) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(302) [user] eval('&self', [let, a, b, 'never-happens'], _571108)
   <span class="ansi1 ansi32"
>Call: </span>(303) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _571108)
^  <span class="ansi1 ansi32"
>Call: </span>(304) [user] catch_metta_return(eval_args(=, _739118, 500, '&self', [let, a, b, 'never-happens'], _571108), _571108)
^  <span class="ansi1 ansi32"
>Call: </span>(306) [user] eval_args(=, _739118, 500, '&self', [let, a, b, 'never-happens'], _571108)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_742228, _742230), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_742228, _742230))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_742228, _742230))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_744316, _744318), once(user:nonvar(_571108)), '$restore_trace'(_744316, _744318))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_744316, _744318))
^  <span class="ansi1 ansi32"
>Call: </span>(308) [system] setup_call_cleanup('$notrace'(_746404, _746406), once(user:nonvar(_571108)), '$restore_trace'(_746404, _746406))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] sig_atomic(system:'$notrace'(_746404, _746406))
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(307) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(307) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(309) [system] setup_call_cleanup('$notrace'(_753560, _753562), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_753560, _753562))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] sig_atomic(system:'$notrace'(_753560, _753562))
^  <span class="ansi1 ansi31"
>Fail: </span>(307) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(307) [user] eval_00(=, _739118, 500, '&self', [let, a, b, 'never-happens'], _571108)
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_758704, _758706), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_758704, _758706))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_758704, _758706))
^  <span class="ansi1 ansi31"
>Fail: </span>(308) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(308) [user] eval_01(=, _739118, 500, '&self', [let, a, b, 'never-happens'], _571108)
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(309) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [system] setup_call_cleanup('$notrace'(_766940, _766942), once(user:(_766916 is 500-1, copy_term([let, a, b, 'never-happens'], _766930))), '$restore_trace'(_766940, _766942))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [system] sig_atomic(system:'$notrace'(_766940, _766942))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] trace_eval(eval_20(=, _739118), e, 499, '&self', [let, a, b, 'never-happens'], _770050)
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] must_det_ll((notrace((flag(eval_num, _771104, _771104+1), _771122 is _771104 mod 500, _771140 is 99-499 mod 100, _771164=_771166, option_else('trace-length', _771178, 500), option_else('trace-depth', _771186, 30))), quietly(if_t((nop(stop_rtrace), _771122>_771178), (set_debug(eval, false), _771242 is _771178+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771242])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_771294)))))
^  <span class="ansi1 ansi32"
>Call: </span>(311) [user] once(user:(notrace((flag(eval_num, _771104, _771104+1), _771122 is _771104 mod 500, _771140 is 99-499 mod 100, _771164=_771166, option_else('trace-length', _771178, 500), option_else('trace-depth', _771186, 30))), quietly(if_t((nop(stop_rtrace), _771122>_771178), (set_debug(eval, false), _771242 is _771178+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771242])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_771294)))))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] setup_call_cleanup('$notrace'(_773340, _773342), once(user:(flag(eval_num, _771104, _771104+1), _771122 is _771104 mod 500, _771140 is 99-499 mod 100, _771164=_771166, option_else('trace-length', _771178, 500), option_else('trace-depth', _771186, 30))), '$restore_trace'(_773340, _773342))
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] sig_atomic(system:'$notrace'(_773340, _773342))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2897, 2897+1), 397 is 2897 mod 500, 0 is 99-499 mod 100, _771164=_771164, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 397>500), (set_debug(eval, false), _771242 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771242])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 397>500), (set_debug(eval, false), _771242 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771242])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] nop(notrace(no_repeats_var(_771294)))
   <span class="ansi1 ansi32"
>Exit: </span>(313) [user] nop(notrace(no_repeats_var(_771294)))
^  <span class="ansi1 ansi32"
>Exit: </span>(311) [system] once(user:(notrace((flag(eval_num, 2897, 2897+1), 397 is 2897 mod 500, 0 is 99-499 mod 100, _771164=_771164, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 397>500), (set_debug(eval, false), _771242 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771242])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_771294)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] must_det_ll(user:(notrace((flag(eval_num, 2897, 2897+1), 397 is 2897 mod 500, 0 is 99-499 mod 100, _771164=_771164, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 397>500), (set_debug(eval, false), _771242 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_771242])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_771294)))))
   <span class="ansi1 ansi32"
>Call: </span>(310) [occurs] occurs:sub_term(_782992, e)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(310) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(310) [occurs] occurs:sub_term(_782992, e)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _790098=e
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] if_trace((eval;e), (_771164=1, indentq(0, 397, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [system] setup_call_cleanup('$notrace'(_793238, _793240), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _771164=1, indentq(0, 397, -->, [e, [let, a, b, 'never-happens']]))), _793196, fbug((_793196-->if_trace((eval;e), (_771164=1, indentq(0, 397, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_793238, _793240))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] sig_atomic(system:'$notrace'(_793238, _793240))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _771164=1, indentq(0, 397, -->, [e, [let, a, b, 'never-happens']]))), _793196, fbug((_793196-->if_trace((eval;e), (_771164=1, indentq(0, 397, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(310) [user] if_trace((eval;e), (_771164=1, indentq(0, 397, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _797434=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(310) [system] _799472=(\+ \+ (flag(eval_num, _799492, _799492+1), (retval(fail)\=@=retval(fail), nonvar(_770050)->indentq(0, _799492, <--, [e, _770050]);indentq(0, _799492, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(310) [system] (\+ \+ (flag(eval_num, _799492, _799492+1), (retval(fail)\=@=retval(fail), nonvar(_770050)->indentq(0, _799492, <--, [e, _770050]);indentq(0, _799492, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _799492, _799492+1), (retval(fail)\=@=retval(fail), nonvar(_770050)->indentq(0, _799492, <--, [e, _770050]);indentq(0, _799492, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] call_cleanup(((call(eval_20(=, _739118), 499, '&self', [let, a, b, 'never-happens'], _770050)*->nb_setarg(1, retval(fail), _770050);fail, trace, call(eval_20(=, _739118), 499, '&self', [let, a, b, 'never-happens'], _770050)), ignore(notrace((\+_770050\=_771294, nb_setarg(1, retval(fail), _770050))))), ignore((_771164==1->ignore(\+ \+ (flag(eval_num, _799492, _799492+1), (retval(fail)\=@=retval(fail), nonvar(_770050)->indentq(0, _799492, <--, [e, _770050]);indentq(0, _799492, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799492, _799492+1), (retval(fail)\=@=retval(fail), nonvar(_770050)->indentq(0, _799492, <--, [e, _770050]);indentq(0, _799492, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval_20(=, _739118, 499, '&self', [let, a, b, 'never-happens'], _770050)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] setup_call_cleanup('$notrace'(_806880, _806882), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_806880, _806882))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] sig_atomic(system:'$notrace'(_806880, _806882))
^  <span class="ansi1 ansi31"
>Fail: </span>(314) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(313) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] once(expand_eval([let, a, b, 'never-happens'], _829224))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] expand_eval([let, a, b, 'never-happens'], _829224)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _835324)
   <span class="ansi1 ansi32"
>Call: </span>(316) [apply] apply:maplist_([a, b, 'never-happens'], _835324, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] expand_eval(a, _837380)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(318) [system] a=_837380
   <span class="ansi1 ansi32"
>Exit: </span>(318) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(317) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(317) [apply] apply:maplist_([b, 'never-happens'], _837382, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] expand_eval(b, _843482)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] b=_843482
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(318) [apply] apply:maplist_(['never-happens'], _843484, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] expand_eval('never-happens', _849584)
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] 'never-happens'=_849584
   <span class="ansi1 ansi32"
>Exit: </span>(320) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(319) [apply] apply:maplist_([], _849586, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(318) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(317) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] possible_type('&self', a, _866876)
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] possible_type('&self', a, _866876)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval_args(=, _866876, 499, '&self', b, _868918)
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_870976, _870978), once(user:self_eval(b)), '$restore_trace'(_870976, _870978))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_870976, _870978))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] _868918=b
   <span class="ansi1 ansi32"
>Exit: </span>(314) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [user] eval_args(=, _866876, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(313) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(312) [user] eval_20(=, _739118, 499, '&self', [let, a, b, 'never-happens'], _770050)
   <span class="ansi1 ansi32"
>Call: </span>(312) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(312) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] ignore((_771164==1->ignore(\+ \+ (flag(eval_num, _799492, _799492+1), (retval(fail)\=@=retval(fail), nonvar(_770050)->indentq(0, _799492, <--, [e, _770050]);indentq(0, _799492, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799492, _799492+1), (retval(fail)\=@=retval(fail), nonvar(_770050)->indentq(0, _799492, <--, [e, _770050]);indentq(0, _799492, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(314) [system] _771164==1
   <span class="ansi1 ansi31"
>Fail: </span>(314) [system] _771164==1
^  <span class="ansi1 ansi32"
>Call: </span>(315) [system] setup_call_cleanup('$notrace'(_884306, _884308), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799492, _799492+1), (retval(fail)\=@=retval(fail), nonvar(_770050)->indentq(0, _799492, <--, [e, _770050]);indentq(0, _799492, <--, [e, retval(fail)])))))))), '$restore_trace'(_884306, _884308))
^  <span class="ansi1 ansi32"
>Call: </span>(316) [system] sig_atomic(system:'$notrace'(_884306, _884308))
^  <span class="ansi1 ansi32"
>Exit: </span>(315) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799492, _799492+1), (retval(fail)\=@=retval(fail), nonvar(_770050)->indentq(0, _799492, <--, [e, _770050]);indentq(0, _799492, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(312) [system] ignore(user:(_771164==1->ignore(\+ \+ (flag(eval_num, _799492, _799492+1), (retval(fail)\=@=retval(fail), nonvar(_770050)->indentq(0, _799492, <--, [e, _770050]);indentq(0, _799492, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799492, _799492+1), (retval(fail)\=@=retval(fail), nonvar(_770050)->indentq(0, _799492, <--, [e, _770050]);indentq(0, _799492, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(310) [system] call_cleanup(user:((call(eval_20(=, _739118), 499, '&self', [let, a, b, 'never-happens'], _770050)*->nb_setarg(1, retval(fail), _770050);fail, trace, call(eval_20(=, _739118), 499, '&self', [let, a, b, 'never-happens'], _770050)), ignore(notrace((\+_770050\=_771294, nb_setarg(1, retval(fail), _770050))))), user:ignore((_771164==1->ignore(\+ \+ (flag(eval_num, _799492, _799492+1), (retval(fail)\=@=retval(fail), nonvar(_770050)->indentq(0, _799492, <--, [e, _770050]);indentq(0, _799492, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _799492, _799492+1), (retval(fail)\=@=retval(fail), nonvar(_770050)->indentq(0, _799492, <--, [e, _770050]);indentq(0, _799492, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [user] trace_eval(eval_20(=, _739118), e, 499, '&self', [let, a, b, 'never-happens'], _770050)
^  <span class="ansi1 ansi31"
>Fail: </span>(306) [user] eval_args(=, _739118, 500, '&self', [let, a, b, 'never-happens'], _571108)
^  <span class="ansi1 ansi31"
>Fail: </span>(297) [system] call(user:once, user:if_or_else(eval(=, _569434, 495, '&self', [let, a, b, 'never-happens'], _571108), call(eval, [let, a, b, 'never-happens'], _571108)))
^  <span class="ansi1 ansi32"
>Call: </span>(297) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(299) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(299) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(301) [system] setup_call_cleanup('$notrace'(_895768, _895770), once(rtrace:retract(t_l:tracer_reset(_895758))), '$restore_trace'(_895768, _895770))
^  <span class="ansi1 ansi32"
>Call: </span>(302) [system] sig_atomic(system:'$notrace'(_895768, _895770))
^  <span class="ansi1 ansi32"
>Exit: </span>(301) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(301) [rtrace] tAt(false, 271, 271, false)
; 
; EVAL TEST
; took 0.954 secs. (954.00 milliseconds) 

!(assertEqual ((let $x (get-atoms &self) (get-type $x))) (superpose (((get-type &self)) ((get-type &self)))))

<span class="ansi31"
>(loonit_failureR  (equal_enough_for_test  ((hyperon::space::DynSpace) (hyperon::space::DynSpace) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (())) ((hyperon::space::DynSpace) (hyperon::space::DynSpace))))
</span>
Deterministic: ((Error  (got  ((hyperon::space::DynSpace) (hyperon::space::DynSpace) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()))) (expected  ((hyperon::space::DynSpace) (hyperon::space::DynSpace)))))
;;; stdlib is already loaded
<span class="ansi38-013099040"
>!(assertEqual (if (> 1 2) 1 2) 2)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.02"
>;; MODULE-SYSTEM.F1-IMPORTS.02</h3>
; 
; EVAL TEST
; took 0.000267 secs. (266.82 microseconds) 

!(assertEqual (if (> 1 2) 1 2) 2)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (2) (2)))
</span>
Deterministic: ()
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Importing the module into new space
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &m f1_moduleA)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta)
P;HTML|
;                                         (= 1  "[()]")
P;HTML|
;                                         (= 2  "[()]")
P;HTML|
;                                         (= 3  "0.05user 0.00system 0:00.06elapsed 98%CPU (0avgtext+0avgdata 32252maxresident)k")
P;HTML|
;                                         (= 3  "0inputs+0outputs (0major+3916minor)pagefaults 0swaps")
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta is 621 bytes (17 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta is 292 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Number))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()
;;; FIXME? stdlib space is not available at importing time -
;;; only tokens / grounded operations work, while symbolic functions
;;; (like `if`) don't work.
;;; FIXME? Exceptions are not caught by `importOp`
<span class="ansi38-013099040"
>!(assertEqual (+ 1 2) 3)

</span>
;<h3 id="MODULE-SYSTEM.F1-MODULEA.03"
>;; MODULE-SYSTEM.F1-MODULEA.03</h3>
; 
; EVAL TEST
; took 0.000219 secs. (218.93 microseconds) 

!(assertEqual (+ 1 2) 3)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (3) (3)))
</span>
Deterministic: ()
;;; !(assertEqual (if True "S" "F") "S")
<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (+ $x 10) (g $x)))
</span><span class="ansi38-255165000"
> (: f (-> Number Number))
</span><span class="ansi38-255165000"
> (= (f $x) (if (< $x 0) (- 0 $x) (g (+ 1 $x))))
</span>
Last Result(2): ()
;;; Check whether passed expression contains atom for which condition is True
<span class="ansi38-255165000"
> (: contains (-> Expression (-> Atom Bool) Bool))
</span><span class="ansi38-255165000"
> (= (contains $list $condition) (if (== $list ()) False (let $head (car-atom $list) (if ($condition $head) True (let $tail (cdr-atom $list) (contains $tail $condition))))))
</span>;;; Check whether atom is space comparing its type with type of the &self atom
<span class="ansi38-255165000"
> (: is-space (-> Atom Bool))
</span><span class="ansi38-255165000"
> (= (is-space $atom) (let* (($type (get-type $atom)) ($space (get-type &self))) (== $type $space)))
</span>;;; It's first atom is a space
<span class="ansi38-013099040"
>!(assertEqual (let $x (collapse (get-atoms &m)) (contains $x is-space)) True)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.04"
>;; MODULE-SYSTEM.F1-IMPORTS.04</h3>

(failed  once (if_or_else  (eval  = $_336732 495 &self (let a b never-happens) $_338406) (call  eval (let a b never-happens) $_338406)))


(on_mettalog_error  (failed  once (if_or_else  (eval  = $_336732 495 &self (let a b never-happens) $_338406) (call  eval (let a b never-happens) $_338406))))

^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] call(user:once, user:if_or_else(eval(=, _336732, 495, '&self', [let, a, b, 'never-happens'], _338406), call(eval, [let, a, b, 'never-happens'], _338406)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] once(user:if_or_else(eval(=, _336732, 495, '&self', [let, a, b, 'never-happens'], _338406), call(eval, [let, a, b, 'never-happens'], _338406)))
   <span class="ansi1 ansi32"
>Call: </span>(311) [user] if_or_else(eval(=, _336732, 495, '&self', [let, a, b, 'never-happens'], _338406), call(eval, [let, a, b, 'never-happens'], _338406))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval(=, _336732, 495, '&self', [let, a, b, 'never-happens'], _338406)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] catch_metta_return(eval_args(=, _336732, 495, '&self', [let, a, b, 'never-happens'], _338406), _338406)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_args(=, _336732, 495, '&self', [let, a, b, 'never-happens'], _338406)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_346816, _346818), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_346816, _346818))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_346816, _346818))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_348904, _348906), once(user:nonvar(_338406)), '$restore_trace'(_348904, _348906))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_348904, _348906))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_350992, _350994), once(user:nonvar(_338406)), '$restore_trace'(_350992, _350994))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_350992, _350994))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_358148, _358150), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_358148, _358150))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_358148, _358150))
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_00(=, _336732, 495, '&self', [let, a, b, 'never-happens'], _338406)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_363292, _363294), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_363292, _363294))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_363292, _363294))
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] eval_01(=, _336732, 495, '&self', [let, a, b, 'never-happens'], _338406)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] 495<1
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] 495<1
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_371528, _371530), once(user:(_371504 is 495-1, copy_term([let, a, b, 'never-happens'], _371518))), '$restore_trace'(_371528, _371530))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_371528, _371530))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(494 is 495-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] trace_eval(eval_20(=, _336732), e, 494, '&self', [let, a, b, 'never-happens'], _374638)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] must_det_ll((notrace((flag(eval_num, _375692, _375692+1), _375710 is _375692 mod 500, _375728 is 99-494 mod 100, _375752=_375754, option_else('trace-length', _375766, 500), option_else('trace-depth', _375774, 30))), quietly(if_t((nop(stop_rtrace), _375710>_375766), (set_debug(eval, false), _375830 is _375766+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375830])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_375882)))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] once(user:(notrace((flag(eval_num, _375692, _375692+1), _375710 is _375692 mod 500, _375728 is 99-494 mod 100, _375752=_375754, option_else('trace-length', _375766, 500), option_else('trace-depth', _375774, 30))), quietly(if_t((nop(stop_rtrace), _375710>_375766), (set_debug(eval, false), _375830 is _375766+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375830])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_375882)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] setup_call_cleanup('$notrace'(_377928, _377930), once(user:(flag(eval_num, _375692, _375692+1), _375710 is _375692 mod 500, _375728 is 99-494 mod 100, _375752=_375754, option_else('trace-length', _375766, 500), option_else('trace-depth', _375774, 30))), '$restore_trace'(_377928, _377930))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] sig_atomic(system:'$notrace'(_377928, _377930))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2059, 2059+1), 59 is 2059 mod 500, 5 is 99-494 mod 100, _375752=_375752, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 59>500), (set_debug(eval, false), _375830 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375830])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 59>500), (set_debug(eval, false), _375830 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375830])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(322) [user] nop(notrace(no_repeats_var(_375882)))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [user] nop(notrace(no_repeats_var(_375882)))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] once(user:(notrace((flag(eval_num, 2059, 2059+1), 59 is 2059 mod 500, 5 is 99-494 mod 100, _375752=_375752, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 59>500), (set_debug(eval, false), _375830 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375830])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_375882)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] must_det_ll(user:(notrace((flag(eval_num, 2059, 2059+1), 59 is 2059 mod 500, 5 is 99-494 mod 100, _375752=_375752, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 59>500), (set_debug(eval, false), _375830 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375830])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_375882)))))
   <span class="ansi1 ansi32"
>Call: </span>(319) [occurs] occurs:sub_term(_387580, e)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [occurs] occurs:sub_term(_387580, e)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _394686=e
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] if_trace((eval;e), (_375752=1, indentq(5, 59, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_397826, _397828), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _375752=1, indentq(5, 59, -->, [e, [let, a, b, 'never-happens']]))), _397784, fbug((_397784-->if_trace((eval;e), (_375752=1, indentq(5, 59, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_397826, _397828))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_397826, _397828))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _375752=1, indentq(5, 59, -->, [e, [let, a, b, 'never-happens']]))), _397784, fbug((_397784-->if_trace((eval;e), (_375752=1, indentq(5, 59, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] if_trace((eval;e), (_375752=1, indentq(5, 59, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _402022=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _404060=(\+ \+ (flag(eval_num, _404080, _404080+1), (retval(fail)\=@=retval(fail), nonvar(_374638)->indentq(5, _404080, <--, [e, _374638]);indentq(5, _404080, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] (\+ \+ (flag(eval_num, _404080, _404080+1), (retval(fail)\=@=retval(fail), nonvar(_374638)->indentq(5, _404080, <--, [e, _374638]);indentq(5, _404080, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _404080, _404080+1), (retval(fail)\=@=retval(fail), nonvar(_374638)->indentq(5, _404080, <--, [e, _374638]);indentq(5, _404080, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] call_cleanup(((call(eval_20(=, _336732), 494, '&self', [let, a, b, 'never-happens'], _374638)*->nb_setarg(1, retval(fail), _374638);fail, trace, call(eval_20(=, _336732), 494, '&self', [let, a, b, 'never-happens'], _374638)), ignore(notrace((\+_374638\=_375882, nb_setarg(1, retval(fail), _374638))))), ignore((_375752==1->ignore(\+ \+ (flag(eval_num, _404080, _404080+1), (retval(fail)\=@=retval(fail), nonvar(_374638)->indentq(5, _404080, <--, [e, _374638]);indentq(5, _404080, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404080, _404080+1), (retval(fail)\=@=retval(fail), nonvar(_374638)->indentq(5, _404080, <--, [e, _374638]);indentq(5, _404080, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] eval_20(=, _336732, 494, '&self', [let, a, b, 'never-happens'], _374638)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_411468, _411470), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_411468, _411470))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_411468, _411470))
^  <span class="ansi1 ansi31"
>Fail: </span>(323) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] once(expand_eval([let, a, b, 'never-happens'], _433812))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] expand_eval([let, a, b, 'never-happens'], _433812)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _439912)
   <span class="ansi1 ansi32"
>Call: </span>(325) [apply] apply:maplist_([a, b, 'never-happens'], _439912, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] expand_eval(a, _441968)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] a=_441968
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(326) [apply] apply:maplist_([b, 'never-happens'], _441970, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] expand_eval(b, _448070)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] b=_448070
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(327) [apply] apply:maplist_(['never-happens'], _448072, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] expand_eval('never-happens', _454172)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] 'never-happens'=_454172
   <span class="ansi1 ansi32"
>Exit: </span>(329) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(328) [apply] apply:maplist_([], _454174, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] possible_type('&self', a, _471464)
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] possible_type('&self', a, _471464)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] eval_args(=, _471464, 494, '&self', b, _473506)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_475564, _475566), once(user:self_eval(b)), '$restore_trace'(_475564, _475566))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_475564, _475566))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _473506=b
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] eval_args(=, _471464, 494, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] eval_20(=, _336732, 494, '&self', [let, a, b, 'never-happens'], _374638)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] ignore((_375752==1->ignore(\+ \+ (flag(eval_num, _404080, _404080+1), (retval(fail)\=@=retval(fail), nonvar(_374638)->indentq(5, _404080, <--, [e, _374638]);indentq(5, _404080, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404080, _404080+1), (retval(fail)\=@=retval(fail), nonvar(_374638)->indentq(5, _404080, <--, [e, _374638]);indentq(5, _404080, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _375752==1
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] _375752==1
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_488894, _488896), once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404080, _404080+1), (retval(fail)\=@=retval(fail), nonvar(_374638)->indentq(5, _404080, <--, [e, _374638]);indentq(5, _404080, <--, [e, retval(fail)])))))))), '$restore_trace'(_488894, _488896))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_488894, _488896))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404080, _404080+1), (retval(fail)\=@=retval(fail), nonvar(_374638)->indentq(5, _404080, <--, [e, _374638]);indentq(5, _404080, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] ignore(user:(_375752==1->ignore(\+ \+ (flag(eval_num, _404080, _404080+1), (retval(fail)\=@=retval(fail), nonvar(_374638)->indentq(5, _404080, <--, [e, _374638]);indentq(5, _404080, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404080, _404080+1), (retval(fail)\=@=retval(fail), nonvar(_374638)->indentq(5, _404080, <--, [e, _374638]);indentq(5, _404080, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [system] call_cleanup(user:((call(eval_20(=, _336732), 494, '&self', [let, a, b, 'never-happens'], _374638)*->nb_setarg(1, retval(fail), _374638);fail, trace, call(eval_20(=, _336732), 494, '&self', [let, a, b, 'never-happens'], _374638)), ignore(notrace((\+_374638\=_375882, nb_setarg(1, retval(fail), _374638))))), user:ignore((_375752==1->ignore(\+ \+ (flag(eval_num, _404080, _404080+1), (retval(fail)\=@=retval(fail), nonvar(_374638)->indentq(5, _404080, <--, [e, _374638]);indentq(5, _404080, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404080, _404080+1), (retval(fail)\=@=retval(fail), nonvar(_374638)->indentq(5, _404080, <--, [e, _374638]);indentq(5, _404080, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] trace_eval(eval_20(=, _336732), e, 494, '&self', [let, a, b, 'never-happens'], _374638)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] eval_args(=, _336732, 495, '&self', [let, a, b, 'never-happens'], _338406)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] call(eval, [let, a, b, 'never-happens'], _338406)
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval([let, a, b, 'never-happens'], _338406)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] current_self(_498302)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nb_current(self_space, _498302)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(314) [user] eval('&self', [let, a, b, 'never-happens'], _338406)
   <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _338406)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] catch_metta_return(eval_args(=, _506416, 500, '&self', [let, a, b, 'never-happens'], _338406), _338406)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] eval_args(=, _506416, 500, '&self', [let, a, b, 'never-happens'], _338406)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_509526, _509528), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_509526, _509528))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_509526, _509528))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_511614, _511616), once(user:nonvar(_338406)), '$restore_trace'(_511614, _511616))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_511614, _511616))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_513702, _513704), once(user:nonvar(_338406)), '$restore_trace'(_513702, _513704))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_513702, _513704))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_520858, _520860), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_520858, _520860))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_520858, _520860))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_00(=, _506416, 500, '&self', [let, a, b, 'never-happens'], _338406)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_526002, _526004), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_526002, _526004))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_526002, _526004))
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] eval_01(=, _506416, 500, '&self', [let, a, b, 'never-happens'], _338406)
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_534238, _534240), once(user:(_534214 is 500-1, copy_term([let, a, b, 'never-happens'], _534228))), '$restore_trace'(_534238, _534240))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_534238, _534240))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] trace_eval(eval_20(=, _506416), e, 499, '&self', [let, a, b, 'never-happens'], _537348)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] must_det_ll((notrace((flag(eval_num, _538402, _538402+1), _538420 is _538402 mod 500, _538438 is 99-499 mod 100, _538462=_538464, option_else('trace-length', _538476, 500), option_else('trace-depth', _538484, 30))), quietly(if_t((nop(stop_rtrace), _538420>_538476), (set_debug(eval, false), _538540 is _538476+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538540])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_538592)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] once(user:(notrace((flag(eval_num, _538402, _538402+1), _538420 is _538402 mod 500, _538438 is 99-499 mod 100, _538462=_538464, option_else('trace-length', _538476, 500), option_else('trace-depth', _538484, 30))), quietly(if_t((nop(stop_rtrace), _538420>_538476), (set_debug(eval, false), _538540 is _538476+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538540])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_538592)))))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] setup_call_cleanup('$notrace'(_540638, _540640), once(user:(flag(eval_num, _538402, _538402+1), _538420 is _538402 mod 500, _538438 is 99-499 mod 100, _538462=_538464, option_else('trace-length', _538476, 500), option_else('trace-depth', _538484, 30))), '$restore_trace'(_540638, _540640))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] sig_atomic(system:'$notrace'(_540638, _540640))
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2060, 2060+1), 60 is 2060 mod 500, 0 is 99-499 mod 100, _538462=_538462, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 60>500), (set_debug(eval, false), _538540 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538540])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 60>500), (set_debug(eval, false), _538540 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538540])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(325) [user] nop(notrace(no_repeats_var(_538592)))
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] nop(notrace(no_repeats_var(_538592)))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] once(user:(notrace((flag(eval_num, 2060, 2060+1), 60 is 2060 mod 500, 0 is 99-499 mod 100, _538462=_538462, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 60>500), (set_debug(eval, false), _538540 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538540])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_538592)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] must_det_ll(user:(notrace((flag(eval_num, 2060, 2060+1), 60 is 2060 mod 500, 0 is 99-499 mod 100, _538462=_538462, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 60>500), (set_debug(eval, false), _538540 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538540])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_538592)))))
   <span class="ansi1 ansi32"
>Call: </span>(322) [occurs] occurs:sub_term(_550290, e)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(322) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [occurs] occurs:sub_term(_550290, e)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _557396=e
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] if_trace((eval;e), (_538462=1, indentq(0, 60, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_560536, _560538), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _538462=1, indentq(0, 60, -->, [e, [let, a, b, 'never-happens']]))), _560494, fbug((_560494-->if_trace((eval;e), (_538462=1, indentq(0, 60, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_560536, _560538))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_560536, _560538))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _538462=1, indentq(0, 60, -->, [e, [let, a, b, 'never-happens']]))), _560494, fbug((_560494-->if_trace((eval;e), (_538462=1, indentq(0, 60, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] if_trace((eval;e), (_538462=1, indentq(0, 60, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _564732=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _566770=(\+ \+ (flag(eval_num, _566790, _566790+1), (retval(fail)\=@=retval(fail), nonvar(_537348)->indentq(0, _566790, <--, [e, _537348]);indentq(0, _566790, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] (\+ \+ (flag(eval_num, _566790, _566790+1), (retval(fail)\=@=retval(fail), nonvar(_537348)->indentq(0, _566790, <--, [e, _537348]);indentq(0, _566790, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _566790, _566790+1), (retval(fail)\=@=retval(fail), nonvar(_537348)->indentq(0, _566790, <--, [e, _537348]);indentq(0, _566790, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] call_cleanup(((call(eval_20(=, _506416), 499, '&self', [let, a, b, 'never-happens'], _537348)*->nb_setarg(1, retval(fail), _537348);fail, trace, call(eval_20(=, _506416), 499, '&self', [let, a, b, 'never-happens'], _537348)), ignore(notrace((\+_537348\=_538592, nb_setarg(1, retval(fail), _537348))))), ignore((_538462==1->ignore(\+ \+ (flag(eval_num, _566790, _566790+1), (retval(fail)\=@=retval(fail), nonvar(_537348)->indentq(0, _566790, <--, [e, _537348]);indentq(0, _566790, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566790, _566790+1), (retval(fail)\=@=retval(fail), nonvar(_537348)->indentq(0, _566790, <--, [e, _537348]);indentq(0, _566790, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] eval_20(=, _506416, 499, '&self', [let, a, b, 'never-happens'], _537348)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] setup_call_cleanup('$notrace'(_574178, _574180), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_574178, _574180))
^  <span class="ansi1 ansi32"
>Call: </span>(329) [system] sig_atomic(system:'$notrace'(_574178, _574180))
^  <span class="ansi1 ansi31"
>Fail: </span>(326) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] once(expand_eval([let, a, b, 'never-happens'], _596522))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] expand_eval([let, a, b, 'never-happens'], _596522)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _602622)
   <span class="ansi1 ansi32"
>Call: </span>(328) [apply] apply:maplist_([a, b, 'never-happens'], _602622, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] expand_eval(a, _604678)
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] a=_604678
   <span class="ansi1 ansi32"
>Exit: </span>(330) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(329) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(329) [apply] apply:maplist_([b, 'never-happens'], _604680, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] expand_eval(b, _610780)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] b=_610780
   <span class="ansi1 ansi32"
>Exit: </span>(331) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(330) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(330) [apply] apply:maplist_(['never-happens'], _610782, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] expand_eval('never-happens', _616882)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] 'never-happens'=_616882
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(331) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(331) [apply] apply:maplist_([], _616884, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(331) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(330) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(329) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] possible_type('&self', a, _634174)
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [user] possible_type('&self', a, _634174)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] eval_args(=, _634174, 499, '&self', b, _636216)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] setup_call_cleanup('$notrace'(_638274, _638276), once(user:self_eval(b)), '$restore_trace'(_638274, _638276))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] sig_atomic(system:'$notrace'(_638274, _638276))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _636216=b
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [user] eval_args(=, _634174, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(324) [user] eval_20(=, _506416, 499, '&self', [let, a, b, 'never-happens'], _537348)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] ignore((_538462==1->ignore(\+ \+ (flag(eval_num, _566790, _566790+1), (retval(fail)\=@=retval(fail), nonvar(_537348)->indentq(0, _566790, <--, [e, _537348]);indentq(0, _566790, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566790, _566790+1), (retval(fail)\=@=retval(fail), nonvar(_537348)->indentq(0, _566790, <--, [e, _537348]);indentq(0, _566790, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _538462==1
   <span class="ansi1 ansi31"
>Fail: </span>(326) [system] _538462==1
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] setup_call_cleanup('$notrace'(_651604, _651606), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566790, _566790+1), (retval(fail)\=@=retval(fail), nonvar(_537348)->indentq(0, _566790, <--, [e, _537348]);indentq(0, _566790, <--, [e, retval(fail)])))))))), '$restore_trace'(_651604, _651606))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] sig_atomic(system:'$notrace'(_651604, _651606))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566790, _566790+1), (retval(fail)\=@=retval(fail), nonvar(_537348)->indentq(0, _566790, <--, [e, _537348]);indentq(0, _566790, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] ignore(user:(_538462==1->ignore(\+ \+ (flag(eval_num, _566790, _566790+1), (retval(fail)\=@=retval(fail), nonvar(_537348)->indentq(0, _566790, <--, [e, _537348]);indentq(0, _566790, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566790, _566790+1), (retval(fail)\=@=retval(fail), nonvar(_537348)->indentq(0, _566790, <--, [e, _537348]);indentq(0, _566790, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(322) [system] call_cleanup(user:((call(eval_20(=, _506416), 499, '&self', [let, a, b, 'never-happens'], _537348)*->nb_setarg(1, retval(fail), _537348);fail, trace, call(eval_20(=, _506416), 499, '&self', [let, a, b, 'never-happens'], _537348)), ignore(notrace((\+_537348\=_538592, nb_setarg(1, retval(fail), _537348))))), user:ignore((_538462==1->ignore(\+ \+ (flag(eval_num, _566790, _566790+1), (retval(fail)\=@=retval(fail), nonvar(_537348)->indentq(0, _566790, <--, [e, _537348]);indentq(0, _566790, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566790, _566790+1), (retval(fail)\=@=retval(fail), nonvar(_537348)->indentq(0, _566790, <--, [e, _537348]);indentq(0, _566790, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] trace_eval(eval_20(=, _506416), e, 499, '&self', [let, a, b, 'never-happens'], _537348)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] eval_args(=, _506416, 500, '&self', [let, a, b, 'never-happens'], _338406)
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [system] call(user:once, user:if_or_else(eval(=, _336732, 495, '&self', [let, a, b, 'never-happens'], _338406), call(eval, [let, a, b, 'never-happens'], _338406)))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] setup_call_cleanup('$notrace'(_663066, _663068), once(rtrace:retract(t_l:tracer_reset(_663056))), '$restore_trace'(_663066, _663068))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(system:'$notrace'(_663066, _663068))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [rtrace] tAt(false, 271, 271, false)
<span class="ansi1 ansi90"
>Info: Processing progress: 100% </span>[4] current_output closed; set to user_output
<span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/src/canary/stdlib_mettalog.metta progress.
</span><span class="ansi1 ansi90"
>Info: Processing progress: 100% </span><span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta progress.
</span><span class="ansi1 ansi90"
>Info: Processing progress: 100% </span><span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta progress.
</span><span class="ansi1 ansi90"
>Info: Processing progress: 100% </span><span class="ansi1 ansi90"
> - Stopping reporting on /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta progress.
</span>; 
; EVAL TEST
; took 11.71 seconds.

!(assertEqual (let $x (collapse (get-atoms &m)) (contains $x is-space)) True)

<span class="ansi31"
>(loonit_failureR  (equal_enough_for_test  () (True)))
</span>
Deterministic: ((Error  (got  ()) (expected  (True))))
;;; FIXME? Now, it is moduleC space.
;;;        Should it be `stdlib` atom for a separately imported space
;;; !(let $x (collapse (get-atoms &m)) (car-atom $x))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Without additional means like `(&m.f 2)` notation or `(interpret &m (f 2))`,
;;; we cannot execute functions from the separate space - we can only use `match`.
;;; Although `&m` imports another space with definition of `g`, it is not reduced
;;; because it is not defined in the context of `&self`. This is the expected
;;; behavior, but it shows that this way of importing spaces is not too useful
;;; for importing modules with functions.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(assertEqual (match &m (= (f 2) $x) $x) (g 3))

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.05"
>;; MODULE-SYSTEM.F1-IMPORTS.05</h3>
; 
; EVAL TEST
; took 0.003 secs. (3.46 milliseconds) 

!(assertEqual (match &m (= (f 2) $x) $x) (g 3))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  ((g 3)) ((g 3))))
</span>
Deterministic: ()
;;; Importing the same space into `&self` should break nothing
;;; TODO? If stdlib space would be in `&m`, which should check that it is not
;;; there anymore since in should be removed after importing it to `&self`
<span class="ansi38-013099040"
>!(import! &self f1_moduleA)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta is 621 bytes (17 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleA.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta is 292 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Number))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()
;;; FIXME? stdlib space is not available at importing time -
;;; only tokens / grounded operations work, while symbolic functions
;;; (like `if`) don't work.
;;; FIXME? Exceptions are not caught by `importOp`
<span class="ansi38-013099040"
>!(assertEqual (+ 1 2) 3)

</span>
;<h3 id="MODULE-SYSTEM.F1-MODULEA.06"
>;; MODULE-SYSTEM.F1-MODULEA.06</h3>
; 
; EVAL TEST
; took 0.000220 secs. (219.88 microseconds) 

!(assertEqual (+ 1 2) 3)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (3) (3)))
</span>
Deterministic: ()
;;; !(assertEqual (if True "S" "F") "S")
<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (+ $x 10) (g $x)))
</span><span class="ansi38-255165000"
> (: f (-> Number Number))
</span><span class="ansi38-255165000"
> (= (f $x) (if (< $x 0) (- 0 $x) (g (+ 1 $x))))
</span>
Last Result(2): ()
;;; Now indirectly imported `g` works and `f` fully works
<span class="ansi38-013099040"
>!(assertEqual (g 2) 102)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.07"
>;; MODULE-SYSTEM.F1-IMPORTS.07</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.27 milliseconds) 

!(assertEqual (g 2) 102)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102) (102)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (f 2) 103)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.08"
>;; MODULE-SYSTEM.F1-IMPORTS.08</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.46 milliseconds) 

!(assertEqual (f 2) 103)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (103) (103)))
</span>
Deterministic: ()
;;; `&self` contains 4 grounded sub-spaces now:
;;; - stdlib
;;; - corelib
;;; - moduleA itself, which is the same as &m
;;; - moduleC imported by moduleA and removed from A after its import to &self
;;; Check whether atom is &m
<span class="ansi38-255165000"
> (: is-m (-> Atom Bool))
</span><span class="ansi38-255165000"
> (= (is-m $atom) (== $atom &m))
</span>;;; Assert that the &self space contains the same space as &m, which we imported from moduleA
;;; TODO: Comparing spaces like this doesn't work because the source module is the same, but a specialized
;;;   clone of the dependent space without transitive-dependencies was created during the import process.
;;;   Ideally, we can rework importing so that a special space copy isn't created, and then comparing
;;;   spaces will work again.  But, In my opinion comparing spaces is not a good way to check to see if a
;;;   module has been loaded.  I believe a better solution is accessor operations for loaded & imported modules
;;;
;;;!(assertEqual
;;;  (let $a (collapse (get-atoms &self)) (contains $a is-m))
;;;  True)
;;; Check that the &self space contains the corelib child space
;;; Note: corelib doesn't import any modules into itself, so no space copy is needed
<span class="ansi38-013099040"
>!(import! &corelib corelib)

</span>
Deterministic: ()<span class="ansi38-255165000"
> (: is-corelib (-> Atom Bool))
</span><span class="ansi38-255165000"
> (= (is-corelib $atom) (== $atom &corelib))
</span><span class="ansi38-013099040"
>!(assertEqual (let $a (collapse (get-atoms &self)) (contains $a is-corelib)) True)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.09"
>;; MODULE-SYSTEM.F1-IMPORTS.09</h3>

(failed  once (if_or_else  (eval  = $_336692 495 &self (let a b never-happens) $_338366) (call  eval (let a b never-happens) $_338366)))


(on_mettalog_error  (failed  once (if_or_else  (eval  = $_336692 495 &self (let a b never-happens) $_338366) (call  eval (let a b never-happens) $_338366))))

^  <span class="ansi1 ansi32"
>Call: </span>(309) [user] call(user:once, user:if_or_else(eval(=, _336692, 495, '&self', [let, a, b, 'never-happens'], _338366), call(eval, [let, a, b, 'never-happens'], _338366)))
^  <span class="ansi1 ansi32"
>Call: </span>(310) [user] once(user:if_or_else(eval(=, _336692, 495, '&self', [let, a, b, 'never-happens'], _338366), call(eval, [let, a, b, 'never-happens'], _338366)))
   <span class="ansi1 ansi32"
>Call: </span>(311) [user] if_or_else(eval(=, _336692, 495, '&self', [let, a, b, 'never-happens'], _338366), call(eval, [let, a, b, 'never-happens'], _338366))
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] eval(=, _336692, 495, '&self', [let, a, b, 'never-happens'], _338366)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [user] catch_metta_return(eval_args(=, _336692, 495, '&self', [let, a, b, 'never-happens'], _338366), _338366)
^  <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_args(=, _336692, 495, '&self', [let, a, b, 'never-happens'], _338366)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_346776, _346778), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_346776, _346778))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_346776, _346778))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_348864, _348866), once(user:nonvar(_338366)), '$restore_trace'(_348864, _348866))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_348864, _348866))
^  <span class="ansi1 ansi32"
>Call: </span>(317) [system] setup_call_cleanup('$notrace'(_350952, _350954), once(user:nonvar(_338366)), '$restore_trace'(_350952, _350954))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] sig_atomic(system:'$notrace'(_350952, _350954))
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(316) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(316) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(318) [system] setup_call_cleanup('$notrace'(_358108, _358110), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_358108, _358110))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] sig_atomic(system:'$notrace'(_358108, _358110))
^  <span class="ansi1 ansi31"
>Fail: </span>(316) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] eval_00(=, _336692, 495, '&self', [let, a, b, 'never-happens'], _338366)
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_363252, _363254), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_363252, _363254))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_363252, _363254))
^  <span class="ansi1 ansi31"
>Fail: </span>(317) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(317) [user] eval_01(=, _336692, 495, '&self', [let, a, b, 'never-happens'], _338366)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] 495<1
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] 495<1
^  <span class="ansi1 ansi32"
>Exit: </span>(318) [user] if_t((495<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [system] setup_call_cleanup('$notrace'(_371488, _371490), once(user:(_371464 is 495-1, copy_term([let, a, b, 'never-happens'], _371478))), '$restore_trace'(_371488, _371490))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] sig_atomic(system:'$notrace'(_371488, _371490))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(494 is 495-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] trace_eval(eval_20(=, _336692), e, 494, '&self', [let, a, b, 'never-happens'], _374598)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] must_det_ll((notrace((flag(eval_num, _375652, _375652+1), _375670 is _375652 mod 500, _375688 is 99-494 mod 100, _375712=_375714, option_else('trace-length', _375726, 500), option_else('trace-depth', _375734, 30))), quietly(if_t((nop(stop_rtrace), _375670>_375726), (set_debug(eval, false), _375790 is _375726+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375790])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_375842)))))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] once(user:(notrace((flag(eval_num, _375652, _375652+1), _375670 is _375652 mod 500, _375688 is 99-494 mod 100, _375712=_375714, option_else('trace-length', _375726, 500), option_else('trace-depth', _375734, 30))), quietly(if_t((nop(stop_rtrace), _375670>_375726), (set_debug(eval, false), _375790 is _375726+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375790])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_375842)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] setup_call_cleanup('$notrace'(_377888, _377890), once(user:(flag(eval_num, _375652, _375652+1), _375670 is _375652 mod 500, _375688 is 99-494 mod 100, _375712=_375714, option_else('trace-length', _375726, 500), option_else('trace-depth', _375734, 30))), '$restore_trace'(_377888, _377890))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] sig_atomic(system:'$notrace'(_377888, _377890))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2067, 2067+1), 67 is 2067 mod 500, 5 is 99-494 mod 100, _375712=_375712, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 67>500), (set_debug(eval, false), _375790 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375790])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 67>500), (set_debug(eval, false), _375790 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375790])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(322) [user] nop(notrace(no_repeats_var(_375842)))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [user] nop(notrace(no_repeats_var(_375842)))
^  <span class="ansi1 ansi32"
>Exit: </span>(320) [system] once(user:(notrace((flag(eval_num, 2067, 2067+1), 67 is 2067 mod 500, 5 is 99-494 mod 100, _375712=_375712, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 67>500), (set_debug(eval, false), _375790 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375790])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_375842)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] must_det_ll(user:(notrace((flag(eval_num, 2067, 2067+1), 67 is 2067 mod 500, 5 is 99-494 mod 100, _375712=_375712, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 67>500), (set_debug(eval, false), _375790 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_375790])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_375842)))))
   <span class="ansi1 ansi32"
>Call: </span>(319) [occurs] occurs:sub_term(_387540, e)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(319) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(320) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(320) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(319) [occurs] occurs:sub_term(_387540, e)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _394646=e
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] if_trace((eval;e), (_375712=1, indentq(5, 67, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_397786, _397788), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _375712=1, indentq(5, 67, -->, [e, [let, a, b, 'never-happens']]))), _397744, fbug((_397744-->if_trace((eval;e), (_375712=1, indentq(5, 67, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_397786, _397788))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_397786, _397788))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _375712=1, indentq(5, 67, -->, [e, [let, a, b, 'never-happens']]))), _397744, fbug((_397744-->if_trace((eval;e), (_375712=1, indentq(5, 67, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(319) [user] if_trace((eval;e), (_375712=1, indentq(5, 67, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _401982=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] _404020=(\+ \+ (flag(eval_num, _404040, _404040+1), (retval(fail)\=@=retval(fail), nonvar(_374598)->indentq(5, _404040, <--, [e, _374598]);indentq(5, _404040, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] (\+ \+ (flag(eval_num, _404040, _404040+1), (retval(fail)\=@=retval(fail), nonvar(_374598)->indentq(5, _404040, <--, [e, _374598]);indentq(5, _404040, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _404040, _404040+1), (retval(fail)\=@=retval(fail), nonvar(_374598)->indentq(5, _404040, <--, [e, _374598]);indentq(5, _404040, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] call_cleanup(((call(eval_20(=, _336692), 494, '&self', [let, a, b, 'never-happens'], _374598)*->nb_setarg(1, retval(fail), _374598);fail, trace, call(eval_20(=, _336692), 494, '&self', [let, a, b, 'never-happens'], _374598)), ignore(notrace((\+_374598\=_375842, nb_setarg(1, retval(fail), _374598))))), ignore((_375712==1->ignore(\+ \+ (flag(eval_num, _404040, _404040+1), (retval(fail)\=@=retval(fail), nonvar(_374598)->indentq(5, _404040, <--, [e, _374598]);indentq(5, _404040, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404040, _404040+1), (retval(fail)\=@=retval(fail), nonvar(_374598)->indentq(5, _404040, <--, [e, _374598]);indentq(5, _404040, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] eval_20(=, _336692, 494, '&self', [let, a, b, 'never-happens'], _374598)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] setup_call_cleanup('$notrace'(_411428, _411430), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_411428, _411430))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] sig_atomic(system:'$notrace'(_411428, _411430))
^  <span class="ansi1 ansi31"
>Fail: </span>(323) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] once(expand_eval([let, a, b, 'never-happens'], _433772))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] expand_eval([let, a, b, 'never-happens'], _433772)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(324) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _439872)
   <span class="ansi1 ansi32"
>Call: </span>(325) [apply] apply:maplist_([a, b, 'never-happens'], _439872, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] expand_eval(a, _441928)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] a=_441928
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(326) [apply] apply:maplist_([b, 'never-happens'], _441930, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] expand_eval(b, _448030)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(328) [system] b=_448030
   <span class="ansi1 ansi32"
>Exit: </span>(328) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(327) [apply] apply:maplist_(['never-happens'], _448032, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(328) [user] expand_eval('never-happens', _454132)
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(329) [system] 'never-happens'=_454132
   <span class="ansi1 ansi32"
>Exit: </span>(329) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(328) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(328) [apply] apply:maplist_([], _454134, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] possible_type('&self', a, _471424)
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] possible_type('&self', a, _471424)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] eval_args(=, _471424, 494, '&self', b, _473466)
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_475524, _475526), once(user:self_eval(b)), '$restore_trace'(_475524, _475526))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_475524, _475526))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _473466=b
   <span class="ansi1 ansi32"
>Exit: </span>(323) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] eval_args(=, _471424, 494, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] eval_20(=, _336692, 494, '&self', [let, a, b, 'never-happens'], _374598)
   <span class="ansi1 ansi32"
>Call: </span>(321) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(321) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] ignore((_375712==1->ignore(\+ \+ (flag(eval_num, _404040, _404040+1), (retval(fail)\=@=retval(fail), nonvar(_374598)->indentq(5, _404040, <--, [e, _374598]);indentq(5, _404040, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404040, _404040+1), (retval(fail)\=@=retval(fail), nonvar(_374598)->indentq(5, _404040, <--, [e, _374598]);indentq(5, _404040, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] _375712==1
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] _375712==1
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_488854, _488856), once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404040, _404040+1), (retval(fail)\=@=retval(fail), nonvar(_374598)->indentq(5, _404040, <--, [e, _374598]);indentq(5, _404040, <--, [e, retval(fail)])))))))), '$restore_trace'(_488854, _488856))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_488854, _488856))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404040, _404040+1), (retval(fail)\=@=retval(fail), nonvar(_374598)->indentq(5, _404040, <--, [e, _374598]);indentq(5, _404040, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [system] ignore(user:(_375712==1->ignore(\+ \+ (flag(eval_num, _404040, _404040+1), (retval(fail)\=@=retval(fail), nonvar(_374598)->indentq(5, _404040, <--, [e, _374598]);indentq(5, _404040, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404040, _404040+1), (retval(fail)\=@=retval(fail), nonvar(_374598)->indentq(5, _404040, <--, [e, _374598]);indentq(5, _404040, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [system] call_cleanup(user:((call(eval_20(=, _336692), 494, '&self', [let, a, b, 'never-happens'], _374598)*->nb_setarg(1, retval(fail), _374598);fail, trace, call(eval_20(=, _336692), 494, '&self', [let, a, b, 'never-happens'], _374598)), ignore(notrace((\+_374598\=_375842, nb_setarg(1, retval(fail), _374598))))), user:ignore((_375712==1->ignore(\+ \+ (flag(eval_num, _404040, _404040+1), (retval(fail)\=@=retval(fail), nonvar(_374598)->indentq(5, _404040, <--, [e, _374598]);indentq(5, _404040, <--, [e, retval(fail)]))));notrace(ignore(if_t(5<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _404040, _404040+1), (retval(fail)\=@=retval(fail), nonvar(_374598)->indentq(5, _404040, <--, [e, _374598]);indentq(5, _404040, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] trace_eval(eval_20(=, _336692), e, 494, '&self', [let, a, b, 'never-happens'], _374598)
^  <span class="ansi1 ansi31"
>Fail: </span>(315) [user] eval_args(=, _336692, 495, '&self', [let, a, b, 'never-happens'], _338366)
^  <span class="ansi1 ansi32"
>Call: </span>(312) [user] call(eval, [let, a, b, 'never-happens'], _338366)
   <span class="ansi1 ansi32"
>Call: </span>(313) [user] eval([let, a, b, 'never-happens'], _338366)
^  <span class="ansi1 ansi32"
>Call: </span>(314) [user] current_self(_498262)
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] nb_current(self_space, _498262)
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] nb_current(self_space, '&self')
   <span class="ansi1 ansi32"
>Call: </span>(315) [system] '&self'\==[]
   <span class="ansi1 ansi32"
>Exit: </span>(315) [system] '&self'\==[]
^  <span class="ansi1 ansi32"
>Exit: </span>(314) [user] current_self('&self')
   <span class="ansi1 ansi32"
>Call: </span>(314) [user] eval('&self', [let, a, b, 'never-happens'], _338366)
   <span class="ansi1 ansi32"
>Call: </span>(315) [user] eval_H(500, '&self', [let, a, b, 'never-happens'], _338366)
^  <span class="ansi1 ansi32"
>Call: </span>(316) [user] catch_metta_return(eval_args(=, _506376, 500, '&self', [let, a, b, 'never-happens'], _338366), _338366)
^  <span class="ansi1 ansi32"
>Call: </span>(318) [user] eval_args(=, _506376, 500, '&self', [let, a, b, 'never-happens'], _338366)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] var([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_509486, _509488), once(user:self_eval([let, a, b, 'never-happens'])), '$restore_trace'(_509486, _509488))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_509486, _509488))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_511574, _511576), once(user:nonvar(_338366)), '$restore_trace'(_511574, _511576))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_511574, _511576))
^  <span class="ansi1 ansi32"
>Call: </span>(320) [system] setup_call_cleanup('$notrace'(_513662, _513664), once(user:nonvar(_338366)), '$restore_trace'(_513662, _513664))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] sig_atomic(system:'$notrace'(_513662, _513664))
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(319) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(319) [system] (=)\==(=)
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(321) [system] setup_call_cleanup('$notrace'(_520818, _520820), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_520818, _520820))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] sig_atomic(system:'$notrace'(_520818, _520820))
^  <span class="ansi1 ansi31"
>Fail: </span>(319) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(319) [user] eval_00(=, _506376, 500, '&self', [let, a, b, 'never-happens'], _338366)
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_525962, _525964), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_525962, _525964))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_525962, _525964))
^  <span class="ansi1 ansi31"
>Fail: </span>(320) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(320) [user] eval_01(=, _506376, 500, '&self', [let, a, b, 'never-happens'], _338366)
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] 500<1
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] 500<1
^  <span class="ansi1 ansi32"
>Exit: </span>(321) [user] if_t((500<1, trace_on_overflow), debug(metta(eval_args)))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [system] setup_call_cleanup('$notrace'(_534198, _534200), once(user:(_534174 is 500-1, copy_term([let, a, b, 'never-happens'], _534188))), '$restore_trace'(_534198, _534200))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [system] sig_atomic(system:'$notrace'(_534198, _534200))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(499 is 500-1, copy_term([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(321) [user] trace_eval(eval_20(=, _506376), e, 499, '&self', [let, a, b, 'never-happens'], _537308)
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] must_det_ll((notrace((flag(eval_num, _538362, _538362+1), _538380 is _538362 mod 500, _538398 is 99-499 mod 100, _538422=_538424, option_else('trace-length', _538436, 500), option_else('trace-depth', _538444, 30))), quietly(if_t((nop(stop_rtrace), _538380>_538436), (set_debug(eval, false), _538500 is _538436+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538500])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_538552)))))
^  <span class="ansi1 ansi32"
>Call: </span>(323) [user] once(user:(notrace((flag(eval_num, _538362, _538362+1), _538380 is _538362 mod 500, _538398 is 99-499 mod 100, _538422=_538424, option_else('trace-length', _538436, 500), option_else('trace-depth', _538444, 30))), quietly(if_t((nop(stop_rtrace), _538380>_538436), (set_debug(eval, false), _538500 is _538436+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538500])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_538552)))))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [system] setup_call_cleanup('$notrace'(_540598, _540600), once(user:(flag(eval_num, _538362, _538362+1), _538380 is _538362 mod 500, _538398 is 99-499 mod 100, _538422=_538424, option_else('trace-length', _538436, 500), option_else('trace-depth', _538444, 30))), '$restore_trace'(_540598, _540600))
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] sig_atomic(system:'$notrace'(_540598, _540600))
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:(flag(eval_num, 2068, 2068+1), 68 is 2068 mod 500, 0 is 99-499 mod 100, _538422=_538422, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 68>500), (set_debug(eval, false), _538500 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538500])), nop((start_rtrace, rtrace)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [rtrace] rtrace:quietly3(user:if_t((nop(stop_rtrace), 68>500), (set_debug(eval, false), _538500 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538500])), nop((start_rtrace, rtrace)))))
   <span class="ansi1 ansi32"
>Call: </span>(325) [user] nop(notrace(no_repeats_var(_538552)))
   <span class="ansi1 ansi32"
>Exit: </span>(325) [user] nop(notrace(no_repeats_var(_538552)))
^  <span class="ansi1 ansi32"
>Exit: </span>(323) [system] once(user:(notrace((flag(eval_num, 2068, 2068+1), 68 is 2068 mod 500, 0 is 99-499 mod 100, _538422=_538422, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 68>500), (set_debug(eval, false), _538500 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538500])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_538552)))))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] must_det_ll(user:(notrace((flag(eval_num, 2068, 2068+1), 68 is 2068 mod 500, 0 is 99-499 mod 100, _538422=_538422, option_else('trace-length', 500, 500), option_else('trace-depth', 30, 30))), quietly(if_t((nop(stop_rtrace), 68>500), (set_debug(eval, false), _538500 is 500+1, nop(format('; Switched off tracing. For a longer trace: !(pragma! trace-length ~w)', [_538500])), nop((start_rtrace, rtrace))))), nop(notrace(no_repeats_var(_538552)))))
   <span class="ansi1 ansi32"
>Call: </span>(322) [occurs] occurs:sub_term(_550250, e)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [occurs] occurs:sub_term(e, e)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] e\=e
   <span class="ansi1 ansi31"
>Fail: </span>(322) [system] e\=e
   <span class="ansi1 ansi32"
>Call: </span>(323) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(323) [system] compound(e)
   <span class="ansi1 ansi31"
>Fail: </span>(322) [occurs] occurs:sub_term(_550250, e)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _557356=e
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] e=e
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] if_trace((eval;e), (_538422=1, indentq(0, 68, -->, [e, [let, a, b, 'never-happens']])))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [system] setup_call_cleanup('$notrace'(_560496, _560498), once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _538422=1, indentq(0, 68, -->, [e, [let, a, b, 'never-happens']]))), _560454, fbug((_560454-->if_trace((eval;e), (_538422=1, indentq(0, 68, -->, [e, [let, a, b, 'never-happens']])))))))), '$restore_trace'(_560496, _560498))
^  <span class="ansi1 ansi32"
>Call: </span>(325) [system] sig_atomic(system:'$notrace'(_560496, _560498))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:real_notrace(catch_err(ignore((is_debugging((eval;e)), _538422=1, indentq(0, 68, -->, [e, [let, a, b, 'never-happens']]))), _560454, fbug((_560454-->if_trace((eval;e), (_538422=1, indentq(0, 68, -->, [e, [let, a, b, 'never-happens']])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(322) [user] if_trace((eval;e), (_538422=1, indentq(0, 68, -->, [e, [let, a, b, 'never-happens']])))
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _564692=retval(fail)
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] retval(fail)=retval(fail)
   <span class="ansi1 ansi32"
>Call: </span>(322) [system] _566730=(\+ \+ (flag(eval_num, _566750, _566750+1), (retval(fail)\=@=retval(fail), nonvar(_537308)->indentq(0, _566750, <--, [e, _537308]);indentq(0, _566750, <--, [e, retval(fail)]))))
   <span class="ansi1 ansi32"
>Exit: </span>(322) [system] (\+ \+ (flag(eval_num, _566750, _566750+1), (retval(fail)\=@=retval(fail), nonvar(_537308)->indentq(0, _566750, <--, [e, _537308]);indentq(0, _566750, <--, [e, retval(fail)]))))=(\+ \+ (flag(eval_num, _566750, _566750+1), (retval(fail)\=@=retval(fail), nonvar(_537308)->indentq(0, _566750, <--, [e, _537308]);indentq(0, _566750, <--, [e, retval(fail)]))))
^  <span class="ansi1 ansi32"
>Call: </span>(322) [user] call_cleanup(((call(eval_20(=, _506376), 499, '&self', [let, a, b, 'never-happens'], _537308)*->nb_setarg(1, retval(fail), _537308);fail, trace, call(eval_20(=, _506376), 499, '&self', [let, a, b, 'never-happens'], _537308)), ignore(notrace((\+_537308\=_538552, nb_setarg(1, retval(fail), _537308))))), ignore((_538422==1->ignore(\+ \+ (flag(eval_num, _566750, _566750+1), (retval(fail)\=@=retval(fail), nonvar(_537308)->indentq(0, _566750, <--, [e, _537308]);indentq(0, _566750, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566750, _566750+1), (retval(fail)\=@=retval(fail), nonvar(_537308)->indentq(0, _566750, <--, [e, _537308]);indentq(0, _566750, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] eval_20(=, _506376, 499, '&self', [let, a, b, 'never-happens'], _537308)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] atom([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] no_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] self_eval([let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] setup_call_cleanup('$notrace'(_574138, _574140), once(user:self_eval0([let, a, b, 'never-happens'])), '$restore_trace'(_574138, _574140))
^  <span class="ansi1 ansi32"
>Call: </span>(329) [system] sig_atomic(system:'$notrace'(_574138, _574140))
^  <span class="ansi1 ansi31"
>Fail: </span>(326) [user] self_eval([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] atomic(let)
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] atomic(let)
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] is_sl(let)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] number(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] atom(=)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] atom(=)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] (=)\==(=)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] callable(let)
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] callable(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [a, b, 'never-happens']==[]
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(325) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] var(let)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] once(expand_eval([let, a, b, 'never-happens'], _596482))
^  <span class="ansi1 ansi32"
>Call: </span>(326) [user] expand_eval([let, a, b, 'never-happens'], _596482)
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] is_list([let, a, b, 'never-happens'])
   <span class="ansi1 ansi32"
>Call: </span>(327) [system] ground(let)
   <span class="ansi1 ansi32"
>Exit: </span>(327) [system] ground(let)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [user] apply:maplist(expand_eval, [a, b, 'never-happens'], _602582)
   <span class="ansi1 ansi32"
>Call: </span>(328) [apply] apply:maplist_([a, b, 'never-happens'], _602582, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(329) [user] expand_eval(a, _604638)
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] is_list(a)
   <span class="ansi1 ansi32"
>Call: </span>(330) [system] a=_604638
   <span class="ansi1 ansi32"
>Exit: </span>(330) [system] a=a
^  <span class="ansi1 ansi32"
>Exit: </span>(329) [user] expand_eval(a, a)
   <span class="ansi1 ansi32"
>Call: </span>(329) [apply] apply:maplist_([b, 'never-happens'], _604640, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(330) [user] expand_eval(b, _610740)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] is_list(b)
   <span class="ansi1 ansi32"
>Call: </span>(331) [system] b=_610740
   <span class="ansi1 ansi32"
>Exit: </span>(331) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(330) [user] expand_eval(b, b)
   <span class="ansi1 ansi32"
>Call: </span>(330) [apply] apply:maplist_(['never-happens'], _610742, user:expand_eval)
^  <span class="ansi1 ansi32"
>Call: </span>(331) [user] expand_eval('never-happens', _616842)
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] is_list('never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(332) [system] 'never-happens'=_616842
   <span class="ansi1 ansi32"
>Exit: </span>(332) [system] 'never-happens'='never-happens'
^  <span class="ansi1 ansi32"
>Exit: </span>(331) [user] expand_eval('never-happens', 'never-happens')
   <span class="ansi1 ansi32"
>Call: </span>(331) [apply] apply:maplist_([], _616844, user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(331) [apply] apply:maplist_([], [], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(330) [apply] apply:maplist_(['never-happens'], ['never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(329) [apply] apply:maplist_([b, 'never-happens'], [b, 'never-happens'], user:expand_eval)
   <span class="ansi1 ansi32"
>Exit: </span>(328) [apply] apply:maplist_([a, b, 'never-happens'], [a, b, 'never-happens'], user:expand_eval)
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [apply] apply:maplist(user:expand_eval, [a, b, 'never-happens'], [a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(326) [user] expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens'])
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [system] once(user:expand_eval([let, a, b, 'never-happens'], [let, a, b, 'never-happens']))
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] [let, a, b, 'never-happens']\==[let, a, b, 'never-happens']
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] is_progn(let)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(let)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] possible_type('&self', a, _634134)
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [user] possible_type('&self', a, _634134)
^  <span class="ansi1 ansi32"
>Call: </span>(325) [user] eval_args(=, _634134, 499, '&self', b, _636176)
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] var(b)
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] setup_call_cleanup('$notrace'(_638234, _638236), once(user:self_eval(b)), '$restore_trace'(_638234, _638236))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] sig_atomic(system:'$notrace'(_638234, _638236))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:self_eval(b)), system:'$restore_trace'(3, -1))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _636176=b
   <span class="ansi1 ansi32"
>Exit: </span>(326) [system] b=b
^  <span class="ansi1 ansi32"
>Exit: </span>(325) [user] eval_args(=, _634134, 499, '&self', b, b)
   <span class="ansi1 ansi32"
>Call: </span>(325) [system] a=b
^  <span class="ansi1 ansi31"
>Fail: </span>(324) [user] eval_20(=, _506376, 499, '&self', [let, a, b, 'never-happens'], _537308)
   <span class="ansi1 ansi32"
>Call: </span>(324) [system] fail
   <span class="ansi1 ansi31"
>Fail: </span>(324) [system] fail
^  <span class="ansi1 ansi32"
>Call: </span>(324) [user] ignore((_538422==1->ignore(\+ \+ (flag(eval_num, _566750, _566750+1), (retval(fail)\=@=retval(fail), nonvar(_537308)->indentq(0, _566750, <--, [e, _537308]);indentq(0, _566750, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566750, _566750+1), (retval(fail)\=@=retval(fail), nonvar(_537308)->indentq(0, _566750, <--, [e, _537308]);indentq(0, _566750, <--, [e, retval(fail)]))))))))))
   <span class="ansi1 ansi32"
>Call: </span>(326) [system] _538422==1
   <span class="ansi1 ansi31"
>Fail: </span>(326) [system] _538422==1
^  <span class="ansi1 ansi32"
>Call: </span>(327) [system] setup_call_cleanup('$notrace'(_651564, _651566), once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566750, _566750+1), (retval(fail)\=@=retval(fail), nonvar(_537308)->indentq(0, _566750, <--, [e, _537308]);indentq(0, _566750, <--, [e, retval(fail)])))))))), '$restore_trace'(_651564, _651566))
^  <span class="ansi1 ansi32"
>Call: </span>(328) [system] sig_atomic(system:'$notrace'(_651564, _651566))
^  <span class="ansi1 ansi32"
>Exit: </span>(327) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(user:ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566750, _566750+1), (retval(fail)\=@=retval(fail), nonvar(_537308)->indentq(0, _566750, <--, [e, _537308]);indentq(0, _566750, <--, [e, retval(fail)])))))))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Exit: </span>(324) [system] ignore(user:(_538422==1->ignore(\+ \+ (flag(eval_num, _566750, _566750+1), (retval(fail)\=@=retval(fail), nonvar(_537308)->indentq(0, _566750, <--, [e, _537308]);indentq(0, _566750, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566750, _566750+1), (retval(fail)\=@=retval(fail), nonvar(_537308)->indentq(0, _566750, <--, [e, _537308]);indentq(0, _566750, <--, [e, retval(fail)]))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(322) [system] call_cleanup(user:((call(eval_20(=, _506376), 499, '&self', [let, a, b, 'never-happens'], _537308)*->nb_setarg(1, retval(fail), _537308);fail, trace, call(eval_20(=, _506376), 499, '&self', [let, a, b, 'never-happens'], _537308)), ignore(notrace((\+_537308\=_538552, nb_setarg(1, retval(fail), _537308))))), user:ignore((_538422==1->ignore(\+ \+ (flag(eval_num, _566750, _566750+1), (retval(fail)\=@=retval(fail), nonvar(_537308)->indentq(0, _566750, <--, [e, _537308]);indentq(0, _566750, <--, [e, retval(fail)]))));notrace(ignore(if_t(0<30, if_trace((eval;e), ignore(\+ \+ (flag(eval_num, _566750, _566750+1), (retval(fail)\=@=retval(fail), nonvar(_537308)->indentq(0, _566750, <--, [e, _537308]);indentq(0, _566750, <--, [e, retval(fail)])))))))))))
^  <span class="ansi1 ansi31"
>Fail: </span>(321) [user] trace_eval(eval_20(=, _506376), e, 499, '&self', [let, a, b, 'never-happens'], _537308)
^  <span class="ansi1 ansi31"
>Fail: </span>(318) [user] eval_args(=, _506376, 500, '&self', [let, a, b, 'never-happens'], _338366)
^  <span class="ansi1 ansi31"
>Fail: </span>(309) [system] call(user:once, user:if_or_else(eval(=, _336692, 495, '&self', [let, a, b, 'never-happens'], _338366), call(eval, [let, a, b, 'never-happens'], _338366)))
^  <span class="ansi1 ansi32"
>Call: </span>(309) [bugger] bugger:mquietly_if(true, rtrace:pop_tracer)
   <span class="ansi1 ansi32"
>Call: </span>(311) [system] var(rtrace:pop_tracer)
   <span class="ansi1 ansi31"
>Fail: </span>(311) [system] var(rtrace:pop_tracer)
^  <span class="ansi1 ansi32"
>Call: </span>(313) [system] setup_call_cleanup('$notrace'(_663026, _663028), once(rtrace:retract(t_l:tracer_reset(_663016))), '$restore_trace'(_663026, _663028))
^  <span class="ansi1 ansi32"
>Call: </span>(314) [system] sig_atomic(system:'$notrace'(_663026, _663028))
^  <span class="ansi1 ansi32"
>Exit: </span>(313) [system] setup_call_cleanup(system:'$notrace'(3, -1), system:once(rtrace:retract(t_l:tracer_reset(tAt_normal))), system:'$restore_trace'(3, -1))
^  <span class="ansi1 ansi32"
>Call: </span>(313) [rtrace] tAt(false, 271, 271, false)
; 
; EVAL TEST
; took 5.56 seconds.

!(assertEqual (let $a (collapse (get-atoms &self)) (contains $a is-corelib)) True)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (True) (True)))
</span>
Deterministic: ()
;;; Let's check that `if` from stdlib is not duplicated and gives only one result
<span class="ansi38-013099040"
>!(assertEqual (if (> 1 2) 1 2) 2)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.10"
>;; MODULE-SYSTEM.F1-IMPORTS.10</h3>
; 
; EVAL TEST
; took 0.000260 secs. (259.57 microseconds) 

!(assertEqual (if (> 1 2) 1 2) 2)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (2) (2)))
</span>
Deterministic: ()
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Let's import one more module into `&self` with a diamond dependence
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleB)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta is 282 bytes (7 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta is 292 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Number))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (g $x) (+ $x 10)))
</span>
Last Result(2): ()
;;; `g` from moduleC imported via two paths as well as `f`, which uses `g`,
;;; are not duplicated and produce deterministic results
<span class="ansi38-013099040"
>!(assertEqual (g 2) 102)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.11"
>;; MODULE-SYSTEM.F1-IMPORTS.11</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.12 milliseconds) 

!(assertEqual (g 2) 102)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102) (102)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (f 2) 103)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.12"
>;; MODULE-SYSTEM.F1-IMPORTS.12</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.33 milliseconds) 

!(assertEqual (f 2) 103)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (103) (103)))
</span>
Deterministic: ()
;;; Function declared in different imported modules will still produce
;;; non-deterministic results
<span class="ansi38-013099040"
>!(assertEqualToResult (dup 2) (12 102))

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.13"
>;; MODULE-SYSTEM.F1-IMPORTS.13</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.11 milliseconds) 

!(assertEqualToResult (dup 2) (12 102))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102 12) (12 102)))
</span>
Deterministic: ()
;;; Let's import f1_moduleB once more. Such import should be ignored and
;;; thus f, g and dup should remain unchanged.
<span class="ansi38-013099040"
>!(import! &self f1_moduleB)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta is 282 bytes (7 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleB.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040"
>!(import! &self f1_moduleC)

</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)
<span class="ansi1 ansi90"
>
Info: File /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta is 292 bytes (9 lines)
</span>P;HTML|
;                                         (load_answer_file  /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta.answers /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_moduleC.metta)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Example file used by f1_imports.metta
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-255165000"
> (: __g (-> Number))
</span><span class="ansi38-255165000"
> (= (__g) 100)
</span><span class="ansi38-255165000"
> (: g (-> Number Number))
</span><span class="ansi38-255165000"
> (= (g $x) (+ $x (__g)))
</span>
Deterministic: ()<span class="ansi38-255165000"
> (= (dup $x) (if (== $x 0) (g $x) (+ $x 10)))
</span>
Last Result(2): ()
<span class="ansi38-013099040"
>!(assertEqual (g 2) 102)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.14"
>;; MODULE-SYSTEM.F1-IMPORTS.14</h3>
; 
; EVAL TEST
; took 0.000947 secs. (947.31 microseconds) 

!(assertEqual (g 2) 102)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102) (102)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqual (f 2) 103)

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.15"
>;; MODULE-SYSTEM.F1-IMPORTS.15</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.33 milliseconds) 

!(assertEqual (f 2) 103)

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (103) (103)))
</span>
Deterministic: ()
<span class="ansi38-013099040"
>!(assertEqualToResult (dup 2) (12 102))

</span>
;<h3 id="MODULE-SYSTEM.F1-IMPORTS.16"
>;; MODULE-SYSTEM.F1-IMPORTS.16</h3>
; 
; EVAL TEST
; took 0.002 secs. (2.02 milliseconds) 

!(assertEqualToResult (dup 2) (12 102))

<span class="ansi36"
>(loonit_success  (equal_enough_for_test  (102 12) (12 102)))
</span>
Deterministic: ()<span class="ansi32"
>
% 71,571,117 inferences, 18.615 CPU in 18.638 seconds (100% CPU, 3844811 Lips)
</span>P;HTML|
;                       (= /home/runner/work/metta-wam/metta-wam/tests/baseline_compat/module-system/f1_imports.metta  0)
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 14
</span><span class="ansi31"
>Failures: 2
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
P;HTML|
;         (is_cmd_option  execute halt --halt=true true)
P;HTML|
;          (set_option_value  halt true)
P;HTML|
;          (is_cmd_option  execute stdin --stdin=tty tty)
P;HTML|
;          (set_option_value  stdin tty)
P;HTML|
;          (is_cmd_option  execute stdout --stdout=tty tty)
P;HTML|
;           (set_option_value  stdout tty)
P;HTML|
;          (is_cmd_option  execute stderr --stderr=tty tty)
P;HTML|
;           (set_option_value  stderr tty)
P;HTML|
;         (set_option_value  compat false)
P;HTML|
;         (set_option_value  compatio false)
P;HTML|
;         (set_option_value  src_indents false)
P;HTML|
;         (set_option_value  devel false)
P;HTML|
;         (set_option_value  stack-max 500)
P;HTML|
;         (set_option_value  limit inf)
P;HTML|
;         (set_option_value  initial-result-count 10)
P;HTML|
;         (set_option_value  answer-format show)
P;HTML|
;         (set_option_value  repeats true)
P;HTML|
;         (set_option_value  time true)
P;HTML|
;         (set_option_value  synth-unit-tests false)
P;HTML|
;         (set_option_value  optimize true)
P;HTML|
;         (set_option_value  transpiler silent)
P;HTML|
;          (set_debug  transpiler false)
P;HTML|
;         (set_option_value  compile false)
P;HTML|
;         (set_option_value  tabling auto)
P;HTML|
;         (set_option_value  log false)
P;HTML|
;         (set_option_value  output ./)
P;HTML|
;         (set_option_value  exeout ./Sav.gitlab.MeTTaLog)
P;HTML|
;         (set_option_value  halt false)
P;HTML|
;         (set_option_value  trace-length 500)
P;HTML|
;         (set_option_value  trace-on-overtime 4.0)
P;HTML|
;          (set_debug  overtime 4.0)
P;HTML|
;         (set_option_value  trace-on-overflow 1000)
P;HTML|
;          (set_debug  overflow 1000)
P;HTML|
;         (set_option_value  trace-on-eval false)
P;HTML|
;          (set_debug  eval false)
P;HTML|
;         (set_option_value  trace-on-load silent)
P;HTML|
;          (set_debug  load silent)
P;HTML|
;          (set_debug  trace-on-load false)
P;HTML|
;         (set_option_value  trace-on-exec false)
P;HTML|
;          (set_debug  exec false)
P;HTML|
;         (set_option_value  trace-on-error non-type)
P;HTML|
;          (set_debug  error non-type)
P;HTML|
;         (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;         (set_option_value  trace-on-test true)
P;HTML|
;          (set_debug  test true)
P;HTML|
;         (set_option_value  repl-on-error true)
P;HTML|
;         (set_option_value  repl-on-fail false)
P;HTML|
;         (set_option_value  exit-on-fail false)
P;HTML|
;         (set_option_value  repl auto)
P;HTML|
;         (set_option_value  prolog false)
P;HTML|
;         (set_option_value  exec noskip)
P;HTML|
;         (set_option_value  maximum-result-count inf)
P;HTML|
;         (set_option_value  html false)
P;HTML|
;         (set_option_value  python true)
P;HTML|
;         (set_option_value  trace-on-test false)
P;HTML|
;          (set_debug  test false)
P;HTML|
;         (set_option_value  trace-on-fail false)
P;HTML|
;          (set_debug  fail false)
P;HTML|
;         (set_option_value  load show)
P;HTML|
;         (set_option_value  test true)
[((Error  (got  ((hyperon::space::DynSpace) (hyperon::space::DynSpace) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (DocInformal) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()) (()))) (expected  ((hyperon::space::DynSpace) (hyperon::space::DynSpace)))))]
[()]
[()]
[((Error  (got  ()) (expected  (True))))]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
P;HTML|
;         (maybe_halt  7)
<span class="ansi31"
>(in  (maybe_halt  7) (unwind  (halt  7)))
</span>
Script done on 2024-11-22 00:41:11+00:00 [COMMAND_EXIT_CODE="7"]

</pre>
</body>

</html>
\033[0;32mCompleted successfully (EXITCODE=7) Under 40 seconds: ./mettalog '--output=./reports/tests_output/baseline-compat/' --timeout=40 --html --repl=false  --test "tests/baseline_compat/module-system/f1_imports.metta" --halt=true\033[0m
