<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"
>
<title></title>
<style type="text/css"
>
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi36 { color: #00aaaa; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-255165005 { color: #FFA505; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-173216230 { color: #ADD8E6; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content"
>
Script started on 2025-04-13 22:53:53+00:00 [COMMAND="timeout --preserve-status --foreground 121 swipl -x /home/runner/work/metta-testsuite/metta-testsuite/prolog/metta_lang/Sav.fv-az802-713.MeTTaLog  -- --python=enable -- --timeout=121 --output=/home/runner/work/metta-testsuite/metta-testsuite/reports/tests_output/baseline-compat --html --test --compile=full tests/direct_comp/important/task1_whole_atoms_kb.metta --halt=true  --stdin=tty --stdout=tty --stderr=tty" TERM="xterm-256color" TTY="/dev/pts/0" COLUMNS="-1" LINES="-1"]

; user:[load_metta_file &self tests/direct_comp/important/task1_whole_atoms_kb.metta]
P;HTML|
;            [track_load_into_file /home/runner/work/metta-testsuite/metta-testsuite/tests/direct_comp/important/task1_whole_atoms_kb.metta]
P;HTML|
;                    [load_answer_file /home/runner/work/metta-testsuite/metta-testsuite/tests/direct_comp/important/task1_whole_atoms_kb.metta.answers /home/runner/work/metta-testsuite/metta-testsuite/tests/direct_comp/important/task1_whole_atoms_kb.metta]
P;HTML|
;                    [load_answer_file /home/runner/work/metta-testsuite/metta-testsuite/tests/direct_comp/important/task1_whole_atoms_kb.metta.answers /home/runner/work/metta-testsuite/metta-testsuite/tests/direct_comp/important/task1_whole_atoms_kb.metta]

<span class="ansi38-013099040"
>!(bind! &kb (new-space))

</span><span class="ansi38-017068017"
>:- do_metta_runtime(A,
                    ('mc__1_0_new-space'(B), 'mc__1_2_bind!'('&kb', B, A))).

</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &kb (:object a))

</span><span class="ansi38-017068017"
>:- do_metta_runtime(A,
                    (B=[':object', a], 'mc__1_2_add-atom'(space_1, B, A))).

</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &kb (:object b))

</span><span class="ansi38-017068017"
>:- do_metta_runtime(A,
                    (B=[':object', b], 'mc__1_2_add-atom'(space_1, B, A))).

</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &kb (:object c))

</span><span class="ansi38-017068017"
>:- do_metta_runtime(A,
                    (B=[':object', c], 'mc__1_2_add-atom'(space_1, B, A))).

</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &kb (:init ((on-table a) (on-table b) (clear a) (clear b) (arm-empty) (on-table c) (clear c))))

</span><span class="ansi38-017068017"
>:- do_metta_runtime(A,
                    (B=['on-table', a], C=['on-table', b], D=[clear, a], E=[clear, b], F=['arm-empty'], G=['on-table', c], H=[clear, c], I=[B, C, D, E, F, G, H], J=[':init', I], 'mc__1_2_add-atom'(space_1, J, A))).

</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &kb (:goal (And ((on a b) (on b c)))))

</span><span class="ansi38-017068017"
>:- do_metta_runtime(A,
                    (B=[on, a, b], C=[on, b, c], D=[B, C], E=['And', D], F=[':goal', E], 'mc__1_2_add-atom'(space_1, F, A))).

</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &kb (:action pickup :parameters ($53468) :precondition (And ((clear $53468) (on-table $53468) (arm-empty))) :effect (And ((holding $53468) (Not (clear $53468)) (Not (on-table $53468)) (Not (arm-empty))))))

</span><span class="ansi38-017068017"
>:- do_metta_runtime(A,
                    (B=[C], D=[clear, C], E=['on-table', C], F=['arm-empty'], G=[D, E, F], H=['And', G], I=[holding, C], J=[clear, C], K=['Not', J], L=['on-table', C], M=['Not', L], N=['arm-empty'], O=['Not', N], P=[I, K, M, O], Q=['And', P], R=[':action', pickup, ':parameters', B, ':precondition', H, ':effect', Q], 'mc__1_2_add-atom'(space_1, R, A))).

</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &kb (:action putdown :parameters ($31480) :precondition (And ((holding $31480))) :effect (And ((clear $31480) (arm-empty) (on-table $31480) (Not (holding $31480))))))

</span><span class="ansi38-017068017"
>:- do_metta_runtime(A,
                    (B=[C], D=[holding, C], E=[D], F=['And', E], G=[clear, C], H=['arm-empty'], I=['on-table', C], J=[holding, C], K=['Not', J], L=[G, H, I, K], M=['And', L], N=[':action', putdown, ':parameters', B, ':precondition', F, ':effect', M], 'mc__1_2_add-atom'(space_1, N, A))).

</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &kb (:action stack :parameters ($20340 $20346) :precondition (And ((clear $20346) (holding $20340))) :effect (And ((arm-empty) (clear $20340) (on $20340 $20346) (Not (clear $20346)) (Not (holding $20340))))))

</span><span class="ansi38-017068017"
>:- do_metta_runtime(A,
                    (B=[C, D], E=[clear, D], F=[holding, C], G=[E, F], H=['And', G], I=['arm-empty'], J=[clear, C], K=[on, C, D], L=[clear, D], M=['Not', L], N=[holding, C], O=['Not', N], P=[I, J, K, M, O], Q=['And', P], R=[':action', stack, ':parameters', B, ':precondition', H, ':effect', Q], 'mc__1_2_add-atom'(space_1, R, A))).

</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-013099040"
>!(add-atom &kb (:action unstack :parameters ($21314 $21320) :precondition (And ((on $21314 $21320) (clear $21314) (arm-empty))) :effect (And ((holding $21314) (clear $21320) (Not (on $21314 $21320)) (Not (clear $21314)) (Not (arm-empty))))))

</span><span class="ansi38-017068017"
>:- do_metta_runtime(A,
                    (B=[C, D], E=[on, C, D], F=[clear, C], G=['arm-empty'], H=[E, F, G], I=['And', H], J=[holding, C], K=[clear, D], L=[on, C, D], M=['Not', L], N=[clear, C], O=['Not', N], P=['arm-empty'], Q=['Not', P], R=[J, K, M, O, Q], S=['And', R], T=[':action', unstack, ':parameters', B, ':precondition', I, ':effect', S], 'mc__1_2_add-atom'(space_1, T, A))).

</span>
Deterministic: <span class="ansi33"
>()
</span><span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_2_formula-satisfaction'(StateId, ['Not', _expr], A) :-
    'mc__1_2_formula-satisfaction'(StateId, _expr, B),
    mc__1_1_not(B, A).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_2_formula-satisfaction'(StateId, ['Or', ExprList], A) :-
    (   'mc__1_2_=='(ExprList, [], B),
        is_True(B)
    *-> A='False'
    ;   'mc__1_1_decons-atom'(ExprList, C),
        [_head, _rest]=C,
        'mc__1_2_formula-satisfaction'(StateId, _head, D),
        _v=D,
        (   is_True(_v)
        *-> E='True'
        ;   (   is_True(_v)
            *-> F='True'
            ;   G=['Or', _rest],
                'mc__1_2_formula-satisfaction'(StateId, G, H),
                F=H
            ),
            E=F
        ),
        A=E
    ).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_2_formula-satisfaction'(StateId, ['And', ExprList], A) :-
    (   'mc__1_2_=='(ExprList, [], B),
        is_True(B)
    *-> A='True'
    ;   'mc__1_1_decons-atom'(ExprList, C),
        [_head, _rest]=C,
        'mc__1_2_formula-satisfaction'(StateId, _head, D),
        _v=D,
        (   mc__1_1_not(_v, E),
            is_True(E)
        *-> F='False'
        ;   (   is_True(_v)
            *-> G=['And', _rest],
                'mc__1_2_formula-satisfaction'(StateId, G, H),
                I=H
            ;   I='False'
            ),
            F=I
        ),
        A=F
    ).

</span>
<span class="ansi38-255165005"
>1 _15966 [[assign,_16394,list(['State',_1660{vn = ...},_1646{vn = ...}])],[assign,_17316,[ispu,'True']],[assign,_15966,[fcall(match,[3]),[space_1,_16394,_17316]]]]
</span><span class="ansi38-173216230"
>
'mc__1_2_formula-satisfaction'(StateId, _expr, A) :-
    (   true
    *-> B=_expr
    ;   B='Empty'
    ),
    C=['And', _x],
    (   B=C
    *-> mc__1_0_empty(D),
        A=D
    ;   E=['Or', _x],
        (   B=E
        *-> mc__1_0_empty(F),
            G=F
        ;   H=['Not', _x],
            (   B=H
            *-> mc__1_0_empty(I),
                J=I
            ;   (   B=_1
                *-> K=ispeEnNC(L, mc__1_3_match(space_1, M, N, L), O, O=[match, space_1, M, N], (M=['State', StateId, _expr], N=ispu('True'))),
                    mc__1_1_collapse(K, P),
                    _all=P,
                    (   'mc__1_2_=='(_all, [], Q),
                        is_True(Q)
                    *-> R='False'
                    ;   R='True'
                    ),
                    S=R
                ;   T='Empty',
                    S=T
                ),
                J=S
            ),
            G=J
        ),
        A=G
    ).

</span>
<span class="ansi38-255165005"
>1 _28802 [[assign,_29486,[fcall('formula-satisfaction',[2]),[_1606{vn = ...},_1550{vn = ...}]]],[assign,_30050,list(['Error',_1564{vn = ...},'FailedUnification'])],[assign,_28802,list([unf,_1578{vn = ...},_1564{vn = ...},_29486,_30050])]]
</span><span class="ansi38-173216230"
>
'mc__1_3_action-applicable'(StateId, ActionId, _args, A) :-
    B=[':action', ActionId, ':parameters', _params, ':precondition', _preds, ':effect', _effs],
    C=ispeEnN(D, ('mc__1_2_formula-satisfaction'(StateId, _preds, E), F=['Error', _params, 'FailedUnification'], D=[unf, _args, _params, E, F]), G, (H=['formula-satisfaction', StateId, _preds], I=['Error', _params, 'FailedUnification'], G=[unf, _args, _params, H, I])),
    mc__1_3_match(space_1, B, C, A).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_1_args-combination'(_params, A) :-
    (   'mc__1_2_=='(_params, [], B),
        is_True(B)
    *-> A=[]
    ;   'mc__1_1_decons-atom'(_params, C),
        [_1, _rest]=C,
        D=[':object', _o],
        E=ispu(_o),
        mc__1_3_match(space_1, D, E, F),
        _h=F,
        'mc__1_1_args-combination'(_rest, G),
        _r=G,
        'mc__1_2_cons-atom'(_h, _r, H),
        A=H
    ).

</span>
<span class="ansi38-255165005"
>1 _33132 [[assign,_33274,[fcall('args-combination',[1]),[_2130{vn = ...}]]],[assign,_2088{vn = ...},_33274],[assign,_34528,list(['Error',_2130{vn = ...},'FailedUnification'])],[assign,_33786,list([unf,_2088{vn = ...},_2130{vn = ...},'True',_34528])],[assign,_2074{vn = ...},_33786],[prolog_if,[[assign,_35982,[fcall('formula-satisfaction',[2]),[_2158{vn = ...},_2116{vn = ...}]]],[native(is_True),_35982]],[[transpiler_apply,mc__1_1_,_2144{vn = ...},[_2144{vn = ...},_2130{vn = ...}],_36568,[_2130{vn = ...}],[_2130{vn = ...}],[x(noeval,eager,[])],[[]],[[]]],[assign,_33132,_36568]],[[assign,_36916,[fcall(empty,[0]),[]]],[assign,_33132,_36916]]]]
</span><span class="ansi38-173216230"
>
'mc__1_1_actions-applicable'(StateId, A) :-
    B=[':action', ActionId, ':parameters', _params, ':precondition', _preds, ':effect', _effs],
    C=ispeEnNC(D, ('mc__1_2_formula-satisfaction'(StateId, _preds, E), is_True(E)*->transpiler_apply(mc__1_1_, ActionId, [ActionId, _params], F, [_params], [_params], [x(noeval, eager, [])], [true], [true]), D=F;mc__1_0_empty(G), D=G), H, ('mc__1_2_formula-satisfaction'(StateId, _preds, E), is_True(E)*->I=[ActionId, _params], H=I;J=[empty], H=J), ('mc__1_1_args-combination'(_params, K), _args=K, L=['Error', _params, 'FailedUnification'], M=[unf, _args, _params, 'True', L], _1=M)),
    mc__1_3_match(space_1, B, C, A).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_2_action-applyEffect'(ActionId, _args, A) :-
    B=[':action', ActionId, ':parameters', _params, ':precondition', _preds, ':effect', _effs],
    C=ispuU(D, D=[unf, _args, _params, _effs, 'FailedUnification']),
    mc__1_3_match(space_1, B, C, A).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_1_signed-fluents'(_list, A) :-
    (   'mc__1_2_=='(_list, [], B),
        is_True(B)
    *-> C=[[], []],
        A=C
    ;   'mc__1_1_decons-atom'(_list, D),
        [_h, _rest]=D,
        'mc__1_1_signed-fluents'(_rest, E),
        [_pos, _neg]=E,
        F=['Not', _v],
        G=['True', _v],
        H=['False', _h],
        I=[unf, _h, F, G, H],
        [IsNeg, _f]=I,
        (   is_True(IsNeg)
        *-> 'mc__1_2_cons-atom'(_f, _neg, J),
            transpiler_apply(mc__1_1_,
                             _pos,
                             [_pos, J],
                             K,
                             [J],
                             [L],
                             [x(noeval, eager, [list])],
                             ['mc__1_2_cons-atom'(_f, _neg, J)],
                             [L=['cons-atom', _f, _neg]]),
            M=K
        ;   'mc__1_2_cons-atom'(_f, _pos, N),
            O=[N, _neg],
            M=O
        ),
        A=M
    ).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_2_state-diff'(AllStates, _diffs, _s2) :-
    ['And', _d]=_diffs,
    'mc__1_1_signed-fluents'(_d, A),
    [_pos, _neg]=A,
    'mc__1_2_subtraction-atom'(AllStates, _neg, B),
    _s1=B,
    'mc__1_2_union-atom'(_s1, _pos, C),
    _s2=C.

</span>
<span class="ansi38-255165005"
>1 _30754 [[assign,_31182,list(['State',_2266{vn = ...},_2196{vn = ...}])],[assign,_32092,[ispu,_2196{vn = ...}]],[assign,_30754,[fcall(match,[3]),[space_1,_31182,_32092]]]]
</span><span class="ansi38-173216230"
>
'mc__1_1_state-transition'(StateId, A) :-
    'mc__1_1_actions-applicable'(StateId, B),
    [ActionId, _args]=B,
    'mc__1_2_action-applyEffect'(ActionId, _args, C),
    EffsDiff=C,
    D=ispeEnNC(E, mc__1_3_match(space_1, F, G, E), H, H=[match, space_1, F, G], (F=['State', StateId, _form], G=ispu(_form))),
    mc__1_1_collapse(D, I),
    StsEffs=I,
    'mc__1_2_state-diff'(StsEffs, EffsDiff, J),
    NewState=J,
    (   'mc__1_2_=='(NewState, [], K),
        is_True(K)
    *-> transpiler_apply(mc__1_2_,
                         StateId,
                         [StateId, EffsDiff, StsEffs],
                         L,
                         [EffsDiff, StsEffs],
                         [EffsDiff, StsEffs],
                         [x(noeval, eager, []), x(noeval, eager, [])],
                         [true, true],
                         [true, true]),
        M=['Error', L, "Empty State"],
        A=M
    ;   transpiler_apply(mc__2_1_1_,
                         ActionId,
                         [[ActionId, _args], NewState],
                         N,
                         [_args, NewState],
                         [_args, NewState],
                         [x(noeval, eager, []), x(noeval, eager, [])],
                         [true, true],
                         [true, true]),
        A=N
    ).

</span>
<span class="ansi38-255165005"
>1 _48528 [[assign,_48956,list(['State',_11532{vn = ...},_12240{vn = ...}])],[assign,_49874,[ispu,_11532{vn = ...}]],[assign,_48528,[fcall(match,[3]),[space_1,_48956,_49874]]]]
</span><span class="ansi38-173216230"
>
'mc__1_1_state-visited?'(StateFluents, A) :-
    (   'mc__1_2_=='(StateFluents, [], B),
        is_True(B)
    *-> A=[]
    ;   'mc__1_1_decons-atom'(StateFluents, C),
        [_h, _rest]=C,
        D=ispeEnNC(E, mc__1_3_match(space_1, F, G, E), H, H=[match, space_1, F, G], (F=['State', _id, _h], G=ispu(_id))),
        mc__1_1_collapse(D, I),
        _included=I,
        (   'mc__1_2_=='(_rest, [], J),
            is_True(J)
        *-> K=_included
        ;   'mc__1_1_state-visited?'(_rest, L),
            _other=L,
            M=['L-intersection', _included, _other],
            K=M
        ),
        A=K
    ).

</span>
<span class="ansi38-255165005"
>1 _35386 [[assign,_35814,list(['State',_19356{vn = ...},_18888{vn = ...}])],[assign,_36724,[ispu,_18888{vn = ...}]],[assign,_35386,[fcall(match,[3]),[space_1,_35814,_36724]]]]
</span><span class="ansi38-173216230"
>
'mc__1_1_state-visited'(StateId, A) :-
    B=ispeEnNC(C, mc__1_3_match(space_1, D, E, C), F, F=[match, space_1, D, E], (D=['State', StateId, _form], E=ispu(_form))),
    mc__1_1_collapse(B, G),
    _fs=G,
    'mc__1_1_state-visited?'(_fs, A).

</span>
<span class="ansi38-255165005"
>1 _15060 [[assign,_15488,list(['State',_1664{vn = ...},_1636{vn = ...}])],[assign,_16390,[ispu,_1664{vn = ...}]],[assign,_15060,[fcall(match,[3]),[space_1,_15488,_16390]]]]
</span><span class="ansi38-173216230"
>
'mc__1_1_state-enqueued?'(StateId, A) :-
    B=ispeEnNC(C, mc__1_3_match(space_1, D, E, C), F, F=[match, space_1, D, E], (D=['State', StateId, _f], E=ispu(StateId))),
    mc__1_1_collapse(B, G),
    _s=G,
    (   'mc__1_2_=='(_s, [], H),
        is_True(H)
    *-> A='False'
    ;   A='True'
    ).

</span>
<span class="ansi38-255165005"
>1 _48446 [[assign,_48446,[fcall('formula-satisfaction',[2]),[_36062{vn = ...},_35816{vn = ...}]]]]
</span><span class="ansi38-173216230"
>
'mc__1_1_goal-satisfied'(StateId, A) :-
    B=[':goal', _expr],
    C=ispeEnN(D, 'mc__1_2_formula-satisfaction'(StateId, _expr, D), E, E=['formula-satisfaction', StateId, _expr]),
    mc__1_3_match(space_1, B, C, A).

</span>
<span class="ansi38-255165005"
>1 _28890 [[transpiler_apply,mc__1_2_,_1916{vn = ...},[_1916{vn = ...},_1902{vn = ...},_1888{vn = ...}],_28890,[_1902{vn = ...},_1888{vn = ...}],[_1902{vn = ...},_1888{vn = ...}],[x(noeval,eager,[]),x(noeval,eager,[])],[[],[]],[[],[]]]]
</span><span class="ansi38-173216230"
>
'mc__1_1_retrace-steps'(ToStateId, A) :-
    (   'mc__1_2_=='(ToStateId, 0, B),
        is_True(B)
    *-> A=[]
    ;   C=[_action, _args],
        D=['Succ', FromId, C, ToStateId],
        E=ispeEnN(F, transpiler_apply(mc__1_2_, FromId, [FromId, _action, _args], F, [_action, _args], [_action, _args], [x(noeval, eager, []), x(noeval, eager, [])], [true, true], [true, true]), G, G=[FromId, _action, _args]),
        mc__1_3_match(space_1, D, E, H),
        [FromId, _action, _args]=H,
        'mc__1_1_retrace-steps'(FromId, I),
        PrevSteps=I,
        transpiler_apply(mc__1_1_,
                         _action,
                         [_action, _args],
                         J,
                         [_args],
                         [_args],
                         [x(noeval, eager, [])],
                         [true],
                         [true]),
        K=['L-push-back', PrevSteps, J],
        A=K
    ).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_2_add-state-fluents!'(StateId, _fluents, A) :-
    (   'mc__1_2_=='(_fluents, [], B),
        is_True(B)
    *-> A=[]
    ;   'mc__1_1_decons-atom'(_fluents, C),
        [_h, _rest]=C,
        D=['State', StateId, _h],
        'mc__1_2_add-atom'(space_1, D, E),
        []=E,
        'mc__1_2_add-state-fluents!'(StateId, _rest, F),
        A=F
    ).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_3_enqueue-next-states!'(FromID, _states, NextUID, A) :-
    (   'mc__1_2_=='(_states, [], B),
        is_True(B)
    *-> A=NextUID
    ;   'mc__1_1_decons-atom'(_states, C),
        [_state, _rest]=C,
        [[_action, _args], StateFluents]=_state,
        'mc__1_1_state-visited?'(StateFluents, D),
        _visited=D,
        (   'mc__1_2_=='(_visited, [], E),
            is_True(E)
        *-> 'mc__1_2_add-state-fluents!'(NextUID,
                                         StateFluents,
                                         F),
            []=F,
            G=[_action, _args],
            H=['Succ', FromID, G, NextUID],
            'mc__1_2_add-atom'(space_1, H, I),
            []=I,
            J=['ENQUEUED', NextUID],
            'mc__1_1_println!'(J, K),
            []=K,
            'mc__1_2_+'(NextUID, 1, L),
            _id=L,
            'mc__1_3_enqueue-next-states!'(FromID,
                                           _rest,
                                           _id,
                                           M),
            N=M
        ;   'mc__1_3_enqueue-next-states!'(FromID,
                                           _rest,
                                           NextUID,
                                           O),
            N=O
        ),
        A=N
    ).

</span>
<span class="ansi38-255165005"
>1 _19230 [[assign,_19658,list(['State',_2034{vn = ...},_1992{vn = ...}])],[assign,_20568,[ispu,_1992{vn = ...}]],[assign,_19230,[fcall(match,[3]),[space_1,_19658,_20568]]]]
1 _22716 [[transpiler_apply,mc__1_1_,_1964{vn = ...},[_1964{vn = ...},_1950{vn = ...}],_22842,[_1950{vn = ...}],[_1950{vn = ...}],[x(noeval,eager,[])],[[]],[[]]],[transpiler_apply,mc__1_1_,_1978{vn = ...},[_1978{vn = ...},_22842],_22716,[_22842],[_22848],[x(noeval,eager,[])],[[[transpiler_apply,mc__1_1_,_1964{vn = ...},[_1964{vn = ...},_1950{vn = ...}],_22842,[_1950{vn = ...}],[_1950{vn = ...}],[x(noeval,eager,[])],[[]],[[]]]]],[[[assign,_22848,list([_1964{vn = ...},_1950{vn = ...}])]]]]]
1 _21154 [[assign,_22002,list([_1964{vn = ...},_1950{vn = ...}])],[assign,_21404,list(['Succ',_1978{vn = ...},_22002,_2034{vn = ...}])],[assign,_23450,[ispeEnNC,_22716,[[transpiler_apply,mc__1_1_,_1978{vn = ...},[_1978{vn = ...},_22842],_22716,[_22842],[_22848],[x(noeval,eager,[])],[[[transpiler_apply,mc__1_1_,_1964{vn = ...},[_1964{vn = ...},_1950{vn = ...}],_22842,[_1950{vn = ...}],[_1950{vn = ...}],[x(noeval,eager,[])],[[]],[[]]]]],[[[assign,_22848,list([_1964{vn = ...},_1950{vn = ...}])]]]]],_22722,[[assign,_22722,list([_1978{vn = ...},_22842])]],[[transpiler_apply,mc__1_1_,_1964{vn = ...},[_1964{vn = ...},_1950{vn = ...}],_22842,[_1950{vn = ...}],[_1950{vn = ...}],[x(noeval,eager,[])],[[]],[[]]]]]],[assign,_21154,[fcall(match,[3]),[space_1,_21404,_23450]]]]
1 _28428 [[assign,_28428,[fcall('state-transition',[1]),[_2034{vn = ...}]]]]
</span><span class="ansi38-173216230"
>
'mc__1_3_fw-state-search'(CurState, NextUID, StatesLimit, A) :-
    B=ispeEnNC(C, mc__1_3_match(space_1, D, E, C), F, F=[match, space_1, D, E], (D=['State', CurState, _f], E=ispu(_f))),
    mc__1_1_collapse(B, G),
    H=ispeEnNC(I, mc__1_3_match(space_1, J, K, I), L, L=[match, space_1, J, K], (M=[_action, _args], J=['Succ', _from, M, CurState], K=ispeEnNC(N, transpiler_apply(mc__1_1_, _from, [_from, O], N, [O], [P], [x(noeval, eager, [])], [transpiler_apply(mc__1_1_, _action, [_action, _args], O, [_args], [_args], [x(noeval, eager, [])], [true], [true])], [P=[_action, _args]]), Q, Q=[_from, O], transpiler_apply(mc__1_1_, _action, [_action, _args], O, [_args], [_args], [x(noeval, eager, [])], [true], [true])))),
    mc__1_1_collapse(H, R),
    S=['Processing', CurState, G, R],
    'mc__1_1_println!'(S, T),
    []=T,
    (   'mc__1_1_state-enqueued?'(CurState, U),
        mc__1_1_not(U, V),
        is_True(V)
    *-> A='FailedToReachGoal'
    ;   (   'mc__1_1_goal-satisfied'(CurState, W),
            is_True(W)
        *-> 'mc__1_1_retrace-steps'(CurState, X),
            Y=X
        ;   (   'mc__1_2_>'(CurState, StatesLimit, Z),
                is_True(Z)
            *-> A1=['Error', StatesLimit, "Limit of states exploration reached."],
                B1=A1
            ;   C1=ispeEnN(D1, 'mc__1_1_state-transition'(CurState, D1), E1, E1=['state-transition', CurState]),
                mc__1_1_collapse(C1, F1),
                NextStates=F1,
                'mc__1_3_enqueue-next-states!'(CurState,
                                               NextStates,
                                               NextUID,
                                               G1),
                _uid=G1,
                'mc__1_2_+'(CurState, 1, H1),
                NextFront=H1,
                'mc__1_3_fw-state-search'(NextFront,
                                          _uid,
                                          StatesLimit,
                                          I1),
                B1=I1
            ),
            Y=B1
        ),
        A=Y
    ).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_1_planner-main'(StatesLimit, A) :-
    B=['None', 'None'],
    C=[':init', _f],
    D=ispu(_f),
    mc__1_3_match(space_1, C, D, E),
    F=[B, E],
    InitState=F,
    transpiler_apply(mc__1_0_,
                     InitState,
                     [InitState],
                     G,
                     [],
                     [],
                     [],
                     [],
                     []),
    'mc__1_3_enqueue-next-states!'(-1, G, 0, H),
    NextUID=H,
    'mc__1_3_fw-state-search'(0, NextUID, StatesLimit, A).

</span>
<span class="ansi38-255165005"
>1 _42930 [[assign,_43212,[fcall('formula-satisfaction',[2]),[_17522{vn = ...},_17466{vn = ...}]]],[assign,_43598,list(['Error',_17480{vn = ...},'FailedUnification'])],[assign,_42930,[fcall(unf,[4]),[_17494{vn = ...},_17480{vn = ...},_43212,_43598]]]]
</span><span class="ansi38-173216230"
>
'mc__1_3_action-applicable'(B, C, D, A) :-
    B=[':action', C, ':parameters', E, ':precondition', F, ':effect', G],
    C=ispeEnNC(D, mc__1_4_unf(D, E, E, F, D), G, G=[unf, D, E, E, F], ('mc__1_2_formula-satisfaction'(B, F, E), F=['Error', E, 'FailedUnification'])),
    mc__1_3_match(space_1, B, C, A).

</span>1 _33810 [[assign,_33952,[fcall('args-combination',[1]),[_4026{vn = ...}]]],[assign,_3984{vn = ...},_33952],[assign,_34626,list(['Error',_4026{vn = ...},'FailedUnification'])],[assign,_34286,[fcall(unf,[4]),[_3984{vn = ...},_4026{vn = ...},'True',_34626]]],[assign,_3970{vn = ...},_34286],[prolog_if,[[assign,_35752,[fcall('formula-satisfaction',[2]),[_4054{vn = ...},_4012{vn = ...}]]],[native(is_True),_35752]],[[transpiler_apply,mc__1_1_,_4040{vn = ...},[_4040{vn = ...},_4026{vn = ...}],_36160,[_4026{vn = ...}],[_4026{vn = ...}],[x(noeval,eager,[])],[[]],[[]]],[assign,_33810,_36160]],[[assign,_36508,[fcall(empty,[0]),[]]],[assign,_33810,_36508]]]]
<span class="ansi38-173216230"
>
'mc__1_1_actions-applicable'(B, A) :-
    B=[':action', C, ':parameters', D, ':precondition', E, ':effect', F],
    C=ispeEnNC(D, ('mc__1_2_formula-satisfaction'(B, E, E), is_True(E)*->transpiler_apply(mc__1_1_, C, [C, D], F, [D], [D], [x(noeval, eager, [])], [true], [true]), D=F;mc__1_0_empty(G), D=G), H, ('mc__1_2_formula-satisfaction'(B, E, E), is_True(E)*->I=[C, D], H=I;J=[empty], H=J), ('mc__1_1_args-combination'(D, K), G=K, L=['Error', D, 'FailedUnification'], mc__1_4_unf(G, D, 'True', L, M), H=M)),
    mc__1_3_match(space_1, B, C, A).

</span>1 _10962 [[assign,_10962,[fcall(unf,[4]),[_4048{vn = ...},_4034{vn = ...},_4006{vn = ...},'FailedUnification']]]]
<span class="ansi38-173216230"
>
'mc__1_2_action-applyEffect'(B, C, A) :-
    B=[':action', B, ':parameters', D, ':precondition', E, ':effect', F],
    C=ispeEnN(D, mc__1_4_unf(C, D, F, 'FailedUnification', D), E, E=[unf, C, D, F, 'FailedUnification']),
    mc__1_3_match(space_1, B, C, A).

</span><span class="ansi38-173216230"
>
'mc__1_1_signed-fluents'(B, A) :-
    (   'mc__1_2_=='(B, [], B),
        is_True(B)
    *-> C=[[], []],
        A=C
    ;   'mc__1_1_decons-atom'(B, D),
        [C, D]=D,
        'mc__1_1_signed-fluents'(D, E),
        [E, F]=E,
        F=['Not', I],
        G=['True', I],
        H=['False', C],
        mc__1_4_unf(C, F, G, H, I),
        [G, H]=I,
        (   is_True(G)
        *-> 'mc__1_2_cons-atom'(H, F, J),
            transpiler_apply(mc__1_1_,
                             E,
                             [E, J],
                             K,
                             [J],
                             [L],
                             [x(noeval, eager, [list])],
                             ['mc__1_2_cons-atom'(H, F, J)],
                             [L=['cons-atom', H, F]]),
            M=K
        ;   'mc__1_2_cons-atom'(H, E, N),
            O=[N, F],
            M=O
        ),
        A=M
    ).

</span><span class="ansi38-173216230"
>
mc__1_4_unf(_x, _y, _s, _f, A) :-
    B=ispuU('True', _x=_y),
    mc__1_1_collapse(B, C),
    _unf=C,
    (   'mc__1_2_=='(_unf, [], D),
        is_True(D)
    *-> A=_f
    ;   _x=_y,
        A=_s
    ).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_0_make-queue'([]).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_1_empty-queue?'(_q, A) :-
    B=ispu('True'),
    C=ispu('False'),
    mc__1_4_unify(_q, [], B, C, A).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_1_front-queue'(_q, A) :-
    (   'mc__1_1_empty-queue?'(_q, B),
        is_True(B)
    *-> C=['Error', _q, "Can't get front of empty queue"],
        A=C
    ;   'mc__1_1_car-atom'(_q, D),
        A=D
    ).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_1_pop-queue'(_q, A) :-
    'mc__1_1_cdr-atom'(_q, A).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_2_insert-queue'(_q, _item, A) :-
    (   'mc__1_2_=='(_q, [], B),
        is_True(B)
    *-> transpiler_apply(mc__1_0_,
                         _item,
                         [_item],
                         C,
                         [],
                         [],
                         [],
                         [],
                         []),
        A=C
    ;   'mc__1_1_decons-atom'(_q, D),
        [_head, _tail]=D,
        'mc__1_2_insert-queue'(_tail, _item, E),
        _inserted=E,
        'mc__1_2_cons-atom'(_head, _inserted, F),
        A=F
    ).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_1_L-empty?'(_list, A) :-
    (   'mc__1_2_=='(_list, [], B),
        is_True(B)
    *-> A='True'
    ;   A='False'
    ).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_1_L-size'(_list, A) :-
    (   'mc__1_1_L-empty?'(_list, B),
        is_True(B)
    *-> A=0
    ;   'mc__1_1_cdr-atom'(_list, C),
        _tail=C,
        'mc__1_1_L-size'(_tail, D),
        'mc__1_2_+'(1, D, E),
        A=E
    ).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_2_L-push-front'(_list, _item, A) :-
    'mc__1_2_cons-atom'(_item, _list, A).

</span>
<span class="ansi38-255165005"
>1 _27524 [[transpiler_apply,mc__1_2_,_3626{vn = ...},[_3626{vn = ...},_3612{vn = ...},_3598{vn = ...}],_27524,[_3612{vn = ...},_3598{vn = ...}],[_3612{vn = ...},_3598{vn = ...}],[x(noeval,eager,[]),x(noeval,eager,[])],[[],[]],[[],[]]]]
</span><span class="ansi38-173216230"
>
'mc__1_1_retrace-steps'(B, A) :-
    (   'mc__1_2_=='(B, 0, B),
        is_True(B)
    *-> A=[]
    ;   C=[D, E],
        D=['Succ', C, C, B],
        E=ispeEnN(F, transpiler_apply(mc__1_2_, C, [C, D, E], F, [D, E], [D, E], [x(noeval, eager, []), x(noeval, eager, [])], [true, true], [true, true]), G, G=[C, D, E]),
        mc__1_3_match(space_1, D, E, H),
        [C, D, E]=H,
        'mc__1_1_retrace-steps'(C, I),
        F=I,
        transpiler_apply(mc__1_1_,
                         D,
                         [D, E],
                         J,
                         [E],
                         [E],
                         [x(noeval, eager, [])],
                         [true],
                         [true]),
        'mc__1_2_L-push-back'(F, J, K),
        A=K
    ).

</span><span class="ansi38-173216230"
>
'mc__1_2_L-push-back'(_list, _item, A) :-
    (   'mc__1_1_L-empty?'(_list, B),
        is_True(B)
    *-> transpiler_apply(mc__1_0_,
                         _item,
                         [_item],
                         C,
                         [],
                         [],
                         [],
                         [],
                         []),
        A=C
    ;   'mc__1_1_decons-atom'(_list, D),
        [_h, _t]=D,
        'mc__1_2_L-push-back'(_t, _item, E),
        _pushed=E,
        'mc__1_2_cons-atom'(_h, _pushed, F),
        A=F
    ).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_1_L-pop-front'(_list, A) :-
    (   'mc__1_1_L-empty?'(_list, B),
        is_True(B)
    *-> C=['Error', 'L-pop-front', "Empty list"],
        A=C
    ;   'mc__1_1_cdr-atom'(_list, D),
        A=D
    ).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_1_L-pop-back'(_list, A) :-
    (   'mc__1_1_L-empty?'(_list, B),
        is_True(B)
    *-> C=['Error', 'L-pop-back', "Empty list"],
        A=C
    ;   'mc__1_1_decons-atom'(_list, D),
        [_h, _t]=D,
        (   'mc__1_1_L-empty?'(_t, E),
            is_True(E)
        *-> F=[]
        ;   'mc__1_1_L-pop-back'(_t, G),
            _popped=G,
            'mc__1_2_cons-atom'(_h, _popped, H),
            F=H
        ),
        A=F
    ).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_2_L-append'(_list, _list2, A) :-
    (   'mc__1_1_L-empty?'(_list, B),
        is_True(B)
    *-> A=_list2
    ;   'mc__1_1_decons-atom'(_list, C),
        [_h, _rest]=C,
        'mc__1_2_L-append'(_rest, _list2, D),
        _appended=D,
        'mc__1_2_cons-atom'(_h, _appended, E),
        A=E
    ).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_1_L-front'(_list, A) :-
    (   'mc__1_1_L-empty?'(_list, B),
        is_True(B)
    *-> C=['Error', 'L-front', "Empty list"],
        A=C
    ;   'mc__1_1_car-atom'(_list, D),
        A=D
    ).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_1_L-back'(_list, A) :-
    (   'mc__1_1_L-empty?'(_list, B),
        is_True(B)
    *-> C=['Error', 'L-back', "Empty list"],
        A=C
    ;   'mc__1_1_decons-atom'(_list, D),
        [_h, _rest]=D,
        (   'mc__1_1_L-empty?'(_rest, E),
            is_True(E)
        *-> F=_h
        ;   'mc__1_1_L-back'(_rest, G),
            F=G
        ),
        A=F
    ).

</span>
<span class="ansi38-255165005"
>1 _9302 [[prolog_if,[[prolog_if,[[assign,_4768,[fcall(<,[2]),[_1514{vn = ...},0]]],[native(is_True),_4768]],[[assign,_4750,'True']],[[prolog_if,[[assign,_4826,[fcall(>=,[2]),[_1514{vn = ...},0]]],[native(is_True),_4826]],[[assign,_4882,[fcall('L-empty?',[1]),[_1528{vn = ...}]]],[assign,_4824,_4882]],[[assign,_4824,'False']]],[assign,_4750,_4824]]],[native(is_True),_4750]],[[assign,_5424,list(['Error','L-index',"Index out of range"])],[assign,_4740,_5424]],[[prolog_if,[[assign,_6002,[fcall(==,[2]),[_1514{vn = ...},0]]],[native(is_True),_6002]],[[assign,_6584,[fcall('car-atom',[1]),[_1528{vn = ...}]]],[assign,_5992,_6584]],[[assign,_7170,[fcall('cdr-atom',[1]),[_1528{vn = ...}]]],[assign,_1500{vn = ...},_7170],[assign,_7686,[fcall(-,[2]),[_1514{vn = ...},1]]],[assign,_1486{vn = ...},_7686],[assign,_7046,[fcall('L-index',[2]),[_1500{vn = ...},_1486{vn = ...}]]],[assign,_5992,_7046]]],[assign,_4740,_5992]]],[native(as_p1_exec),_4740,_9302]]
</span><span class="ansi38-173216230"
>
'mc__1_2_L-index'(_list, _index, A) :-
    A=ispeEnN(B, ((('mc__1_2_<'(_index, 0, C), is_True(C)*->D='True';('mc__1_2_>='(_index, 0, E), is_True(E)*->'mc__1_1_L-empty?'(_list, F), G=F;G='False'), D=G), is_True(D)*->H=['Error', 'L-index', "Index out of range"], I=H;('mc__1_2_=='(_index, 0, J), is_True(J)*->'mc__1_1_car-atom'(_list, K), L=K;'mc__1_1_cdr-atom'(_list, M), _rest=M, 'mc__1_2_-'(_index, 1, N), _idx=N, 'mc__1_2_L-index'(_rest, _idx, O), L=O), I=L), as_p1_exec(I, B)), P, ((('mc__1_2_<'(_index, 0, C), is_True(C)*->D='True';('mc__1_2_>='(_index, 0, E), is_True(E)*->'mc__1_1_L-empty?'(_list, F), G=F;G='False'), D=G), is_True(D)*->Q=['Error', 'L-index', "Index out of range"], R=Q;('mc__1_2_=='(_index, 0, J), is_True(J)*->S=['car-atom', _list], T=S;'mc__1_1_cdr-atom'(_list, M), _rest=M, 'mc__1_2_-'(_index, 1, N), _idx=N, U=['L-index', _rest, _idx], T=U), R=T), as_p1_expr(R, P))).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_2_L-contains?'(_list, _item, A) :-
    (   'mc__1_1_L-empty?'(_list, B),
        is_True(B)
    *-> A='False'
    ;   'mc__1_1_decons-atom'(_list, C),
        [_h, _t]=C,
        (   'mc__1_2_=='(_h, _item, D),
            is_True(D)
        *-> E='True'
        ;   'mc__1_2_L-contains?'(_t, _item, F),
            E=F
        ),
        A=E
    ).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_2_L-subset?'(_list1, _list2, A) :-
    (   'mc__1_2_=='(_list1, [], B),
        is_True(B)
    *-> A='True'
    ;   'mc__1_1_decons-atom'(_list1, C),
        [_h, _rest]=C,
        (   'mc__1_2_L-contains?'(_list2, _h, D),
            is_True(D)
        *-> 'mc__1_2_L-subset?'(_rest, _list2, E),
            F=E
        ;   F='False'
        ),
        A=F
    ).

</span>
<span class="ansi38-255165005"
></span><span class="ansi38-173216230"
>
'mc__1_2_L-seteq?'(_list1, _list2, A) :-
    (   'mc__1_2_L-subset?'(_list1, _list2, B),
        is_True(B)
    *-> 'mc__1_2_L-subset?'(_list2, _list1, C),
        A=C
    ;   A='False'
    ).

</span>
<span class="ansi38-255165005"
>1 _31788 [[assign,_32038,list(['State',_3534{vn = ...},_3576{vn = ...}])],[assign,_32778,[ispu,_3534{vn = ...}]],[assign,_31788,[fcall(match,[3]),[space_1,_32038,_32778]]]]
</span><span class="ansi38-173216230"
>
'mc__1_1_state-visited?'(B, A) :-
    (   'mc__1_2_=='(B, [], B),
        is_True(B)
    *-> A=[]
    ;   'mc__1_1_decons-atom'(B, C),
        [C, D]=C,
        D=ispeEnNC(E, mc__1_3_match(space_1, F, G, E), H, H=[match, space_1, F, G], (F=['State', F, C], G=ispu(F))),
        mc__1_1_collapse(D, I),
        E=I,
        (   'mc__1_2_=='(D, [], J),
            is_True(J)
        *-> K=E
        ;   'mc__1_1_state-visited?'(D, L),
            G=L,
            'mc__1_2_L-intersection'(E, G, M),
            K=M
        ),
        A=K
    ).

</span><span class="ansi38-173216230"
>
'mc__1_2_L-intersection'(_list1, _list2, A) :-
    (   'mc__1_2_=='(_list1, [], B),
        is_True(B)
    *-> A=[]
    ;   'mc__1_1_decons-atom'(_list1, C),
        [_h, _t]=C,
        'mc__1_2_L-intersection'(_t, _list2, D),
        _inters=D,
        (   'mc__1_2_L-contains?'(_list2, _h, E),
            is_True(E)
        *-> 'mc__1_2_cons-atom'(_h, _inters, F),
            G=F
        ;   G=_inters
        ),
        A=G
    ).

</span>
<span class="ansi38-013099040"
>!(time (assertEqualToResult (planner-main 100) (((pickup (b)) (stack (b c)) (pickup (a)) (stack (a b))))))

</span>1 _34692 [[assign,_34692,[fcall('planner-main',[1]),[100]]]]
1 _34554 [[assign,_40458,[ispeEnN,_34692,[[assign,_34692,[fcall('planner-main',[1]),[100]]]],_34698,[[assign,_34698,list(['planner-main',100])]]]],[assign,_36024,list([b])],[assign,_35760,list([pickup,_36024])],[assign,_36906,list([b,c])],[assign,_36642,list([stack,_36906])],[assign,_37942,list([a])],[assign,_37678,list([pickup,_37942])],[assign,_38824,list([a,b])],[assign,_38560,list([stack,_38824])],[assign,_35392,list([_35760,_36642,_37678,_38560])],[assign,_34978,list([_35392])],[assign,_34554,[fcall(assertEqualToResult,[2]),[_40458,_34978]]]]
<span class="ansi38-017068017"
>:- do_metta_runtime(A,
                    (B=ispeEnNC(C, mc__1_2_assertEqualToResult(D, E, C), F, F=[assertEqualToResult, D, E], (D=ispeEnN(G, 'mc__1_1_planner-main'(100, G), H, H=['planner-main', 100]), I=[b], J=[pickup, I], K=[b, c], L=[stack, K], M=[a], N=[pickup, M], O=[a, b], P=[stack, O], Q=[J, L, N, P], E=[Q])), mc__1_1_time(B, A))).

</span>
;<h3 id="IMPORTANT-COMP.TASK1-WHOLE-ATOMS-KB-COMP.01"
>;; IMPORTANT-COMP.TASK1-WHOLE-ATOMS-KB-COMP.01</h3>
(ENQUEUED 0)
(Processing 0 ((on-table a) (on-table b) (clear a) (clear b) (arm-empty) (on-table c) (clear c)) ((-1 (None None))))
(ENQUEUED 1)
(ENQUEUED 2)
(ENQUEUED 3)
(Processing 1 ((on-table b) (clear b) (on-table c) (clear c) (holding a)) ((0 (pickup (a)))))
(ENQUEUED 4)
(ENQUEUED 5)
(Processing 2 ((on-table a) (clear a) (on-table c) (clear c) (holding b)) ((0 (pickup (b)))))
(ENQUEUED 6)
(ENQUEUED 7)
(Processing 3 ((on-table a) (on-table b) (clear a) (clear b) (holding c)) ((0 (pickup (c)))))
(ENQUEUED 8)
(ENQUEUED 9)
(Processing 4 ((on-table b) (on-table c) (clear c) (arm-empty) (clear a) (on a b)) ((1 (stack (a b)))))
(ENQUEUED 10)
(Processing 5 ((on-table b) (clear b) (on-table c) (arm-empty) (clear a) (on a c)) ((1 (stack (a c)))))
(ENQUEUED 11)
(Processing 6 ((on-table a) (on-table c) (clear c) (arm-empty) (clear b) (on b a)) ((2 (stack (b a)))))
(ENQUEUED 12)
(Processing 7 ((on-table a) (clear a) (on-table c) (arm-empty) (clear b) (on b c)) ((2 (stack (b c)))))
(ENQUEUED 13)
(Processing 8 ((on-table a) (on-table b) (clear b) (arm-empty) (clear c) (on c a)) ((3 (stack (c a)))))
(ENQUEUED 14)
(Processing 9 ((on-table a) (on-table b) (clear a) (arm-empty) (clear c) (on c b)) ((3 (stack (c b)))))
(ENQUEUED 15)
(Processing 10 ((on-table b) (clear a) (on a b) (holding c)) ((4 (pickup (c)))))
(ENQUEUED 16)
(Processing 11 ((on-table c) (clear a) (on a c) (holding b)) ((5 (pickup (b)))))
(ENQUEUED 17)
(Processing 12 ((on-table a) (clear b) (on b a) (holding c)) ((6 (pickup (c)))))
(ENQUEUED 18)
(Processing 13 ((on-table c) (clear b) (on b c) (holding a)) ((7 (pickup (a)))))
(ENQUEUED 19)
(Processing 14 ((on-table a) (clear c) (on c a) (holding b)) ((8 (pickup (b)))))
(ENQUEUED 20)
(Processing 15 ((on-table b) (clear c) (on c b) (holding a)) ((9 (pickup (a)))))
(ENQUEUED 21)
(Processing 16 ((on-table b) (on a b) (arm-empty) (clear c) (on c a)) ((10 (stack (c a)))))
(Processing 17 ((on-table c) (on a c) (arm-empty) (clear b) (on b a)) ((11 (stack (b a)))))
(Processing 18 ((on-table a) (on b a) (arm-empty) (clear c) (on c b)) ((12 (stack (c b)))))
(Processing 19 ((on-table c) (on b c) (arm-empty) (clear a) (on a b)) ((13 (stack (a b)))))
; 
; EVAL TEST
; took 0.043 secs. (42.53 milliseconds) 

!(time (assertEqualToResult (planner-main 100) (((pickup (b)) (stack (b c)) (pickup (a)) (stack (a b))))))

<span class="ansi36"
>  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( ( (pickup (b)) 
          (stack (b c)) 
          (pickup (a)) 
          (stack (a b)))) 
      ( ( (pickup (b)) 
          (stack (b c)) 
          (pickup (a)) 
          (stack (a b))))]]
</span>; Evaluation took 0.044 secs. (44.00 milliseconds) 


Deterministic: <span class="ansi33"
>()
</span>P;HTML|
;            [ = /home/runner/work/metta-testsuite/metta-testsuite/tests/direct_comp/important/task1_whole_atoms_kb.metta 0 ]
<span class="ansi1"
>LoonIt Report
</span>------------
<span class="ansi32"
>Successes: 1
</span><span class="ansi32"
>Failures: 0
</span><br/> <a href="#" onclick="window.history.back(); return false;"
>Return to summaries</a><br/>
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
<span class="ansi1 ansi31"
>ERROR: source_sink `'/home/runner/.config/metta/repl_history.txt'' does not exist
</span>
Script done on 2025-04-13 22:53:54+00:00 [COMMAND_EXIT_CODE="1"]

</pre>
</body>

</html>
\033[1;33mCompleted successfully (EXITCODE=1) Under 121 seconds: /home/runner/work/metta-testsuite/metta-testsuite/mettalog '--output=/home/runner/work/metta-testsuite/metta-testsuite/reports/tests_output/baseline-compat' --timeout=121 --html --repl=false  --test --compile=full "tests/direct_comp/important/task1_whole_atoms_kb.metta" --halt=true\033[0m
