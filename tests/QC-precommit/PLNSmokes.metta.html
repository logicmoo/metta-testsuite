<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi2 { font-weight: lighter; }
.ansi4 { text-decoration: underline; }
.ansi5 { text-decoration: blink; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi35 { color: #E850A8; }
.ansi36 { color: #00aaaa; }
.ansi37 { color: #F5F1DE; }
.ansi40 { background-color: #000316; }
.ansi91 { color: #ff0000; }
.ansi92 { color: #00ff00; }
.ansi93 { color: #ffff00; }
.ansi94 { color: #5c5cff; }
.ansi96 { color: #00ffff; }
.ansi100 { background-color: #7f7f7f; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-079079015 { color: #4F4F0F; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-218112214 { color: #DA70D6; }
.ansi38-218112214 { color: #DA70D6; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
Script started on 2025-05-14 10:09:03-07:00 [COMMAND="swipl -x /home/deb12user/metta-wam/prolog/metta_lang/Sav.HOSTAGE.MeTTaLog  -- --python=enable -- --html --show=code --hide=nonsense,pre_ast tests/before_commit/PLNSmokes.metta --repl " TERM="xterm" TTY="/dev/pts/3" COLUMNS="203" LINES="57"]
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">cmdargs</span>: <span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">set_debug(prolog,true)
</span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">cmdargs</span>: <span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">set_debug(loading,true)
</span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">cmdargs</span>: <span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">set_debug(code,true)
</span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">cmdargs</span>: <span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">set_debug(nonsense,false)
</span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">cmdargs</span>: <span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">set_debug(pre_ast,false)
</span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">cmdargs</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">'trace-on-test'==false
</span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">cmdargs</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">load==show
</span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">cmdargs</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">test==true
</span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">cmdargs</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">html==true
</span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">cmdargs</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">'trace-on-test'==false
</span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">cmdargs</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">test==true
</span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">cmdargs</span>: <span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">set_debug(code,true)
</span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">cmdargs</span>: <span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">set_debug(nonsense,false)
</span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">cmdargs</span>: <span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">set_debug(pre_ast,false)
</span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">cmdargs</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">html==true
</span> 

; user:[load_metta_file &self tests/before_commit/PLNSmokes.metta]
;;; MeTTa standard lib extension
<span class="ansi38-255165000"> (: If (-> Bool Atom Atom))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[:,'If',[->,'Bool','Atom','Atom']])
 
</span><span class="ansi38-255165000"> (= (If True $then)  $then)
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['If','True','$VAR'("_then")],'$VAR'("_then")])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    ['If','True',_then], 
    _then])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'If', 
  [2], 
  0, 
  ['Bool','Atom'], 
  'Atom', 
  [ x(doeval,eager,[boolean]), 
    x(noeval,lazy,[])], 
  x(noeval,lazy,[]), 
  ['If','True',_then], 
  _then)
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'If', 
  [2], todo,todo, 
  [ x(doeval,eager,[boolean]), 
    x(noeval,lazy,[])], 
  x(noeval,lazy,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('If',[2]) =  
  []
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">mc__1_2_If('True',P,P):-true
</span> 
<span class="ansi38-255165000"> (= (If False $then)  
  (let $x 0 
    (let $x 1 $x)))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['If','False','$VAR'("_then")],[let,'$VAR'("_x"),0,[let,'$VAR'("_x"),1,'$VAR'("_x")]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    ['If','False',_then], 
    [ let, _x,0, 
      [let,_x,1,_x]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'If', 
  [2], 
  1, 
  ['Bool','Atom'], 
  'Atom', 
  [ x(doeval,eager,[boolean]), 
    x(noeval,lazy,[])], 
  x(noeval,lazy,[]), 
  ['If','False',_then], 
  [ let, _x,0, 
    [let,_x,1,_x]])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">mc__1_2_If('False',P,Q) :-  
  Q =  
    ispuU(R,(R=0,R=1))
</span> 
<span class="ansi38-255165000"> (: If (-> Bool Atom Atom Atom))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[:,'If',[->,'Bool','Atom','Atom','Atom']])
 
</span><span class="ansi38-255165000"> (= (If $cond $then $else)  
  (if $cond $then $else))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['If','$VAR'("_cond"),'$VAR'("_then"),_12986692{$_else}],[if,'$VAR'("_cond"),'$VAR'("_then"),_12986692{$_else}]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    ['If',_cond,_then,_else], 
    [if,_cond,_then,_else]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'If', 
  [3], 
  0, 
  ['Bool','Atom','Atom'], 
  'Atom', 
  [ x(doeval,eager,[boolean]), x(noeval,lazy,[]),x(noeval,lazy,[])], 
  x(noeval,lazy,[]), 
  ['If',_cond,_then,_else], 
  [if,_cond,_then,_else])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'If', 
  [3], todo,todo, 
  [ x(doeval,eager,[boolean]), x(noeval,lazy,[]),x(noeval,lazy,[])], 
  x(noeval,lazy,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('If',[3]) =  
  []
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">mc__1_3_If(P,Q,R,S) :-  
  S =  
    ispeEnN( T, 
      (is_True(P)*->U=Q;U=R),as_p1_exec(U,T), 
      V, 
      (is_True(P)*->W=Q;W=R),as_p1_expr(W,V))
</span> 
<span class="ansi38-255165000"> (: (max (-> Number Number Bool)))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[:,[max,[->,'Number','Number','Bool']]])
 
</span><span class="ansi38-255165000"> (= (max $1 $2)  
  (if 
    (> $1 $2) $1 $2))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,[max,'$VAR'("_1"),'$VAR'("_2")],[if,[>,'$VAR'("_1"),'$VAR'("_2")],'$VAR'("_1"),'$VAR'("_2")]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [max,_1,_2], 
    [ if, 
      [>,_1,_2], _1,_2]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( max, 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [max,_1,_2], 
  [ if, 
    [>,_1,_2], _1,_2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  max, 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa(max,[2]) =  
  []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on(max,[2],>,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">mc__1_2_max(P,Q,R) :-  
    ((
     ('mc__1_2_>'(P,Q,S),is_True(S)*->R=P);
     (R=Q)  ))
</span> 
<span class="ansi38-255165000"> (: (min (-> Number Number Bool)))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[:,[min,[->,'Number','Number','Bool']]])
 
</span><span class="ansi38-255165000"> (= (min $1 $2)  
  (if 
    (< $1 $2) $1 $2))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,[min,'$VAR'("_1"),'$VAR'("_2")],[if,[<,'$VAR'("_1"),'$VAR'("_2")],'$VAR'("_1"),'$VAR'("_2")]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [min,_1,_2], 
    [ if, 
      [<,_1,_2], _1,_2]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( min, 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [min,_1,_2], 
  [ if, 
    [<,_1,_2], _1,_2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  min, 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa(min,[2]) =  
  []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on(min,[2],<,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">mc__1_2_min(P,Q,R) :-  
    ((
     ('mc__1_2_<'(P,Q,S),is_True(S)*->R=P);
     (R=Q)  ))
</span> 
<span class="ansi38-255165000"> (: (max (-> Number Number Number Number)))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[:,[max,[->,'Number','Number','Number','Number']]])
 
</span><span class="ansi38-255165000"> (= (clamp $v $min $max)  
  (min $max 
    (max $v $min)))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,[clamp,'$VAR'("_v"),'$VAR'("_min"),_13528960{$_max}],[min,_13528960{$_max},[max,'$VAR'("_v"),'$VAR'("_min")]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [clamp,_v,_min,_max], 
    [ min, 
      _max, 
      [max,_v,_min]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( clamp, 
  [3], 
  0, 
  ['Any','Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), x(doeval,eager,[]),x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [clamp,_v,_min,_max], 
  [ min, 
    _max, 
    [max,_v,_min]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  clamp, 
  [3], todo,todo, 
  [ x(doeval,eager,[]), x(doeval,eager,[]),x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa(clamp,[3]) =  
  []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on(clamp,[3],min,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on(clamp,[3],max,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">mc__1_3_clamp(P,Q,R,S) :- 
  mc__1_2_max(P,Q,T) , 
  mc__1_2_min(R,T,S)
</span> 
<span class="ansi38-255165000"> (= (TupleConcat $Ev1 $Ev2)  
  (collapse (superpose ((superpose $Ev1) (superpose $Ev2)))))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['TupleConcat','$VAR'("_Ev1"),'$VAR'("_Ev2")],[collapse,[superpose,[[superpose,'$VAR'("_Ev1")],[superpose,'$VAR'("_Ev2")]]]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    ['TupleConcat',Ev1,Ev2], 
    [ collapse, 
      [ superpose, 
        [ [ superpose,   Ev1   ],
          [ superpose,   Ev2   ]]]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'TupleConcat', 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  ['TupleConcat',Ev1,Ev2], 
  [ collapse, 
    [ superpose, 
      [ [ superpose,   Ev1   ],
        [ superpose,   Ev2   ]]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'TupleConcat', 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('TupleConcat',[2]) =  
  []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('TupleConcat',[2],collapse,[1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('TupleConcat',[2],superpose,[1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">
 transpiler_depends_on('TupleConcat',[2],superpose,[1,1])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 mc__1_2_TupleConcat(P,Q,R) :- 
  S =  
    ispeEnNC( T, 
      mc__1_1_superpose(U,T), 
      V, 
      V=[superpose,U], 
      ( mc__1_1_superpose(P,W)  ,
        mc__1_1_superpose(Q,X) , 
        U=[W,X])) , 
  mc__1_1_collapse(S,R)
</span> 
;;; Consistency Conditions: PLN book "5.2.2.2 PLN Deduction and Second-Order Probability", page 74:
;;; borrowed from https://github.com/trueagi-io/hyperon-pln/blob/main/metta/pln/dependent-types/DeductionDTL.metta
<span class="ansi38-255165000"> (: smallest-intersection-probability (-> Number Number Number))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[:,'smallest-intersection-probability',[->,'Number','Number','Number']])
 
</span><span class="ansi38-255165000"> (= (smallest-intersection-probability $As $Bs)  
  (clamp 
    (/ 
      (- 
        (+ $As $Bs) 1) $As) 0 1))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['smallest-intersection-probability','$VAR'("_As"),'$VAR'("_Bs")],[clamp,[/,[-,[+,'$VAR'("_As"),'$VAR'("_Bs")],1],'$VAR'("_As")],0,1]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    ['smallest-intersection-probability',As,Bs], 
    [ clamp, 
      [ /, 
        [ -, 
          [+,As,Bs], 
          1], 
        As], 0,1]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'smallest-intersection-probability', 
  [2], 
  0, 
  ['Number','Number'], 
  'Number', 
  [ x(doeval,eager,[number]), 
    x(doeval,eager,[number])], 
  x(doeval,eager,[number]), 
  ['smallest-intersection-probability',As,Bs], 
  [ clamp, 
    [ /, 
      [ -, 
        [+,As,Bs], 
        1], 
      As], 0,1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'smallest-intersection-probability', 
  [2], todo,todo, 
  [ x(doeval,eager,[number]), 
    x(doeval,eager,[number])], 
  x(doeval,eager,[number]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('smallest-intersection-probability',[2]) =  
  []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('smallest-intersection-probability',[2],clamp,[3])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('smallest-intersection-probability',[2],/,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('smallest-intersection-probability',[2],-,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('smallest-intersection-probability',[2],+,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">'mc__1_2_smallest-intersection-probability'(P,Q,R) :- 
  'mc__1_2_+'(P,Q,S) , 
  'mc__1_2_-'(S,1,T) , 
  'mc__1_2_/'(T,P,U) , 
  mc__1_3_clamp(U,0,1,R)
</span> 
<span class="ansi38-255165000"> (: largest-intersection-probability (-> Number Number Number))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[:,'largest-intersection-probability',[->,'Number','Number','Number']])
 
</span><span class="ansi38-255165000"> (= (largest-intersection-probability $As $Bs)  
  (clamp 
    (/ $Bs $As) 0 1))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['largest-intersection-probability','$VAR'("_As"),'$VAR'("_Bs")],[clamp,[/,'$VAR'("_Bs"),'$VAR'("_As")],0,1]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    ['largest-intersection-probability',As,Bs], 
    [ clamp, 
      [/,Bs,As], 0,1]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'largest-intersection-probability', 
  [2], 
  0, 
  ['Number','Number'], 
  'Number', 
  [ x(doeval,eager,[number]), 
    x(doeval,eager,[number])], 
  x(doeval,eager,[number]), 
  ['largest-intersection-probability',As,Bs], 
  [ clamp, 
    [/,Bs,As], 0,1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'largest-intersection-probability', 
  [2], todo,todo, 
  [ x(doeval,eager,[number]), 
    x(doeval,eager,[number])], 
  x(doeval,eager,[number]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('largest-intersection-probability',[2]) =  
  []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('largest-intersection-probability',[2],clamp,[3])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('largest-intersection-probability',[2],/,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">'mc__1_2_largest-intersection-probability'(P,Q,R) :- 
  'mc__1_2_/'(Q,P,S) , 
  mc__1_3_clamp(S,0,1,R)
</span> 
<span class="ansi38-255165000"> (: conditional-probability-consistency (-> Number Number Number Bool))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[:,'conditional-probability-consistency',[->,'Number','Number','Number','Bool']])
 
</span><span class="ansi38-255165000"> (= (conditional-probability-consistency $As $Bs $ABs)  
  (and 
    (< 0 $As) 
    (and 
      (<= 
        (smallest-intersection-probability $As $Bs) $ABs) 
      (<= $ABs 
        (largest-intersection-probability $As $Bs)))))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['conditional-probability-consistency','$VAR'("_As"),'$VAR'("_Bs"),_14394892{$ABs}],[and,[<,0,'$VAR'("_As")],[and,[<=,['smallest-intersection-probability','$VAR'("_As"),'$VAR'("_Bs")],_14394892{$ABs}],[<=,_14394892{$ABs},['largest-intersection-probability','$VAR'("_As"),'$VAR'("_Bs")]]]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    ['conditional-probability-consistency',As,Bs,ABs], 
    [ and, 
      [<,0,As], 
      [ and, 
        [ <=, 
          ['smallest-intersection-probability',As,Bs], 
          ABs], 
        [ <=, 
          ABs, 
          ['largest-intersection-probability',As,Bs]]]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'conditional-probability-consistency', 
  [3], 
  0, 
  ['Number','Number','Number'], 
  'Bool', 
  [ x(doeval,eager,[number]), 
    x(doeval,eager,[number]), 
    x(doeval,eager,[number])], 
  x(doeval,eager,[boolean]), 
  ['conditional-probability-consistency',As,Bs,ABs], 
  [ and, 
    [<,0,As], 
    [ and, 
      [ <=, 
        ['smallest-intersection-probability',As,Bs], 
        ABs], 
      [ <=, 
        ABs, 
        ['largest-intersection-probability',As,Bs]]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'conditional-probability-consistency', 
  [3], todo,todo, 
  [ x(doeval,eager,[number]), 
    x(doeval,eager,[number]), 
    x(doeval,eager,[number])], 
  x(doeval,eager,[boolean]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('conditional-probability-consistency',[3]) =  
  []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('conditional-probability-consistency',[3],<,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('conditional-probability-consistency',[3],<=,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on( 'conditional-probability-consistency', 
  [3], 
  'smallest-intersection-probability', 
  [2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('conditional-probability-consistency',[3],'largest-intersection-probability',[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">'mc__1_3_conditional-probability-consistency'(P,Q,R,S) :-  
    ((
     (  ((
         ('mc__1_2_<'(0,P,T),is_True(T))*->
         (  ((
             (  ((
                 (  ((
                     (( 'mc__1_2_smallest-intersection-probability'(P,Q,U)  ,
                        'mc__1_2_<='(U,R,V) , 
                        is_True(V)))*->
                     (( 'mc__1_2_largest-intersection-probability'(P,Q,W)  ,
                        'mc__1_2_<='(R,W,X) , 
                        Y=X))  )));
                 (Y='False')  ))),
             (S=Y)  )))  )));
     (S='False')  ))
</span> 
;;;; TRUTH FORMULAS
;;; Deduction formula: PLN book "1.4 Truth-value Formulas", page 15:
;;; borrowed from https://github.com/trueagi-io/hyperon-pln/blob/main/metta/pln/dependent-types/DeductionDTL.metta
<span class="ansi38-255165000"> (= (Truth_Deduction (stv $Ps $Pc) (stv $Qs $Qc) (stv $Rs $Rc) (stv $PQs $PQc) (stv $QRs $QRc))  
  (if 
    (and 
      (conditional-probability-consistency $Ps $Qs $PQs) 
      (conditional-probability-consistency $Qs $Rs $QRs)) 
    (stv 
      (if 
        (< 0.9999 $Qs) $Rs 
        (+ 
          (* $PQs $QRs) 
          (/ 
            (* 
              (- 1 $PQs) 
              (- $Rs 
                (* $Qs $QRs))) 
            (- 1 $Qs)))) 
      (min $Pc 
        (min $Qc 
          (min $Rc 
            (min $PQc $QRc))))) 
    (stv 1 0)))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['Truth_Deduction',[stv,'$VAR'("_Ps"),'$VAR'("_Pc")],[stv,_14786806{$Qs},_14786786{$Qc}],[stv,_14786766{$Rs},_14786746{$Rc}],[stv,_14786726{$PQs},_14786706{$PQc}],[stv,_14786686{$QRs},_14786666{$QRc}]],[if,[and,['conditional-probability-consistency','$VAR'("_Ps"),_14786806{$Qs},_14786726{$PQs}],['conditional-probability-consistency',_14786806{$Qs},_14786766{$Rs},_14786686{$QRs}]],[stv,[if,[<,0.9999,_14786806{$Qs}],_14786766{$Rs},[+,[*,_14786726{$PQs},_14786686{$QRs}],[/,[*,[-,1,_14786726{$PQs}],[-,_14786766{$Rs},[*,_14786806{$Qs},_14786686{$QRs}]]],[-,1,_14786806{$Qs}]]]],[min,'$VAR'("_Pc"),[min,_14786786{$Qc},[min,_14786746{$Rc},[min,_14786706{$PQc},_14786666{$QRc}]]]]],[stv,1,0]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ 'Truth_Deduction', 
      [stv,Ps,Pc], 
      [stv,Qs,Qc], 
      [stv,Rs,Rc], 
      [stv,PQs,PQc], 
      [stv,QRs,QRc]], 
    [ if, 
      [ and, 
        ['conditional-probability-consistency',Ps,Qs,PQs], 
        ['conditional-probability-consistency',Qs,Rs,QRs]], 
      [ stv, 
        [ if, 
          [<,0.9999,Qs], 
          Rs, 
          [ +, 
            [*,PQs,QRs], 
            [ /, 
              [ *, 
                [-,1,PQs], 
                [ -, 
                  Rs, 
                  [*,Qs,QRs]]], 
              [-,1,Qs]]]], 
        [ min, 
          Pc, 
          [ min, 
            Qc, 
            [ min, 
              Rc, 
              [min,PQc,QRc]]]]], 
      [stv,1,0]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'Truth_Deduction', 
  [5], 
  0, 
  [ 'Any', 'Any','Any','Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), x(doeval,eager,[]),x(doeval,eager,[]), 
    x(doeval,eager,[]),x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ 'Truth_Deduction', 
    [stv,Ps,Pc], 
    [stv,Qs,Qc], 
    [stv,Rs,Rc], 
    [stv,PQs,PQc], 
    [stv,QRs,QRc]], 
  [ if, 
    [ and, 
      ['conditional-probability-consistency',Ps,Qs,PQs], 
      ['conditional-probability-consistency',Qs,Rs,QRs]], 
    [ stv, 
      [ if, 
        [<,0.9999,Qs], 
        Rs, 
        [ +, 
          [*,PQs,QRs], 
          [ /, 
            [ *, 
              [-,1,PQs], 
              [ -, 
                Rs, 
                [*,Qs,QRs]]], 
            [-,1,Qs]]]], 
      [ min, 
        Pc, 
        [ min, 
          Qc, 
          [ min, 
            Rc, 
            [min,PQc,QRc]]]]], 
    [stv,1,0]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'Truth_Deduction', 
  [5], todo,todo, 
  [ x(doeval,eager,[]), x(doeval,eager,[]),x(doeval,eager,[]), 
    x(doeval,eager,[]),x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('Truth_Deduction',[5]) =  
  []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Deduction',[5],'conditional-probability-consistency',[3])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Deduction',[5],stv,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Deduction',[5],<,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Deduction',[5],+,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Deduction',[5],*,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Deduction',[5],/,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Deduction',[5],-,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Deduction',[5],min,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 mc__1_5_Truth_Deduction( [stv,P,Q], 
  [stv,R,S], 
  [stv,T,U], 
  [stv,V,W], 
  [stv,X,Y], 
  Z) :-  
    ((
     (  ((
         (  ((
             (  ((
                 (  ((
                     (  ((
                         ('mc__1_3_conditional-probability-consistency'(P,R,V,A1)),
                         (is_True(A1))  )))*->
                     (  ((
                         ('mc__1_3_conditional-probability-consistency'(R,T,X,B1)),
                         (C1=B1)  )))  )));
                 (C1='False')  ))),
             (is_True(C1))  )))*->
         ((   ((
               ('mc__1_2_<'(0.9999,R,D1),is_True(D1)*->E1=T);
               (( 'mc__1_2_*'(V,X,F1)  ,
                  'mc__1_2_-'(1,V,G1) , 
                  'mc__1_2_*'(R,X,H1) , 
                  'mc__1_2_-'(T,H1,I1) , 
                  'mc__1_2_*'(G1,I1,J1) , 
                  'mc__1_2_-'(1,R,K1) , 
                  'mc__1_2_/'(J1,K1,L1) , 
                  'mc__1_2_+'(F1,L1,M1) , 
                  E1=M1))  ))  ,
            mc__1_2_min(W,Y,N1) , 
            mc__1_2_min(U,N1,O1) , 
            mc__1_2_min(S,O1,P1) , 
            mc__1_2_min(Q,P1,Q1) , 
            R1=[stv,E1,Q1] , 
            Z=R1))  )));
     (S1=[stv,1,0],Z=S1)  ))
</span> 
;;; Induction formula: PLN book "Appendix A: Comparison of PLN Rules with NARS Rules", page 307
<span class="ansi38-255165000"> (= (Truth_Induction (stv $SA $CA) (stv $SB $CB) (stv $SC $CC) (stv $SAB $CAB) (stv $SBC $CBC))  
  (stv 
    (+ 
      (/ 
        (* 
          (* $SBA $SBC) $SB) $SA) 
      (* 
        (- 1 
          (/ 
            (* $SBA $SB) $SA)) 
        (/ 
          (- $SC 
            (* $SB $SBC)) 
          (- 1 $SB)))) 
    (Truth_w2c (min $CAB $CBc))))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['Truth_Induction',[stv,'$VAR'("_SA"),'$VAR'("_CA")],[stv,_15539842{$SB},_15539822{$CB}],[stv,_15539802{$SC},_15539782{$CC}],[stv,_15539762{$SAB},_15539742{$CAB}],[stv,_15539722{$SBC},_15539702{$CBC}]],[stv,[+,[/,[*,[*,_15539682{$SBA},_15539722{$SBC}],_15539842{$SB}],'$VAR'("_SA")],[*,[-,1,[/,[*,_15539682{$SBA},_15539842{$SB}],'$VAR'("_SA")]],[/,[-,_15539802{$SC},[*,_15539842{$SB},_15539722{$SBC}]],[-,1,_15539842{$SB}]]]],['Truth_w2c',[min,_15539742{$CAB},_15539662{$CBc}]]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ 'Truth_Induction', 
      [stv,SA,CA], 
      [stv,SB,CB], 
      [stv,SC,CC], 
      [stv,SAB,CAB], 
      [stv,SBC,CBC]], 
    [ stv, 
      [ +, 
        [ /, 
          [ *, 
            [*,SBA,SBC], 
            SB], 
          SA], 
        [ *, 
          [ -, 
            1, 
            [ /, 
              [*,SBA,SB], 
              SA]], 
          [ /, 
            [ -, 
              SC, 
              [*,SB,SBC]], 
            [-,1,SB]]]], 
      [ 'Truth_w2c', 
        [min,CAB,CBc]]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'Truth_Induction', 
  [5], 
  0, 
  [ 'Any', 'Any','Any','Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), x(doeval,eager,[]),x(doeval,eager,[]), 
    x(doeval,eager,[]),x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ 'Truth_Induction', 
    [stv,SA,CA], 
    [stv,SB,CB], 
    [stv,SC,CC], 
    [stv,SAB,CAB], 
    [stv,SBC,CBC]], 
  [ stv, 
    [ +, 
      [ /, 
        [ *, 
          [*,SBA,SBC], 
          SB], 
        SA], 
      [ *, 
        [ -, 
          1, 
          [ /, 
            [*,SBA,SB], 
            SA]], 
        [ /, 
          [ -, 
            SC, 
            [*,SB,SBC]], 
          [-,1,SB]]]], 
    [ 'Truth_w2c', 
      [min,CAB,CBc]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'Truth_Induction', 
  [5], todo,todo, 
  [ x(doeval,eager,[]), x(doeval,eager,[]),x(doeval,eager,[]), 
    x(doeval,eager,[]),x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('Truth_Induction',[5]) =  
  []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Induction',[5],stv,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Induction',[5],+,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Induction',[5],/,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Induction',[5],*,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Induction',[5],-,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Induction',[5],'Truth_w2c',[1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Induction',[5],min,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 mc__1_5_Truth_Induction( [stv,P,Q], 
  [stv,R,S], 
  [stv,T,U], 
  [stv,V,W], 
  [stv,X,Y], 
  Z) :- 
  'mc__1_2_*'(A1,X,B1) , 
  'mc__1_2_*'(B1,R,C1) , 
  'mc__1_2_/'(C1,P,D1) , 
  'mc__1_2_*'(A1,R,E1) , 
  'mc__1_2_/'(E1,P,F1) , 
  'mc__1_2_-'(1,F1,G1) , 
  'mc__1_2_*'(R,X,H1) , 
  'mc__1_2_-'(T,H1,I1) , 
  'mc__1_2_-'(1,R,J1) , 
  'mc__1_2_/'(I1,J1,K1) , 
  'mc__1_2_*'(G1,K1,L1) , 
  'mc__1_2_+'(D1,L1,M1) , 
  mc__1_2_min(W,N1,O1) , 
  P1=['Truth_w2c',O1] , 
  Z=[stv,M1,P1]
</span> 
;;;confidence TODO check
;;; Abduction formula: PLN book "Appendix A: Comparison of PLN Rules with NARS Rules", page 307
<span class="ansi38-255165000"> (= (Truth_Abduction (stv $SA $CA) (stv $SB $CB) (stv $SC $CC) (stv $SAB $CAB) (stv $SBC $CBC))  
  (stv 
    (+ 
      (/ 
        (* 
          (* $SAB $SCB) $SC) $SB) 
      (/ 
        (* sC 
          (* 
            (- 1 sAB) 
            (- 1 sCB))) 
        (- 1 sB))) 
    (Truth_w2c (min $CAB $CBc))))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['Truth_Abduction',[stv,'$VAR'("_SA"),'$VAR'("_CA")],[stv,_16173036{$SB},_16173016{$CB}],[stv,_16172996{$SC},_16172976{$CC}],[stv,_16172956{$SAB},_16172936{$CAB}],[stv,_16172916{$SBC},_16172896{$CBC}]],[stv,[+,[/,[*,[*,_16172956{$SAB},_16172876{$SCB}],_16172996{$SC}],_16173036{$SB}],[/,[*,sC,[*,[-,1,sAB],[-,1,sCB]]],[-,1,sB]]],['Truth_w2c',[min,_16172936{$CAB},_16172856{$CBc}]]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ 'Truth_Abduction', 
      [stv,SA,CA], 
      [stv,SB,CB], 
      [stv,SC,CC], 
      [stv,SAB,CAB], 
      [stv,SBC,CBC]], 
    [ stv, 
      [ +, 
        [ /, 
          [ *, 
            [*,SAB,SCB], 
            SC], 
          SB], 
        [ /, 
          [ *, 
            sC, 
            [ *, 
              [-,1,sAB], 
              [-,1,sCB]]], 
          [-,1,sB]]], 
      [ 'Truth_w2c', 
        [min,CAB,CBc]]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'Truth_Abduction', 
  [5], 
  0, 
  [ 'Any', 'Any','Any','Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), x(doeval,eager,[]),x(doeval,eager,[]), 
    x(doeval,eager,[]),x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ 'Truth_Abduction', 
    [stv,SA,CA], 
    [stv,SB,CB], 
    [stv,SC,CC], 
    [stv,SAB,CAB], 
    [stv,SBC,CBC]], 
  [ stv, 
    [ +, 
      [ /, 
        [ *, 
          [*,SAB,SCB], 
          SC], 
        SB], 
      [ /, 
        [ *, 
          sC, 
          [ *, 
            [-,1,sAB], 
            [-,1,sCB]]], 
        [-,1,sB]]], 
    [ 'Truth_w2c', 
      [min,CAB,CBc]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'Truth_Abduction', 
  [5], todo,todo, 
  [ x(doeval,eager,[]), x(doeval,eager,[]),x(doeval,eager,[]), 
    x(doeval,eager,[]),x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('Truth_Abduction',[5]) =  
  []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Abduction',[5],stv,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Abduction',[5],+,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Abduction',[5],/,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Abduction',[5],*,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Abduction',[5],-,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Abduction',[5],'Truth_w2c',[1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Abduction',[5],min,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 mc__1_5_Truth_Abduction( [stv,P,Q], 
  [stv,R,S], 
  [stv,T,U], 
  [stv,V,W], 
  [stv,X,Y], 
  Z) :- 
  'mc__1_2_*'(V,A1,B1) , 
  'mc__1_2_*'(B1,T,C1) , 
  'mc__1_2_/'(C1,R,D1) , 
  'mc__1_2_-'(1,sAB,E1) , 
  'mc__1_2_-'(1,sCB,F1) , 
  'mc__1_2_*'(E1,F1,G1) , 
  'mc__1_2_*'(sC,G1,H1) , 
  'mc__1_2_-'(1,sB,I1) , 
  'mc__1_2_/'(H1,I1,J1) , 
  'mc__1_2_+'(D1,J1,K1) , 
  mc__1_2_min(W,L1,M1) , 
  N1=['Truth_w2c',M1] , 
  Z=[stv,K1,N1]
</span> 
;;;confidence TODO check
;;;Modus Ponens: PLN book "5.7.1 Modus Ponens", page 111:
<span class="ansi38-255165000"> (= (Truth_ModusPonens (stv $f1 $c1) (stv $f2 $c2))  
  (stv 
    (+ 
      (* $f1 $f2) 
      (* 0.02 
        (- 1 $f1))) 
    (min $c1 $c2)))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['Truth_ModusPonens',[stv,'$VAR'("_f1"),'$VAR'("_c1")],[stv,_16664330{$_f2},_16664310{$_c2}]],[stv,[+,[*,'$VAR'("_f1"),_16664330{$_f2}],[*,0.02,[-,1,'$VAR'("_f1")]]],[min,'$VAR'("_c1"),_16664310{$_c2}]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ 'Truth_ModusPonens', 
      [stv,_f1,_c1], 
      [stv,_f2,_c2]], 
    [ stv, 
      [ +, 
        [*,_f1,_f2], 
        [ *, 
          0.02, 
          [-,1,_f1]]], 
      [min,_c1,_c2]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'Truth_ModusPonens', 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ 'Truth_ModusPonens', 
    [stv,_f1,_c1], 
    [stv,_f2,_c2]], 
  [ stv, 
    [ +, 
      [*,_f1,_f2], 
      [ *, 
        0.02, 
        [-,1,_f1]]], 
    [min,_c1,_c2]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'Truth_ModusPonens', 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('Truth_ModusPonens',[2]) =  
  []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_ModusPonens',[2],stv,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_ModusPonens',[2],+,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_ModusPonens',[2],*,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_ModusPonens',[2],-,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_ModusPonens',[2],min,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 mc__1_2_Truth_ModusPonens( [stv,P,Q], 
  [stv,R,S], 
  T) :- 
  'mc__1_2_*'(P,R,U) , 
  'mc__1_2_-'(1,P,V) , 
  'mc__1_2_*'(0.02,V,W) , 
  'mc__1_2_+'(U,W,X) , 
  mc__1_2_min(Q,S,Y) , 
  T=[stv,X,Y]
</span> 
;;;Revision: PLN Book "5.10.2 A Heuristic Revision Rule for Simple Truth-values", page 116:
<span class="ansi38-255165000"> (: Truth_c2w (-> Number Number))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[:,'Truth_c2w',[->,'Number','Number']])
 
</span><span class="ansi38-255165000"> (= (Truth_c2w $c)  
  (/ $c 
    (- 1 $c)))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['Truth_c2w','$VAR'("_c")],[/,'$VAR'("_c"),[-,1,'$VAR'("_c")]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    ['Truth_c2w',_c], 
    [ /, 
      _c, 
      [-,1,_c]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'Truth_c2w', 
  [1], 
  0, 
  ['Number'], 
  'Number', 
  [ x(doeval,eager,[number])], 
  x(doeval,eager,[number]), 
  ['Truth_c2w',_c], 
  [ /, 
    _c, 
    [-,1,_c]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">transpiler_predicate_store( user, 
  'Truth_c2w', 
  [1], todo,todo, 
  [ x(doeval,eager,[number])], 
  x(doeval,eager,[number]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('Truth_c2w',[1]) =  
  []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_c2w',[1],/,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_c2w',[1],-,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">mc__1_1_Truth_c2w(P,Q) :- 
  'mc__1_2_-'(1,P,R) , 
  'mc__1_2_/'(P,R,Q)
</span> 
<span class="ansi38-255165000"> (: Truth_w2c (-> Number Number))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[:,'Truth_w2c',[->,'Number','Number']])
 
</span><span class="ansi38-255165000"> (= (Truth_w2c $w)  
  (/ $w 
    (+ $w 1)))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['Truth_w2c','$VAR'("_w")],[/,'$VAR'("_w"),[+,'$VAR'("_w"),1]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    ['Truth_w2c',_w], 
    [ /, 
      _w, 
      [+,_w,1]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'Truth_w2c', 
  [1], 
  0, 
  ['Number'], 
  'Number', 
  [ x(doeval,eager,[number])], 
  x(doeval,eager,[number]), 
  ['Truth_w2c',_w], 
  [ /, 
    _w, 
    [+,_w,1]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">transpiler_predicate_store( user, 
  'Truth_w2c', 
  [1], todo,todo, 
  [ x(doeval,eager,[number])], 
  x(doeval,eager,[number]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">
 fa('Truth_w2c',[1]) =  
  [ 'Truth_Induction'/[5], 
    'Truth_Abduction'/[5]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'Truth_Induction', 
  [5], 
  0, 
  [ 'Any', 'Any','Any','Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), x(doeval,eager,[]),x(doeval,eager,[]), 
    x(doeval,eager,[]),x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ 'Truth_Induction', 
    [stv,C,D], 
    [stv,E,F], 
    [stv,G,H], 
    [stv,I,J], 
    [stv,K,L]], 
  [ stv, 
    [ +, 
      [ /, 
        [ *, 
          [*,M,K], 
          E], 
        C], 
      [ *, 
        [ -, 
          1, 
          [ /, 
            [*,M,E], 
            C]], 
        [ /, 
          [ -, 
            G, 
            [*,E,K]], 
          [-,1,E]]]], 
    [ 'Truth_w2c', 
      [min,J,N]]])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 mc__1_5_Truth_Induction( [stv,C,D], 
  [stv,E,F], 
  [stv,G,H], 
  [stv,I,J], 
  [stv,K,L], 
  P) :- 
  'mc__1_2_*'(M,K,Q) , 
  'mc__1_2_*'(Q,E,R) , 
  'mc__1_2_/'(R,C,S) , 
  'mc__1_2_*'(M,E,T) , 
  'mc__1_2_/'(T,C,U) , 
  'mc__1_2_-'(1,U,V) , 
  'mc__1_2_*'(E,K,W) , 
  'mc__1_2_-'(G,W,X) , 
  'mc__1_2_-'(1,E,Y) , 
  'mc__1_2_/'(X,Y,Z) , 
  'mc__1_2_*'(V,Z,A1) , 
  'mc__1_2_+'(S,A1,B1) , 
  mc__1_2_min(J,N,C1) , 
  mc__1_1_Truth_w2c(C1,D1) , 
  P=[stv,B1,D1]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'Truth_Abduction', 
  [5], 
  0, 
  [ 'Any', 'Any','Any','Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), x(doeval,eager,[]),x(doeval,eager,[]), 
    x(doeval,eager,[]),x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ 'Truth_Abduction', 
    [stv,C,D], 
    [stv,E,F], 
    [stv,G,H], 
    [stv,I,J], 
    [stv,K,L]], 
  [ stv, 
    [ +, 
      [ /, 
        [ *, 
          [*,I,M], 
          G], 
        E], 
      [ /, 
        [ *, 
          sC, 
          [ *, 
            [-,1,sAB], 
            [-,1,sCB]]], 
        [-,1,sB]]], 
    [ 'Truth_w2c', 
      [min,J,N]]])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 mc__1_5_Truth_Abduction( [stv,C,D], 
  [stv,E,F], 
  [stv,G,H], 
  [stv,I,J], 
  [stv,K,L], 
  P) :- 
  'mc__1_2_*'(I,M,Q) , 
  'mc__1_2_*'(Q,G,R) , 
  'mc__1_2_/'(R,E,S) , 
  'mc__1_2_-'(1,sAB,T) , 
  'mc__1_2_-'(1,sCB,U) , 
  'mc__1_2_*'(T,U,V) , 
  'mc__1_2_*'(sC,V,W) , 
  'mc__1_2_-'(1,sB,X) , 
  'mc__1_2_/'(W,X,Y) , 
  'mc__1_2_+'(S,Y,Z) , 
  mc__1_2_min(J,N,A1) , 
  mc__1_1_Truth_w2c(A1,B1) , 
  P=[stv,Z,B1]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_w2c',[1],/,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_w2c',[1],+,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">mc__1_1_Truth_w2c(P,Q) :- 
  'mc__1_2_+'(P,1,R) , 
  'mc__1_2_/'(P,R,Q)
</span> 
<span class="ansi38-255165000"> (= (Truth_Revision (stv $f1 $c1) (stv $f2 $c2))  
  (let* 
    ( ($w1 (Truth_c2w $c1)) 
      ($w2 (Truth_c2w $c2)) 
      ($w (+ $w1 $w2)) 
      ($f (/ (+ (* $w1 $f1) (* $w2 $f2)) $w)) 
      ($c (Truth_w2c $w))) 
    (stv 
      (min 1.0 $f) 
      (min 1.0 
        (max 
          (max $c $c1) $c2)))))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['Truth_Revision',[stv,'$VAR'("_f1"),'$VAR'("_c1")],[stv,_17774686{$_f2},_17774666{$_c2}]],['let*',[[_17774646{$_w1},['Truth_c2w','$VAR'("_c1")]],[_17774626{$_w2},['Truth_c2w',_17774666{$_c2}]],[_17774606{$_w},[+,_17774646{$_w1},_17774626{$_w2}]],[_17774586{$_f},[/,[+,[*,_17774646{$_w1},'$VAR'("_f1")],[*,_17774626{$_w2},_17774686{$_f2}]],_17774606{$_w}]],[_17774566{$_c},['Truth_w2c',_17774606{$_w}]]],[stv,[min,1.0,_17774586{$_f}],[min,1.0,[max,[max,_17774566{$_c},'$VAR'("_c1")],_17774666{$_c2}]]]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ 'Truth_Revision', 
      [stv,_f1,_c1], 
      [stv,_f2,_c2]], 
    [ 'let*', 
      [ [ _w1, 
          ['Truth_c2w',_c1]], 
        [ _w2, 
          ['Truth_c2w',_c2]], 
        [ _w, 
          [+,_w1,_w2]], 
        [ _f, 
          [ /, 
            [ +, 
              [*,_w1,_f1], 
              [*,_w2,_f2]], 
            _w]], 
        [ _c, 
          ['Truth_w2c',_w]]], 
      [ stv, 
        [min,1.0,_f], 
        [ min, 
          1.0, 
          [ max, 
            [max,_c,_c1], 
            _c2]]]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'Truth_Revision', 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ 'Truth_Revision', 
    [stv,_f1,_c1], 
    [stv,_f2,_c2]], 
  [ 'let*', 
    [ [ _w1, 
        ['Truth_c2w',_c1]], 
      [ _w2, 
        ['Truth_c2w',_c2]], 
      [ _w, 
        [+,_w1,_w2]], 
      [ _f, 
        [ /, 
          [ +, 
            [*,_w1,_f1], 
            [*,_w2,_f2]], 
          _w]], 
      [ _c, 
        ['Truth_w2c',_w]]], 
    [ stv, 
      [min,1.0,_f], 
      [ min, 
        1.0, 
        [ max, 
          [max,_c,_c1], 
          _c2]]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'Truth_Revision', 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('Truth_Revision',[2]) =  
  []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Revision',[2],'Truth_c2w',[1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Revision',[2],+,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Revision',[2],/,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Revision',[2],*,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Revision',[2],'Truth_w2c',[1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Revision',[2],stv,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Revision',[2],min,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Truth_Revision',[2],max,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 mc__1_2_Truth_Revision( [stv,P,Q], 
  [stv,R,S], 
  T) :- 
  mc__1_1_Truth_c2w(Q,U) , 
  V=U , 
  mc__1_1_Truth_c2w(S,W) , 
  X=W , 
  'mc__1_2_+'(V,X,Y) , 
  Z=Y , 
  'mc__1_2_*'(V,P,A1) , 
  'mc__1_2_*'(X,R,B1) , 
  'mc__1_2_+'(A1,B1,C1) , 
  'mc__1_2_/'(C1,Z,D1) , 
  E1=D1 , 
  mc__1_1_Truth_w2c(Z,F1) , 
  G1=F1 , 
  mc__1_2_min(1.0,E1,H1) , 
  mc__1_2_max(G1,Q,I1) , 
  mc__1_2_max(I1,S,J1) , 
  mc__1_2_min(1.0,J1,K1) , 
  T=[stv,H1,K1]
</span> 
;;;; INFERENCE RULES
;;;Revision
<span class="ansi38-255165000"> (= (|- ($T $T1) ($T $T2))  
  ($T (Truth_Revision $T1 $T2)))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['|-',['$VAR'("_T"),'$VAR'("_T1")],['$VAR'("_T"),_18286536{$T2}]],['$VAR'("_T"),['Truth_Revision','$VAR'("_T1"),_18286536{$T2}]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ '|-', 
      [T,T1], 
      [T,T2]], 
    [ T, 
      ['Truth_Revision',T1,T2]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( '|-', 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ '|-', 
    [T,T1], 
    [T,T2]], 
  [ T, 
    ['Truth_Revision',T1,T2]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  '|-', 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('|-',[2]) =  
  []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('|-',[2],'Truth_Revision',[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 'mc__1_2_|-'([P,Q],[P,R],S) :- 
  mc__1_2_Truth_Revision(Q,R,T) , 
  transpiler_apply( mc__1_1_, 
    P, 
    [P,T], 
    S, 
    [T], 
    [U], 
    [x(doeval,eager,[])], 
    [mc__1_2_Truth_Revision(Q,R,T)], 
    [U=['Truth_Revision',Q,R]])
</span> 
;;;Modus Ponens
<span class="ansi38-255165000"> (= (|- ($A $T1) ((Implication $A $B) $T2))  
  ($B (Truth_ModusPonens $T1 $T2)))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['|-',['$VAR'("_A"),'$VAR'("_T1")],[['Implication','$VAR'("_A"),_18478664{$B}],_18478644{$T2}]],[_18478664{$B},['Truth_ModusPonens','$VAR'("_T1"),_18478644{$T2}]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ '|-', 
      [A,T1], 
      [ ['Implication',A,B], 
        T2]], 
    [ B, 
      ['Truth_ModusPonens',T1,T2]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( '|-', 
  [2], 
  1, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ '|-', 
    [A,T1], 
    [ ['Implication',A,B], 
      T2]], 
  [ B, 
    ['Truth_ModusPonens',T1,T2]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('|-',[2],'Truth_ModusPonens',[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 'mc__1_2_|-'( [P,Q], 
  [ ['Implication',P,R], 
    S], 
  T) :- 
  mc__1_2_Truth_ModusPonens(Q,S,U) , 
  transpiler_apply( mc__1_1_, 
    R, 
    [R,U], 
    T, 
    [U], 
    [V], 
    [x(doeval,eager,[])], 
    [mc__1_2_Truth_ModusPonens(Q,S,U)], 
    [V=['Truth_ModusPonens',Q,S]])
</span> 
;;;Deduction
<span class="ansi38-255165000"> (= (|- ((Inheritance (Concept $A) (Concept $B)) $T1) ((Inheritance (Concept $B) (Concept $C)) $T2))  
    
  (Inheritance $A $C)
    
  (Truth_Deduction 
    (STV $A) 
    (STV $B) 
    (STV $C) $T1 $T2))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['|-',[['Inheritance',['Concept','$VAR'("_A")],['Concept','$VAR'("_B")]],_18669194{$T1}],[['Inheritance',['Concept','$VAR'("_B")],['Concept',_18669174{$C}]],_18669154{$T2}]],[['Inheritance','$VAR'("_A"),_18669174{$C}],['Truth_Deduction',['STV','$VAR'("_A")],['STV','$VAR'("_B")],['STV',_18669174{$C}],_18669194{$T1},_18669154{$T2}]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ '|-', 
      [ [ 'Inheritance', 
          ['Concept',A], 
          ['Concept',B]], 
        T1], 
      [ [ 'Inheritance', 
          ['Concept',B], 
          ['Concept',C]], 
        T2]], 
    [ ['Inheritance',A,C], 
      [ 'Truth_Deduction', 
        ['STV',A], 
        ['STV',B], 
        ['STV',C], T1,T2]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( '|-', 
  [2], 
  2, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ '|-', 
    [ [ 'Inheritance', 
        ['Concept',A], 
        ['Concept',B]], 
      T1], 
    [ [ 'Inheritance', 
        ['Concept',B], 
        ['Concept',C]], 
      T2]], 
  [ ['Inheritance',A,C], 
    [ 'Truth_Deduction', 
      ['STV',A], 
      ['STV',B], 
      ['STV',C], T1,T2]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">
 transpiler_depends_on('|-',[2],'Inheritance',[1,2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('|-',[2],'Inheritance',[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('|-',[2],'Truth_Deduction',[5])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('|-',[2],'STV',[1])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 'mc__1_2_|-'( 
   [ [ 'Inheritance', 
       ['Concept',P], 
       ['Concept',Q]], 
     R], 
   [ [ 'Inheritance', 
       ['Concept',Q], 
       ['Concept',S]], 
     T], 
   U) :- 
  V=['Inheritance',P,S] , 
  W=['STV',P] , 
  X=['STV',Q] , 
  Y=['STV',S] , 
  mc__1_5_Truth_Deduction(W,X,Y,R,T,Z) , 
  U=[V,Z]
</span> 
;;;Induction
<span class="ansi38-255165000"> (= (|- ((Inheritance (Concept $C) (Concept $A)) $T1) ((Inheritance (Concept $C) (Concept $B)) $T2))  
    
  (Inheritance $A $B)
    
  (Truth_Induction 
    (STV $A) 
    (STV $B) 
    (STV $C) $T1 $T2))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['|-',[['Inheritance',['Concept','$VAR'("_C")],['Concept','$VAR'("_A")]],_19001760{$T1}],[['Inheritance',['Concept','$VAR'("_C")],['Concept',_19001740{$B}]],_19001720{$T2}]],[['Inheritance','$VAR'("_A"),_19001740{$B}],['Truth_Induction',['STV','$VAR'("_A")],['STV',_19001740{$B}],['STV','$VAR'("_C")],_19001760{$T1},_19001720{$T2}]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ '|-', 
      [ [ 'Inheritance', 
          ['Concept',C], 
          ['Concept',A]], 
        T1], 
      [ [ 'Inheritance', 
          ['Concept',C], 
          ['Concept',B]], 
        T2]], 
    [ ['Inheritance',A,B], 
      [ 'Truth_Induction', 
        ['STV',A], 
        ['STV',B], 
        ['STV',C], T1,T2]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( '|-', 
  [2], 
  3, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ '|-', 
    [ [ 'Inheritance', 
        ['Concept',C], 
        ['Concept',A]], 
      T1], 
    [ [ 'Inheritance', 
        ['Concept',C], 
        ['Concept',B]], 
      T2]], 
  [ ['Inheritance',A,B], 
    [ 'Truth_Induction', 
      ['STV',A], 
      ['STV',B], 
      ['STV',C], T1,T2]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('|-',[2],'Truth_Induction',[5])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 'mc__1_2_|-'( 
   [ [ 'Inheritance', 
       ['Concept',P], 
       ['Concept',Q]], 
     R], 
   [ [ 'Inheritance', 
       ['Concept',P], 
       ['Concept',S]], 
     T], 
   U) :- 
  V=['Inheritance',Q,S] , 
  W=['STV',Q] , 
  X=['STV',S] , 
  Y=['STV',P] , 
  mc__1_5_Truth_Induction(W,X,Y,R,T,Z) , 
  U=[V,Z]
</span> 
;;;Abduction
<span class="ansi38-255165000"> (= (|- ((Inheritance (Concept $A) (Concept $C)) $T1) ((Inheritance (Concept $B) (Concept $C)) $T2))  
    
  (Inheritance $A $B)
    
  (Truth_Abduction 
    (STV $A) 
    (STV $B) 
    (STV $C) $T1 $T2))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['|-',[['Inheritance',['Concept','$VAR'("_A")],['Concept','$VAR'("_C")]],_19299986{$T1}],[['Inheritance',['Concept',_19299966{$B}],['Concept','$VAR'("_C")]],_19299946{$T2}]],[['Inheritance','$VAR'("_A"),_19299966{$B}],['Truth_Abduction',['STV','$VAR'("_A")],['STV',_19299966{$B}],['STV','$VAR'("_C")],_19299986{$T1},_19299946{$T2}]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ '|-', 
      [ [ 'Inheritance', 
          ['Concept',A], 
          ['Concept',C]], 
        T1], 
      [ [ 'Inheritance', 
          ['Concept',B], 
          ['Concept',C]], 
        T2]], 
    [ ['Inheritance',A,B], 
      [ 'Truth_Abduction', 
        ['STV',A], 
        ['STV',B], 
        ['STV',C], T1,T2]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( '|-', 
  [2], 
  4, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ '|-', 
    [ [ 'Inheritance', 
        ['Concept',A], 
        ['Concept',C]], 
      T1], 
    [ [ 'Inheritance', 
        ['Concept',B], 
        ['Concept',C]], 
      T2]], 
  [ ['Inheritance',A,B], 
    [ 'Truth_Abduction', 
      ['STV',A], 
      ['STV',B], 
      ['STV',C], T1,T2]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('|-',[2],'Truth_Abduction',[5])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 'mc__1_2_|-'( 
   [ [ 'Inheritance', 
       ['Concept',P], 
       ['Concept',Q]], 
     R], 
   [ [ 'Inheritance', 
       ['Concept',S], 
       ['Concept',Q]], 
     T], 
   U) :- 
  V=['Inheritance',P,S] , 
  W=['STV',P] , 
  X=['STV',S] , 
  Y=['STV',Q] , 
  mc__1_5_Truth_Abduction(W,X,Y,R,T,Z) , 
  U=[V,Z]
</span> 
;;;Usage of inheritance for predicates
;;;unary arg
<span class="ansi38-255165000"> (= (|- ((Evaluation (Predicate $x) (List (Concept $C))) $T1) ((Inheritance (Concept $S) (Concept $C)) $T2))  
    
  (Evaluation 
    (Predicate $x) 
    (List (Concept $S)))
    
  (Truth_ModusPonens $T1 $T2))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['|-',[['Evaluation',['Predicate','$VAR'("_x")],['List',['Concept','$VAR'("_C")]]],_19598278{$T1}],[['Inheritance',['Concept',_19598258{$S}],['Concept','$VAR'("_C")]],_19598238{$T2}]],[['Evaluation',['Predicate','$VAR'("_x")],['List',['Concept',_19598258{$S}]]],['Truth_ModusPonens',_19598278{$T1},_19598238{$T2}]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ '|-', 
      [ [ 'Evaluation', 
          ['Predicate',_x], 
          [ 'List', 
            ['Concept',C]]], 
        T1], 
      [ [ 'Inheritance', 
          ['Concept',S], 
          ['Concept',C]], 
        T2]], 
    [ [ 'Evaluation', 
        ['Predicate',_x], 
        [ 'List', 
          ['Concept',S]]], 
      ['Truth_ModusPonens',T1,T2]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( '|-', 
  [2], 
  5, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ '|-', 
    [ [ 'Evaluation', 
        ['Predicate',_x], 
        [ 'List', 
          ['Concept',C]]], 
      T1], 
    [ [ 'Inheritance', 
        ['Concept',S], 
        ['Concept',C]], 
      T2]], 
  [ [ 'Evaluation', 
      ['Predicate',_x], 
      [ 'List', 
        ['Concept',S]]], 
    ['Truth_ModusPonens',T1,T2]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">
 transpiler_depends_on('|-',[2],'Evaluation',[1,2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('|-',[2],'Evaluation',[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('|-',[2],'Predicate',[1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('|-',[2],'List',[1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('|-',[2],'Concept',[1])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 'mc__1_2_|-'( 
   [ [ 'Evaluation', 
       ['Predicate',P], 
       [ 'List', 
         ['Concept',Q]]], 
     R], 
   [ [ 'Inheritance', 
       ['Concept',S], 
       ['Concept',Q]], 
     T], 
   U) :- 
  V=['Predicate',P] , 
  W=['Concept',S] , 
  X=['List',W] , 
  Y=['Evaluation',V,X] , 
  mc__1_2_Truth_ModusPonens(R,T,Z) , 
  U=[Y,Z]
</span> 
;;;binary arg1
<span class="ansi38-255165000"> (= (|- ((Evaluation (Predicate $x) (List (Concept $C1) (Concept $C2))) $T1) ((Inheritance (Concept $S) (Concept $C1)) $T2))  
    
  (Evaluation 
    (Predicate $x) 
    (List 
      (Concept $S) 
      (Concept $C2)))
    
  (Truth_ModusPonens $T1 $T2))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['|-',[['Evaluation',['Predicate','$VAR'("_x")],['List',['Concept','$VAR'("_C1")],['Concept',_19969718{$C2}]]],_19969698{$T1}],[['Inheritance',['Concept',_19969678{$S}],['Concept','$VAR'("_C1")]],_19969658{$T2}]],[['Evaluation',['Predicate','$VAR'("_x")],['List',['Concept',_19969678{$S}],['Concept',_19969718{$C2}]]],['Truth_ModusPonens',_19969698{$T1},_19969658{$T2}]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ '|-', 
      [ [ 'Evaluation', 
          ['Predicate',_x], 
          [ 'List', 
            ['Concept',C1], 
            ['Concept',C2]]], 
        T1], 
      [ [ 'Inheritance', 
          ['Concept',S], 
          ['Concept',C1]], 
        T2]], 
    [ [ 'Evaluation', 
        ['Predicate',_x], 
        [ 'List', 
          ['Concept',S], 
          ['Concept',C2]]], 
      ['Truth_ModusPonens',T1,T2]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( '|-', 
  [2], 
  6, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ '|-', 
    [ [ 'Evaluation', 
        ['Predicate',_x], 
        [ 'List', 
          ['Concept',C1], 
          ['Concept',C2]]], 
      T1], 
    [ [ 'Inheritance', 
        ['Concept',S], 
        ['Concept',C1]], 
      T2]], 
  [ [ 'Evaluation', 
      ['Predicate',_x], 
      [ 'List', 
        ['Concept',S], 
        ['Concept',C2]]], 
    ['Truth_ModusPonens',T1,T2]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('|-',[2],'List',[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 'mc__1_2_|-'( 
   [ [ 'Evaluation', 
       ['Predicate',P], 
       [ 'List', 
         ['Concept',Q], 
         ['Concept',R]]], 
     S], 
   [ [ 'Inheritance', 
       ['Concept',T], 
       ['Concept',Q]], 
     U], 
   V) :- 
  W=['Predicate',P] , 
  X=['Concept',T] , 
  Y=['Concept',R] , 
  Z=['List',X,Y] , 
  A1=['Evaluation',W,Z] , 
  mc__1_2_Truth_ModusPonens(S,U,B1) , 
  V=[A1,B1]
</span> 
;;;binary arg2
<span class="ansi38-255165000"> (= (|- ((Evaluation (Predicate $x) (List (Concept $C1) (Concept $C2))) $T1) ((Inheritance (Concept $S) (Concept $C2)) $T2))  
    
  (Evaluation 
    (Predicate $x) 
    (List 
      (Concept $C1) 
      (Concept $S)))
    
  (Truth_ModusPonens $T1 $T2))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['|-',[['Evaluation',['Predicate','$VAR'("_x")],['List',['Concept','$VAR'("_C1")],['Concept',_20316436{$C2}]]],_20316416{$T1}],[['Inheritance',['Concept',_20316396{$S}],['Concept',_20316436{$C2}]],_20316376{$T2}]],[['Evaluation',['Predicate','$VAR'("_x")],['List',['Concept','$VAR'("_C1")],['Concept',_20316396{$S}]]],['Truth_ModusPonens',_20316416{$T1},_20316376{$T2}]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ '|-', 
      [ [ 'Evaluation', 
          ['Predicate',_x], 
          [ 'List', 
            ['Concept',C1], 
            ['Concept',C2]]], 
        T1], 
      [ [ 'Inheritance', 
          ['Concept',S], 
          ['Concept',C2]], 
        T2]], 
    [ [ 'Evaluation', 
        ['Predicate',_x], 
        [ 'List', 
          ['Concept',C1], 
          ['Concept',S]]], 
      ['Truth_ModusPonens',T1,T2]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( '|-', 
  [2], 
  7, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ '|-', 
    [ [ 'Evaluation', 
        ['Predicate',_x], 
        [ 'List', 
          ['Concept',C1], 
          ['Concept',C2]]], 
      T1], 
    [ [ 'Inheritance', 
        ['Concept',S], 
        ['Concept',C2]], 
      T2]], 
  [ [ 'Evaluation', 
      ['Predicate',_x], 
      [ 'List', 
        ['Concept',C1], 
        ['Concept',S]]], 
    ['Truth_ModusPonens',T1,T2]])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 'mc__1_2_|-'( 
   [ [ 'Evaluation', 
       ['Predicate',P], 
       [ 'List', 
         ['Concept',Q], 
         ['Concept',R]]], 
     S], 
   [ [ 'Inheritance', 
       ['Concept',T], 
       ['Concept',R]], 
     U], 
   V) :- 
  W=['Predicate',P] , 
  X=['Concept',Q] , 
  Y=['Concept',T] , 
  Z=['List',X,Y] , 
  A1=['Evaluation',W,Z] , 
  mc__1_2_Truth_ModusPonens(S,U,B1) , 
  V=[A1,B1]
</span> 
;;;Whether evidence was just counted once
<span class="ansi38-255165000"> (= (StampDisjoint $Ev1 $Ev2)  
  (== () 
    (collapse (let* (($x (superpose $Ev1)) ($y (superpose $Ev2))) (case (== $x $y) ((True overlap)))))))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['StampDisjoint','$VAR'("_Ev1"),'$VAR'("_Ev2")],[==,[],[collapse,['let*',[[_20633286{$_x},[superpose,'$VAR'("_Ev1")]],[_20633266{$_y},[superpose,'$VAR'("_Ev2")]]],[case,[==,_20633286{$_x},_20633266{$_y}],[['True',overlap]]]]]]])
 
</span>load_hook_compiler(load,'&top',[=,['StampDisjoint',Ev1,Ev2],[==,[],[collapse,['let*',[[_x,[superpose,Ev1]],[_y,[superpose,Ev2]]],[case,[==,_x,_y],[['True',overlap]]]]]]])<span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">
 
</span> 
transpiler_clause_store(
     'StampDisjoint',
     [2],
     0,
     ['Any','Any'],
     'Any',
     [x(doeval,eager,[]),x(doeval,eager,[])],
     x(doeval,eager,[]),
     ['StampDisjoint',Ev1,Ev2],
     [==,[],[collapse,['let*',[[_x,[superpose,Ev1]],[_y,[superpose,Ev2]]],[case,[==,_x,_y],[['True',overlap]]]]]])<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">
 
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'StampDisjoint', 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('StampDisjoint',[2]) =  
  []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">transpiler_depends_on('StampDisjoint',[2],==,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('StampDisjoint',[2],collapse,[1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('StampDisjoint',[2],superpose,[1])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">mc__1_2_StampDisjoint(P,Q,R) :- 
  S =  
    ispuU( T, 
      ( mc__1_1_superpose(P,U)  ,
        V=U , 
        mc__1_1_superpose(Q,W) , 
        X=W , 
        'mc__1_2_=='(V,X,Y)*->Z=Y;Z='Empty' , 
        Z='True'*->T=overlap;A1='Empty',T=A1)) , 
  mc__1_1_collapse(S,B1) , 
  'mc__1_2_=='([],B1,R)
</span> 
;;;; Exhaustive-until-depth deriver
<span class="ansi38-255165000"> (= (Derive $beliefs $depth $maxdepth)  
  (If 
    (> $depth $maxdepth) $beliefs 
    (let $derivations 
      (collapse (let* (((Sentence $x $Ev1) (superpose $beliefs)) ((Sentence $y $Ev2) (superpose $beliefs)) ($stamp (TupleConcat $Ev1 $Ev2))) (If (StampDisjoint $Ev1 $Ev2) (case (|- $x $y) ((($T $TV) (Sentence ($T $TV) $stamp))))))) 
      (Derive 
        (TupleConcat $beliefs $derivations) 
        (+ $depth 1) $maxdepth))))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['Derive','$VAR'("_beliefs"),'$VAR'("_depth"),_21047840{$_maxdepth}],['If',[>,'$VAR'("_depth"),_21047840{$_maxdepth}],'$VAR'("_beliefs"),[let,_21047820{$_derivations},[collapse,['let*',[[['Sentence',_21047800{$_x},_21047780{$Ev1}],[superpose,'$VAR'("_beliefs")]],[['Sentence',_21047760{$_y},_21047740{$Ev2}],[superpose,'$VAR'("_beliefs")]],[_21047720{$_stamp},['TupleConcat',_21047780{$Ev1},_21047740{$Ev2}]]],['If',['StampDisjoint',_21047780{$Ev1},_21047740{$Ev2}],[case,['|-',_21047800{$_x},_21047760{$_y}],[[[_21047700{$T},_21047680{$TV}],['Sentence',[_21047700{$T},_21047680{$TV}],_21047720{$_stamp}]]]]]]],['Derive',['TupleConcat','$VAR'("_beliefs"),_21047820{$_derivations}],[+,'$VAR'("_depth"),1],_21047840{$_maxdepth}]]]])
 
</span>load_hook_compiler(
     load,
     '&top',
     [ =,
       ['Derive',_beliefs,_depth,_maxdepth],
       [ 'If',
	 [>,_depth,_maxdepth],
	 _beliefs,
	 [ let,
	   _derivations,
	   [ collapse,
	     [ 'let*',
	       [[['Sentence',_x,Ev1],[superpose,_beliefs]],[['Sentence',_y,Ev2],[superpose,_beliefs]],[_stamp,['TupleConcat',Ev1,Ev2]]],
	       ['If',['StampDisjoint',Ev1,Ev2],[case,['|-',_x,_y],[[[T,TV],['Sentence',[T,TV],_stamp]]]]]
	     ]
	   ],
	   ['Derive',['TupleConcat',_beliefs,_derivations],[+,_depth,1],_maxdepth]
	 ]
       ]
     ])<span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 
</span> 
transpiler_clause_store(
     'Derive',
     [3],
     0,
     ['Any','Any','Any'],
     'Any',
     [x(doeval,eager,[]),x(doeval,eager,[]),x(doeval,eager,[])],
     x(doeval,eager,[]),
     ['Derive',_beliefs,_depth,_maxdepth],
     [ 'If',
       [>,_depth,_maxdepth],
       _beliefs,
       [ let,
	 _derivations,
	 [ collapse,
	   [ 'let*',
	     [[['Sentence',_x,Ev1],[superpose,_beliefs]],[['Sentence',_y,Ev2],[superpose,_beliefs]],[_stamp,['TupleConcat',Ev1,Ev2]]],
	     ['If',['StampDisjoint',Ev1,Ev2],[case,['|-',_x,_y],[[[T,TV],['Sentence',[T,TV],_stamp]]]]]
	   ]
	 ],
	 ['Derive',['TupleConcat',_beliefs,_derivations],[+,_depth,1],_maxdepth]
       ]
     ])<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'Derive', 
  [3], todo,todo, 
  [ x(doeval,eager,[]), x(doeval,eager,[]),x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('Derive',[3]) =  
  []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Derive',[3],'If',[3])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Derive',[3],>,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Derive',[3],collapse,[1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Derive',[3],superpose,[1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Derive',[3],'TupleConcat',[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Derive',[3],'If',[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Derive',[3],'StampDisjoint',[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Derive',[3],'|-',[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Derive',[3],'Sentence',[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Derive',[3],+,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 mc__1_3_Derive(P,Q,R,S) :- 
  'mc__1_2_>'(Q,R,T) , 
  U=ispu(P) , 
  V =  
    ispeEnNC( W, 
      mc__1_3_Derive(X,Y,R,W), 
      Z, 
      Z=['Derive',X,Y,R], 
      ( A1 =  
          ispeEnNC( B1, 
            mc__1_2_If(C1,D1,E1),as_p1_exec(E1,B1), 
            F1, 
            G1=['If',C1,D1],as_p1_expr(G1,F1), 
            ( mc__1_1_superpose(P,H1)  ,
              ['Sentence',I1,J1]=H1 , 
              mc__1_1_superpose(P,K1) , 
              ['Sentence',L1,M1]=K1 , 
              mc__1_2_TupleConcat(J1,M1,N1) , 
              O1=N1 , 
              mc__1_2_StampDisjoint(J1,M1,C1) , 
              D1 =  
                ispeEnNC( P1, 
                    ((
                     (  ((
                         (Q1=R1)*->
                         (( transpiler_apply( mc__1_1_, 
                              S1, 
                              [S1,T1], 
                              U1, 
                              [T1], 
                              [T1], 
                              [x(noeval,eager,[])], 
                              [true], 
                              [true])  ,
                            V1=['Sentence',U1,O1] , 
                            P1=V1))  )));
                     (W1='Empty',P1=W1)  )), 
                  P1, 
                    ((
                     (  ((
                         (Q1=R1)*->
                         (( X1=[S1,T1]  ,
                            Y1=['Sentence',X1,O1] , 
                            P1=Y1))  )));
                     (Z1='Empty',P1=Z1)  )), 
                    ((
                     ('mc__1_2_|-'(I1,L1,A2)*->Q1=A2;Q1='Empty'),
                     (transpiler_apply( mc__1_1_, 
                        S1, 
                        [S1,T1], 
                        R1, 
                        [T1], 
                        [T1], 
                        [x(noeval,eager,[])], 
                        [true], 
                        [true]))  )))))  ,
        mc__1_1_collapse(A1,B2) , 
        C2=B2 , 
        mc__1_2_TupleConcat(P,C2,X) , 
        'mc__1_2_+'(Q,1,Y))) , 
  mc__1_3_If(T,U,V,D2) , 
  as_p1_exec(D2,S)
</span> 
;;;retrieve the best candidate
<span class="ansi38-255165000"> (= (BestCandidate $EvaluateCandidateFunction $BestCandidate $tuple)  
  (If 
    (== $tuple ()) $BestCandidate 
    (let* 
      ( ($head (car-atom $tuple)) ($tail (cdr-atom $tuple))) 
      (If 
        (> 
          ($EvaluateCandidateFunction $head) 
          ($EvaluateCandidateFunction $BestCandidate)) 
        (BestCandidate $EvaluateCandidateFunction $head $tail) 
        (BestCandidate $EvaluateCandidateFunction $BestCandidate $tail)))))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['BestCandidate','$VAR'("_EvaluateCandidateFunction"),'$VAR'("_BestCandidate"),_21724920{$_tuple}],['If',[==,_21724920{$_tuple},[]],'$VAR'("_BestCandidate"),['let*',[[_21724900{$_head},['car-atom',_21724920{$_tuple}]],[_21724880{$_tail},['cdr-atom',_21724920{$_tuple}]]],['If',[>,['$VAR'("_EvaluateCandidateFunction"),_21724900{$_head}],['$VAR'("_EvaluateCandidateFunction"),'$VAR'("_BestCandidate")]],['BestCandidate','$VAR'("_EvaluateCandidateFunction"),_21724900{$_head},_21724880{$_tail}],['BestCandidate','$VAR'("_EvaluateCandidateFunction"),'$VAR'("_BestCandidate"),_21724880{$_tail}]]]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ 'BestCandidate',      EvaluateCandidateFunction, BestCandidate, _tuple], 
    [ 'If', 
      [==,_tuple,[]], 
      BestCandidate, 
      [ 'let*', 
        [ [ _head, 
            ['car-atom',_tuple]], 
          [ _tail, 
            ['cdr-atom',_tuple]]], 
        [ 'If', 
          [ >, 
            [EvaluateCandidateFunction,_head], 
            [EvaluateCandidateFunction,BestCandidate]], 
          [ 'BestCandidate',            EvaluateCandidateFunction, _head, _tail], 
          [ 'BestCandidate',            EvaluateCandidateFunction, BestCandidate, _tail]]]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">
 transpiler_clause_store( 'BestCandidate', 
  [3], 
  0, 
  ['Any','Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), x(doeval,eager,[]),x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ 'BestCandidate',    EvaluateCandidateFunction, BestCandidate, _tuple], 
  [ 'If', 
    [==,_tuple,[]], 
    BestCandidate, 
    [ 'let*', 
      [ [ _head, 
          ['car-atom',_tuple]], 
        [ _tail, 
          ['cdr-atom',_tuple]]], 
      [ 'If', 
        [ >, 
          [EvaluateCandidateFunction,_head], 
          [EvaluateCandidateFunction,BestCandidate]], 
        [ 'BestCandidate', EvaluateCandidateFunction,_head, 
          _tail], 
        [ 'BestCandidate',          EvaluateCandidateFunction, BestCandidate, _tail]]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'BestCandidate', 
  [3], todo,todo, 
  [ x(doeval,eager,[]), x(doeval,eager,[]),x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('BestCandidate',[3]) =  
  []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('BestCandidate',[3],'If',[3])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">transpiler_depends_on('BestCandidate',[3],==,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('BestCandidate',[3],'car-atom',[1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('BestCandidate',[3],'cdr-atom',[1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('BestCandidate',[3],>,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 mc__1_3_BestCandidate(P,Q,R,S) :- 
  'mc__1_2_=='(R,[],T) , 
  U=ispu(Q) , 
  V =  
    ispeEnNC( W, 
      mc__1_3_If(X,Y,Z,A1),as_p1_exec(A1,W), 
      B1, 
        ((
         (C1=['If',X,Y,Z]),
         (as_p1_expr(C1,B1))  )), 
      ( 'mc__1_1_car-atom'(R,D1)  ,
        E1=D1 , 
        'mc__1_1_cdr-atom'(R,F1) , 
        G1=F1 , 
        transpiler_apply( mc__1_1_, 
          P, 
          [P,E1], 
          H1, 
          [E1], 
          [E1], 
          [x(noeval,eager,[])], 
          [true], 
          [true]) , 
        transpiler_apply( mc__1_1_, 
          P, 
          [P,Q], 
          I1, 
          [Q], 
          [Q], 
          [x(doeval,eager,[])], 
          [true], 
          [true]) , 
        'mc__1_2_>'(H1,I1,X) , 
        Y =  
          ispeEnN( J1, 
            mc__1_3_BestCandidate(P,E1,G1,J1), 
            K1, 
            K1=['BestCandidate',P,E1,G1]) , 
        Z =  
          ispeEnN( L1, 
            mc__1_3_BestCandidate(P,Q,G1,L1), 
            M1, 
            M1=['BestCandidate',P,Q,G1]))) , 
  mc__1_3_If(T,U,V,N1) , 
  as_p1_exec(N1,S)
</span> 
;;;candidate evaluation based on confidence
<span class="ansi38-255165000"> (= (ConfidenceRank ((stv $f $c) $Ev))  $c)
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['ConfidenceRank',[[stv,'$VAR'("_f"),'$VAR'("_c")],_22249248{$Ev}]],'$VAR'("_c")])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ 'ConfidenceRank', 
      [ [stv,_f,_c], 
        Ev]], 
    _c])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'ConfidenceRank', 
  [1], 
  0, 
  ['Any'], 
  'Any', 
  [x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ 'ConfidenceRank', 
    [ [stv,_f,_c], 
      Ev]], 
  _c)
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">transpiler_predicate_store(user,'ConfidenceRank',[1],todo,todo,[x(doeval,eager,[])],x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('ConfidenceRank',[1]) =  
  []
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 mc__1_1_ConfidenceRank([[stv,P,Q],R],Q) :-  
  true
</span> 
<span class="ansi38-255165000"> (= (ConfidenceRank ())  0)
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['ConfidenceRank',[]],0])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler(load,'&top',[=,['ConfidenceRank',[]],0])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'ConfidenceRank', 
  [1], 
  1, 
  ['Any'], 
  'Any', 
  [x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  ['ConfidenceRank',[]], 
  0)
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">mc__1_1_ConfidenceRank([],0):-true
</span> 
;;;pose a question of a certain term to the system on some knowledge base
<span class="ansi38-255165000"> (= (Question $kb $term $steps)  
  (BestCandidate ConfidenceRank () 
    (collapse (let $x (Derive $kb 1 $steps) (case (superpose $x) (((Sentence ($T $TV) $Ev) (case (== $T $term) ((True ($TV $Ev)))))))))))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['Question','$VAR'("_kb"),'$VAR'("_term"),_22481968{$_steps}],['BestCandidate','ConfidenceRank',[],[collapse,[let,_22481948{$_x},['Derive','$VAR'("_kb"),1,_22481968{$_steps}],[case,[superpose,_22481948{$_x}],[[['Sentence',[_22481928{$T},_22481908{$TV}],_22481888{$Ev}],[case,[==,_22481928{$T},'$VAR'("_term")],[['True',[_22481908{$TV},_22481888{$Ev}]]]]]]]]]]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    ['Question',_kb,_term,_steps], 
    [ 'BestCandidate', 
      'ConfidenceRank', 
      [], 
      [ collapse, 
        [ let, 
          _x, 
          ['Derive',_kb,1,_steps], 
          [ case, 
            [superpose,_x], 
            [ [ [ 'Sentence', 
                  [T,TV], 
                  Ev], 
                [ case, 
                  [==,T,_term], 
                  [ [ 'True', 
                      [TV,Ev]]]]]]]]]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">
 transpiler_clause_store( 'Question', 
  [3], 
  0, 
  ['Any','Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), x(doeval,eager,[]),x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  ['Question',_kb,_term,_steps], 
  [ 'BestCandidate', 
    'ConfidenceRank', 
    [], 
    [ collapse, 
      [ let, 
        _x, 
        ['Derive',_kb,1,_steps], 
        [ case, 
          [superpose,_x], 
          [ [ [ 'Sentence', 
                [T,TV], 
                Ev], 
              [ case, 
                [==,T,_term], 
                [ [ 'True', 
                    [TV,Ev]]]]]]]]]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'Question', 
  [3], todo,todo, 
  [ x(doeval,eager,[]), x(doeval,eager,[]),x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('Question',[3]) =  
  []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Question',[3],'BestCandidate',[3])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Question',[3],collapse,[1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Question',[3],'Derive',[3])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Question',[3],superpose,[1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('Question',[3],'Sentence',[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">transpiler_depends_on('Question',[3],==,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 mc__1_3_Question(P,Q,R,S) :- 
  T =  
    ispeEnNC( U, 
        ((
         (  ((
             (V=W)*->
             (( 'mc__1_2_=='(X,Q,Y)*->Z=Y;Z='Empty'  ,
                  ((
                   (  ((
                       (Z='True')*->
                       (  ((
                           (transpiler_apply( mc__1_1_, 
                              A1, 
                              [A1,B1], 
                              C1, 
                              [B1], 
                              [B1], 
                              [x(noeval,eager,[])], 
                              [true], 
                              [true])),
                           (D1=C1)  )))  )));
                   (E1='Empty',D1=E1)  )) , 
                U=D1))  )));
         (F1='Empty',U=F1)  )), 
      U, 
        ((
         (  ((
             (V=W)*->
             (( 'mc__1_2_=='(X,Q,Y)*->Z=Y;Z='Empty'  ,
                  ((
                   (  ((
                       (Z='True')*->
                       (G1=[A1,B1],D1=G1)  )));
                   (H1='Empty',D1=H1)  )) , 
                U=D1))  )));
         (I1='Empty',U=I1)  )), 
      ( mc__1_3_Derive(P,1,R,J1)  ,
        K1=J1 , 
        mc__1_1_superpose(K1,L1)*->V=L1;V='Empty' , 
        transpiler_apply( mc__1_1_, 
          X, 
          [X,A1], 
          M1, 
          [A1], 
          [A1], 
          [x(noeval,eager,[])], 
          [true], 
          [true]) , 
        W=['Sentence',M1,B1])) , 
  mc__1_1_collapse(T,N1) , 
  mc__1_3_BestCandidate('ConfidenceRank',[],N1,S)
</span> 
<span class="ansi38-255165000"> (= (STV (Concept Anna))  
  (stv 0.1667 1))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['STV',['Concept','Anna']],[stv,0.1667,1]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ 'STV', 
      ['Concept','Anna']], 
    [stv,0.1667,1]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'STV', 
  [1], 
  0, 
  ['Any'], 
  'Any', 
  [x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ 'STV', 
    ['Concept','Anna']], 
  [stv,0.1667,1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">transpiler_predicate_store(user,'STV',[1],todo,todo,[x(doeval,eager,[])],x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('STV',[1]) =  
  ['|-'/[2]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( '|-', 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ '|-', 
    [B,C], 
    [B,D]], 
  [ B, 
    ['Truth_Revision',C,D]])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 'mc__1_2_|-'([B,C],[B,D],P) :- 
  mc__1_2_Truth_Revision(C,D,Q) , 
  transpiler_apply( mc__1_1_, 
    B, 
    [B,Q], 
    P, 
    [Q], 
    [R], 
    [x(doeval,eager,[])], 
    [mc__1_2_Truth_Revision(C,D,Q)], 
    [R=['Truth_Revision',C,D]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( '|-', 
  [2], 
  1, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ '|-', 
    [E,F], 
    [ ['Implication',E,G], 
      H]], 
  [ G, 
    ['Truth_ModusPonens',F,H]])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 'mc__1_2_|-'( [E,F], 
  [ ['Implication',E,G], 
    H], 
  P) :- 
  mc__1_2_Truth_ModusPonens(F,H,Q) , 
  transpiler_apply( mc__1_1_, 
    G, 
    [G,Q], 
    P, 
    [Q], 
    [R], 
    [x(doeval,eager,[])], 
    [mc__1_2_Truth_ModusPonens(F,H,Q)], 
    [R=['Truth_ModusPonens',F,H]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( '|-', 
  [2], 
  2, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ '|-', 
    [ [ 'Inheritance', 
        ['Concept',I], 
        ['Concept',J]], 
      K], 
    [ [ 'Inheritance', 
        ['Concept',J], 
        ['Concept',L]], 
      M]], 
  [ ['Inheritance',I,L], 
    [ 'Truth_Deduction', 
      ['STV',I], 
      ['STV',J], 
      ['STV',L], K,M]])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 'mc__1_2_|-'( 
   [ [ 'Inheritance', 
       ['Concept',I], 
       ['Concept',J]], 
     K], 
   [ [ 'Inheritance', 
       ['Concept',J], 
       ['Concept',L]], 
     M], 
   P) :- 
  Q=['Inheritance',I,L] , 
  mc__1_1_STV(I,R) , 
  mc__1_1_STV(J,S) , 
  mc__1_1_STV(L,T) , 
  mc__1_5_Truth_Deduction(R,S,T,K,M,U) , 
  P=[Q,U]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( '|-', 
  [2], 
  3, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ '|-', 
    [ [ 'Inheritance', 
        ['Concept',N], 
        ['Concept',O]], 
      P], 
    [ [ 'Inheritance', 
        ['Concept',N], 
        ['Concept',Q]], 
      R]], 
  [ ['Inheritance',O,Q], 
    [ 'Truth_Induction', 
      ['STV',O], 
      ['STV',Q], 
      ['STV',N], P,R]])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 'mc__1_2_|-'( 
   [ [ 'Inheritance', 
       ['Concept',N], 
       ['Concept',O]], 
     P], 
   [ [ 'Inheritance', 
       ['Concept',N], 
       ['Concept',Q]], 
     R], 
   P) :- 
  Q=['Inheritance',O,Q] , 
  mc__1_1_STV(O,R) , 
  mc__1_1_STV(Q,S) , 
  mc__1_1_STV(N,T) , 
  mc__1_5_Truth_Induction(R,S,T,P,R,U) , 
  P=[Q,U]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( '|-', 
  [2], 
  4, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ '|-', 
    [ [ 'Inheritance', 
        ['Concept',S], 
        ['Concept',T]], 
      U], 
    [ [ 'Inheritance', 
        ['Concept',V], 
        ['Concept',T]], 
      W]], 
  [ ['Inheritance',S,V], 
    [ 'Truth_Abduction', 
      ['STV',S], 
      ['STV',V], 
      ['STV',T], U,W]])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 'mc__1_2_|-'( 
   [ [ 'Inheritance', 
       ['Concept',S], 
       ['Concept',T]], 
     U], 
   [ [ 'Inheritance', 
       ['Concept',V], 
       ['Concept',T]], 
     W], 
   P) :- 
  Q=['Inheritance',S,V] , 
  mc__1_1_STV(S,R) , 
  mc__1_1_STV(V,S) , 
  mc__1_1_STV(T,T) , 
  mc__1_5_Truth_Abduction(R,S,T,U,W,U) , 
  P=[Q,U]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( '|-', 
  [2], 
  5, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ '|-', 
    [ [ 'Evaluation', 
        ['Predicate',X], 
        [ 'List', 
          ['Concept',Y]]], 
      Z], 
    [ [ 'Inheritance', 
        ['Concept',A1], 
        ['Concept',Y]], 
      B1]], 
  [ [ 'Evaluation', 
      ['Predicate',X], 
      [ 'List', 
        ['Concept',A1]]], 
    ['Truth_ModusPonens',Z,B1]])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 'mc__1_2_|-'( 
   [ [ 'Evaluation', 
       ['Predicate',X], 
       [ 'List', 
         ['Concept',Y]]], 
     Z], 
   [ [ 'Inheritance', 
       ['Concept',A1], 
       ['Concept',Y]], 
     B1], 
   P) :- 
  Q=['Predicate',X] , 
  R=['Concept',A1] , 
  S=['List',R] , 
  T=['Evaluation',Q,S] , 
  mc__1_2_Truth_ModusPonens(Z,B1,U) , 
  P=[T,U]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( '|-', 
  [2], 
  6, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ '|-', 
    [ [ 'Evaluation', 
        ['Predicate',C1], 
        [ 'List', 
          ['Concept',D1], 
          ['Concept',E1]]], 
      F1], 
    [ [ 'Inheritance', 
        ['Concept',G1], 
        ['Concept',D1]], 
      H1]], 
  [ [ 'Evaluation', 
      ['Predicate',C1], 
      [ 'List', 
        ['Concept',G1], 
        ['Concept',E1]]], 
    ['Truth_ModusPonens',F1,H1]])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 'mc__1_2_|-'( 
   [ [ 'Evaluation', 
       ['Predicate',C1], 
       [ 'List', 
         ['Concept',D1], 
         ['Concept',E1]]], 
     F1], 
   [ [ 'Inheritance', 
       ['Concept',G1], 
       ['Concept',D1]], 
     H1], 
   P) :- 
  Q=['Predicate',C1] , 
  R=['Concept',G1] , 
  S=['Concept',E1] , 
  T=['List',R,S] , 
  U=['Evaluation',Q,T] , 
  mc__1_2_Truth_ModusPonens(F1,H1,V) , 
  P=[U,V]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( '|-', 
  [2], 
  7, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ '|-', 
    [ [ 'Evaluation', 
        ['Predicate',I1], 
        [ 'List', 
          ['Concept',J1], 
          ['Concept',K1]]], 
      L1], 
    [ [ 'Inheritance', 
        ['Concept',M1], 
        ['Concept',K1]], 
      N1]], 
  [ [ 'Evaluation', 
      ['Predicate',I1], 
      [ 'List', 
        ['Concept',J1], 
        ['Concept',M1]]], 
    ['Truth_ModusPonens',L1,N1]])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 'mc__1_2_|-'( 
   [ [ 'Evaluation', 
       ['Predicate',I1], 
       [ 'List', 
         ['Concept',J1], 
         ['Concept',K1]]], 
     L1], 
   [ [ 'Inheritance', 
       ['Concept',M1], 
       ['Concept',K1]], 
     N1], 
   P) :- 
  Q=['Predicate',I1] , 
  R=['Concept',J1] , 
  S=['Concept',M1] , 
  T=['List',R,S] , 
  U=['Evaluation',Q,T] , 
  mc__1_2_Truth_ModusPonens(L1,N1,V) , 
  P=[U,V]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('STV',[1],stv,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 mc__1_1_STV(['Concept','Anna'],P) :-  
  P=[stv,0.1667,1]
</span> 
<span class="ansi38-255165000"> (= (STV (Concept Bob))  
  (stv 0.1667 1))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['STV',['Concept','Bob']],[stv,0.1667,1]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ 'STV', 
      ['Concept','Bob']], 
    [stv,0.1667,1]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'STV', 
  [1], 
  1, 
  ['Any'], 
  'Any', 
  [x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ 'STV', 
    ['Concept','Bob']], 
  [stv,0.1667,1])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 mc__1_1_STV(['Concept','Bob'],P) :-  
  P=[stv,0.1667,1]
</span> 
<span class="ansi38-255165000"> (= (STV (Concept Edward))  
  (stv 0.1667 1))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['STV',['Concept','Edward']],[stv,0.1667,1]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ 'STV', 
      ['Concept','Edward']], 
    [stv,0.1667,1]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'STV', 
  [1], 
  2, 
  ['Any'], 
  'Any', 
  [x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ 'STV', 
    ['Concept','Edward']], 
  [stv,0.1667,1])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 mc__1_1_STV(['Concept','Edward'],P) :-  
  P=[stv,0.1667,1]
</span> 
<span class="ansi38-255165000"> (= (STV (Concept Frank))  
  (stv 0.1667 1))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['STV',['Concept','Frank']],[stv,0.1667,1]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ 'STV', 
      ['Concept','Frank']], 
    [stv,0.1667,1]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'STV', 
  [1], 
  3, 
  ['Any'], 
  'Any', 
  [x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ 'STV', 
    ['Concept','Frank']], 
  [stv,0.1667,1])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 mc__1_1_STV(['Concept','Frank'],P) :-  
  P=[stv,0.1667,1]
</span> 
<span class="ansi38-255165000"> (= (STV (Concept Gary))  
  (stv 0.1667 1))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['STV',['Concept','Gary']],[stv,0.1667,1]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ 'STV', 
      ['Concept','Gary']], 
    [stv,0.1667,1]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'STV', 
  [1], 
  4, 
  ['Any'], 
  'Any', 
  [x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ 'STV', 
    ['Concept','Gary']], 
  [stv,0.1667,1])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 mc__1_1_STV(['Concept','Gary'],P) :-  
  P=[stv,0.1667,1]
</span> 
<span class="ansi38-255165000"> (= (STV (Concept Helen))  
  (stv 0.1667 1))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['STV',['Concept','Helen']],[stv,0.1667,1]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    [ 'STV', 
      ['Concept','Helen']], 
    [stv,0.1667,1]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'STV', 
  [1], 
  5, 
  ['Any'], 
  'Any', 
  [x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ 'STV', 
    ['Concept','Helen']], 
  [stv,0.1667,1])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 mc__1_1_STV(['Concept','Helen'],P) :-  
  P=[stv,0.1667,1]
</span> 
<span class="ansi38-255165000"> (= (DoQuestion)  
  (Question 
    ( (Sentence 
        ( (Implication 
            (Evaluation 
              (Predicate friend) 
              (List $1 $2)) 
            (Implication 
              (Evaluation 
                (Predicate smokes) 
                (List $1)) 
              (Evaluation 
                (Predicate smokes) 
                (List $2)))) (stv 0.4 0.9)) 
        (1)) 
      (Sentence 
        ( (Implication 
            (Evaluation 
              (Predicate smokes) 
              (List $1)) 
            (Evaluation 
              (Predicate cancerous) 
              (List $1))) (stv 0.6 0.9)) 
        (2)) 
      (Sentence 
        ( (Evaluation 
            (Predicate friend) 
            (List 
              (Concept Anna) 
              (Concept Bob))) (stv 1.0 0.9)) 
        (3)) 
      (Sentence 
        ( (Evaluation 
            (Predicate friend) 
            (List 
              (Concept Anna) 
              (Concept Edward))) (stv 1.0 0.9)) 
        (4)) 
      (Sentence 
        ( (Evaluation 
            (Predicate friend) 
            (List 
              (Concept Anna) 
              (Concept Frank))) (stv 1.0 0.9)) 
        (5)) 
      (Sentence 
        ( (Evaluation 
            (Predicate friend) 
            (List 
              (Concept Edward) 
              (Concept Frank))) (stv 1.0 0.9)) 
        (6)) 
      (Sentence 
        ( (Evaluation 
            (Predicate friend) 
            (List 
              (Concept Gary) 
              (Concept Helen))) (stv 1.0 0.9)) 
        (7)) 
      (Sentence 
        ( (Evaluation 
            (Predicate friend) 
            (List 
              (Concept Gary) 
              (Concept Frank))) (stv 0.0 0.9)) 
        (8)) 
      (Sentence 
        ( (Evaluation 
            (Predicate smokes) 
            (List (Concept Anna))) (stv 1.0 0.9)) 
        (9))) 
    (Evaluation 
      (Predicate cancerous) 
      (List (Concept Edward))) 3))
 
</span><span class="ansi38-079079015">; Action: load=metta_atom_asserted('&top',[=,['DoQuestion'],['Question',[['Sentence',[['Implication',['Evaluation',['Predicate',friend],['List','$VAR'("_1"),'$VAR'("_2")]],['Implication',['Evaluation',['Predicate',smokes],['List','$VAR'("_1")]],['Evaluation',['Predicate',smokes],['List','$VAR'("_2")]]]],[stv,0.4,0.9]],[1]],['Sentence',[['Implication',['Evaluation',['Predicate',smokes],['List','$VAR'("_1")]],['Evaluation',['Predicate',cancerous],['List','$VAR'("_1")]]],[stv,0.6,0.9]],[2]],['Sentence',[['Evaluation',['Predicate',friend],['List',['Concept','Anna'],['Concept','Bob']]],[stv,1.0,0.9]],[3]],['Sentence',[['Evaluation',['Predicate',friend],['List',['Concept','Anna'],['Concept','Edward']]],[stv,1.0,0.9]],[4]],['Sentence',[['Evaluation',['Predicate',friend],['List',['Concept','Anna'],['Concept','Frank']]],[stv,1.0,0.9]],[5]],['Sentence',[['Evaluation',['Predicate',friend],['List',['Concept','Edward'],['Concept','Frank']]],[stv,1.0,0.9]],[6]],['Sentence',[['Evaluation',['Predicate',friend],['List',['Concept','Gary'],['Concept','Helen']]],[stv,1.0,0.9]],[7]],['Sentence',[['Evaluation',['Predicate',friend],['List',['Concept','Gary'],['Concept','Frank']]],[stv,0.0,0.9]],[8]],['Sentence',[['Evaluation',['Predicate',smokes],['List',['Concept','Anna']]],[stv,1.0,0.9]],[9]]],['Evaluation',['Predicate',cancerous],['List',['Concept','Edward']]],3]])
 
</span><span class="ansi2"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35"></span><span class="ansi2 ansi35">assert_hooks</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">
 load_hook_compiler( load, 
  '&top', 
  [ =, 
    ['DoQuestion'], 
    [ 'Question', 
      [ [ 'Sentence', 
          [ [ 'Implication', 
              [ 'Evaluation', 
                ['Predicate',friend], 
                ['List',_1,_2]], 
              [ 'Implication', 
                [ 'Evaluation', 
                  ['Predicate',smokes], 
                  ['List',_1]], 
                [ 'Evaluation', 
                  ['Predicate',smokes], 
                  ['List',_2]]]], 
            [stv,0.4,0.9]], 
          [1]], 
        [ 'Sentence', 
          [ [ 'Implication', 
              [ 'Evaluation', 
                ['Predicate',smokes], 
                ['List',_1]], 
              [ 'Evaluation', 
                ['Predicate',cancerous], 
                ['List',_1]]], 
            [stv,0.6,0.9]], 
          [2]], 
        [ 'Sentence', 
          [ [ 'Evaluation', 
              ['Predicate',friend], 
              [ 'List', 
                ['Concept','Anna'], 
                ['Concept','Bob']]], 
            [stv,1.0,0.9]], 
          [3]], 
        [ 'Sentence', 
          [ [ 'Evaluation', 
              ['Predicate',friend], 
              [ 'List', 
                ['Concept','Anna'], 
                ['Concept','Edward']]], 
            [stv,1.0,0.9]], 
          [4]], 
        [ 'Sentence', 
          [ [ 'Evaluation', 
              ['Predicate',friend], 
              [ 'List', 
                ['Concept','Anna'], 
                ['Concept','Frank']]], 
            [stv,1.0,0.9]], 
          [5]], 
        [ 'Sentence', 
          [ [ 'Evaluation', 
              ['Predicate',friend], 
              [ 'List', 
                ['Concept','Edward'], 
                ['Concept','Frank']]], 
            [stv,1.0,0.9]], 
          [6]], 
        [ 'Sentence', 
          [ [ 'Evaluation', 
              ['Predicate',friend], 
              [ 'List', 
                ['Concept','Gary'], 
                ['Concept','Helen']]], 
            [stv,1.0,0.9]], 
          [7]], 
        [ 'Sentence', 
          [ [ 'Evaluation', 
              ['Predicate',friend], 
              [ 'List', 
                ['Concept','Gary'], 
                ['Concept','Frank']]], 
            [stv,0.0,0.9]], 
          [8]], 
        [ 'Sentence', 
          [ [ 'Evaluation', 
              ['Predicate',smokes], 
              [ 'List', 
                ['Concept','Anna']]], 
            [stv,1.0,0.9]], 
          [9]]], 
      [ 'Evaluation', 
        ['Predicate',cancerous], 
        [ 'List', 
          ['Concept','Edward']]], 
      3]])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94"></span><span class="ansi1 ansi94">
 transpiler_clause_store( 'DoQuestion', 
  [0], 
  0, 
  [], 
  'Any', 
  [], 
  x(doeval,eager,[]), 
  ['DoQuestion'], 
  [ 'Question', 
    [ [ 'Sentence', 
        [ [ 'Implication', 
            [ 'Evaluation', 
              ['Predicate',friend], 
              ['List',_1,_2]], 
            [ 'Implication', 
              [ 'Evaluation', 
                ['Predicate',smokes], 
                ['List',_1]], 
              [ 'Evaluation', 
                ['Predicate',smokes], 
                ['List',_2]]]], 
          [stv,0.4,0.9]], 
        [1]], 
      [ 'Sentence', 
        [ [ 'Implication', 
            [ 'Evaluation', 
              ['Predicate',smokes], 
              ['List',_1]], 
            [ 'Evaluation', 
              ['Predicate',cancerous], 
              ['List',_1]]], 
          [stv,0.6,0.9]], 
        [2]], 
      [ 'Sentence', 
        [ [ 'Evaluation', 
            ['Predicate',friend], 
            [ 'List', 
              ['Concept','Anna'], 
              ['Concept','Bob']]], 
          [stv,1.0,0.9]], 
        [3]], 
      [ 'Sentence', 
        [ [ 'Evaluation', 
            ['Predicate',friend], 
            [ 'List', 
              ['Concept','Anna'], 
              ['Concept','Edward']]], 
          [stv,1.0,0.9]], 
        [4]], 
      [ 'Sentence', 
        [ [ 'Evaluation', 
            ['Predicate',friend], 
            [ 'List', 
              ['Concept','Anna'], 
              ['Concept','Frank']]], 
          [stv,1.0,0.9]], 
        [5]], 
      [ 'Sentence', 
        [ [ 'Evaluation', 
            ['Predicate',friend], 
            [ 'List', 
              ['Concept','Edward'], 
              ['Concept','Frank']]], 
          [stv,1.0,0.9]], 
        [6]], 
      [ 'Sentence', 
        [ [ 'Evaluation', 
            ['Predicate',friend], 
            [ 'List', 
              ['Concept','Gary'], 
              ['Concept','Helen']]], 
          [stv,1.0,0.9]], 
        [7]], 
      [ 'Sentence', 
        [ [ 'Evaluation', 
            ['Predicate',friend], 
            [ 'List', 
              ['Concept','Gary'], 
              ['Concept','Frank']]], 
          [stv,0.0,0.9]], 
        [8]], 
      [ 'Sentence', 
        [ [ 'Evaluation', 
            ['Predicate',smokes], 
            [ 'List', 
              ['Concept','Anna']]], 
          [stv,1.0,0.9]], 
        [9]]], 
    [ 'Evaluation', 
      ['Predicate',cancerous], 
      [ 'List', 
        ['Concept','Edward']]], 
    3])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">transpiler_predicate_store(user,'DoQuestion',[0],todo,todo,[],x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi2"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93"></span><span class="ansi2 ansi93">recompile_from_depends</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">fa('DoQuestion',[0]) =  
  []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('DoQuestion',[0],'Question',[3])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">
 transpiler_depends_on('DoQuestion',[0],'Sentence',[8,2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('DoQuestion',[0],'Sentence',[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">
 transpiler_depends_on('DoQuestion',[0],'Implication',[1,2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('DoQuestion',[0],'Implication',[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('DoQuestion',[0],'Evaluation',[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('DoQuestion',[0],'Predicate',[1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('DoQuestion',[0],'List',[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('DoQuestion',[0],'List',[1])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('DoQuestion',[0],stv,[2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">
 transpiler_depends_on('DoQuestion',[0],'Evaluation',[1,2])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96"></span><span class="ansi1 ansi96">compiler_assertz</span> - <span class="ansi5"></span><span class="ansi5 ansi31"></span><span class="ansi5 ansi31 ansi100"></span>: <span class="ansi1"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92"></span><span class="ansi1 ansi92">transpiler_depends_on('DoQuestion',[0],'Concept',[1])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">
 mc__1_0_DoQuestion(P) :- 
  Q=['Predicate',friend] , 
  R=['List',S,T] , 
  U=['Evaluation',Q,R] , 
  V=['Predicate',smokes] , 
  W=['List',S] , 
  X=['Evaluation',V,W] , 
  Y=['Predicate',smokes] , 
  Z=['List',T] , 
  A1=['Evaluation',Y,Z] , 
  B1=['Implication',X,A1] , 
  C1=['Implication',U,B1] , 
  D1=[stv,0.4,0.9] , 
  E1=[C1,D1] , 
  F1=[1] , 
  G1=['Sentence',E1,F1] , 
  H1=['Predicate',smokes] , 
  I1=['List',S] , 
  J1=['Evaluation',H1,I1] , 
  K1=['Predicate',cancerous] , 
  L1=['List',S] , 
  M1=['Evaluation',K1,L1] , 
  N1=['Implication',J1,M1] , 
  O1=[stv,0.6,0.9] , 
  P1=[N1,O1] , 
  Q1=[2] , 
  R1=['Sentence',P1,Q1] , 
  S1=['Predicate',friend] , 
  T1=['Concept','Anna'] , 
  U1=['Concept','Bob'] , 
  V1=['List',T1,U1] , 
  W1=['Evaluation',S1,V1] , 
  X1=[stv,1.0,0.9] , 
  Y1=[W1,X1] , 
  Z1=[3] , 
  A2=['Sentence',Y1,Z1] , 
  B2=['Predicate',friend] , 
  C2=['Concept','Anna'] , 
  D2=['Concept','Edward'] , 
  E2=['List',C2,D2] , 
  F2=['Evaluation',B2,E2] , 
  G2=[stv,1.0,0.9] , 
  H2=[F2,G2] , 
  I2=[4] , 
  J2=['Sentence',H2,I2] , 
  K2=['Predicate',friend] , 
  L2=['Concept','Anna'] , 
  M2=['Concept','Frank'] , 
  N2=['List',L2,M2] , 
  O2=['Evaluation',K2,N2] , 
  P2=[stv,1.0,0.9] , 
  Q2=[O2,P2] , 
  R2=[5] , 
  S2=['Sentence',Q2,R2] , 
  T2=['Predicate',friend] , 
  U2=['Concept','Edward'] , 
  V2=['Concept','Frank'] , 
  W2=['List',U2,V2] , 
  X2=['Evaluation',T2,W2] , 
  Y2=[stv,1.0,0.9] , 
  Z2=[X2,Y2] , 
  A3=[6] , 
  B3=['Sentence',Z2,A3] , 
  C3=['Predicate',friend] , 
  D3=['Concept','Gary'] , 
  E3=['Concept','Helen'] , 
  F3=['List',D3,E3] , 
  G3=['Evaluation',C3,F3] , 
  H3=[stv,1.0,0.9] , 
  I3=[G3,H3] , 
  J3=[7] , 
  K3=['Sentence',I3,J3] , 
  L3=['Predicate',friend] , 
  M3=['Concept','Gary'] , 
  N3=['Concept','Frank'] , 
  O3=['List',M3,N3] , 
  P3=['Evaluation',L3,O3] , 
  Q3=[stv,0.0,0.9] , 
  R3=[P3,Q3] , 
  S3=[8] , 
  T3=['Sentence',R3,S3] , 
  U3=['Predicate',smokes] , 
  V3=['Concept','Anna'] , 
  W3=['List',V3] , 
  X3=['Evaluation',U3,W3] , 
  Y3=[stv,1.0,0.9] , 
  Z3=[X3,Y3] , 
  A4=[9] , 
  B4=['Sentence',Z3,A4] , 
  C4 =  
    [ G1, R1,A2,J2,S2, 
      B3,K3,T3,B4] , 
  D4=['Predicate',cancerous] , 
  E4=['Concept','Edward'] , 
  F4=['List',E4] , 
  G4=['Evaluation',D4,F4] , 
  mc__1_3_Question(C4,G4,3,P)
</span> 
<span class="ansi38-013099040">!(assertEqual (DoQuestion) ((stv 0.252 0.9) (9 4 1 2)))

</span>
;<h3 id="BEFORE-COMMIT.PLNSMOKES.01">;; BEFORE-COMMIT.PLNSMOKES.01</h3>
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">arg_type_n('If',3,2,non_eval('Atom'))
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">arg_type_n('If',3,3,non_eval('Atom'))
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi37"></span><span class="ansi2 ansi37 ansi40"></span><span class="ansi2 ansi37 ansi40">arg_type_n('If',2,2,non_eval('Atom'))
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">arg_type_n(==,2,1,var)
</span> 
<span class="ansi2"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96"></span><span class="ansi2 ansi96">[show=assertz_code]</span>: <span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">arg_type_n(==,2,2,var)
</span> 
; 
; EVAL TEST
; took 8.45 seconds.

!(assertEqual (DoQuestion) ((stv 0.252 0.9) (9 4 1 2)))

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( ( (stv 0.252 0.9) (9 4 1 2))) 
      ( ( (stv 0.252 0.9) (9 4 1 2)))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi1">LoonIt Report
</span>------------
<span class="ansi32">Successes: 1
</span><span class="ansi32">Failures: 0
</span>[()]
metta+>
maek.
! (random-int (new-random-generator 0) 0 1000000)
maek.
(println (|- (ZZZ (stv 0.5 0.5
)
)
)
)
[1@!((println (|- (ZZZ (stv 0.5 0.5))))

)
<span class="ansi38-218112214">% DEBUG:   eval('&top',[println,['|-',['ZZZ',[stv,0.5,0.5]]]],OUT).

</span>
Deterministic: <span class="ansi33">(println (|- (ZZZ (stv 0.5 0.5))))
</span>[(println (|- (ZZZ (stv 0.5 0.5))))]
metta+>
!(println (|- (ZZZ (stv 0.5 0.5))))n
[1@! 
<span class="ansi38-218112214">% DEBUG:   eval('&top',['println!',['|-',['ZZZ',[stv,0.5,0.5]]]],OUT).

</span>(|- (ZZZ (stv 0.5 0.5)))

Deterministic: <span class="ansi33">()
</span>[()]
metta+>d~

c^C
Action (h for help) ? exit (status 4)

Script done on 2025-05-14 10:10:38-07:00 [COMMAND_EXIT_CODE="4"]

</pre>
</body>

</html>
