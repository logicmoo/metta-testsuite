<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi35 { color: #E850A8; }
.ansi36 { color: #00aaaa; }
.ansi95 { color: #ff00ff; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-017068017 { color: #114411; }
.ansi38-255165000 { color: #FFA500; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
Script started on 2025-05-05 08:38:58-07:00 [COMMAND="swipl -x /home/deb12user/metta-wam/prolog/metta_lang/Sav.HOSTAGE.MeTTaLog  -- --python=enable -- --html --compile=full show=load tests/quick_quality/NilG_ai-dsl/english-to-chinese-song/issue_First_part.metta  " TERM="xterm" TTY="/dev/pts/2" COLUMNS="156" LINES="38"]
<span class="ansi95"></span><span class="ansi95"></span><span class="ansi95">cmdargs</span>: <span class="ansi1"></span><span class="ansi1 ansi35"></span><span class="ansi1 ansi35"></span><span class="ansi1 ansi35">set_debug(load,true)
</span> 
<span class="ansi95"></span><span class="ansi95"></span><span class="ansi95">cmdargs</span>: <span class="ansi1"></span><span class="ansi1 ansi35"></span><span class="ansi1 ansi35"></span><span class="ansi1 ansi35">set_debug(load,true)
</span> 

; user:[load_metta_file &self tests/quick_quality/NilG_ai-dsl/english-to-chinese-song/issue_First_part.metta]
;            [track_load_into_file /home/deb12user/metta-wam/tests/quick_quality/NilG_ai-dsl/english-to-chinese-song/issue_First_part.metta]
;                    [load_answer_file /home/deb12user/metta-wam/tests/quick_quality/NilG_ai-dsl/english-to-chinese-song/issue_First_part.metta.answers /home/deb12user/metta-wam/tests/quick_quality/NilG_ai-dsl/english-to-chinese-song/issue_First_part.metta]
;                    [load_answer_file /home/deb12user/metta-wam/tests/quick_quality/NilG_ai-dsl/english-to-chinese-song/issue_First_part.metta.answers /home/deb12user/metta-wam/tests/quick_quality/NilG_ai-dsl/english-to-chinese-song/issue_First_part.metta]
;;;; Like etcs-combinator-sd-data-uncurry-xp.metta but tested on the
;;;; whole AI service composition instead of the scaled down one.
;;;;;;;;;;;;;
;;;; Utils ;;
;;;;;;;;;;;;;
;;;; Run the code if the condition is true, otherwise prune the branch
<span class="ansi38-255165000"> (: when (-> Bool $a $a))
 
</span><span class="ansi38-255165000"> (= (when $c $x)  
  (if $c $x 
    (empty)))
 
</span>;;;; Return the total length of a term, corresponding roughly to the
;;;; number of symbols in the term.
<span class="ansi38-255165000"> (: termLength (-> Atom Number))
 
</span><span class="ansi38-255165000"> (= (termLength $term)  
  (case 
    (get-metatype $term) 
    ( (Expression (if (== $term ()) 0 (let* (($head (car-atom $term)) ($tail (cdr-atom $term))) (+ (termLength $head) (termLength $tail))))) ($else 1))))
 
</span>;;;; Test termLength
<span class="ansi38-013099040">

!(assertEqual (termLength (A B (C D))) 4)

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, mc__1_1_termLength(D, C), E, E=[termLength, D], D=ispuU(F, (G=['C', 'D'], F=['A', 'B', G]))), H=ispu(4), mc__1_2_assertEqual(B, H, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.01">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.01</h3>
; 
; EVAL TEST
; took 0.000527 secs. (527.30 microseconds) 

!(assertEqual [ispeEnNC $2006152 [mc__1_1_termLength $2006164 $2006152] $2006156 [ = $2006156 (termLength $2006164) ] [ = $2006164 [ispuU $2006194 [ , [ = $2006206 (C D) ] [ = $2006194 (A B $2006206) ] ]] ]] [ispu 4])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (4) 
      (4)]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Compare two terms by their lengths
<span class="ansi38-255165000"> (: termLengthLT (-> Atom Atom Bool))
 
</span><span class="ansi38-255165000"> (= (termLengthLT $x $y)  
  (< 
    (termLength $x) 
    (termLength $y)))
 
</span>;;;; Return True iff $term is closed
<span class="ansi38-255165000"> (: is-closed (-> Atom Bool))
 
</span><span class="ansi38-255165000"> (= (is-closed $term)  
  (case 
    (get-metatype $term) 
    ( (Variable False) 
      (Symbol True) 
      (Grounded True) 
      (Expression (if (== $term ()) True (let* (($head (car-atom $term)) ($tail (cdr-atom $term))) (and (is-closed $head) (is-closed $tail))))))))
 
</span>;;;;;;;;;;;;;
;;;; Maybe ;;
;;;;;;;;;;;;;
;;;; Define Maybe type
<span class="ansi38-255165000"> (: Maybe (-> $a Type))
 
</span><span class="ansi38-255165000"> (: Nothing (Maybe $a))
 
</span><span class="ansi38-255165000"> (: Just (-> $a (Maybe $a)))
 
</span>;;;;;;;;;;;;
;;;; List ;;
;;;;;;;;;;;;
;;;; Declaration of List data type and constructors
<span class="ansi38-255165000"> (: List (-> $a Type))
 
</span><span class="ansi38-255165000"> (: Nil (List $a))
 
</span><span class="ansi38-255165000"> (: Cons (-> $a (List $a) (List $a)))
 
</span>;;;; Construct list from tuple
<span class="ansi38-255165000"> (: toList (-> Expression (List $a)))
 
</span><span class="ansi38-255165000"> (= (toList $expr)  
  (if 
    (== $expr ()) Nil 
    (let* 
      ( ($head (car-atom $expr)) ($tail (cdr-atom $expr))) 
      (Cons $head 
        (toList $tail)))))
 
</span>;;;; Test toList
<span class="ansi38-013099040">

!(assertEqual (toList (A (A B) (A B (C D)))) (Cons A (Cons (A B) (Cons (A B (C D)) Nil))))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, mc__1_1_toList(D, C), E, E=[toList, D], (F=['A', 'B'], G=['C', 'D'], H=['A', 'B', G], D=['A', F, H])), I=ispuU(J, (K=['A', 'B'], L=['C', 'D'], M=['A', 'B', L], N=['Cons', M, 'Nil'], O=['Cons', K, N], J=['Cons', 'A', O])), mc__1_2_assertEqual(B, I, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.02">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.02</h3>
; 
; EVAL TEST
; took 0.000056 secs. (56.30 microseconds) 

!(assertEqual [ispeEnNC $2138854 [mc__1_1_toList $2138866 $2138854] $2138858 [ = $2138858 (toList $2138866) ] [ , [ = $2138896 (A B) ] [ , [ = $2138920 (C D) ] [ , [ = $2138944 (A B $2138920) ] [ = $2138866 (A $2138896 $2138944) ] ] ] ]] [ispuU $2138998 [ , [ = $2139010 (A B) ] [ , [ = $2139034 (C D) ] [ , [ = $2139058 (A B $2139034) ] [ , [ = $2139088 (Cons $2139058 Nil) ] [ , [ = $2139118 (Cons $2139010 $2139088) ] [ = $2138998 (Cons A $2139118) ] ] ] ] ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (Cons A 
          (Cons 
            (A B) 
            (Cons 
              (A B 
                (C D)) Nil)))) 
      ( (Cons A 
          (Cons 
            (A B) 
            (Cons 
              (A B 
                (C D)) Nil))))]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Fold a List from right to left
<span class="ansi38-255165000"> (: List.foldr (-> (-> $a $b $b) $b (List $a) $b))
 
</span><span class="ansi38-255165000"> (= (List.foldr $f $i Nil)  $i)
 
</span><span class="ansi38-255165000"> (= (List.foldr $f $i (Cons $h $t))  
  ($f $h 
    (List.foldr $f $i $t)))
 
</span>;;;; Fold a List from left to right
<span class="ansi38-255165000"> (: List.foldl (-> (-> $b $a $b) $b (List $a) $b))
 
</span><span class="ansi38-255165000"> (= (List.foldl $f $i Nil)  $i)
 
</span><span class="ansi38-255165000"> (= (List.foldl $f $i (Cons $h $t))  
  (List.foldl $f 
    ($f $i $h) $t))
 
</span>;;;; Define List.append (concatenate two lists).
<span class="ansi38-255165000"> (: List.append (-> (List $a) (List $a) (List $a)))
 
</span><span class="ansi38-255165000"> (= (List.append $xs $ys)  
  (List.foldr Cons $ys $xs))
 
</span>;;;; Test List.append
<span class="ansi38-013099040">

!(assertEqual (List.append (Cons a (Cons b Nil)) (Cons c (Cons d Nil))) (Cons a (Cons b (Cons c (Cons d Nil)))))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_2_List.append'(D, E, C), F, F=['List.append', D, E], (G=['Cons', b, 'Nil'], D=['Cons', a, G], H=['Cons', d, 'Nil'], E=['Cons', c, H])), I=ispuU(J, (K=['Cons', d, 'Nil'], L=['Cons', c, K], M=['Cons', b, L], J=['Cons', a, M])), mc__1_2_assertEqual(B, I, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.03">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.03</h3>
; 
; EVAL TEST
; took 0.000047 secs. (47.30 microseconds) 

!(assertEqual [ispeEnNC $2254788 [mc__1_2_List.append $2254800 $2254802 $2254788] $2254792 [ = $2254792 (List.append $2254800 $2254802) ] [ , [ = $2254838 (Cons b Nil) ] [ , [ = $2254800 (Cons a $2254838) ] [ , [ = $2254898 (Cons d Nil) ] [ = $2254802 (Cons c $2254898) ] ] ] ]] [ispuU $2254952 [ , [ = $2254964 (Cons d Nil) ] [ , [ = $2254994 (Cons c $2254964) ] [ , [ = $2255024 (Cons b $2254994) ] [ = $2254952 (Cons a $2255024) ] ] ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (Cons a 
          (Cons b 
            (Cons c 
              (Cons d Nil))))) 
      ( (Cons a 
          (Cons b 
            (Cons c 
              (Cons d Nil)))))]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Overload List.append to support more than 2 arguments
<span class="ansi38-255165000"> (: List.append3 (-> (List $a) (List $a) (List $a) (List $a)))
 
</span><span class="ansi38-255165000"> (= (List.append3 $x $y $z)  
  (List.append $x 
    (List.append $y $z)))
 
</span><span class="ansi38-255165000"> (: List.append4 (-> (List $a) (List $a) (List $a) (List $a) (List $a)))
 
</span><span class="ansi38-255165000"> (= (List.append4 $x $y $z $w)  
  (List.append $x 
    (List.append3 $y $z $w)))
 
</span><span class="ansi38-255165000"> (: List.append5 (-> (List $a) (List $a) (List $a) (List $a) (List $a) (List $a)))
 
</span><span class="ansi38-255165000"> (= (List.append5 $x $y $z $w $s)  
  (List.append $x 
    (List.append4 $y $z $w $s)))
 
</span>;;;; Define List.map (produce a new list by applying unary function to
;;;; all elements of a list).
<span class="ansi38-255165000"> (: List.map (-> (-> $a $b) (List $a) (List $b)))
 
</span><span class="ansi38-255165000"> (= (List.map $f Nil)  Nil)
 
</span><span class="ansi38-255165000"> (= (List.map $f (Cons $head $tail))  
  (Cons 
    ($f $head) 
    (List.map $f $tail)))
 
</span>;;;; Insert an element to a presumably sorted list according to a given
;;;; order (less than).  The result remains sorted.
<span class="ansi38-255165000"> (: List.insertWith (-> (-> $a $a Bool) $a (List $a) (List $a)))
 
</span><span class="ansi38-255165000"> (= (List.insertWith $lt $x Nil)  
  (Cons $x Nil))
 
</span><span class="ansi38-255165000"> (= (List.insertWith $lt $x (Cons $head $tail))  
  (if 
    ($lt $x $head) 
    (Cons $x 
      (Cons $head $tail)) 
    (Cons $head 
      (List.insertWith $lt $x $tail))))
 
</span>;;;; Sort a list according to a given a less than order.
<span class="ansi38-255165000"> (: List.sortWith (-> (-> $a $a Bool) (List $a) (List $a)))
 
</span><span class="ansi38-255165000"> (= (List.sortWith $lt Nil)  Nil)
 
</span><span class="ansi38-255165000"> (= (List.sortWith $lt (Cons $head $tail))  
  (List.insertWith $lt $head 
    (List.sortWith $lt $tail)))
 
</span>;;;; Test sortWith
<span class="ansi38-013099040">

!(assertEqual (List.sortWith termLengthLT Nil) Nil)

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnN(C, 'mc__1_2_List.sortWith'(termLengthLT, 'Nil', C), D, D=['List.sortWith', termLengthLT, 'Nil']), E=ispu('Nil'), mc__1_2_assertEqual(B, E, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.04">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.04</h3>
; 
; EVAL TEST
; took 0.000011 secs. (11.20 microseconds) 

!(assertEqual [ispeEnN $2425076 [mc__1_2_List.sortWith termLengthLT Nil $2425076] $2425080 [ = $2425080 (List.sortWith termLengthLT Nil) ]] [ispu Nil])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (Nil) 
      (Nil)]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (List.sortWith termLengthLT (Cons A Nil)) (Cons A Nil))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_2_List.sortWith'(termLengthLT, D, C), E, E=['List.sortWith', termLengthLT, D], D=['Cons', 'A', 'Nil']), F=ispuU(G, G=['Cons', 'A', 'Nil']), mc__1_2_assertEqual(B, F, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.05">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.05</h3>
; 
; EVAL TEST
; took 0.000015 secs. (14.80 microseconds) 

!(assertEqual [ispeEnNC $2451904 [mc__1_2_List.sortWith termLengthLT $2451918 $2451904] $2451908 [ = $2451908 (List.sortWith termLengthLT $2451918) ] [ = $2451918 (Cons A Nil) ]] [ispuU $2451978 [ = $2451978 (Cons A Nil) ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (Cons A Nil)) 
      ( (Cons A Nil))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (List.sortWith termLengthLT (Cons (A B) (Cons A Nil))) (Cons A (Cons (A B) Nil)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_2_List.sortWith'(termLengthLT, D, C), E, E=['List.sortWith', termLengthLT, D], (F=['A', 'B'], G=['Cons', 'A', 'Nil'], D=['Cons', F, G])), H=ispuU(I, (J=['A', 'B'], K=['Cons', J, 'Nil'], I=['Cons', 'A', K])), mc__1_2_assertEqual(B, H, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.06">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.06</h3>
; 
; EVAL TEST
; took 0.000366 secs. (365.90 microseconds) 

!(assertEqual [ispeEnNC $2484394 [mc__1_2_List.sortWith termLengthLT $2484408 $2484394] $2484398 [ = $2484398 (List.sortWith termLengthLT $2484408) ] [ , [ = $2484444 (A B) ] [ , [ = $2484468 (Cons A Nil) ] [ = $2484408 (Cons $2484444 $2484468) ] ] ]] [ispuU $2484522 [ , [ = $2484534 (A B) ] [ , [ = $2484558 (Cons $2484534 Nil) ] [ = $2484522 (Cons A $2484558) ] ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (Cons A 
          (Cons 
            (A B) Nil))) 
      ( (Cons A 
          (Cons 
            (A B) Nil)))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (List.sortWith termLengthLT (Cons (A B) (Cons A (Cons (A B (C D)) (Cons () Nil))))) (Cons () (Cons A (Cons (A B) (Cons (A B (C D)) Nil)))))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_2_List.sortWith'(termLengthLT, D, C), E, E=['List.sortWith', termLengthLT, D], (F=['A', 'B'], G=['C', 'D'], H=['A', 'B', G], I=['Cons', [], 'Nil'], J=['Cons', H, I], K=['Cons', 'A', J], D=['Cons', F, K])), L=ispuU(M, (N=['A', 'B'], O=['C', 'D'], P=['A', 'B', O], Q=['Cons', P, 'Nil'], R=['Cons', N, Q], S=['Cons', 'A', R], M=['Cons', [], S])), mc__1_2_assertEqual(B, L, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.07">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.07</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.57 milliseconds) 

!(assertEqual [ispeEnNC $2529084 [mc__1_2_List.sortWith termLengthLT $2529098 $2529084] $2529088 [ = $2529088 (List.sortWith termLengthLT $2529098) ] [ , [ = $2529134 (A B) ] [ , [ = $2529158 (C D) ] [ , [ = $2529182 (A B $2529158) ] [ , [ = $2529212 (Cons () Nil) ] [ , [ = $2529242 (Cons $2529182 $2529212) ] [ , [ = $2529272 (Cons A $2529242) ] [ = $2529098 (Cons $2529134 $2529272) ] ] ] ] ] ] ]] [ispuU $2529326 [ , [ = $2529338 (A B) ] [ , [ = $2529362 (C D) ] [ , [ = $2529386 (A B $2529362) ] [ , [ = $2529416 (Cons $2529386 Nil) ] [ , [ = $2529446 (Cons $2529338 $2529416) ] [ , [ = $2529476 (Cons A $2529446) ] [ = $2529326 (Cons () $2529476) ] ] ] ] ] ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (Cons () 
          (Cons A 
            (Cons 
              (A B) 
              (Cons 
                (A B 
                  (C D)) Nil))))) 
      ( (Cons () 
          (Cons A 
            (Cons 
              (A B) 
              (Cons 
                (A B 
                  (C D)) Nil)))))]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Returns the pre predix of a list of a given length.
<span class="ansi38-255165000"> (: List.take (-> Number (List $a) (List $a)))
 
</span><span class="ansi38-255165000"> (= (List.take $n Nil)  Nil)
 
</span><span class="ansi38-255165000"> (= (List.take $n (Cons $head $tail))  
  (if 
    (< 0 $n) 
    (Cons $head 
      (List.take 
        (- $n 1) $tail)) Nil))
 
</span>;;;; Test List.take
<span class="ansi38-013099040">

!(assertEqual (List.take 2 (Cons A (Cons B (Cons C Nil)))) (Cons A (Cons B Nil)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_2_List.take'(2, D, C), E, E=['List.take', 2, D], (F=['Cons', 'C', 'Nil'], G=['Cons', 'B', F], D=['Cons', 'A', G])), H=ispuU(I, (J=['Cons', 'B', 'Nil'], I=['Cons', 'A', J])), mc__1_2_assertEqual(B, H, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.08">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.08</h3>
; 
; EVAL TEST
; took 0.000073 secs. (73.20 microseconds) 

!(assertEqual [ispeEnNC $2589334 [mc__1_2_List.take 2 $2589348 $2589334] $2589338 [ = $2589338 (List.take 2 $2589348) ] [ , [ = $2589384 (Cons C Nil) ] [ , [ = $2589414 (Cons B $2589384) ] [ = $2589348 (Cons A $2589414) ] ] ]] [ispuU $2589468 [ , [ = $2589480 (Cons B Nil) ] [ = $2589468 (Cons A $2589480) ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (Cons A 
          (Cons B Nil))) 
      ( (Cons A 
          (Cons B Nil)))]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;;;;;;;;;;
;;; String ;
;;;;;;;;;;;;
;;;; Fold a tuple from right to left
<span class="ansi38-255165000"> (: foldr (-> (-> $a $b $b) $b $c $d))
 
</span><span class="ansi38-255165000"> (= (foldr $f $i $xs)  
  (if 
    (== $xs ()) $i 
    (let* 
      ( ($h (car-atom $xs)) 
        ($t (cdr-atom $xs)) 
        ($ft (foldr $f $i $t))) 
      ($f $h $ft))))
 
</span>;;;; Concatenate two terms
<span class="ansi38-255165000"> (: append (-> $a $a $a))
 
</span><span class="ansi38-255165000"> (= (append $lhs $rhs)  
  (foldr cons-atom $rhs $lhs))
 
</span>;;;; Concatenate two strings (implemented in my own branch)
<span class="ansi38-255165000"> (: String.append (-> String String String))
 
</span><span class="ansi38-255165000"> (= (String.append $x $y)  
  (call-fn! string_concat $x $y))
 
</span>;;; Only MeTTaLog
;;;; (= (String.append $x $y) ((py-dot $x __add__ (-> String String String)) $y))
;;;; (= (String.append $x $y) (charsToString (append (stringToChars $x) (stringToChars $y))))
;;;; Test String.append
<span class="ansi38-013099040">

!(assertEqual (String.append "abc" "def") "abcdef")

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnN(C, 'mc__1_2_String.append'("abc", "def", C), D, D=['String.append', "abc", "def"]), E=ispu("abcdef"), mc__1_2_assertEqual(B, E, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.09">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.09</h3>
; 
; EVAL TEST
; took 0.000021 secs. (21.20 microseconds) 

!(assertEqual [ispeEnN $2680940 [mc__1_2_String.append "abc" "def" $2680940] $2680944 [ = $2680944 (String.append "abc" "def") ]] [ispu "abcdef"])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("abcdef") 
      ("abcdef")]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (String.append "\"" "\"") "\"\"")

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnN(C, 'mc__1_2_String.append'("\"", "\"", C), D, D=['String.append', "\"", "\""]), E=ispu("\"\""), mc__1_2_assertEqual(B, E, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.10">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.10</h3>
; 
; EVAL TEST
; took 0.000017 secs. (17.30 microseconds) 

!(assertEqual [ispeEnN $2704146 [mc__1_2_String.append "\"" "\"" $2704146] $2704150 [ = $2704150 (String.append "\"" "\"") ]] [ispu "\"\""])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("\"\"") 
      ("\"\"")]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Overload String.append to support more than 2 arguments
<span class="ansi38-255165000"> (: String.append3 (-> String String String String))
 
</span><span class="ansi38-255165000"> (= (String.append3 $x $y $z)  
  (String.append $x 
    (String.append $y $z)))
 
</span><span class="ansi38-255165000"> (: String.append4 (-> String String String String String))
 
</span><span class="ansi38-255165000"> (= (String.append4 $x $y $z $w)  
  (String.append $x 
    (String.append3 $y $z $w)))
 
</span><span class="ansi38-255165000"> (: String.append5 (-> String String String String String String))
 
</span><span class="ansi38-255165000"> (= (String.append5 $x $y $z $w $s)  
  (String.append $x 
    (String.append4 $y $z $w $s)))
 
</span>;;;; Join a list of string by a separator
<span class="ansi38-255165000"> (: String.join (-> String (List String) String))
 
</span><span class="ansi38-255165000"> (= (String.join $separator Nil)  "")
 
</span><span class="ansi38-255165000"> (= (String.join $separator (Cons $head $tail))  
  (case $tail 
    ( (Nil $head) ($else (String.append3 $head $separator (String.join $separator $tail))))))
 
</span>;;;; Test String.join
<span class="ansi38-013099040">

!(assertEqual (String.join ", " (Cons "x=42" (Cons "y=24" Nil))) "x=42, y=24")

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_2_String.join'(", ", D, C), E, E=['String.join', ", ", D], (F=['Cons', "y=24", 'Nil'], D=['Cons', "x=42", F])), G=ispu("x=42, y=24"), mc__1_2_assertEqual(B, G, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.11">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.11</h3>
; 
; EVAL TEST
; took 0.000032 secs. (31.70 microseconds) 

!(assertEqual [ispeEnNC $2817654 [mc__1_2_String.join ", " $2817668 $2817654] $2817658 [ = $2817658 (String.join ", " $2817668) ] [ , [ = $2817704 (Cons "y=24" Nil) ] [ = $2817668 (Cons "x=42" $2817704) ] ]] [ispu "x=42, y=24"])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("x=42, y=24") 
      ("x=42, y=24")]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;;;;;;;;;
;;;; Nat ;;
;;;;;;;;;;;
;;;; Define Nat
<span class="ansi38-255165000"> (: Nat Type)
 
</span><span class="ansi38-255165000"> (: Z Nat)
 
</span><span class="ansi38-255165000"> (: S (-> Nat Nat))
 
</span>;;;; Define cast functions between Nat and Number
<span class="ansi38-255165000"> (: fromNumber (-> Number Nat))
 
</span><span class="ansi38-255165000"> (= (fromNumber $n)  
  (if 
    (<= $n 0) Z 
    (S (fromNumber (- $n 1)))))
 
</span><span class="ansi38-255165000"> (: fromNat (-> Nat Number))
 
</span><span class="ansi38-255165000"> (= (fromNat Z)  0)
 
</span><span class="ansi38-255165000"> (= (fromNat (S $k))  
  (+ 1 
    (fromNat $k)))
 
</span>;;;;;;;;;;;
;;;; DOT ;;
;;;;;;;;;;;
;;;; DOT Rankdir
<span class="ansi38-255165000"> (: DOT.Rankdir Type)
 
</span><span class="ansi38-255165000"> (: DOT.Rankdir.BT DOT.Rankdir)
 
</span>;;; Bottom to top
<span class="ansi38-255165000"> (: DOT.Rankdir.TB DOT.Rankdir)
 
</span>;;; Top to bottom
<span class="ansi38-255165000"> (: DOT.Rankdir.LR DOT.Rankdir)
 
</span>;;; Left to right
<span class="ansi38-255165000"> (: DOT.Rankdir.RL DOT.Rankdir)
 
</span>;;; Right to left
;;;; DOT Style
<span class="ansi38-255165000"> (: DOT.Style Type)
 
</span><span class="ansi38-255165000"> (: DOT.Style.Rounded DOT.Style)
 
</span>;;;; DOT shape
<span class="ansi38-255165000"> (: DOT.Shape Type)
 
</span><span class="ansi38-255165000"> (: DOT.Shape.Plain DOT.Shape)
 
</span><span class="ansi38-255165000"> (: DOT.Shape.Box DOT.Shape)
 
</span><span class="ansi38-255165000"> (: DOT.Shape.None DOT.Shape)
 
</span><span class="ansi38-255165000"> (: DOT.Shape.Parallelogram DOT.Shape)
 
</span>;;;; DOT attribute
<span class="ansi38-255165000"> (: DOT.Attribute Type)
 
</span>;;;; Constructors
<span class="ansi38-255165000"> (: DOT.MkLabelAttribute (-> String DOT.Attribute))
 
</span><span class="ansi38-255165000"> (: DOT.MkStyleAttribute (-> DOT.Style DOT.Attribute))
 
</span><span class="ansi38-255165000"> (: DOT.MkShapeAttribute (-> DOT.Shape DOT.Attribute))
 
</span><span class="ansi38-255165000"> (: DOT.MkRankdirAttribute (-> DOT.Rankdir DOT.Attribute))
 
</span>;;;; Access functions
<span class="ansi38-255165000"> (: DOT.Attribute.label (-> DOT.Attribute (Maybe String)))
 
</span><span class="ansi38-255165000"> (= (DOT.Attribute.label $attribute)  
  (case $attribute 
    ( ( (DOT.MkLabelAttribute $label) (Just $label)) ($else Nothing))))
 
</span><span class="ansi38-255165000"> (: DOT.Attribute.style (-> DOT.Attribute (Maybe DOT.Style)))
 
</span><span class="ansi38-255165000"> (= (DOT.Attribute.style $style)  
  (case $style 
    ( ( (DOT.MkStyleAttribute $style) (Just $style)) ($else Nothing))))
 
</span><span class="ansi38-255165000"> (: DOT.Attribute.shape (-> DOT.Attribute (Maybe DOT.Shape)))
 
</span><span class="ansi38-255165000"> (= (DOT.Attribute.shape $attribute)  
  (case $attribute 
    ( ( (DOT.MkShapeAttribute $shape) (Just $shape)) ($else Nothing))))
 
</span><span class="ansi38-255165000"> (: DOT.Attribute.rankdir (-> DOT.Attribute (Maybe DOT.Rankdir)))
 
</span><span class="ansi38-255165000"> (= (DOT.Attribute.rankdir $attribute)  
  (case $attribute 
    ( ( (DOT.MkRankdirAttribute $rankdir) (Just $rankdir)) ($else Nothing))))
 
</span>;;;; Test DOT attributes
<span class="ansi38-013099040">

!(assertEqual (get-type (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil)) (List DOT.Attribute))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_get-type'(D, C), E, E=['get-type', D], (F=['DOT.MkShapeAttribute', 'DOT.Shape.Box'], D=['Cons', F, 'Nil'])), G=ispuU(H, H=['List', 'DOT.Attribute']), mc__1_2_assertEqual(B, G, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.12">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.12</h3>
; 
; EVAL TEST
; took 0.000432 secs. (432.00 microseconds) 

!(assertEqual [ispeEnNC $3064890 [mc__1_1_get-type $3064902 $3064890] $3064894 [ = $3064894 (get-type $3064902) ] [ , [ = $3064932 (DOT.MkShapeAttribute DOT.Shape.Box) ] [ = $3064902 (Cons $3064932 Nil) ] ]] [ispuU $3064980 [ = $3064980 (List DOT.Attribute) ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (List DOT.Attribute)) 
      ( (List DOT.Attribute))]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;; DOT Identifier
<span class="ansi38-255165000"> (: DOT.Identifier Type)
 
</span>;;;; Constructors.  The Symbol based identifier constructor takes an
;;;; extra index argument to be treated as unique in the flowchart where
;;;; it appears (because if it appears with different arguments it is
;;;; should be treated as different).  The Grounded based identifier
;;;; constructor does not need such extra index because it used for
;;;; constants only, which should be unique since they take no argument.
<span class="ansi38-255165000"> (: DOT.MkSymbolIdentifier (-> Symbol Number DOT.Identifier))
 
</span><span class="ansi38-255165000"> (: DOT.MkGroundedIdentifier (-> Grounded DOT.Identifier))
 
</span>;;;; DOT node
<span class="ansi38-255165000"> (: DOT.Node Type)
 
</span>;;;; Constructor
<span class="ansi38-255165000"> (: DOT.MkNode (-> DOT.Identifier (List DOT.Attribute) DOT.Node))
 
</span>;;;; Access functions
<span class="ansi38-255165000"> (: DOT.Node.identifier (-> DOT.Node DOT.Identifier))
 
</span><span class="ansi38-255165000"> (= (DOT.Node.identifier (DOT.MkNode $identifier $attributes))  $identifier)
 
</span><span class="ansi38-255165000"> (: DOT.Node.attributes (-> DOT.Node (List DOT.Attribute)))
 
</span><span class="ansi38-255165000"> (= (DOT.Node.attributes (DOT.MkNode $identifier $attributes))  $attributes)
 
</span>;;;; Data type of DOT edge
<span class="ansi38-255165000"> (: DOT.Edge Type)
 
</span>;;;; Constructor
<span class="ansi38-255165000"> (: DOT.MkEdge (-> DOT.Node DOT.Node (List DOT.Attribute) DOT.Edge))
 
</span>;;;; Access functions
<span class="ansi38-255165000"> (: DOT.Edge.source (-> DOT.Edge DOT.Node))
 
</span><span class="ansi38-255165000"> (= (DOT.Edge.source (DOT.MkEdge $source $destination $attributes))  $source)
 
</span><span class="ansi38-255165000"> (: DOT.Edge.destination (-> DOT.Edge DOT.Node))
 
</span><span class="ansi38-255165000"> (= (DOT.Edge.destination (DOT.MkEdge $source $destination $attributes))  $destination)
 
</span><span class="ansi38-255165000"> (: DOT.Edge.attributes (-> DOT.Edge (List DOT.Attribute)))
 
</span><span class="ansi38-255165000"> (= (DOT.Edge.attributes (DOT.MkEdge $source $destination $attributes))  $attributes)
 
</span>;;;; Data type to describe Graphviz DOT data
<span class="ansi38-255165000"> (: DOT Type)
 
</span><span class="ansi38-255165000"> (: MkDOT (-> (List DOT.Node) (List DOT.Edge) DOT.Node DOT.Node (List DOT.Attribute) DOT))
 
</span>;;;; Test MkDOT
<span class="ansi38-013099040">

!(assertEqual (MkDOT Nil Nil (DOT.MkNode (DOT.MkSymbolIdentifier mix 0) (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil)) (DOT.MkNode (DOT.MkSymbolIdentifier mix 0) (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil)) (Cons (DOT.MkRankdirAttribute DOT.Rankdir.BT) Nil)) (MkDOT Nil Nil (DOT.MkNode (DOT.MkSymbolIdentifier mix 0) (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil)) (DOT.MkNode (DOT.MkSymbolIdentifier mix 0) (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil)) (Cons (DOT.MkRankdirAttribute DOT.Rankdir.BT) Nil)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispuU(C, (D=['DOT.MkSymbolIdentifier', mix, 0], E=['DOT.MkShapeAttribute', 'DOT.Shape.Box'], F=['Cons', E, 'Nil'], G=['DOT.MkNode', D, F], H=['DOT.MkSymbolIdentifier', mix, 0], I=['DOT.MkShapeAttribute', 'DOT.Shape.Box'], J=['Cons', I, 'Nil'], K=['DOT.MkNode', H, J], L=['DOT.MkRankdirAttribute', 'DOT.Rankdir.BT'], M=['Cons', L, 'Nil'], C=['MkDOT', 'Nil', 'Nil', G, K, M])), N=ispuU(O, (P=['DOT.MkSymbolIdentifier', mix, 0], Q=['DOT.MkShapeAttribute', 'DOT.Shape.Box'], R=['Cons', Q, 'Nil'], S=['DOT.MkNode', P, R], T=['DOT.MkSymbolIdentifier', mix, 0], U=['DOT.MkShapeAttribute', 'DOT.Shape.Box'], V=['Cons', U, 'Nil'], W=['DOT.MkNode', T, V], X=['DOT.MkRankdirAttribute', 'DOT.Rankdir.BT'], Y=['Cons', X, 'Nil'], O=['MkDOT', 'Nil', 'Nil', S, W, Y])), mc__1_2_assertEqual(B, N, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.13">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.13</h3>
; 
; EVAL TEST
; took 0.000080 secs. (79.80 microseconds) 

!(assertEqual [ispuU $3265358 [ , [ = $3265370 (DOT.MkSymbolIdentifier mix 0) ] [ , [ = $3265400 (DOT.MkShapeAttribute DOT.Shape.Box) ] [ , [ = $3265424 (Cons $3265400 Nil) ] [ , [ = $3265454 (DOT.MkNode $3265370 $3265424) ] [ , [ = $3265484 (DOT.MkSymbolIdentifier mix 0) ] [ , [ = $3265514 (DOT.MkShapeAttribute DOT.Shape.Box) ] [ , [ = $3265538 (Cons $3265514 Nil) ] [ , [ = $3265568 (DOT.MkNode $3265484 $3265538) ] [ , [ = $3265598 (DOT.MkRankdirAttribute DOT.Rankdir.BT) ] [ , [ = $3265622 (Cons $3265598 Nil) ] [ = $3265358 (MkDOT Nil Nil $3265454 $3265568 $3265622) ] ] ] ] ] ] ] ] ] ] ]] [ispuU $3265694 [ , [ = $3265706 (DOT.MkSymbolIdentifier mix 0) ] [ , [ = $3265736 (DOT.MkShapeAttribute DOT.Shape.Box) ] [ , [ = $3265760 (Cons $3265736 Nil) ] [ , [ = $3265790 (DOT.MkNode $3265706 $3265760) ] [ , [ = $3265820 (DOT.MkSymbolIdentifier mix 0) ] [ , [ = $3265850 (DOT.MkShapeAttribute DOT.Shape.Box) ] [ , [ = $3265874 (Cons $3265850 Nil) ] [ , [ = $3265904 (DOT.MkNode $3265820 $3265874) ] [ , [ = $3265934 (DOT.MkRankdirAttribute DOT.Rankdir.BT) ] [ , [ = $3265958 (Cons $3265934 Nil) ] [ = $3265694 (MkDOT Nil Nil $3265790 $3265904 $3265958) ] ] ] ] ] ] ] ] ] ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (MkDOT Nil Nil 
          (DOT.MkNode 
            (DOT.MkSymbolIdentifier mix 0) 
            (Cons 
              (DOT.MkShapeAttribute DOT.Shape.Box) Nil)) 
          (DOT.MkNode 
            (DOT.MkSymbolIdentifier mix 0) 
            (Cons 
              (DOT.MkShapeAttribute DOT.Shape.Box) Nil)) 
          (Cons 
            (DOT.MkRankdirAttribute DOT.Rankdir.BT) Nil))) 
      ( (MkDOT Nil Nil 
          (DOT.MkNode 
            (DOT.MkSymbolIdentifier mix 0) 
            (Cons 
              (DOT.MkShapeAttribute DOT.Shape.Box) Nil)) 
          (DOT.MkNode 
            (DOT.MkSymbolIdentifier mix 0) 
            (Cons 
              (DOT.MkShapeAttribute DOT.Shape.Box) Nil)) 
          (Cons 
            (DOT.MkRankdirAttribute DOT.Rankdir.BT) Nil)))]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Return the default attributes of a DOT file
<span class="ansi38-255165000"> (: globalAttributes (-> (List DOT.Attribute)))
 
</span><span class="ansi38-255165000"> (= (globalAttributes)  
  (Cons 
    (DOT.MkRankdirAttribute DOT.Rankdir.BT) Nil))
 
</span>;;;; Return the default attributes of a node representing a function
<span class="ansi38-255165000"> (: functionAttributes (-> (List DOT.Attribute)))
 
</span><span class="ansi38-255165000"> (= (functionAttributes)  
  (Cons 
    (DOT.MkShapeAttribute DOT.Shape.Box) Nil))
 
</span>;;;; Return the default attributes of a node representing a constant
<span class="ansi38-255165000"> (: constantAttributes (-> (List DOT.Attribute)))
 
</span><span class="ansi38-255165000"> (= (constantAttributes)  
  (Cons 
    (DOT.MkShapeAttribute DOT.Shape.Box) 
    (Cons 
      (DOT.MkStyleAttribute DOT.Style.Rounded) Nil)))
 
</span>;;;; Return the default attributes of a none node, typically used as
;;;; input and output
<span class="ansi38-255165000"> (: noneAttributes (-> (List DOT.Attribute)))
 
</span><span class="ansi38-255165000"> (= (noneAttributes)  
  (Cons 
    (DOT.MkLabelAttribute "\"\"") 
    (Cons 
      (DOT.MkShapeAttribute DOT.Shape.None) Nil)))
 
</span>;;;; Return the default attibutes of the input node
<span class="ansi38-255165000"> (: inputAttributes (-> (List DOT.Attribute)))
 
</span><span class="ansi38-255165000"> (= (inputAttributes)  
  (Cons 
    (DOT.MkLabelAttribute "In") 
    (Cons 
      (DOT.MkShapeAttribute DOT.Shape.Parallelogram) Nil)))
 
</span>;;;; Return the default attibutes of the output node
<span class="ansi38-255165000"> (: outputAttributes (-> (List DOT.Attribute)))
 
</span><span class="ansi38-255165000"> (= (outputAttributes)  
  (Cons 
    (DOT.MkLabelAttribute "Out") 
    (Cons 
      (DOT.MkShapeAttribute DOT.Shape.Parallelogram) Nil)))
 
</span>;;;; Build default input node
<span class="ansi38-255165000"> (: inputNode (-> DOT.Node))
 
</span><span class="ansi38-255165000"> (= (inputNode)  
  (DOT.MkNode 
    (DOT.MkSymbolIdentifier __IN__ 0) 
    (noneAttributes)))
 
</span>;;;; Build default output node
<span class="ansi38-255165000"> (: outputNode (-> DOT.Node))
 
</span><span class="ansi38-255165000"> (= (outputNode)  
  (DOT.MkNode 
    (DOT.MkSymbolIdentifier __OUT__ 0) 
    (noneAttributes)))
 
</span>;;;; Return the default attributes of a node representing a phoenix
<span class="ansi38-255165000"> (: phoenixAttributes (-> (List DOT.Attribute)))
 
</span><span class="ansi38-255165000"> (= (phoenixAttributes)  
  (Cons 
    (DOT.MkLabelAttribute "\"Φ\"") 
    (Cons 
      (DOT.MkShapeAttribute DOT.Shape.Plain) Nil)))
 
</span>;;;; Return the default attributes of an edge providing the term to use
;;;; as edge label.  Typically that term may represent a type.
<span class="ansi38-255165000"> (: edgeAttributes (-> Atom (List DOT.Attribute)))
 
</span><span class="ansi38-255165000"> (= (edgeAttributes $term)  
  (Cons 
    (DOT.MkLabelAttribute (let $rt (repr $term) (repr $rt))) Nil))
 
</span>;;;; Build the DOT data structure corresponding to a given term.  That
;;;; function is crafted around the assumption that the input term is an
;;;; AI service composition, which, from overall standpoint, corresponds
;;;; to a unary function.
<span class="ansi38-255165000"> (: toDOT (-> Atom DOT))
 
</span><span class="ansi38-255165000"> (= (toDOT $term)  
  (let* 
    ( ($ext_in (inputNode)) 
      ($ext_out (outputNode)) 
      ( (MkDOT $nodes $edges $entry $exit $attributes) (toDOT_ (Just $ext_in) (Just $ext_out) $term)) 
      ($νnodes (Cons $ext_in (Cons $ext_out $nodes)))) 
    (MkDOT $νnodes $edges $ext_in $ext_out 
      (List.append 
        (globalAttributes) $attributes))))
 
</span>;;;; Make empty DOT data structure
<span class="ansi38-255165000"> (: mkEmptyDOT (-> DOT))
 
</span><span class="ansi38-255165000"> (= (mkEmptyDOT)  
  (MkDOT Nil Nil 
    (MkGroundedIdentifier "") 
    (MkGroundedIdentifier "") Nil))
 
</span>;;;; Output the string representing the label corresponding to an
;;;; identifier in DOT format
<span class="ansi38-255165000"> (: DOT.Identifier.toLabelString (-> DOT.Identifier String))
 
</span><span class="ansi38-255165000"> (= (DOT.Identifier.toLabelString (DOT.MkSymbolIdentifier $symbol $index))  
  (let $sr 
    (repr $symbol) 
    (repr $sr)))
 
</span><span class="ansi38-255165000"> (= (DOT.Identifier.toLabelString (DOT.MkGroundedIdentifier $grounded))  
  (let $gr 
    (repr $grounded) 
    (repr $gr)))
 
</span>;;;; Output the label attribute corresponding to an identifier
<span class="ansi38-255165000"> (: DOT.Identifier.toLabelAttribute (-> DOT.Identifier DOT.Attribute))
 
</span><span class="ansi38-255165000"> (= (DOT.Identifier.toLabelAttribute $identifier)  
  (DOT.MkLabelAttribute (DOT.Identifier.toLabelString $identifier)))
 
</span>;;;; Test DOT.Identifier.toLabelAttribute
<span class="ansi38-013099040">

!(assertEqual (DOT.Identifier.toLabelAttribute (DOT.MkSymbolIdentifier mix 0)) (DOT.MkLabelAttribute "\"mix\""))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_DOT.Identifier.toLabelAttribute'(D, C), E, E=['DOT.Identifier.toLabelAttribute', D], D=['DOT.MkSymbolIdentifier', mix, 0]), F=ispuU(G, G=['DOT.MkLabelAttribute', "\"mix\""]), mc__1_2_assertEqual(B, F, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.14">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.14</h3>
; 
; EVAL TEST
; took 0.000281 secs. (281.30 microseconds) 

!(assertEqual [ispeEnNC $3520642 [mc__1_1_DOT.Identifier.toLabelAttribute $3520654 $3520642] $3520646 [ = $3520646 (DOT.Identifier.toLabelAttribute $3520654) ] [ = $3520654 (DOT.MkSymbolIdentifier mix 0) ]] [ispuU $3520708 [ = $3520708 (DOT.MkLabelAttribute "\"mix\"") ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (DOT.MkLabelAttribute "\"mix\"")) 
      ( (DOT.MkLabelAttribute "\"mix\""))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (DOT.Identifier.toLabelAttribute (DOT.MkGroundedIdentifier 42)) (DOT.MkLabelAttribute "\"42\""))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_DOT.Identifier.toLabelAttribute'(D, C), E, E=['DOT.Identifier.toLabelAttribute', D], D=['DOT.MkGroundedIdentifier', 42]), F=ispuU(G, G=['DOT.MkLabelAttribute', "\"42\""]), mc__1_2_assertEqual(B, F, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.15">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.15</h3>
; 
; EVAL TEST
; took 0.000103 secs. (102.90 microseconds) 

!(assertEqual [ispeEnNC $3548410 [mc__1_1_DOT.Identifier.toLabelAttribute $3548422 $3548410] $3548414 [ = $3548414 (DOT.Identifier.toLabelAttribute $3548422) ] [ = $3548422 (DOT.MkGroundedIdentifier 42) ]] [ispuU $3548470 [ = $3548470 (DOT.MkLabelAttribute "\"42\"") ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (DOT.MkLabelAttribute "\"42\"")) 
      ( (DOT.MkLabelAttribute "\"42\""))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (DOT.Identifier.toLabelAttribute (DOT.MkGroundedIdentifier "Hello World!")) (DOT.MkLabelAttribute "\"\\\"Hello World!\\\"\""))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_DOT.Identifier.toLabelAttribute'(D, C), E, E=['DOT.Identifier.toLabelAttribute', D], D=['DOT.MkGroundedIdentifier', "Hello World!"]), F=ispuU(G, G=['DOT.MkLabelAttribute', "\"\\\"Hello World!\\\"\""]), mc__1_2_assertEqual(B, F, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.16">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.16</h3>
; 
; EVAL TEST
; took 0.000178 secs. (177.70 microseconds) 

!(assertEqual [ispeEnNC $3576236 [mc__1_1_DOT.Identifier.toLabelAttribute $3576248 $3576236] $3576240 [ = $3576240 (DOT.Identifier.toLabelAttribute $3576248) ] [ = $3576248 (DOT.MkGroundedIdentifier "Hello World!") ]] [ispuU $3576296 [ = $3576296 (DOT.MkLabelAttribute "\"\\\"Hello World!\\\"\"") ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (DOT.MkLabelAttribute "\"\\\"Hello World!\\\"\"")) 
      ( (DOT.MkLabelAttribute "\"\\\"Hello World!\\\"\""))]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Randomly sample an index, to be (almost) sure that every node has a
;;;; unique ID.
<span class="ansi38-255165000"> (: random-index (-> Number))
 
</span><span class="ansi38-255165000"> (= (random-index)  
  (random-int &rng 0 1_000_000))
 
</span>;;;; Test random-index
<span class="ansi38-013099040">

!(set-random-seed &rng 0)

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    'mc__1_2_set-random-seed'(rng('&rng', _), 0, A)).

</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (random-index) 823576)

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnN(C, 'mc__1_0_random-index'(C), D, D=['random-index']), E=ispu(823576), mc__1_2_assertEqual(B, E, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.17">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.17</h3>
; 
; EVAL TEST
; took 0.000231 secs. (231.30 microseconds) 

!(assertEqual [ispeEnN $3628138 [mc__1_0_random-index $3628138] $3628142 [ = $3628142 (random-index) ]] [ispu 823576])

<span class="ansi31">  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (885440) 
      (823576)]]
</span>
Deterministic: <span class="ansi33">(Error (assertEqual [ispeEnN $3620214 [mc__1_0_random-index $3620214] $3620220 [ = $3620220 (random-index) ]] [ispu 823576]) ('
Got: ' (885440) '
EXP: ' (823576)))
</span>;;;; Create edges between optionally provided entry and exit nodes and
;;;; internal entry and exit nodes
<span class="ansi38-255165000"> (: externalToInteralEdges (-> (Maybe DOT.Node) (Maybe DOT.Node) Atom Atom (List DOT.Attribute) (List DOT.Attribute) (List DOT.Edge)))
 
</span><span class="ansi38-255165000"> (= (externalToInteralEdges (Just $ext_entry) (Just $ext_exit) $int_entry $int_exit $entry_attrs $exit_attrs)  
  (Cons 
    (DOT.MkEdge $ext_entry $int_entry $entry_attrs) 
    (Cons 
      (DOT.MkEdge $int_exit $ext_exit $exit_attrs) Nil)))
 
</span><span class="ansi38-255165000"> (= (externalToInteralEdges (Just $ext_entry) Nothing $int_entry $int_exit $entry_attrs $exit_attrs)  
  (Cons 
    (DOT.MkEdge $ext_entry $int_entry $entry_attrs) Nil))
 
</span><span class="ansi38-255165000"> (= (externalToInteralEdges Nothing (Just $ext_exit) $int_entry $int_exit $entry_attrs $exit_attrs)  
  (Cons 
    (DOT.MkEdge $int_exit $ext_exit $exit_attrs) Nil))
 
</span><span class="ansi38-255165000"> (= (externalToInteralEdges Nothing Nothing $int_entry $int_exit $entry_attrs $exit_attrs)  Nil)
 
</span>;;;; Like toDOT but it is the recursive definition, not the entry point.
;;;; It also adds two extra arguments, optional entry and exit nodes
;;;; external the graph to be produced.  The returned graph will
;;;; possibly contain links between the external nodes, if these are
;;;; provided, and the internal entry and exit nodes of the given term.
;;;; It will not contain the external nodes, these will need to be added
;;;; by the called if needed.
;;;;
;;;; TODO: it should actually take a list of entry nodes, corresponding
;;;; to the arity of the function corresponding to the term.  But to
;;;; determine that arity we need the type.
<span class="ansi38-255165000"> (: toDOT_ (-> (Maybe DOT.Node) (Maybe DOT.Node) Atom DOT))
 
</span><span class="ansi38-255165000"> (= (toDOT_ $ext_entry $ext_exit $term)  
  (case 
    (get-metatype $term) 
    ( (Symbol (let* (($id (DOT.MkSymbolIdentifier $term (random-index))) ($attrs (Cons (DOT.Identifier.toLabelAttribute $id) (functionAttributes))) ($node (DOT.MkNode $id $attrs)) ($nodes (Cons $node Nil)) ($edges (externalToInteralEdges $ext_entry $ext_exit $node $node Nil Nil))) (MkDOT $nodes $edges $node $node Nil))) 
      (Grounded (let* (($id (if (== $term coerce) (DOT.MkSymbolIdentifier $term (random-index)) (DOT.MkGroundedIdentifier $term))) ($attrs (Cons (DOT.Identifier.toLabelAttribute $id) (if (== $term coerce) (functionAttributes) (constantAttributes)))) ($node (DOT.MkNode $id $attrs)) ($nodes (Cons $node Nil)) ($edges (externalToInteralEdges $ext_entry $ext_exit $node $node Nil Nil))) (MkDOT $nodes $edges $node $node Nil))) 
      (Expression (case $term ((() (mkEmptyDOT)) ((: $f $ty) (let (MkDOT $fnodes $fedges $fentry $fexit $fattrs) (toDOT_ Nothing Nothing $f) (case (get-metatype $ty) ((Expression (case $ty (((-> $inty $outy) (let* (($inty_attr (edgeAttributes $inty)) ($outy_attr (edgeAttributes $outy)) ($ext_edges (externalToInteralEdges $ext_entry $ext_exit $fentry $fexit $inty_attr $outy_attr)) ($edges (List.append $ext_edges $fedges))) (MkDOT $fnodes $edges $fentry $fexit $fattrs))) ((-> $inty1 $inty2 $outy) (let* (($outy_attr (edgeAttributes $outy)) ($ext_edges (externalToInteralEdges Nothing $ext_exit $fentry $fexit Nil $outy_attr)) ($edges (List.append $ext_edges $fedges))) (MkDOT $fnodes $edges $fentry $fexit $fattrs))) ($else (let* (($ty_attr (edgeAttributes $ty)) ($ext_edges (externalToInteralEdges Nothing $ext_exit $fentry $fexit Nil $ty_attr)) ($edges (List.append $ext_edges $fedges))) (MkDOT $fnodes $edges $fentry $fexit $fattrs)))))) ($else (let* (($ty_attr (edgeAttributes $ty)) ($ext_edges (externalToInteralEdges Nothing $ext_exit $fentry $fexit Nil $ty_attr)) ($edges (List.append $ext_edges $fedges))) (MkDOT $fnodes $edges $fentry $fexit $fattrs))))))) ((. $f $g) (let* (((MkDOT $gnodes $gedges $gentry $gexit $gattrs) (toDOT_ $ext_entry Nothing $g)) ((MkDOT $fnodes $fedges $fentry $fexit $fattrs) (toDOT_ (Just $gexit) $ext_exit $f)) ($nodes (List.append $fnodes $gnodes)) ($edges (List.append $fedges $gedges)) ($attrs (List.append $fattrs $gattrs))) (MkDOT $nodes $edges $gentry $fexit $attrs))) ((Φ $f $g $h) (let* (((MkDOT $fnodes $fedges $fentry $fexit $fattrs) (toDOT_ Nothing $ext_exit $f)) ($Φid (DOT.MkSymbolIdentifier Φ (random-index))) ($Φ (DOT.MkNode $Φid (phoenixAttributes))) ($ext_edges (externalToInteralEdges $ext_entry Nothing $Φ $Φ Nil Nil)) ((MkDOT $gnodes $gedges $gentry $gexit $gattrs) (toDOT_ (Just $Φ) (Just $fentry) $g)) ((MkDOT $hnodes $hedges $hentry $hexit $hattrs) (toDOT_ (Just $Φ) (Just $fentry) $h)) ($nodes (Cons $Φ (List.append3 $fnodes $gnodes $hnodes))) ($edges (List.append4 $ext_edges $fedges $gedges $hedges)) ($attrs (List.append3 $fattrs $gattrs $hattrs))) (MkDOT $nodes $edges $Φ $fexit $attrs))) (($f $x) (let* (((MkDOT $fnodes $fedges $fentry $fexit $fattrs) (toDOT_ $ext_entry $ext_exit $f)) ((MkDOT $xnodes $xedges $xentry $xexit $xattrs) (toDOT_ Nothing (Just $fentry) $x)) ($nodes (List.append $fnodes $xnodes)) ($edges (List.append $fedges $xedges)) ($attrs (List.append $fattrs $xattrs))) (MkDOT $nodes $edges $fentry $fexit $attrs))) (($f $x $y) (let* (((MkDOT $fnodes $fedges $fentry $fexit $fattrs) (toDOT_ $ext_entry $ext_exit $f)) ((MkDOT $xnodes $xedges $xentry $xexit $xattrs) (toDOT_ Nothing (Just $fentry) $x)) ((MkDOT $ynodes $yedges $yentry $yexit $yattrs) (toDOT_ Nothing (Just $fentry) $y)) ($nodes (List.append3 $fnodes $xnodes $ynodes)) ($edges (List.append3 $fedges $xedges $yedges)) ($attrs (List.append3 $fattrs $xattrs $yattrs))) (MkDOT $nodes $edges $fentry $fexit $attrs))) (($f $x $y $z) (mkEmptyDOT)) ($else (mkEmptyDOT))))) 
      ($else (mkEmptyDOT)))))
 
</span>;;;; Test toDOT
<span class="ansi38-013099040">

!(set-random-seed &rng 0)

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    'mc__1_2_set-random-seed'(rng('&rng', _), 0, A)).

</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (toDOT mix) (MkDOT (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier mix 823576) (Cons (DOT.MkLabelAttribute "\"mix\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil))) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier mix 823576) (Cons (DOT.MkLabelAttribute "\"mix\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier mix 823576) (Cons (DOT.MkLabelAttribute "\"mix\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) Nil) Nil)) (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkRankdirAttribute DOT.Rankdir.BT) Nil)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, mc__1_1_toDOT(D, C), E, E=[toDOT, D], D=ispu(mix)), F=ispuU(G, (H=['DOT.MkSymbolIdentifier', '__IN__', 0], I=['DOT.MkLabelAttribute', "\"\""], J=['DOT.MkShapeAttribute', 'DOT.Shape.None'], K=['Cons', J, 'Nil'], L=['Cons', I, K], M=['DOT.MkNode', H, L], N=['DOT.MkSymbolIdentifier', '__OUT__', 0], O=['DOT.MkLabelAttribute', "\"\""], P=['DOT.MkShapeAttribute', 'DOT.Shape.None'], Q=['Cons', P, 'Nil'], R=['Cons', O, Q], S=['DOT.MkNode', N, R], T=['DOT.MkSymbolIdentifier', mix, 823576], U=['DOT.MkLabelAttribute', "\"mix\""], V=['DOT.MkShapeAttribute', 'DOT.Shape.Box'], W=['Cons', V, 'Nil'], X=['Cons', U, W], Y=['DOT.MkNode', T, X], Z=['Cons', Y, 'Nil'], A1=['Cons', S, Z], B1=['Cons', M, A1], C1=['DOT.MkSymbolIdentifier', '__IN__', 0], D1=['DOT.MkLabelAttribute', "\"\""], E1=['DOT.MkShapeAttribute', 'DOT.Shape.None'], F1=['Cons', E1, 'Nil'], G1=['Cons', D1, F1], H1=['DOT.MkNode', C1, G1], I1=['DOT.MkSymbolIdentifier', mix, 823576], J1=['DOT.MkLabelAttribute', "\"mix\""], K1=['DOT.MkShapeAttribute', 'DOT.Shape.Box'], L1=['Cons', K1, 'Nil'], M1=['Cons', J1, L1], N1=['DOT.MkNode', I1, M1], O1=['DOT.MkEdge', H1, N1, 'Nil'], P1=['DOT.MkSymbolIdentifier', mix, 823576], Q1=['DOT.MkLabelAttribute', "\"mix\""], R1=['DOT.MkShapeAttribute', 'DOT.Shape.Box'], S1=['Cons', R1, 'Nil'], T1=['Cons', Q1, S1], U1=['DOT.MkNode', P1, T1], V1=['DOT.MkSymbolIdentifier', '__OUT__', 0], W1=['DOT.MkLabelAttribute', "\"\""], X1=['DOT.MkShapeAttribute', 'DOT.Shape.None'], Y1=['Cons', X1, 'Nil'], Z1=['Cons', W1, Y1], A2=['DOT.MkNode', V1, Z1], B2=['DOT.MkEdge', U1, A2, 'Nil'], C2=['Cons', B2, 'Nil'], D2=['Cons', O1, C2], E2=['DOT.MkSymbolIdentifier', '__IN__', 0], F2=['DOT.MkLabelAttribute', "\"\""], G2=['DOT.MkShapeAttribute', 'DOT.Shape.None'], H2=['Cons', G2, 'Nil'], I2=['Cons', F2, H2], J2=['DOT.MkNode', E2, I2], K2=['DOT.MkSymbolIdentifier', '__OUT__', 0], L2=['DOT.MkLabelAttribute', "\"\""], M2=['DOT.MkShapeAttribute', 'DOT.Shape.None'], N2=['Cons', M2, 'Nil'], O2=['Cons', L2, N2], P2=['DOT.MkNode', K2, O2], Q2=['DOT.MkRankdirAttribute', 'DOT.Rankdir.BT'], R2=['Cons', Q2, 'Nil'], G=['MkDOT', B1, D2, J2, P2, R2])), mc__1_2_assertEqual(B, F, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.18">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.18</h3>
; 
; EVAL TEST
; took 0.000400 secs. (400.00 microseconds) 

!(assertEqual [ispeEnNC $5506222 [mc__1_1_toDOT $5506234 $5506222] $5506226 [ = $5506226 (toDOT $5506234) ] [ = $5506234 [ispu mix] ]] [ispuU $5506274 [ , [ = $5506286 (DOT.MkSymbolIdentifier __IN__ 0) ] [ , [ = $5506316 (DOT.MkLabelAttribute "\"\"") ] [ , [ = $5506340 (DOT.MkShapeAttribute DOT.Shape.None) ] [ , [ = $5506364 (Cons $5506340 Nil) ] [ , [ = $5506394 (Cons $5506316 $5506364) ] [ , [ = $5506424 (DOT.MkNode $5506286 $5506394) ] [ , [ = $5506454 (DOT.MkSymbolIdentifier __OUT__ 0) ] [ , [ = $5506484 (DOT.MkLabelAttribute "\"\"") ] [ , [ = $5506508 (DOT.MkShapeAttribute DOT.Shape.None) ] [ , [ = $5506532 (Cons $5506508 Nil) ] [ , [ = $5506562 (Cons $5506484 $5506532) ] [ , [ = $5506592 (DOT.MkNode $5506454 $5506562) ] [ , [ = $5506622 (DOT.MkSymbolIdentifier mix 823576) ] [ , [ = $5506652 (DOT.MkLabelAttribute "\"mix\"") ] [ , [ = $5506676 (DOT.MkShapeAttribute DOT.Shape.Box) ] [ , [ = $5506700 (Cons $5506676 Nil) ] [ , [ = $5506730 (Cons $5506652 $5506700) ] [ , [ = $5506760 (DOT.MkNode $5506622 $5506730) ] [ , [ = $5506790 (Cons $5506760 Nil) ] [ , [ = $5506820 (Cons $5506592 $5506790) ] [ , [ = $5506850 (Cons $5506424 $5506820) ] [ , [ = $5506880 (DOT.MkSymbolIdentifier __IN__ 0) ] [ , [ = $5506910 (DOT.MkLabelAttribute "\"\"") ] [ , [ = $5506934 (DOT.MkShapeAttribute DOT.Shape.None) ] [ , [ = $5506958 (Cons $5506934 Nil) ] [ , [ = $5506988 (Cons $5506910 $5506958) ] [ , [ = $5507018  ['DOT.MkNode',_5506880,_5506988]  ] [ ,  _5507048=['DOT.MkSymbolIdentifier',mix,823576]   _5507078=['DOT.MkLabelAttribute',"\"mix\""],_5507102=['DOT.MkShapeAttribute','DOT.Shape.Box'],_5507126=['Cons',_5507102,'Nil'],_5507156=['Cons',_5507078,_5507126],_5507186=['DOT.MkNode',_5507048,_5507156],_5507216=['DOT.MkEdge',_5507018,_5507186,'Nil'],_5507252=['DOT.MkSymbolIdentifier',mix,823576],_5507282=['DOT.MkLabelAttribute',"\"mix\""],_5507306=['DOT.MkShapeAttribute','DOT.Shape.Box'],_5507330=['Cons',_5507306,'Nil'],_5507360=['Cons',_5507282,_5507330],_5507390=['DOT.MkNode',_5507252,_5507360],_5507420=['DOT.MkSymbolIdentifier','__OUT__',0],_5507450=['DOT.MkLabelAttribute',"\"\""],_5507474=['DOT.MkShapeAttribute','DOT.Shape.None'],_5507498=['Cons',_5507474,'Nil'],_5507528=['Cons',_5507450,_5507498],_5507558=['DOT.MkNode',_5507420,_5507528],_5507588=['DOT.MkEdge',_5507390,_5507558,'Nil'],_5507624=['Cons',_5507588,'Nil'],_5507654=['Cons',_5507216,_5507624],_5507684=['DOT.MkSymbolIdentifier','__IN__',0],_5507714=['DOT.MkLabelAttribute',"\"\""],_5507738=['DOT.MkShapeAttribute','DOT.Shape.None'],_5507762=['Cons',_5507738,'Nil'],_5507792=['Cons',_5507714,_5507762],_5507822=['DOT.MkNode',_5507684,_5507792],_5507852=['DOT.MkSymbolIdentifier','__OUT__',0],_5507882=['DOT.MkLabelAttribute',"\"\""],_5507906=['DOT.MkShapeAttribute','DOT.Shape.None'],_5507930=['Cons',_5507906,'Nil'],_5507960=['Cons',_5507882,_5507930],_5507990=['DOT.MkNode',_5507852,_5507960],_5508020=['DOT.MkRankdirAttribute','DOT.Rankdir.BT'],_5508044=['Cons',_5508020,'Nil'],_5506274=['MkDOT',_5506850,_5507654,_5507822,_5507990,_5508044]  ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ]])

<span class="ansi31">  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (MkDOT 
          (Cons 
            (DOT.MkNode 
              (DOT.MkSymbolIdentifier __IN__ 0) 
              (Cons 
                (DOT.MkLabelAttribute "\"\"") 
                (Cons 
                  (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
            (Cons 
              (DOT.MkNode 
                (DOT.MkSymbolIdentifier __OUT__ 0) 
                (Cons 
                  (DOT.MkLabelAttribute "\"\"") 
                  (Cons 
                    (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
              (Cons 
                (DOT.MkNode 
                  (DOT.MkSymbolIdentifier mix 885440) 
                  (Cons 
                    (DOT.MkLabelAttribute "\"mix\"") 
                    (Cons 
                      (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil))) 
          (Cons 
            (DOT.MkEdge 
              (DOT.MkNode 
                (DOT.MkSymbolIdentifier __IN__ 0) 
                (Cons 
                  (DOT.MkLabelAttribute "\"\"") 
                  (Cons 
                    (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
              (DOT.MkNode 
                (DOT.MkSymbolIdentifier mix 885440) 
                (Cons 
                  (DOT.MkLabelAttribute "\"mix\"") 
                  (Cons 
                    (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil) 
            (Cons 
              (DOT.MkEdge 
                (DOT.MkNode 
                  (DOT.MkSymbolIdentifier mix 885440) 
                  (Cons 
                    (DOT.MkLabelAttribute "\"mix\"") 
                    (Cons 
                      (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) 
                (DOT.MkNode 
                  (DOT.MkSymbolIdentifier __OUT__ 0) 
                  (Cons 
                    (DOT.MkLabelAttribute "\"\"") 
                    (Cons 
                      (DOT.MkShapeAttribute DOT.Shape.None) Nil))) Nil) Nil)) 
          (DOT.MkNode 
            (DOT.MkSymbolIdentifier __IN__ 0) 
            (Cons 
              (DOT.MkLabelAttribute "\"\"") 
              (Cons 
                (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
          (DOT.MkNode 
            (DOT.MkSymbolIdentifier __OUT__ 0) 
            (Cons 
              (DOT.MkLabelAttribute "\"\"") 
              (Cons 
                (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
          (Cons 
            (DOT.MkRankdirAttribute DOT.Rankdir.BT) Nil))) 
      ( (MkDOT 
          (Cons 
            (DOT.MkNode 
              (DOT.MkSymbolIdentifier __IN__ 0) 
              (Cons 
                (DOT.MkLabelAttribute "\"\"") 
                (Cons 
                  (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
            (Cons 
              (DOT.MkNode 
                (DOT.MkSymbolIdentifier __OUT__ 0) 
                (Cons 
                  (DOT.MkLabelAttribute "\"\"") 
                  (Cons 
                    (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
              (Cons 
                (DOT.MkNode 
                  (DOT.MkSymbolIdentifier mix 823576) 
                  (Cons 
                    (DOT.MkLabelAttribute "\"mix\"") 
                    (Cons 
                      (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil))) 
          (Cons 
            (DOT.MkEdge 
              (DOT.MkNode 
                (DOT.MkSymbolIdentifier __IN__ 0) 
                (Cons 
                  (DOT.MkLabelAttribute "\"\"") 
                  (Cons 
                    (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
              (DOT.MkNode 
                (DOT.MkSymbolIdentifier mix 823576) 
                (Cons 
                  (DOT.MkLabelAttribute "\"mix\"") 
                  (Cons 
                    (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil) 
            (Cons 
              (DOT.MkEdge 
                (DOT.MkNode 
                  (DOT.MkSymbolIdentifier mix 823576) 
                  (Cons 
                    (DOT.MkLabelAttribute "\"mix\"") 
                    (Cons 
                      (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) 
                (DOT.MkNode 
                  (DOT.MkSymbolIdentifier __OUT__ 0) 
                  (Cons 
                    (DOT.MkLabelAttribute "\"\"") 
                    (Cons 
                      (DOT.MkShapeAttribute DOT.Shape.None) Nil))) Nil) Nil)) 
          (DOT.MkNode 
            (DOT.MkSymbolIdentifier __IN__ 0) 
            (Cons 
              (DOT.MkLabelAttribute "\"\"") 
              (Cons 
                (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
          (DOT.MkNode 
            (DOT.MkSymbolIdentifier __OUT__ 0) 
            (Cons 
              (DOT.MkLabelAttribute "\"\"") 
              (Cons 
                (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
          (Cons 
            (DOT.MkRankdirAttribute DOT.Rankdir.BT) Nil)))]]
</span>
Deterministic: <span class="ansi33">(Error (assertEqual [ispeEnNC $5380284 [mc__1_1_toDOT $5380472 $5380284] $5380290 [ = $5380290 (toDOT $5380472) ] [ = $5380472 [ispu mix] ]] [ispuU $5380648 [ , [ = $5383624 (DOT.MkSymbolIdentifier __IN__ 0) ] [ , [ = $5385820 (DOT.MkLabelAttribute "\"\"") ] [ , [ = $5387880 (DOT.MkShapeAttribute DOT.Shape.None) ] [ , [ = $5386950 (Cons $5387880 Nil) ] [ , [ = $5384890 (Cons $5385820 $5386950) ] [ , [ = $5382700 (DOT.MkNode $5383624 $5384890) ] [ , [ = $5391892 (DOT.MkSymbolIdentifier __OUT__ 0) ] [ , [ = $5394088 (DOT.MkLabelAttribute "\"\"") ] [ , [ = $5396148 (DOT.MkShapeAttribute DOT.Shape.None) ] [ , [ = $5395218 (Cons $5396148 Nil) ] [ , [ = $5393158 (Cons $5394088 $5395218) ] [ , [ = $5390968 (DOT.MkNode $5391892 $5393158) ] [ , [ = $5400160 (DOT.MkSymbolIdentifier mix 823576) ] [ , [ = $5402356 (DOT.MkLabelAttribute "\"mix\"") ] [ , [ = $5404416 (DOT.MkShapeAttribute DOT.Shape.Box) ] [ , [ = $5403486 (Cons $5404416 Nil) ] [ , [ = $5401426 (Cons $5402356 $5403486) ] [ , [ = $5399236 (DOT.MkNode $5400160 $5401426) ] [ , [ = $5398306 (Cons $5399236 Nil) ] [ , [ = $5390038 (Cons $5390968 $5398306) ] [ , [ = $5381770 (Cons $5382700 $5390038) ] [ , [ = $5411158 (DOT.MkSymbolIdentifier __IN__ 0) ] [ , [ = $5413354 (DOT.MkLabelAttribute "\"\"") ] [ , [ = $5415414 (DOT.MkShapeAttribute DOT.Shape.None) ] [ , [ = $5414484 (Cons $5415414 Nil) ] [ , [ = $5412424 (Cons $5413354 $5414484) ] [ , [ = $5410234  ['DOT.MkNode',_5411158,_5412424]  ] [ ,  _5418496=['DOT.MkSymbolIdentifier',mix,823576]   _5420692=['DOT.MkLabelAttribute',"\"mix\""],_5422752=['DOT.MkShapeAttribute','DOT.Shape.Box'],_5421822=['Cons',_5422752,'Nil'],_5419762=['Cons',_5420692,_5421822],_5417572=['DOT.MkNode',_5418496,_5419762],_5409252=['DOT.MkEdge',_5410234,_5417572,'Nil'],_5428390=['DOT.MkSymbolIdentifier',mix,823576],_5430586=['DOT.MkLabelAttribute',"\"mix\""],_5432646=['DOT.MkShapeAttribute','DOT.Shape.Box'],_5431716=['Cons',_5432646,'Nil'],_5429656=['Cons',_5430586,_5431716],_5427466=['DOT.MkNode',_5428390,_5429656],_5435728=['DOT.MkSymbolIdentifier','__OUT__',0],_5437924=['DOT.MkLabelAttribute',"\"\""],_5439984=['DOT.MkShapeAttribute','DOT.Shape.None'],_5439054=['Cons',_5439984,'Nil'],_5436994=['Cons',_5437924,_5439054],_5434804=['DOT.MkNode',_5435728,_5436994],_5426484=['DOT.MkEdge',_5427466,_5434804,'Nil'],_5425554=['Cons',_5426484,'Nil'],_5408322=['Cons',_5409252,_5425554],_5445234=['DOT.MkSymbolIdentifier','__IN__',0],_5447430=['DOT.MkLabelAttribute',"\"\""],_5449490=['DOT.MkShapeAttribute','DOT.Shape.None'],_5448560=['Cons',_5449490,'Nil'],_5446500=['Cons',_5447430,_5448560],_5444310=['DOT.MkNode',_5445234,_5446500],_5452572=['DOT.MkSymbolIdentifier','__OUT__',0],_5454768=['DOT.MkLabelAttribute',"\"\""],_5456828=['DOT.MkShapeAttribute','DOT.Shape.None'],_5455898=['Cons',_5456828,'Nil'],_5453838=['Cons',_5454768,_5455898],_5451648=['DOT.MkNode',_5452572,_5453838],_5459916=['DOT.MkRankdirAttribute','DOT.Rankdir.BT'],_5458986=['Cons',_5459916,'Nil'],_5380648=['MkDOT',_5381770,_5408322,_5444310,_5451648,_5458986]  ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ]]) ('
Got: ' ((MkDOT (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier mix 885440) (Cons (DOT.MkLabelAttribute "\"mix\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil))) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier mix 885440) (Cons (DOT.MkLabelAttribute "\"mix\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier mix 885440) (Cons (DOT.MkLabelAttribute "\"mix\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) Nil) Nil)) (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkRankdirAttribute DOT.Rankdir.BT) Nil))) '
EXP: ' ((MkDOT (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier mix 823576) (Cons (DOT.MkLabelAttribute "\"mix\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil))) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier mix 823576) (Cons (DOT.MkLabelAttribute "\"mix\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier mix 823576) (Cons (DOT.MkLabelAttribute "\"mix\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) Nil) Nil)) (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkRankdirAttribute DOT.Rankdir.BT) Nil)))))
</span><span class="ansi38-013099040">

!(set-random-seed &rng 0)

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    'mc__1_2_set-random-seed'(rng('&rng', _), 0, A)).

</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (toDOT (: f (-> A B))) (MkDOT (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier f 823576) (Cons (DOT.MkLabelAttribute "\"f\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil))) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier f 823576) (Cons (DOT.MkLabelAttribute "\"f\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) (Cons (DOT.MkLabelAttribute "\"A\"") Nil)) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier f 823576) (Cons (DOT.MkLabelAttribute "\"f\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkLabelAttribute "\"B\"") Nil)) Nil)) (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkRankdirAttribute DOT.Rankdir.BT) Nil)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, mc__1_1_toDOT(D, C), E, E=[toDOT, D], D=ispuU(F, (G=[->, 'A', 'B'], F=[:, f, G]))), H=ispuU(I, (J=['DOT.MkSymbolIdentifier', '__IN__', 0], K=['DOT.MkLabelAttribute', "\"\""], L=['DOT.MkShapeAttribute', 'DOT.Shape.None'], M=['Cons', L, 'Nil'], N=['Cons', K, M], O=['DOT.MkNode', J, N], P=['DOT.MkSymbolIdentifier', '__OUT__', 0], Q=['DOT.MkLabelAttribute', "\"\""], R=['DOT.MkShapeAttribute', 'DOT.Shape.None'], S=['Cons', R, 'Nil'], T=['Cons', Q, S], U=['DOT.MkNode', P, T], V=['DOT.MkSymbolIdentifier', f, 823576], W=['DOT.MkLabelAttribute', "\"f\""], X=['DOT.MkShapeAttribute', 'DOT.Shape.Box'], Y=['Cons', X, 'Nil'], Z=['Cons', W, Y], A1=['DOT.MkNode', V, Z], B1=['Cons', A1, 'Nil'], C1=['Cons', U, B1], D1=['Cons', O, C1], E1=['DOT.MkSymbolIdentifier', '__IN__', 0], F1=['DOT.MkLabelAttribute', "\"\""], G1=['DOT.MkShapeAttribute', 'DOT.Shape.None'], H1=['Cons', G1, 'Nil'], I1=['Cons', F1, H1], J1=['DOT.MkNode', E1, I1], K1=['DOT.MkSymbolIdentifier', f, 823576], L1=['DOT.MkLabelAttribute', "\"f\""], M1=['DOT.MkShapeAttribute', 'DOT.Shape.Box'], N1=['Cons', M1, 'Nil'], O1=['Cons', L1, N1], P1=['DOT.MkNode', K1, O1], Q1=['DOT.MkLabelAttribute', "\"A\""], R1=['Cons', Q1, 'Nil'], S1=['DOT.MkEdge', J1, P1, R1], T1=['DOT.MkSymbolIdentifier', f, 823576], U1=['DOT.MkLabelAttribute', "\"f\""], V1=['DOT.MkShapeAttribute', 'DOT.Shape.Box'], W1=['Cons', V1, 'Nil'], X1=['Cons', U1, W1], Y1=['DOT.MkNode', T1, X1], Z1=['DOT.MkSymbolIdentifier', '__OUT__', 0], A2=['DOT.MkLabelAttribute', "\"\""], B2=['DOT.MkShapeAttribute', 'DOT.Shape.None'], C2=['Cons', B2, 'Nil'], D2=['Cons', A2, C2], E2=['DOT.MkNode', Z1, D2], F2=['DOT.MkLabelAttribute', "\"B\""], G2=['Cons', F2, 'Nil'], H2=['DOT.MkEdge', Y1, E2, G2], I2=['Cons', H2, 'Nil'], J2=['Cons', S1, I2], K2=['DOT.MkSymbolIdentifier', '__IN__', 0], L2=['DOT.MkLabelAttribute', "\"\""], M2=['DOT.MkShapeAttribute', 'DOT.Shape.None'], N2=['Cons', M2, 'Nil'], O2=['Cons', L2, N2], P2=['DOT.MkNode', K2, O2], Q2=['DOT.MkSymbolIdentifier', '__OUT__', 0], R2=['DOT.MkLabelAttribute', "\"\""], S2=['DOT.MkShapeAttribute', 'DOT.Shape.None'], T2=['Cons', S2, 'Nil'], U2=['Cons', R2, T2], V2=['DOT.MkNode', Q2, U2], W2=['DOT.MkRankdirAttribute', 'DOT.Rankdir.BT'], X2=['Cons', W2, 'Nil'], I=['MkDOT', D1, J2, P2, V2, X2])), mc__1_2_assertEqual(B, H, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.19">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.19</h3>
; 
; EVAL TEST
; took 0.000789 secs. (788.80 microseconds) 

!(assertEqual [ispeEnNC $5716234 [mc__1_1_toDOT $5716246 $5716234] $5716238 [ = $5716238 (toDOT $5716246) ] [ = $5716246 [ispuU $5716276 [ , [ = $5716288 (-> A B) ] [ = $5716276 (: f $5716288) ] ]] ]] [ispuU $5716342 [ , [ = $5716354 (DOT.MkSymbolIdentifier __IN__ 0) ] [ , [ = $5716384 (DOT.MkLabelAttribute "\"\"") ] [ , [ = $5716408 (DOT.MkShapeAttribute DOT.Shape.None) ] [ , [ = $5716432 (Cons $5716408 Nil) ] [ , [ = $5716462 (Cons $5716384 $5716432) ] [ , [ = $5716492 (DOT.MkNode $5716354 $5716462) ] [ , [ = $5716522 (DOT.MkSymbolIdentifier __OUT__ 0) ] [ , [ = $5716552 (DOT.MkLabelAttribute "\"\"") ] [ , [ = $5716576 (DOT.MkShapeAttribute DOT.Shape.None) ] [ , [ = $5716600 (Cons $5716576 Nil) ] [ , [ = $5716630 (Cons $5716552 $5716600) ] [ , [ = $5716660 (DOT.MkNode $5716522 $5716630) ] [ , [ = $5716690 (DOT.MkSymbolIdentifier f 823576) ] [ , [ = $5716720 (DOT.MkLabelAttribute "\"f\"") ] [ , [ = $5716744 (DOT.MkShapeAttribute DOT.Shape.Box) ] [ , [ = $5716768 (Cons $5716744 Nil) ] [ , [ = $5716798 (Cons $5716720 $5716768) ] [ , [ = $5716828 (DOT.MkNode $5716690 $5716798) ] [ , [ = $5716858 (Cons $5716828 Nil) ] [ , [ = $5716888 (Cons $5716660 $5716858) ] [ , [ = $5716918 (Cons $5716492 $5716888) ] [ , [ = $5716948 (DOT.MkSymbolIdentifier __IN__ 0) ] [ , [ = $5716978 (DOT.MkLabelAttribute "\"\"") ] [ , [ = $5717002 (DOT.MkShapeAttribute DOT.Shape.None) ] [ , [ = $5717026 (Cons $5717002 Nil) ] [ , [ = $5717056 (Cons $5716978 $5717026) ] [ , [ = $5717086  ['DOT.MkNode',_5716948,_5717056]  ] [ ,  _5717116=['DOT.MkSymbolIdentifier',f,823576]   _5717146=['DOT.MkLabelAttribute',"\"f\""],_5717170=['DOT.MkShapeAttribute','DOT.Shape.Box'],_5717194=['Cons',_5717170,'Nil'],_5717224=['Cons',_5717146,_5717194],_5717254=['DOT.MkNode',_5717116,_5717224],_5717284=['DOT.MkLabelAttribute',"\"A\""],_5717308=['Cons',_5717284,'Nil'],_5717338=['DOT.MkEdge',_5717086,_5717254,_5717308],_5717374=['DOT.MkSymbolIdentifier',f,823576],_5717404=['DOT.MkLabelAttribute',"\"f\""],_5717428=['DOT.MkShapeAttribute','DOT.Shape.Box'],_5717452=['Cons',_5717428,'Nil'],_5717482=['Cons',_5717404,_5717452],_5717512=['DOT.MkNode',_5717374,_5717482],_5717542=['DOT.MkSymbolIdentifier','__OUT__',0],_5717572=['DOT.MkLabelAttribute',"\"\""],_5717596=['DOT.MkShapeAttribute','DOT.Shape.None'],_5717620=['Cons',_5717596,'Nil'],_5717650=['Cons',_5717572,_5717620],_5717680=['DOT.MkNode',_5717542,_5717650],_5717710=['DOT.MkLabelAttribute',"\"B\""],_5717734=['Cons',_5717710,'Nil'],_5717764=['DOT.MkEdge',_5717512,_5717680,_5717734],_5717800=['Cons',_5717764,'Nil'],_5717830=['Cons',_5717338,_5717800],_5717860=['DOT.MkSymbolIdentifier','__IN__',0],_5717890=['DOT.MkLabelAttribute',"\"\""],_5717914=['DOT.MkShapeAttribute','DOT.Shape.None'],_5717938=['Cons',_5717914,'Nil'],_5717968=['Cons',_5717890,_5717938],_5717998=['DOT.MkNode',_5717860,_5717968],_5718028=['DOT.MkSymbolIdentifier','__OUT__',0],_5718058=['DOT.MkLabelAttribute',"\"\""],_5718082=['DOT.MkShapeAttribute','DOT.Shape.None'],_5718106=['Cons',_5718082,'Nil'],_5718136=['Cons',_5718058,_5718106],_5718166=['DOT.MkNode',_5718028,_5718136],_5718196=['DOT.MkRankdirAttribute','DOT.Rankdir.BT'],_5718220=['Cons',_5718196,'Nil'],_5716342=['MkDOT',_5716918,_5717830,_5717998,_5718166,_5718220]  ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ]])

<span class="ansi31">  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (MkDOT 
          (Cons 
            (DOT.MkNode 
              (DOT.MkSymbolIdentifier __IN__ 0) 
              (Cons 
                (DOT.MkLabelAttribute "\"\"") 
                (Cons 
                  (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
            (Cons 
              (DOT.MkNode 
                (DOT.MkSymbolIdentifier __OUT__ 0) 
                (Cons 
                  (DOT.MkLabelAttribute "\"\"") 
                  (Cons 
                    (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
              (Cons 
                (DOT.MkNode 
                  (DOT.MkSymbolIdentifier f 885440) 
                  (Cons 
                    (DOT.MkLabelAttribute "\"f\"") 
                    (Cons 
                      (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil))) 
          (Cons 
            (DOT.MkEdge 
              (DOT.MkNode 
                (DOT.MkSymbolIdentifier __IN__ 0) 
                (Cons 
                  (DOT.MkLabelAttribute "\"\"") 
                  (Cons 
                    (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
              (DOT.MkNode 
                (DOT.MkSymbolIdentifier f 885440) 
                (Cons 
                  (DOT.MkLabelAttribute "\"f\"") 
                  (Cons 
                    (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) 
              (Cons 
                (DOT.MkLabelAttribute "\"A\"") Nil)) 
            (Cons 
              (DOT.MkEdge 
                (DOT.MkNode 
                  (DOT.MkSymbolIdentifier f 885440) 
                  (Cons 
                    (DOT.MkLabelAttribute "\"f\"") 
                    (Cons 
                      (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) 
                (DOT.MkNode 
                  (DOT.MkSymbolIdentifier __OUT__ 0) 
                  (Cons 
                    (DOT.MkLabelAttribute "\"\"") 
                    (Cons 
                      (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
                (Cons 
                  (DOT.MkLabelAttribute "\"B\"") Nil)) Nil)) 
          (DOT.MkNode 
            (DOT.MkSymbolIdentifier __IN__ 0) 
            (Cons 
              (DOT.MkLabelAttribute "\"\"") 
              (Cons 
                (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
          (DOT.MkNode 
            (DOT.MkSymbolIdentifier __OUT__ 0) 
            (Cons 
              (DOT.MkLabelAttribute "\"\"") 
              (Cons 
                (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
          (Cons 
            (DOT.MkRankdirAttribute DOT.Rankdir.BT) Nil))) 
      ( (MkDOT 
          (Cons 
            (DOT.MkNode 
              (DOT.MkSymbolIdentifier __IN__ 0) 
              (Cons 
                (DOT.MkLabelAttribute "\"\"") 
                (Cons 
                  (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
            (Cons 
              (DOT.MkNode 
                (DOT.MkSymbolIdentifier __OUT__ 0) 
                (Cons 
                  (DOT.MkLabelAttribute "\"\"") 
                  (Cons 
                    (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
              (Cons 
                (DOT.MkNode 
                  (DOT.MkSymbolIdentifier f 823576) 
                  (Cons 
                    (DOT.MkLabelAttribute "\"f\"") 
                    (Cons 
                      (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil))) 
          (Cons 
            (DOT.MkEdge 
              (DOT.MkNode 
                (DOT.MkSymbolIdentifier __IN__ 0) 
                (Cons 
                  (DOT.MkLabelAttribute "\"\"") 
                  (Cons 
                    (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
              (DOT.MkNode 
                (DOT.MkSymbolIdentifier f 823576) 
                (Cons 
                  (DOT.MkLabelAttribute "\"f\"") 
                  (Cons 
                    (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) 
              (Cons 
                (DOT.MkLabelAttribute "\"A\"") Nil)) 
            (Cons 
              (DOT.MkEdge 
                (DOT.MkNode 
                  (DOT.MkSymbolIdentifier f 823576) 
                  (Cons 
                    (DOT.MkLabelAttribute "\"f\"") 
                    (Cons 
                      (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) 
                (DOT.MkNode 
                  (DOT.MkSymbolIdentifier __OUT__ 0) 
                  (Cons 
                    (DOT.MkLabelAttribute "\"\"") 
                    (Cons 
                      (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
                (Cons 
                  (DOT.MkLabelAttribute "\"B\"") Nil)) Nil)) 
          (DOT.MkNode 
            (DOT.MkSymbolIdentifier __IN__ 0) 
            (Cons 
              (DOT.MkLabelAttribute "\"\"") 
              (Cons 
                (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
          (DOT.MkNode 
            (DOT.MkSymbolIdentifier __OUT__ 0) 
            (Cons 
              (DOT.MkLabelAttribute "\"\"") 
              (Cons 
                (DOT.MkShapeAttribute DOT.Shape.None) Nil))) 
          (Cons 
            (DOT.MkRankdirAttribute DOT.Rankdir.BT) Nil)))]]
</span>
Deterministic: <span class="ansi33">(Error (assertEqual [ispeEnNC $5580372 [mc__1_1_toDOT $5581820 $5580372] $5580378 [ = $5580378 (toDOT $5581820) ] [ = $5581820 [ispuU $5580488 [ , [ = $5580858 (-> A B) ] [ = $5580488 (: f $5580858) ] ]] ]] [ispuU $5582026 [ , [ = $5585002 (DOT.MkSymbolIdentifier __IN__ 0) ] [ , [ = $5587198 (DOT.MkLabelAttribute "\"\"") ] [ , [ = $5589258 (DOT.MkShapeAttribute DOT.Shape.None) ] [ , [ = $5588328 (Cons $5589258 Nil) ] [ , [ = $5586268 (Cons $5587198 $5588328) ] [ , [ = $5584078 (DOT.MkNode $5585002 $5586268) ] [ , [ = $5593270 (DOT.MkSymbolIdentifier __OUT__ 0) ] [ , [ = $5595466 (DOT.MkLabelAttribute "\"\"") ] [ , [ = $5597526 (DOT.MkShapeAttribute DOT.Shape.None) ] [ , [ = $5596596 (Cons $5597526 Nil) ] [ , [ = $5594536 (Cons $5595466 $5596596) ] [ , [ = $5592346 (DOT.MkNode $5593270 $5594536) ] [ , [ = $5601538 (DOT.MkSymbolIdentifier f 823576) ] [ , [ = $5603734 (DOT.MkLabelAttribute "\"f\"") ] [ , [ = $5605794 (DOT.MkShapeAttribute DOT.Shape.Box) ] [ , [ = $5604864 (Cons $5605794 Nil) ] [ , [ = $5602804 (Cons $5603734 $5604864) ] [ , [ = $5600614 (DOT.MkNode $5601538 $5602804) ] [ , [ = $5599684 (Cons $5600614 Nil) ] [ , [ = $5591416 (Cons $5592346 $5599684) ] [ , [ = $5583148 (Cons $5584078 $5591416) ] [ , [ = $5612536 (DOT.MkSymbolIdentifier __IN__ 0) ] [ , [ = $5614732 (DOT.MkLabelAttribute "\"\"") ] [ , [ = $5616792 (DOT.MkShapeAttribute DOT.Shape.None) ] [ , [ = $5615862 (Cons $5616792 Nil) ] [ , [ = $5613802 (Cons $5614732 $5615862) ] [ , [ = $5611612  ['DOT.MkNode',_5612536,_5613802]  ] [ ,  _5619874=['DOT.MkSymbolIdentifier',f,823576]   _5622070=['DOT.MkLabelAttribute',"\"f\""],_5624130=['DOT.MkShapeAttribute','DOT.Shape.Box'],_5623200=['Cons',_5624130,'Nil'],_5621140=['Cons',_5622070,_5623200],_5618950=['DOT.MkNode',_5619874,_5621140],_5627218=['DOT.MkLabelAttribute',"\"A\""],_5626288=['Cons',_5627218,'Nil'],_5610630=['DOT.MkEdge',_5611612,_5618950,_5626288],_5632148=['DOT.MkSymbolIdentifier',f,823576],_5634344=['DOT.MkLabelAttribute',"\"f\""],_5636404=['DOT.MkShapeAttribute','DOT.Shape.Box'],_5635474=['Cons',_5636404,'Nil'],_5633414=['Cons',_5634344,_5635474],_5631224=['DOT.MkNode',_5632148,_5633414],_5639486=['DOT.MkSymbolIdentifier','__OUT__',0],_5641682=['DOT.MkLabelAttribute',"\"\""],_5643742=['DOT.MkShapeAttribute','DOT.Shape.None'],_5642812=['Cons',_5643742,'Nil'],_5640752=['Cons',_5641682,_5642812],_5638562=['DOT.MkNode',_5639486,_5640752],_5646830=['DOT.MkLabelAttribute',"\"B\""],_5645900=['Cons',_5646830,'Nil'],_5630242=['DOT.MkEdge',_5631224,_5638562,_5645900],_5629312=['Cons',_5630242,'Nil'],_5609700=['Cons',_5610630,_5629312],_5651516=['DOT.MkSymbolIdentifier','__IN__',0],_5653712=['DOT.MkLabelAttribute',"\"\""],_5655772=['DOT.MkShapeAttribute','DOT.Shape.None'],_5654842=['Cons',_5655772,'Nil'],_5652782=['Cons',_5653712,_5654842],_5650592=['DOT.MkNode',_5651516,_5652782],_5658854=['DOT.MkSymbolIdentifier','__OUT__',0],_5661050=['DOT.MkLabelAttribute',"\"\""],_5663110=['DOT.MkShapeAttribute','DOT.Shape.None'],_5662180=['Cons',_5663110,'Nil'],_5660120=['Cons',_5661050,_5662180],_5657930=['DOT.MkNode',_5658854,_5660120],_5666198=['DOT.MkRankdirAttribute','DOT.Rankdir.BT'],_5665268=['Cons',_5666198,'Nil'],_5582026=['MkDOT',_5583148,_5609700,_5650592,_5657930,_5665268]  ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ]]) ('
Got: ' ((MkDOT (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier f 885440) (Cons (DOT.MkLabelAttribute "\"f\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil))) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier f 885440) (Cons (DOT.MkLabelAttribute "\"f\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) (Cons (DOT.MkLabelAttribute "\"A\"") Nil)) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier f 885440) (Cons (DOT.MkLabelAttribute "\"f\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkLabelAttribute "\"B\"") Nil)) Nil)) (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkRankdirAttribute DOT.Rankdir.BT) Nil))) '
EXP: ' ((MkDOT (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier f 823576) (Cons (DOT.MkLabelAttribute "\"f\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil))) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier f 823576) (Cons (DOT.MkLabelAttribute "\"f\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) (Cons (DOT.MkLabelAttribute "\"A\"") Nil)) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier f 823576) (Cons (DOT.MkLabelAttribute "\"f\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkLabelAttribute "\"B\"") Nil)) Nil)) (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkRankdirAttribute DOT.Rankdir.BT) Nil)))))
</span>;;;; TODO: re-enable as needed  (don't forget to reset the random seed at every test)
;;;; !(toDOT (STTrans VA VIV))
;;;; !(toDOT (: (STTrans VA VIV) (<: (VocalsIn "English") Audio)))
;;;; !(toDOT (: (STTrans (: VA (<: Vocals Audio))
;;;;                     (: VIV (<: (VocalsIn "English") Vocals)))
;;;;            (<: (VocalsIn "English") Audio)))
;;;; !(toDOT (. upload speech-recognition.s2t))
;;;; !(toDOT (: (coerce (: (STTrans (: VA (<: Vocals Audio))
;;;;                                (: VIV (<: (VocalsIn "English") Vocals)))
;;;;                       (<: (VocalsIn "English") Audio)))
;;;;            (-> (: $x (VocalsIn "English")) Audio)))
;;;; !(toDOT (: (. (: speech-recognition.s2t (-> (: $y Audio) (TextIn "English")))
;;;;               (: (coerce (: (STTrans (: VA (<: Vocals Audio))
;;;;                                      (: VIV (<: (VocalsIn "English") Vocals)))
;;;;                             (<: (VocalsIn "English") Audio)))
;;;;                  (-> (: $x (VocalsIn "English")) Audio)))
;;;;            (-> (: $x (VocalsIn "English")) (TextIn "English"))))
;;;; !(toDOT (Φ f g h))
;;;; !(toDOT
;;;;   (: (Φ (: midi2voice-zh.singingZH
;;;;            (-> (: $y (TextIn "Chinese"))
;;;;                (: $z MusicalInstrumentDigitalInterface)
;;;;                (VocalsIn "Chinese")))
;;;;         g
;;;;         h)
;;;;      (-> (: $u Audio) (VocalsIn "Chinese"))))
;;;; !(toDOT
;;;;   (: (Φ (: f (-> B C D))
;;;;         (: g (-> A B))
;;;;         h)
;;;;      (-> (: $u Audio) (VocalsIn "Chinese"))))
;;;; !(toDOT
;;;;   (: (Φ (: midi2voice-zh.singingZH
;;;;            (-> (: $y (TextIn "Chinese"))
;;;;                (: $z MusicalInstrumentDigitalInterface)
;;;;                (VocalsIn "Chinese")))
;;;;         (: g (-> A B))
;;;;         h)
;;;;      (-> (: $u Audio) (VocalsIn "Chinese"))))
;;;; !(toDOT
;;;;   (: (Φ (: midi2voice-zh.singingZH
;;;;            (-> (: $y (TextIn "Chinese"))
;;;;                (: $z MusicalInstrumentDigitalInterface)
;;;;                (VocalsIn "Chinese")))
;;;;         g
;;;;         (: tomidi.a2m (-> (: $u Audio) MusicalInstrumentDigitalInterface)))
;;;;      (-> (: $u Audio) (VocalsIn "Chinese"))))
;;;; !(toDOT
;;;;   (: (Φ (: midi2voice-zh.singingZH
;;;;            (-> (: $y (TextIn "Chinese"))
;;;;                (: $z MusicalInstrumentDigitalInterface)
;;;;                (VocalsIn "Chinese")))
;;;;         (: g (-> A B))
;;;;         (: tomidi.a2m (-> (: $u Audio) MusicalInstrumentDigitalInterface)))
;;;;      (-> (: $u Audio) (VocalsIn "Chinese"))))
;;;; !(toDOT (machine-translation.translate "English" "Chinese"))
;;;; !(toDOT (machine-translation.translate (: "English" NaturalLanguage)
;;;;                                        (: "Chinese" NaturalLanguage)))
;;;; !(toDOT
;;;;   (: (machine-translation.translate
;;;;       (: "English" NaturalLanguage)
;;;;       (: "Chinese" NaturalLanguage))
;;;;      (-> (: $w (UniformResourceLocatorOfType (TextIn "English")))
;;;;          (TextIn "Chinese"))))
;;;; !(toDOT
;;;;   (: (. (: (machine-translation.translate
;;;;             (: "English" NaturalLanguage)
;;;;             (: "Chinese" NaturalLanguage))
;;;;            (-> (: $w (UniformResourceLocatorOfType (TextIn "English")))
;;;;                (TextIn "Chinese")))
;;;;         g)
;;;;      (-> (: $u Audio) (TextIn "Chinese"))))
;;;; !(toDOT
;;;;   (: (. (: (machine-translation.translate
;;;;             (: "English" NaturalLanguage)
;;;;             (: "Chinese" NaturalLanguage))
;;;;            (-> (: $w (UniformResourceLocatorOfType (TextIn "English")))
;;;;                (TextIn "Chinese")))
;;;;         (: (. (: upload
;;;;                  (-> (: $t (TextIn "English"))
;;;;                      (UniformResourceLocatorOfType (TextIn "English"))))
;;;;               (: speech-recognition.s2t
;;;;                  (-> (: $u Audio) (TextIn "English"))))
;;;;            (-> (: $u Audio)
;;;;                (UniformResourceLocatorOfType (TextIn "English")))))
;;;;      (-> (: $u Audio) (TextIn "Chinese"))))
;;;; !(toDOT
;;;;   (: (Φ f
;;;;         (: (. (: (machine-translation.translate
;;;;                   (: "English" NaturalLanguage)
;;;;                   (: "Chinese" NaturalLanguage))
;;;;                  (-> (: $w (UniformResourceLocatorOfType (TextIn "English")))
;;;;                      (TextIn "Chinese")))
;;;;               (: (. (: upload
;;;;                        (-> (: $t (TextIn "English"))
;;;;                            (UniformResourceLocatorOfType (TextIn "English"))))
;;;;                     (: speech-recognition.s2t
;;;;                        (-> (: $u Audio) (TextIn "English"))))
;;;;                  (-> (: $u Audio)
;;;;                      (UniformResourceLocatorOfType (TextIn "English")))))
;;;;            (-> (: $u Audio) (TextIn "Chinese")))
;;;;         h)
;;;;      (-> (: $u Audio) (VocalsIn "Chinese"))))
;;;; !(toDOT
;;;;   (: (Φ (: midi2voice-zh.singingZH
;;;;            (-> (: $y (TextIn "Chinese"))
;;;;                (: $z MusicalInstrumentDigitalInterface)
;;;;                (VocalsIn "Chinese")))
;;;;         (: (. (: (machine-translation.translate
;;;;                   (: "English" NaturalLanguage)
;;;;                   (: "Chinese" NaturalLanguage))
;;;;                  (-> (: $w (UniformResourceLocatorOfType (TextIn "English")))
;;;;                      (TextIn "Chinese")))
;;;;               (: (. (: upload
;;;;                        (-> (: $t (TextIn "English"))
;;;;                            (UniformResourceLocatorOfType (TextIn "English"))))
;;;;                     (: speech-recognition.s2t
;;;;                        (-> (: $u Audio) (TextIn "English"))))
;;;;                  (-> (: $u Audio)
;;;;                      (UniformResourceLocatorOfType (TextIn "English")))))
;;;;            (-> (: $u Audio) (TextIn "Chinese")))
;;;;         (: tomidi.a2m (-> (: $u Audio) MusicalInstrumentDigitalInterface)))
;;;;      (-> (: $u Audio) (VocalsIn "Chinese"))))
;;;; !(toDOT
;;;;   (: (. (: (Φ (: midi2voice-zh.singingZH
;;;;                  (-> (: $y (TextIn "Chinese"))
;;;;                      (: $z MusicalInstrumentDigitalInterface)
;;;;                      (VocalsIn "Chinese")))
;;;;               (: (. (: (machine-translation.translate
;;;;                         (: "English" NaturalLanguage)
;;;;                         (: "Chinese" NaturalLanguage))
;;;;                        (-> (: $w (UniformResourceLocatorOfType (TextIn "English")))
;;;;                            (TextIn "Chinese")))
;;;;                     (: (. (: upload
;;;;                              (-> (: $t (TextIn "English"))
;;;;                                  (UniformResourceLocatorOfType (TextIn "English"))))
;;;;                           (: speech-recognition.s2t
;;;;                              (-> (: $u Audio) (TextIn "English"))))
;;;;                        (-> (: $u Audio)
;;;;                            (UniformResourceLocatorOfType (TextIn "English")))))
;;;;                  (-> (: $u Audio) (TextIn "Chinese")))
;;;;               (: tomidi.a2m (-> (: $u Audio) MusicalInstrumentDigitalInterface)))
;;;;            (-> (: $u Audio) (VocalsIn "Chinese")))
;;;;         (: (coerce (: SIA (<: (SongIn $l) Audio)))
;;;;            (-> (: $x (SongIn $l)) Audio)))
;;;;      (-> (: $x (SongIn $l)) (VocalsIn "Chinese"))))
;;;; !(toDOT
;;;;   (: (. (: (Φ (: mixer.mix $a)
;;;;               (: sound-spleeter.DTLOutput.accomp $b)
;;;;               (: (. (: (Φ (: midi2voice-zh.singingZH $c)
;;;;                           (: (. (: (machine-translation.translate (: "English" $d)
;;;;                                                                   (: "Chinese" $e))
;;;;                                    $f)
;;;;                                 (: (. (: upload $g)
;;;;                                       (: speech-recognition.s2t $h))
;;;;                                    $i))
;;;;                              $j)
;;;;                           (: tomidi.a2m $k))
;;;;                        $l)
;;;;                     (: (. (: (coerce (: (STTrans (: VA $m) (: VIV $n)) $o))
;;;;                              $p)
;;;;                           (: sound-spleeter.DTLOutput.vocals $q))
;;;;                        $r))
;;;;                  $s))
;;;;            $t)
;;;;         (: sound-spleeter.spleeter $u))
;;;;      (-> (: $x (SongIn "English")) (SongIn "Chinese"))))
;;;; Output the string representing a style in DOT format
<span class="ansi38-255165000"> (: DOT.Style.toString (-> DOT.Style String))
 
</span><span class="ansi38-255165000"> (= (DOT.Style.toString DOT.Style.Rounded)  "rounded")
 
</span>;;;; Output the string representing a shape in DOT format
<span class="ansi38-255165000"> (: DOT.Shape.toString (-> DOT.Shape String))
 
</span><span class="ansi38-255165000"> (= (DOT.Shape.toString DOT.Shape.Plain)  "plain")
 
</span><span class="ansi38-255165000"> (= (DOT.Shape.toString DOT.Shape.Box)  "box")
 
</span><span class="ansi38-255165000"> (= (DOT.Shape.toString DOT.Shape.None)  "none")
 
</span><span class="ansi38-255165000"> (= (DOT.Shape.toString DOT.Shape.Parallelogram)  "parallelogram")
 
</span>;;;; Output the string representing a rankdir in DOT format
<span class="ansi38-255165000"> (: DOT.Rankdir.toString (-> DOT.Rankdir String))
 
</span><span class="ansi38-255165000"> (= (DOT.Rankdir.toString DOT.Rankdir.BT)  "BT")
 
</span><span class="ansi38-255165000"> (= (DOT.Rankdir.toString DOT.Rankdir.TB)  "TB")
 
</span><span class="ansi38-255165000"> (= (DOT.Rankdir.toString DOT.Rankdir.LR)  "LR")
 
</span><span class="ansi38-255165000"> (= (DOT.Rankdir.toString DOT.Rankdir.RL)  "RL")
 
</span>;;;; Output the string representing an attribute in DOT format
<span class="ansi38-255165000"> (: DOT.Attribute.toString (-> DOT.Attribute String))
 
</span><span class="ansi38-255165000"> (= (DOT.Attribute.toString (DOT.MkLabelAttribute $label))  
  (String.append "label=" $label))
 
</span><span class="ansi38-255165000"> (= (DOT.Attribute.toString (DOT.MkStyleAttribute $style))  
  (String.append "style=" 
    (DOT.Style.toString $style)))
 
</span><span class="ansi38-255165000"> (= (DOT.Attribute.toString (DOT.MkShapeAttribute $shape))  
  (String.append "shape=" 
    (DOT.Shape.toString $shape)))
 
</span><span class="ansi38-255165000"> (= (DOT.Attribute.toString (DOT.MkRankdirAttribute $rankdir))  
  (String.append "rankdir=" 
    (DOT.Rankdir.toString $rankdir)))
 
</span>;;;; test DOT.Attribute.toString
<span class="ansi38-013099040">

!(assertEqual (DOT.Attribute.toString (DOT.MkLabelAttribute "mix")) "label=mix")

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_DOT.Attribute.toString'(D, C), E, E=['DOT.Attribute.toString', D], D=['DOT.MkLabelAttribute', "mix"]), F=ispu("label=mix"), mc__1_2_assertEqual(B, F, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.20">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.20</h3>
; 
; EVAL TEST
; took 0.000104 secs. (103.60 microseconds) 

!(assertEqual [ispeEnNC $5893172 [mc__1_1_DOT.Attribute.toString $5893184 $5893172] $5893176 [ = $5893176 (DOT.Attribute.toString $5893184) ] [ = $5893184 (DOT.MkLabelAttribute "mix") ]] [ispu "label=mix"])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("label=mix") 
      ("label=mix")]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (DOT.Attribute.toString (DOT.MkStyleAttribute DOT.Style.Rounded)) "style=rounded")

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_DOT.Attribute.toString'(D, C), E, E=['DOT.Attribute.toString', D], D=['DOT.MkStyleAttribute', 'DOT.Style.Rounded']), F=ispu("style=rounded"), mc__1_2_assertEqual(B, F, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.21">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.21</h3>
; 
; EVAL TEST
; took 0.000027 secs. (27.30 microseconds) 

!(assertEqual [ispeEnNC $5917838 [mc__1_1_DOT.Attribute.toString $5917850 $5917838] $5917842 [ = $5917842 (DOT.Attribute.toString $5917850) ] [ = $5917850 (DOT.MkStyleAttribute DOT.Style.Rounded) ]] [ispu "style=rounded"])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("style=rounded") 
      ("style=rounded")]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (DOT.Attribute.toString (DOT.MkShapeAttribute DOT.Shape.Box)) "shape=box")

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_DOT.Attribute.toString'(D, C), E, E=['DOT.Attribute.toString', D], D=['DOT.MkShapeAttribute', 'DOT.Shape.Box']), F=ispu("shape=box"), mc__1_2_assertEqual(B, F, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.22">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.22</h3>
; 
; EVAL TEST
; took 0.000047 secs. (47.20 microseconds) 

!(assertEqual [ispeEnNC $5942500 [mc__1_1_DOT.Attribute.toString $5942512 $5942500] $5942504 [ = $5942504 (DOT.Attribute.toString $5942512) ] [ = $5942512 (DOT.MkShapeAttribute DOT.Shape.Box) ]] [ispu "shape=box"])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("shape=box") 
      ("shape=box")]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (DOT.Attribute.toString (DOT.MkRankdirAttribute DOT.Rankdir.BT)) "rankdir=BT")

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_DOT.Attribute.toString'(D, C), E, E=['DOT.Attribute.toString', D], D=['DOT.MkRankdirAttribute', 'DOT.Rankdir.BT']), F=ispu("rankdir=BT"), mc__1_2_assertEqual(B, F, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.23">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.23</h3>
; 
; EVAL TEST
; took 0.000090 secs. (90.30 microseconds) 

!(assertEqual [ispeEnNC $5967162 [mc__1_1_DOT.Attribute.toString $5967174 $5967162] $5967166 [ = $5967166 (DOT.Attribute.toString $5967174) ] [ = $5967174 (DOT.MkRankdirAttribute DOT.Rankdir.BT) ]] [ispu "rankdir=BT"])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("rankdir=BT") 
      ("rankdir=BT")]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Output the string representing a list of attributes in DOT format
<span class="ansi38-255165000"> (: DOT.Attributes.toOneLinerString (-> (List DOT.Attribute) String))
 
</span><span class="ansi38-255165000"> (= (DOT.Attributes.toOneLinerString $attributes)  
  (let $joined_attributes 
    (String.join ", " 
      (List.map DOT.Attribute.toString $attributes)) 
    (String.append3 "[" $joined_attributes "]")))
 
</span>;;;; Test DOT.Attributes.toOneLinerString
<span class="ansi38-013099040">

!(assertEqual (DOT.Attributes.toOneLinerString (Cons (DOT.MkLabelAttribute "mix") (Cons (DOT.MkStyleAttribute DOT.Style.Rounded) (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil)))) "[label=mix, style=rounded, shape=box]")

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_DOT.Attributes.toOneLinerString'(D, C), E, E=['DOT.Attributes.toOneLinerString', D], (F=['DOT.MkLabelAttribute', "mix"], G=['DOT.MkStyleAttribute', 'DOT.Style.Rounded'], H=['DOT.MkShapeAttribute', 'DOT.Shape.Box'], I=['Cons', H, 'Nil'], J=['Cons', G, I], D=['Cons', F, J])), K=ispu("[label=mix, style=rounded, shape=box]"), mc__1_2_assertEqual(B, K, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.24">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.24</h3>
; 
; EVAL TEST
; took 0.000088 secs. (88.40 microseconds) 

!(assertEqual [ispeEnNC $6016780 [mc__1_1_DOT.Attributes.toOneLinerString $6016792 $6016780] $6016784 [ = $6016784 (DOT.Attributes.toOneLinerString $6016792) ] [ , [ = $6016822 (DOT.MkLabelAttribute "mix") ] [ , [ = $6016846 (DOT.MkStyleAttribute DOT.Style.Rounded) ] [ , [ = $6016870 (DOT.MkShapeAttribute DOT.Shape.Box) ] [ , [ = $6016894 (Cons $6016870 Nil) ] [ , [ = $6016924 (Cons $6016846 $6016894) ] [ = $6016792 (Cons $6016822 $6016924) ] ] ] ] ] ]] [ispu "[label=mix, style=rounded, shape=box]"])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("[label=mix, style=rounded, shape=box]") 
      ("[label=mix, style=rounded, shape=box]")]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Output the string representing an identifier in DOT format
<span class="ansi38-255165000"> (: DOT.Identifier.toString (-> DOT.Identifier String))
 
</span><span class="ansi38-255165000"> (= (DOT.Identifier.toString (DOT.MkSymbolIdentifier $symbol $index))  
  (let $sir 
    (String.append 
      (repr $symbol) 
      (repr $index)) 
    (repr $sir)))
 
</span><span class="ansi38-255165000"> (= (DOT.Identifier.toString (DOT.MkGroundedIdentifier $grounded))  
  (repr $grounded))
 
</span>;;;; Test DOT.Identifier.toString
<span class="ansi38-013099040">

!(assertEqual (DOT.Identifier.toString (DOT.MkSymbolIdentifier mix 0)) "\"mix0\"")

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_DOT.Identifier.toString'(D, C), E, E=['DOT.Identifier.toString', D], D=['DOT.MkSymbolIdentifier', mix, 0]), F=ispu("\"mix0\""), mc__1_2_assertEqual(B, F, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.25">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.25</h3>
; 
; EVAL TEST
; took 0.000139 secs. (139.30 microseconds) 

!(assertEqual [ispeEnNC $6067342 [mc__1_1_DOT.Identifier.toString $6067354 $6067342] $6067346 [ = $6067346 (DOT.Identifier.toString $6067354) ] [ = $6067354 (DOT.MkSymbolIdentifier mix 0) ]] [ispu "\"mix0\""])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("\"mix0\"") 
      ("\"mix0\"")]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (DOT.Identifier.toString (DOT.MkGroundedIdentifier "Hello World!")) "\"Hello World!\"")

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_DOT.Identifier.toString'(D, C), E, E=['DOT.Identifier.toString', D], D=['DOT.MkGroundedIdentifier', "Hello World!"]), F=ispu("\"Hello World!\""), mc__1_2_assertEqual(B, F, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.26">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.26</h3>
; 
; EVAL TEST
; took 0.000059 secs. (58.60 microseconds) 

!(assertEqual [ispeEnNC $6094896 [mc__1_1_DOT.Identifier.toString $6094908 $6094896] $6094900 [ = $6094900 (DOT.Identifier.toString $6094908) ] [ = $6094908 (DOT.MkGroundedIdentifier "Hello World!") ]] [ispu "\"Hello World!\""])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("\"Hello World!\"") 
      ("\"Hello World!\"")]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Output the string representing a node in DOT format.
<span class="ansi38-255165000"> (: DOT.Node.toString (-> DOT.Node String))
 
</span><span class="ansi38-255165000"> (= (DOT.Node.toString (DOT.MkNode $identifier $attributes))  
  (let* 
    ( ($id_repr (DOT.Identifier.toString $identifier)) ($attr_repr (DOT.Attributes.toOneLinerString $attributes))) 
    (String.append3 $id_repr " " $attr_repr)))
 
</span>;;;; Test DOT.Node.toString
<span class="ansi38-013099040">

!(assertEqual (DOT.Node.toString (DOT.MkNode (DOT.MkSymbolIdentifier mix 0) Nil)) "\"mix0\" []")

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_DOT.Node.toString'(D, C), E, E=['DOT.Node.toString', D], (F=['DOT.MkSymbolIdentifier', mix, 0], D=['DOT.MkNode', F, 'Nil'])), G=ispu("\"mix0\" []"), mc__1_2_assertEqual(B, G, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.27">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.27</h3>
; 
; EVAL TEST
; took 0.000154 secs. (154.10 microseconds) 

!(assertEqual [ispeEnNC $6143920 [mc__1_1_DOT.Node.toString $6143932 $6143920] $6143924 [ = $6143924 (DOT.Node.toString $6143932) ] [ , [ = $6143962 (DOT.MkSymbolIdentifier mix 0) ] [ = $6143932 (DOT.MkNode $6143962 Nil) ] ]] [ispu "\"mix0\" []"])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("\"mix0\" []") 
      ("\"mix0\" []")]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (DOT.Node.toString (DOT.MkNode (DOT.MkGroundedIdentifier "Hello World!") Nil)) "\"Hello World!\" []")

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_DOT.Node.toString'(D, C), E, E=['DOT.Node.toString', D], (F=['DOT.MkGroundedIdentifier', "Hello World!"], D=['DOT.MkNode', F, 'Nil'])), G=ispu("\"Hello World!\" []"), mc__1_2_assertEqual(B, G, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.28">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.28</h3>
; 
; EVAL TEST
; took 0.000083 secs. (82.70 microseconds) 

!(assertEqual [ispeEnNC $6173280 [mc__1_1_DOT.Node.toString $6173292 $6173280] $6173284 [ = $6173284 (DOT.Node.toString $6173292) ] [ , [ = $6173322 (DOT.MkGroundedIdentifier "Hello World!") ] [ = $6173292 (DOT.MkNode $6173322 Nil) ] ]] [ispu "\"Hello World!\" []"])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("\"Hello World!\" []") 
      ("\"Hello World!\" []")]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (DOT.Node.toString (DOT.MkNode (DOT.MkSymbolIdentifier mix 0) (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) "\"mix0\" [shape=box]")

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_DOT.Node.toString'(D, C), E, E=['DOT.Node.toString', D], (F=['DOT.MkSymbolIdentifier', mix, 0], G=['DOT.MkShapeAttribute', 'DOT.Shape.Box'], H=['Cons', G, 'Nil'], D=['DOT.MkNode', F, H])), I=ispu("\"mix0\" [shape=box]"), mc__1_2_assertEqual(B, I, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.29">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.29</h3>
; 
; EVAL TEST
; took 0.000155 secs. (155.50 microseconds) 

!(assertEqual [ispeEnNC $6203358 [mc__1_1_DOT.Node.toString $6203370 $6203358] $6203362 [ = $6203362 (DOT.Node.toString $6203370) ] [ , [ = $6203400 (DOT.MkSymbolIdentifier mix 0) ] [ , [ = $6203430 (DOT.MkShapeAttribute DOT.Shape.Box) ] [ , [ = $6203454 (Cons $6203430 Nil) ] [ = $6203370 (DOT.MkNode $6203400 $6203454) ] ] ] ]] [ispu "\"mix0\" [shape=box]"])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("\"mix0\" [shape=box]") 
      ("\"mix0\" [shape=box]")]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Output the string representing an edge in DOT format.
<span class="ansi38-255165000"> (: DOT.Edge.toString (-> DOT.Edge String))
 
</span><span class="ansi38-255165000"> (= (DOT.Edge.toString (DOT.MkEdge $source $destination $attributes))  
  (let* 
    ( ($src_repr (DOT.Identifier.toString (DOT.Node.identifier $source))) 
      ($dst_repr (DOT.Identifier.toString (DOT.Node.identifier $destination))) 
      ($edge_repr (String.append3 $src_repr " -> " $dst_repr)) 
      ($attrs_repr (DOT.Attributes.toOneLinerString $attributes))) 
    (String.append3 $edge_repr " " $attrs_repr)))
 
</span>;;;; Test DOT.Edge.toString
<span class="ansi38-013099040">

!(assertEqual (DOT.Edge.toString (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier src 0) Nil) (DOT.MkNode (DOT.MkSymbolIdentifier dst 0) Nil) Nil)) "\"src0\" -> \"dst0\" []")

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_DOT.Edge.toString'(D, C), E, E=['DOT.Edge.toString', D], (F=['DOT.MkSymbolIdentifier', src, 0], G=['DOT.MkNode', F, 'Nil'], H=['DOT.MkSymbolIdentifier', dst, 0], I=['DOT.MkNode', H, 'Nil'], D=['DOT.MkEdge', G, I, 'Nil'])), J=ispu("\"src0\" -> \"dst0\" []"), mc__1_2_assertEqual(B, J, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.30">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.30</h3>
; 
; EVAL TEST
; took 0.000219 secs. (218.50 microseconds) 

!(assertEqual [ispeEnNC $6276038 [mc__1_1_DOT.Edge.toString $6276050 $6276038] $6276042 [ = $6276042 (DOT.Edge.toString $6276050) ] [ , [ = $6276080 (DOT.MkSymbolIdentifier src 0) ] [ , [ = $6276110 (DOT.MkNode $6276080 Nil) ] [ , [ = $6276140 (DOT.MkSymbolIdentifier dst 0) ] [ , [ = $6276170 (DOT.MkNode $6276140 Nil) ] [ = $6276050 (DOT.MkEdge $6276110 $6276170 Nil) ] ] ] ] ]] [ispu "\"src0\" -> \"dst0\" []"])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("\"src0\" -> \"dst0\" []") 
      ("\"src0\" -> \"dst0\" []")]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Takes a DOT data structure and outputs the corresponding string in
;;;; DOT format.
<span class="ansi38-255165000"> (: DOT.toString (-> DOT String))
 
</span><span class="ansi38-255165000"> (= (DOT.toString (MkDOT $nodes $edges $entry $exit $attrs))  
  (let* 
    ( ($nodes_repr (String.join "\n" (List.map DOT.Node.toString $nodes))) 
      ($edges_repr (String.join "\n" (List.map DOT.Edge.toString $edges))) 
      ($attrs_repr (String.join "\n" (List.map DOT.Attribute.toString $attrs))) 
      ($nodes_repr_nl (String.append $nodes_repr "\n\n")) 
      ($attrs_repr_nl (String.append $attrs_repr "\n\n"))) 
    (String.append5 "digraph Flowchart {\n" $attrs_repr_nl $nodes_repr_nl $edges_repr "\n}")))
 
</span>;;;; Test DOT.toString
<span class="ansi38-013099040">

!(set-random-seed &rng 0)

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    'mc__1_2_set-random-seed'(rng('&rng', _), 0, A)).

</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (DOT.toString (toDOT mix)) "digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"mix823576\" [label=\"mix\", shape=box]\n\n\"__IN__0\" -> \"mix823576\" []\n\"mix823576\" -> \"__OUT__0\" []\n}")

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_DOT.toString'(D, C), E, E=['DOT.toString', D], (F=ispu(mix), mc__1_1_toDOT(F, D))), G=ispu("digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"mix823576\" [label=\"mix\", shape=box]\n\n\"__IN__0\" -> \"mix823576\" []\n\"mix823576\" -> \"__OUT__0\" []\n}"), mc__1_2_assertEqual(B, G, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.31">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.31</h3>
; 
; EVAL TEST
; took 0.000969 secs. (968.70 microseconds) 

!(assertEqual [ispeEnNC $6382500 [mc__1_1_DOT.toString $6382512 $6382500] $6382504 [ = $6382504 (DOT.toString $6382512) ] [ , [ = $6382542 [ispu mix] ] [mc__1_1_toDOT $6382542 $6382512] ]] [ispu "digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"mix823576\" [label=\"mix\", shape=box]\n\n\"__IN__0\" -> \"mix823576\" []\n\"mix823576\" -> \"__OUT__0\" []\n}"])

<span class="ansi31">  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"mix885440\" [label=\"mix\", shape=box]\n\n\"__IN__0\" -> \"mix885440\" []\n\"mix885440\" -> \"__OUT__0\" []\n}") 
      ("digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"mix823576\" [label=\"mix\", shape=box]\n\n\"__IN__0\" -> \"mix823576\" []\n\"mix823576\" -> \"__OUT__0\" []\n}")]]
</span>
Deterministic: <span class="ansi33">(Error (assertEqual [ispeEnNC $6372560 [mc__1_1_DOT.toString $6372682 $6372560] $6372566 [ = $6372566 (DOT.toString $6372682) ] [ , [ = $6372870 [ispu mix] ] [mc__1_1_toDOT $6372870 $6372682] ]] [ispu "digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"mix823576\" [label=\"mix\", shape=box]\n\n\"__IN__0\" -> \"mix823576\" []\n\"mix823576\" -> \"__OUT__0\" []\n}"]) ('
Got: ' ("digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"mix885440\" [label=\"mix\", shape=box]\n\n\"__IN__0\" -> \"mix885440\" []\n\"mix885440\" -> \"__OUT__0\" []\n}") '
EXP: ' ("digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"mix823576\" [label=\"mix\", shape=box]\n\n\"__IN__0\" -> \"mix823576\" []\n\"mix823576\" -> \"__OUT__0\" []\n}")))
</span><span class="ansi38-013099040">

!(set-random-seed &rng 0)

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    'mc__1_2_set-random-seed'(rng('&rng', _), 0, A)).

</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (DOT.toString (toDOT (. f g))) "digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"f616257\" [label=\"f\", shape=box]\n\"g823576\" [label=\"g\", shape=box]\n\n\"g823576\" -> \"f616257\" []\n\"f616257\" -> \"__OUT__0\" []\n\"__IN__0\" -> \"g823576\" []\n}")

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_DOT.toString'(D, C), E, E=['DOT.toString', D], (F=ispuU(G, G=['.', f, g]), mc__1_1_toDOT(F, D))), H=ispu("digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"f616257\" [label=\"f\", shape=box]\n\"g823576\" [label=\"g\", shape=box]\n\n\"g823576\" -> \"f616257\" []\n\"f616257\" -> \"__OUT__0\" []\n\"__IN__0\" -> \"g823576\" []\n}"), mc__1_2_assertEqual(B, H, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.32">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.32</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.31 milliseconds) 

!(assertEqual [ispeEnNC $6461176 [mc__1_1_DOT.toString $6461188 $6461176] $6461180 [ = $6461180 (DOT.toString $6461188) ] [ , [ = $6461218 [ispuU $6461224 [ = $6461224 (. f g) ]] ] [mc__1_1_toDOT $6461218 $6461188] ]] [ispu "digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"f616257\" [label=\"f\", shape=box]\n\"g823576\" [label=\"g\", shape=box]\n\n\"g823576\" -> \"f616257\" []\n\"f616257\" -> \"__OUT__0\" []\n\"__IN__0\" -> \"g823576\" []\n}"])

<span class="ansi31">  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ("digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"f403958\" [label=\"f\", shape=box]\n\"g885440\" [label=\"g\", shape=box]\n\n\"g885440\" -> \"f403958\" []\n\"f403958\" -> \"__OUT__0\" []\n\"__IN__0\" -> \"g885440\" []\n}") 
      ("digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"f616257\" [label=\"f\", shape=box]\n\"g823576\" [label=\"g\", shape=box]\n\n\"g823576\" -> \"f616257\" []\n\"f616257\" -> \"__OUT__0\" []\n\"__IN__0\" -> \"g823576\" []\n}")]]
</span>
Deterministic: <span class="ansi33">(Error (assertEqual [ispeEnNC $6450272 [mc__1_1_DOT.toString $6450394 $6450272] $6450278 [ = $6450278 (DOT.toString $6450394) ] [ , [ = $6451200 [ispuU $6450510 [ = $6450510 (. f g) ]] ] [mc__1_1_toDOT $6451200 $6450394] ]] [ispu "digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"f616257\" [label=\"f\", shape=box]\n\"g823576\" [label=\"g\", shape=box]\n\n\"g823576\" -> \"f616257\" []\n\"f616257\" -> \"__OUT__0\" []\n\"__IN__0\" -> \"g823576\" []\n}"]) ('
Got: ' ("digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"f403958\" [label=\"f\", shape=box]\n\"g885440\" [label=\"g\", shape=box]\n\n\"g885440\" -> \"f403958\" []\n\"f403958\" -> \"__OUT__0\" []\n\"__IN__0\" -> \"g885440\" []\n}") '
EXP: ' ("digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"f616257\" [label=\"f\", shape=box]\n\"g823576\" [label=\"g\", shape=box]\n\n\"g823576\" -> \"f616257\" []\n\"f616257\" -> \"__OUT__0\" []\n\"__IN__0\" -> \"g823576\" []\n}")))
</span>;;;; TODO: re-enable as needed (don't forget to reset the random seed at every test)
;;;; !(assertEqual
;;;;   (DOT.toString (toDOT (Φ f g h)))
;;;;   "digraph Flowchart {\nrankdir=BT\n\n\"Φ1000\" [label=\"Φ\", shape=plain]\n\"f1\" [label=\"f\", shape=box]\n\"g10\" [label=\"g\", shape=box]\n\"h100\" [label=\"h\", shape=box]\n\n\"Φ1000\" -> \"g10\" []\n\"Φ1000\" -> \"h100\" []\n\"g10\" -> \"f1\" []\n\"h100\" -> \"f1\" []\n}")
;;;; !(assertEqual
;;;;   (DOT.toString (toDOT (f "Hello World!")))
;;;;   "digraph Flowchart {\nrankdir=BT\n\n\"f1\" [label=\"f\", shape=box]\n\"Hello World!\" [label=\"\\\"Hello World!\\\"\", shape=box, style=rounded]\n\n\"Hello World!\" -> \"f1\" []\n}")
;;;; !(assertEqual
;;;;   (DOT.toString (toDOT (f "Hello" "World!")))
;;;;   "digraph Flowchart {\nrankdir=BT\n\n\"f1\" [label=\"f\", shape=box]\n\"Hello\" [label=\"\\\"Hello\\\"\", shape=box, style=rounded]\n\"World!\" [label=\"\\\"World!\\\"\", shape=box, style=rounded]\n\n\"Hello\" -> \"f1\" []\n\"World!\" -> \"f1\" []\n}")
;;;; !(assertEqual
;;;;   (DOT.toString (toDOT (: f (-> (: $x (SongIn "English")) (SongIn "Chinese")))))
;;;;   "digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"f1\" [label=\"f\", shape=box]\n\n\"__IN__0\" -> \"f1\" [label=\"(: $10000 (SongIn \\\"English\\\"))\"]\n\"f1\" -> \"__OUT__0\" [label=\"(SongIn \\\"Chinese\\\")\"]\n}")
;;;; Print a MeTTa term in DOT format
<span class="ansi38-255165000"> (= (DOT.println! $term)  
  (println! (DOT.toString (toDOT $term))))
 
</span>;;;; ;; Test DOT.println!
;;;; !(DOT.println! mix)
;;;; !(DOT.println! (: f (-> A B)))
;;;; !(DOT.println! (STTrans VA VIV))
;;;; !(DOT.println! (: (STTrans VA VIV) (<: (VocalsIn "English") Audio)))
;;;; !(DOT.println! (: (STTrans (: VA (<: Vocals Audio))
;;;;                            (: VIV (<: (VocalsIn "English") Vocals)))
;;;;                   (<: (VocalsIn "English") Audio)))
;;;; !(DOT.println! (. upload speech-recognition.s2t))
;;;; !(DOT.println! (: (coerce (: (STTrans (: VA (<: Vocals Audio))
;;;;                                       (: VIV (<: (VocalsIn "English") Vocals)))
;;;;                              (<: (VocalsIn "English") Audio)))
;;;;                   (-> (: $x (VocalsIn "English")) Audio)))
;;;; !(DOT.println! (: (. (: speech-recognition.s2t (-> (: $y Audio) (TextIn "English")))
;;;;                      (: (coerce (: (STTrans (: VA (<: Vocals Audio))
;;;;                                             (: VIV (<: (VocalsIn "English") Vocals)))
;;;;                                    (<: (VocalsIn "English") Audio)))
;;;;                         (-> (: $x (VocalsIn "English")) Audio)))
;;;;                   (-> (: $x (VocalsIn "English")) (TextIn "English"))))
;;;; !(DOT.println!
;;;;   (: (. (: upload (-> (: $y (TextIn "English"))
;;;;                       (UniformResourceLocatorOfType (TextIn "English"))))
;;;;         (: (. (: speech-recognition.s2t (-> (: $z Audio) (TextIn "English")))
;;;;               (: (coerce (: (STTrans (: VA (<: Vocals Audio))
;;;;                                      (: VIV (<: (VocalsIn "English") Vocals)))
;;;;                             (<: (VocalsIn "English") Audio)))
;;;;                  (-> (: $x (VocalsIn "English")) Audio)))
;;;;            (-> (: $x (VocalsIn "English")) (TextIn "English"))))
;;;;      (-> (: $x (VocalsIn "English"))
;;;;          (UniformResourceLocatorOfType (TextIn "English")))))
;;;; !(DOT.println! (Φ f g h))
;;;; !(DOT.println! (: (Φ f g h) (-> A D)))
;;;; !(DOT.println! (: (Φ (: f (-> B C D)) (: g (-> A B)) (: h (-> A C))) (-> A D)))
;;;; !(DOT.println!
;;;;   (: (. (: (Φ (: midi2voice-zh.singingZH
;;;;                  (-> (: $y (TextIn "Chinese"))
;;;;                      (: $z MusicalInstrumentDigitalInterface)
;;;;                      (VocalsIn "Chinese")))
;;;;               (: (. (: (machine-translation.translate
;;;;                         (: "English" NaturalLanguage)
;;;;                         (: "Chinese" NaturalLanguage))
;;;;                        (-> (: $w (UniformResourceLocatorOfType (TextIn "English")))
;;;;                            (TextIn "Chinese")))
;;;;                     (: (. (: upload
;;;;                              (-> (: $t (TextIn "English"))
;;;;                                  (UniformResourceLocatorOfType (TextIn "English"))))
;;;;                           (: speech-recognition.s2t
;;;;                              (-> (: $u Audio) (TextIn "English"))))
;;;;                        (-> (: $u Audio)
;;;;                            (UniformResourceLocatorOfType (TextIn "English")))))
;;;;                  (-> (: $u Audio) (TextIn "Chinese")))
;;;;               (: tomidi.a2m (-> (: $u Audio) MusicalInstrumentDigitalInterface)))
;;;;            (-> (: $u Audio) (VocalsIn "Chinese")))
;;;;         (: (coerce (: SIA (<: (SongIn $l) Audio)))
;;;;            (-> (: $x (SongIn $l)) Audio)))
;;;;      (-> (: $x (SongIn $l)) (VocalsIn "Chinese"))))
;;;;;;;;;;;;;;;
;;;; Uncurry ;;
;;;;;;;;;;;;;;;
;;;; Uncurry ((. f) g) to (. f g)
<span class="ansi38-255165000"> (: bluebird-uncurry (-> Atom (Maybe Atom)))
 
</span><span class="ansi38-255165000"> (= (bluebird-uncurry $term)  
  (case $term 
    ( ( ( ($bluebird $f) $g) (if (== $bluebird .) (Just (. $f $g)) Nothing)) ($else Nothing))))
 
</span>;;;; Test bluebird-uncurry
<span class="ansi38-013099040">

!(assertEqual (bluebird-uncurry ((. $f) $g)) (Just (. $f $g)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_bluebird-uncurry'(D, C), E, E=['bluebird-uncurry', D], D=ispuU(F, (G=['.', H], F=[G, I]))), J=ispuU(K, (L=['.', H, I], K=['Just', L])), mc__1_2_assertEqual(B, J, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.33">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.33</h3>
; 
; EVAL TEST
; took 0.000048 secs. (47.90 microseconds) 

!(assertEqual [ispeEnNC $6581096 [mc__1_1_bluebird-uncurry $6581108 $6581096] $6581100 [ = $6581100 (bluebird-uncurry $6581108) ] [ = $6581108 [ispuU $6581138 [ , [ = $6581150 (. $f) ] [ = $6581138 ($6581150 $g) ] ]] ]] [ispuU $6581220 [ , [ = $6581232 (. $f $g) ] [ = $6581220 (Just $6581232) ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (Just (. $f $g))) 
      ( (Just (. $f $g)))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (bluebird-uncurry (((Φ $f) $g) $h)) Nothing)

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_bluebird-uncurry'(D, C), E, E=['bluebird-uncurry', D], D=ispuU(F, (G=['Φ', _], H=[G, _], F=[H, _]))), I=ispu('Nothing'), mc__1_2_assertEqual(B, I, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.34">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.34</h3>
; 
; EVAL TEST
; took 0.000022 secs. (21.60 microseconds) 

!(assertEqual [ispeEnNC $6612088 [mc__1_1_bluebird-uncurry $6612100 $6612088] $6612092 [ = $6612092 (bluebird-uncurry $6612100) ] [ = $6612100 [ispuU $6612130 [ , [ = $6612142 (Φ $f) ] [ , [ = $6612180 ($6612142 $g) ] [ = $6612130 ($6612180 $h) ] ] ]] ]] [ispu Nothing])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (Nothing) 
      (Nothing)]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Uncurry (((Φ f) g) h) to (Φ f g h)
<span class="ansi38-255165000"> (: phoenix-uncurry (-> Atom (Maybe Atom)))
 
</span><span class="ansi38-255165000"> (= (phoenix-uncurry $term)  
  (case $term 
    ( ( ( ( ($phoenix $f) $g) $h) (if (== $phoenix Φ) (Just (Φ $f $g $h)) Nothing)) ($6645202 Nothing))))
 
</span>;;;; Test bluebird-uncurry
<span class="ansi38-013099040">

!(assertEqual (phoenix-uncurry ((. $f) $g)) Nothing)

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_phoenix-uncurry'(D, C), E, E=['phoenix-uncurry', D], D=ispuU(F, (G=['.', _], F=[G, _]))), H=ispu('Nothing'), mc__1_2_assertEqual(B, H, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.35">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.35</h3>
; 
; EVAL TEST
; took 0.000043 secs. (42.70 microseconds) 

!(assertEqual [ispeEnNC $6666610 [mc__1_1_phoenix-uncurry $6666622 $6666610] $6666614 [ = $6666614 (phoenix-uncurry $6666622) ] [ = $6666622 [ispuU $6666652 [ , [ = $6666664 (. $f) ] [ = $6666652 ($6666664 $g) ] ]] ]] [ispu Nothing])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (Nothing) 
      (Nothing)]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (phoenix-uncurry (((Φ $f) $g) $h)) (Just (Φ $f $g $h)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_phoenix-uncurry'(D, C), E, E=['phoenix-uncurry', D], D=ispuU(F, (G=['Φ', H], I=[G, J], F=[I, K]))), L=ispuU(M, (N=['Φ', H, J, K], M=['Just', N])), mc__1_2_assertEqual(B, L, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.36">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.36</h3>
; 
; EVAL TEST
; took 0.000045 secs. (44.80 microseconds) 

!(assertEqual [ispeEnNC $6698150 [mc__1_1_phoenix-uncurry $6698162 $6698150] $6698154 [ = $6698154 (phoenix-uncurry $6698162) ] [ = $6698162 [ispuU $6698192 [ , [ = $6698204 (Φ $f) ] [ , [ = $6698242 ($6698204 $g) ] [ = $6698192 ($6698242 $h) ] ] ]] ]] [ispuU $6698312 [ , [ = $6698324 (Φ $f $g $h) ] [ = $6698312 (Just $6698324) ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (Just (Φ $f $g $h))) 
      ( (Just (Φ $f $g $h)))]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Uncurry term, so for instance
;;;;
;;;; ((. $f) $g)
;;;;
;;;; becomes
;;;;
;;;; (. $f $g)
;;;;
;;;; Take into account the arity of the operators involved.  For
;;;; instance
;;;;
;;;; (((. $f) $g) $x)
;;;;
;;;; becomes
;;;;
;;;; ((. $f $g) $x)
;;;;
;;;; instead of
;;;;
;;;; (. $f $g $x)
;;;;
;;;; because . is binary, not trinary.
<span class="ansi38-255165000"> (: uncurry (-> Atom Atom))
 
</span><span class="ansi38-255165000"> (= (uncurry $term)  
  (case 
    (get-metatype $term) 
    ( (Variable $term) 
      (Symbol $term) 
      (Grounded $term) 
      (Expression (if (== $term ()) () (case $term ((($f $g) (let* (($νf (uncurry $f)) ($νg (uncurry $g))) (if (and (== $νf $f) (== $νg $g)) (case (bluebird-uncurry $term) (((Just $r) $r) (Nothing (case (phoenix-uncurry $term) (((Just $r) $r) (Nothing ($f $g))))))) (uncurry ($νf $νg))))) ($else $term))))))))
 
</span>;;;; Test uncurry
<span class="ansi38-013099040">

!(assertEqual (uncurry ((. $f) $g)) (. $f $g))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, (mc__1_1_uncurry(D, E), as_p1_exec(E, C)), F, (G=[uncurry, D], as_p1_expr(G, F)), D=ispuU(H, (I=['.', J], H=[I, K]))), L=ispuU(M, M=['.', J, K]), mc__1_2_assertEqual(B, L, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.37">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.37</h3>
; 
; EVAL TEST
; took 0.000415 secs. (415.00 microseconds) 

!(assertEqual [ispeEnNC $6783112 [ , [mc__1_1_uncurry $6783130 $6783132] [as_p1_exec $6783132 $6783112] ] $6783116 [ , [ = $6783148 (uncurry $6783130) ] [as_p1_expr $6783148 $6783116] ] [ = $6783130 [ispuU $6783178 [ , [ = $6783190 (. $f) ] [ = $6783178 ($6783190 $g) ] ]] ]] [ispuU $6783260 [ = $6783260 (. $f $g) ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (. $f $g)) 
      ( (. $f $g))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (uncurry (((Φ $f) $g) $h)) (Φ $f $g $h))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, (mc__1_1_uncurry(D, E), as_p1_exec(E, C)), F, (G=[uncurry, D], as_p1_expr(G, F)), D=ispuU(H, (I=['Φ', J], K=[I, L], H=[K, M]))), N=ispuU(O, O=['Φ', J, L, M]), mc__1_2_assertEqual(B, N, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.38">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.38</h3>
; 
; EVAL TEST
; took 0.000452 secs. (452.00 microseconds) 

!(assertEqual [ispeEnNC $6816162 [ , [mc__1_1_uncurry $6816180 $6816182] [as_p1_exec $6816182 $6816162] ] $6816166 [ , [ = $6816198 (uncurry $6816180) ] [as_p1_expr $6816198 $6816166] ] [ = $6816180 [ispuU $6816228 [ , [ = $6816240 (Φ $f) ] [ , [ = $6816278 ($6816240 $g) ] [ = $6816228 ($6816278 $h) ] ] ]] ]] [ispuU $6816348 [ = $6816348 (Φ $f $g $h) ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (Φ $f $g $h)) 
      ( (Φ $f $g $h))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (uncurry (((Φ (. $f $g)) $j) ((. $h) ((. $i) $j)))) (Φ (. $f $g) $j (. $h (. $i $j))))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, (mc__1_1_uncurry(D, E), as_p1_exec(E, C)), F, (G=[uncurry, D], as_p1_expr(G, F)), D=ispuU(H, (I=['.', J, K], L=['Φ', I], M=[L, N], O=['.', P], Q=['.', R], S=[Q, N], T=[O, S], H=[M, T]))), U=ispuU(V, (W=['.', J, K], X=['.', R, N], Y=['.', P, X], V=['Φ', W, N, Y])), mc__1_2_assertEqual(B, U, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.39">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.39</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.04 milliseconds) 

!(assertEqual [ispeEnNC $6860536 [ , [mc__1_1_uncurry $6860554 $6860556] [as_p1_exec $6860556 $6860536] ] $6860540 [ , [ = $6860572 (uncurry $6860554) ] [as_p1_expr $6860572 $6860540] ] [ = $6860554 [ispuU $6860602 [ , [ = $6860614 (. $f $g) ] [ , [ = $6860672 (Φ $6860614) ] [ , [ = $6860696 ($6860672 $j) ] [ , [ = $6860734 (. $h) ] [ , [ = $6860772 (. $i) ] [ , [ = $6860810 ($6860772 $j) ] [ , [ = $6860834 ($6860734 $6860810) ] [ = $6860602 ($6860696 $6860834) ] ] ] ] ] ] ] ]] ]] [ispuU $6860876 [ , [ = $6860888 (. $f $g) ] [ , [ = $6860918 (. $i $j) ] [ , [ = $6860948 (. $h $6860918) ] [ = $6860876 (Φ $6860888 $j $6860948) ] ] ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (Φ 
          (. $f $g) $j 
          (. $h 
            (. $i $j)))) 
      ( (Φ 
          (. $f $g) $j 
          (. $h 
            (. $i $j))))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (uncurry (((Φ $f) ((. $g) $j)) ((. $h) ((. $i) $j)))) (Φ $f (. $g $j) (. $h (. $i $j))))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, (mc__1_1_uncurry(D, E), as_p1_exec(E, C)), F, (G=[uncurry, D], as_p1_expr(G, F)), D=ispuU(H, (I=['Φ', J], K=['.', L], M=[K, N], O=[I, M], P=['.', Q], R=['.', S], T=[R, N], U=[P, T], H=[O, U]))), V=ispuU(W, (X=['.', L, N], Y=['.', S, N], Z=['.', Q, Y], W=['Φ', J, X, Z])), mc__1_2_assertEqual(B, V, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.40">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.40</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.26 milliseconds) 

!(assertEqual [ispeEnNC $6911538 [ , [mc__1_1_uncurry $6911556 $6911558] [as_p1_exec $6911558 $6911538] ] $6911542 [ , [ = $6911574 (uncurry $6911556) ] [as_p1_expr $6911574 $6911542] ] [ = $6911556 [ispuU $6911604 [ , [ = $6911616 (Φ $f) ] [ , [ = $6911654 (. $g) ] [ , [ = $6911692 ($6911654 $j) ] [ , [ = $6911730 ($6911616 $6911692) ] [ , [ = $6911754 (. $h) ] [ , [ = $6911792 (. $i) ] [ , [ = $6911830 ($6911792 $j) ] [ , [ = $6911854 ($6911754 $6911830) ] [ = $6911604 ($6911730 $6911854) ] ] ] ] ] ] ] ] ]] ]] [ispuU $6911896 [ , [ = $6911908 (. $g $j) ] [ , [ = $6911938 (. $i $j) ] [ , [ = $6911968 (. $h $6911938) ] [ = $6911896 (Φ $f $6911908 $6911968) ] ] ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (Φ $f 
          (. $g $j) 
          (. $h 
            (. $i $j)))) 
      ( (Φ $f 
          (. $g $j) 
          (. $h 
            (. $i $j))))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (uncurry (((Φ $f) ((. $g) $j)) ((. $h) ((. $i) $j)))) (Φ $f (. $g $j) (. $h (. $i $j))))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, (mc__1_1_uncurry(D, E), as_p1_exec(E, C)), F, (G=[uncurry, D], as_p1_expr(G, F)), D=ispuU(H, (I=['Φ', J], K=['.', L], M=[K, N], O=[I, M], P=['.', Q], R=['.', S], T=[R, N], U=[P, T], H=[O, U]))), V=ispuU(W, (X=['.', L, N], Y=['.', S, N], Z=['.', Q, Y], W=['Φ', J, X, Z])), mc__1_2_assertEqual(B, V, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.41">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.41</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.21 milliseconds) 

!(assertEqual [ispeEnNC $6964220 [ , [mc__1_1_uncurry $6964238 $6964240] [as_p1_exec $6964240 $6964220] ] $6964224 [ , [ = $6964256 (uncurry $6964238) ] [as_p1_expr $6964256 $6964224] ] [ = $6964238 [ispuU $6964286 [ , [ = $6964298 (Φ $f) ] [ , [ = $6964336 (. $g) ] [ , [ = $6964374 ($6964336 $j) ] [ , [ = $6964412 ($6964298 $6964374) ] [ , [ = $6964436 (. $h) ] [ , [ = $6964474 (. $i) ] [ , [ = $6964512 ($6964474 $j) ] [ , [ = $6964536 ($6964436 $6964512) ] [ = $6964286 ($6964412 $6964536) ] ] ] ] ] ] ] ] ]] ]] [ispuU $6964578 [ , [ = $6964590 (. $g $j) ] [ , [ = $6964620 (. $i $j) ] [ , [ = $6964650 (. $h $6964620) ] [ = $6964578 (Φ $f $6964590 $6964650) ] ] ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (Φ $f 
          (. $g $j) 
          (. $h 
            (. $i $j)))) 
      ( (Φ $f 
          (. $g $j) 
          (. $h 
            (. $i $j))))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertEqual (uncurry ((. (((Φ $f) $g) ((. $h) $i))) $j)) (. (Φ $f $g (. $h $i)) $j))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, (mc__1_1_uncurry(D, E), as_p1_exec(E, C)), F, (G=[uncurry, D], as_p1_expr(G, F)), D=ispuU(H, (I=['Φ', J], K=[I, L], M=['.', N], O=[M, P], Q=[K, O], R=['.', Q], H=[R, S]))), T=ispuU(U, (V=['.', N, P], W=['Φ', J, L, V], U=['.', W, S])), mc__1_2_assertEqual(B, T, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.42">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.42</h3>
; 
; EVAL TEST
; took 0.001 secs. (1.06 milliseconds) 

!(assertEqual [ispeEnNC $7011930 [ , [mc__1_1_uncurry $7011948 $7011950] [as_p1_exec $7011950 $7011930] ] $7011934 [ , [ = $7011966 (uncurry $7011948) ] [as_p1_expr $7011966 $7011934] ] [ = $7011948 [ispuU $7011996 [ , [ = $7012008 (Φ $f) ] [ , [ = $7012046 ($7012008 $g) ] [ , [ = $7012084 (. $h) ] [ , [ = $7012122 ($7012084 $i) ] [ , [ = $7012160 ($7012046 $7012122) ] [ , [ = $7012184 (. $7012160) ] [ = $7011996 ($7012184 $j) ] ] ] ] ] ] ]] ]] [ispuU $7012240 [ , [ = $7012252 (. $h $i) ] [ , [ = $7012282 (Φ $f $g $7012252) ] [ = $7012240 (. $7012282 $j) ] ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (. 
          (Φ $f $g 
            (. $h $i)) $j)) 
      ( (. 
          (Φ $f $g 
            (. $h $i)) $j))]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Backward chainer ;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Check is a given type is a subtype of Data.  Use the backward
;;;; chainer for type checking but only allow a depth of 0 in order to
;;;; have maximum efficiency.
<span class="ansi38-255165000"> (: isData (-> Type Bool))
 
</span><span class="ansi38-255165000"> (= (isData $a)  True)
 
</span>;;; Disabled for now because it
;;; does not result in pruning,
;;; and only slows down for no
;;; reason.
;;;; (let (: $prf (<: $a Data)) (limit 1 (bc &kb Z (: $prf (<: $a Data))))
;;;;      (is-closed $prf)))
;;;; Uncurried Backward Chainer with dependent types (no lambda
;;;; abstraction here, combinatory logic is used instead).  Inference
;;;; rules are directly embedded in the backchainer chainer code.
;;;;
;;;; The arguments of the backward chainer are:
;;;;
;;;; * Knowledge base: pointer to a space containing axioms and rules in
;;;;   the format (: <NAME> <RULE>).  Note that rules are explicitely
;;;;   curried, meaning that a rule with two premises is represented by
;;;;
;;;;   (: <NAME> (-> <PREMISE1> (-> <PREMISE2> <CONCLUSION>)))
;;;;
;;;;   In addition, each premise must be an inline typing relationship,
;;;;   to represent dependent types.  It should be noted that such
;;;;   typing relationship must be provided even if the witness is not
;;;;   present in the rest of the definition.  For instance <PREMISE1>
;;;;   would have the format
;;;;
;;;;   (: <TERM1> <TYPE1>)
;;;;
;;;; * Maximum depth: maximum depth of the generated proof tree.
;;;;
;;;; * Query: a metta term of the form (: <PROOF> <THEOREM>) where
;;;;   <PROOF> and <THEOREM> may contain free variables that may be
;;;;   filled by the backward chainer.
;;;;
;;;; A result is the query with its variables grounded, fully or
;;;; partially.  If multiple results are possible, they are returned as
;;;; a superposition.
<span class="ansi38-255165000"> (: bc (-> $a Nat $b $b))
 
</span>;;; Result
;;;; Base cases: match the knowledge base
<span class="ansi38-255165000"> (= (bc $kb $7058990 (: $prf $thrm))  
  (match $kb 
    (: $prf $thrm) 
    (: $prf $thrm)))
 
</span>;;;; Recursive step for subtyping transitivity
<span class="ansi38-255165000"> (= (bc $kb (S $k) (: (STTrans $bc $ab) (<: $a $c)))  
  (let* 
    ( ( (: $bc 
          (<: $b $c)) (bc $kb $k (: $bc (<: $b $c)))) ((: $ab (<: $a $b)) (bc $kb $k (: $ab (<: $a $b))))) 
    (when 
      (and 
        (isData $a) 
        (and 
          (isData $b) 
          (isData $c))) 
      (: 
        (STTrans $bc $ab) 
        (<: $a $c)))))
 
</span>;;;; Recursive step for subtyping coercion.
<span class="ansi38-255165000"> (= (bc $kb (S $k) (: (coerce $ab) (-> (: $x $a) $b)))  
  (let 
    (: $ab 
      (<: $a $b)) 
    (bc $kb $k 
      (: $ab 
        (<: $a $b))) 
    (when 
      (and 
        (isData $a) 
        (isData $b)) 
      (: 
        (coerce $ab) 
        (-> 
          (: $x $a) $b)))))
 
</span>;;;; Recursive step: bluebird
<span class="ansi38-255165000"> (= (bc $kb (S $k) (: (. $f $g) (-> (: $x $a) $c)))  
  (let* 
    ( ( (: $f 
          (-> 
            (: $y $b) $c)) (bc $kb $k (: $f (-> (: $y $b) $c)))) ((: $g (-> (: $x $a) $b)) (bc $kb $k (: $g (-> (: $x $a) $b))))) 
    (when 
      (and 
        (isData $a) 
        (and 
          (isData $b) 
          (isData $c))) 
      (: 
        (. $f $g) 
        (-> 
          (: $x $a) $c)))))
 
</span>;;;; Recursive step: phoenix
<span class="ansi38-255165000"> (= (bc $kb (S $k) (: (Φ $f $g $h) (-> (: $x $a) $d)))  
  (let* 
    ( ( (: $f 
          (-> 
            (: $y $b) 
            (: $z $c) $d)) (bc $kb $k (: $f (-> (: $y $b) (: $z $c) $d)))) 
      ( (: $g 
          (-> 
            (: $x $a) $b)) (bc $kb $k (: $g (-> (: $x $a) $b)))) 
      ( (: $h 
          (-> 
            (: $x $a) $c)) (bc $kb $k (: $h (-> (: $x $a) $c))))) 
    (when 
      (and 
        (isData $a) 
        (and 
          (isData $b) 
          (and 
            (isData $c) 
            (isData $d)))) 
      (: 
        (Φ $f $g $h) 
        (-> 
          (: $x $a) $d)))))
 
</span>;;;; Recursive step for machine-translation.translate.  The point of
;;;; embedding the machine-translation.translate call in the backward
;;;; chainer is to be able to infer the correct parameters (in/out
;;;; languages) for call the service.
<span class="ansi38-255165000"> (= (bc $kb (S $k) (: (machine-translation.translate $in_nl $out_nl) (-> (: $url (UniformResourceLocatorOfType (TextIn $in_nl))) (TextIn $out_nl))))  
  (let* 
    ( ( (: $in_nl NaturalLanguage) (bc $kb $k (: $in_nl NaturalLanguage))) ((: $out_nl NaturalLanguage) (bc $kb $k (: $out_nl NaturalLanguage)))) 
    (: 
      (machine-translation.translate $in_nl $out_nl) 
      (-> 
        (: $url 
          (UniformResourceLocatorOfType (TextIn $in_nl))) 
        (TextIn $out_nl)))))
 
</span>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Backward Chainer with Type Annotation ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Like bc but infer a fully type annotated program.  For instance
;;;; instead of inferring
;;;;
;;;; (: (ϕ f g h) (-> T1 T2))
;;;;
;;;; it will infer
;;;;
;;;; (: (ϕ (: f T3) (: g T4) (: h T5)) (-> T1 T2))
<span class="ansi38-255165000"> (: type-annotated-bc (-> $a Nat $b $b))
 
</span>;;; Result
;;;; Base cases: match the knowledge base
<span class="ansi38-255165000"> (= (type-annotated-bc $kb $7387188 (: $prf $thrm))  
  (match $kb 
    (: $prf $thrm) 
    (: $prf $thrm)))
 
</span>;;;; Recursive step for subtyping transitivity
<span class="ansi38-255165000"> (= (type-annotated-bc $kb (S $k) (: (STTrans (: $bc (<: $b $c)) (: $ab (<: $a $b))) (<: $a $c)))  
  (let* 
    ( ( (: $bc 
          (<: $b $c)) (type-annotated-bc $kb $k (: $bc (<: $b $c)))) ((: $ab (<: $a $b)) (type-annotated-bc $kb $k (: $ab (<: $a $b))))) 
    (when 
      (and 
        (isData $a) 
        (and 
          (isData $b) 
          (isData $c))) 
      (: 
        (STTrans 
          (: $bc 
            (<: $b $c)) 
          (: $ab 
            (<: $a $b))) 
        (<: $a $c)))))
 
</span>;;;; Recursive step for subtyping coercion.
<span class="ansi38-255165000"> (= (type-annotated-bc $kb (S $k) (: (coerce (: $ab (<: $a $b))) (-> (: $x $a) $b)))  
  (let 
    (: $ab 
      (<: $a $b)) 
    (type-annotated-bc $kb $k 
      (: $ab 
        (<: $a $b))) 
    (when 
      (and 
        (isData $a) 
        (isData $b)) 
      (: 
        (coerce (: $ab (<: $a $b))) 
        (-> 
          (: $x $a) $b)))))
 
</span>;;;; Recursive step: bluebird
<span class="ansi38-255165000"> (= (type-annotated-bc $kb (S $k) (: (. (: $f (-> (: $y $b) $c)) (: $g (-> (: $x $a) $b))) (-> (: $x $a) $c)))  
  (let* 
    ( ( (: $f 
          (-> 
            (: $y $b) $c)) (type-annotated-bc $kb $k (: $f (-> (: $y $b) $c)))) ((: $g (-> (: $x $a) $b)) (type-annotated-bc $kb $k (: $g (-> (: $x $a) $b))))) 
    (when 
      (and 
        (isData $a) 
        (and 
          (isData $b) 
          (isData $c))) 
      (: 
        (. 
          (: $f 
            (-> 
              (: $y $b) $c)) 
          (: $g 
            (-> 
              (: $x $a) $b))) 
        (-> 
          (: $x $a) $c)))))
 
</span>;;;; Recursive step: phoenix
<span class="ansi38-255165000"> (= (type-annotated-bc $kb (S $k) (: (Φ (: $f (-> (: $y $b) (: $z $c) $d)) (: $g (-> (: $x $a) $b)) (: $h (-> (: $x $a) $c))) (-> (: $x $a) $d)))  
  (let* 
    ( ( (: $f 
          (-> 
            (: $y $b) 
            (: $z $c) $d)) (type-annotated-bc $kb $k (: $f (-> (: $y $b) (: $z $c) $d)))) 
      ( (: $g 
          (-> 
            (: $x $a) $b)) (type-annotated-bc $kb $k (: $g (-> (: $x $a) $b)))) 
      ( (: $h 
          (-> 
            (: $x $a) $c)) (type-annotated-bc $kb $k (: $h (-> (: $x $a) $c))))) 
    (when 
      (and 
        (isData $a) 
        (and 
          (isData $b) 
          (and 
            (isData $c) 
            (isData $d)))) 
      (: 
        (Φ 
          (: $f 
            (-> 
              (: $y $b) 
              (: $z $c) $d)) 
          (: $g 
            (-> 
              (: $x $a) $b)) 
          (: $h 
            (-> 
              (: $x $a) $c))) 
        (-> 
          (: $x $a) $d)))))
 
</span>;;;; Recursive step for machine-translation.translate.  The point of
;;;; embedding the machine-translation.translate call in the backward
;;;; chainer is to be able to infer the correct parameters (in/out
;;;; languages) for call the service.
<span class="ansi38-255165000"> (= (type-annotated-bc $kb (S $k) (: (machine-translation.translate (: $in_nl NaturalLanguage) (: $out_nl NaturalLanguage)) (-> (: $url (UniformResourceLocatorOfType (TextIn $in_nl))) (TextIn $out_nl))))  
  (let* 
    ( ( (: $in_nl NaturalLanguage) (type-annotated-bc $kb $k (: $in_nl NaturalLanguage))) ((: $out_nl NaturalLanguage) (type-annotated-bc $kb $k (: $out_nl NaturalLanguage)))) 
    (: 
      (machine-translation.translate 
        (: $in_nl NaturalLanguage) 
        (: $out_nl NaturalLanguage)) 
      (-> 
        (: $url 
          (UniformResourceLocatorOfType (TextIn $in_nl))) 
        (TextIn $out_nl)))))
 
</span>;;;; Add type missing annotation to be compatible with type-annotated-bc
;;;; query format.  Whatever is missing is only added as variables, not
;;;; inferred, for that one may use the bc.  Note that the first
;;;; annotation must be provided manually
;;;;
;;;; For instance
;;;;
;;;; (add-type-annotation-holes (ModusPonens ab a))
;;;;
;;;; only outputs
;;;;
;;;; (ModusPonens (: ab $t#1) (: a $t#2))
;;;;
;;;; not
;;;;
;;;; (: (ModusPonens (: ab $t#1) (: a $t#2)) $t#3)
;;;;
;;;; That is because add-type can only detect application, that is a
;;;; term of the form (<ABS> <ARG>) to add the type annotation to <ARG>.
<span class="ansi38-255165000"> (: add-type-annotation-holes (-> $a $a))
 
</span><span class="ansi38-255165000"> (= (add-type-annotation-holes $term)  
  (case 
    (get-metatype $term) 
    ( (Symbol $term) 
      (Grounded $term) 
      (Variable $term) 
      (Expression (case $term ((() ()) (($x) ((add-type-annotation-hole $x))) (($x $y) ((add-type-annotation-holes $x) (: (add-type-annotation-holes $y) $a))) (($x $y $z) (if (== $x :) (: (add-type-annotation-holes $y) $z) ((add-type-annotation-holes $x) (: (add-type-annotation-holes $y) $a) (: (add-type-annotation-holes $z) $b)))) (($x $y $z $w) ((add-type-annotation-holes $x) (: (add-type-annotation-holes $y) $a) (: (add-type-annotation-holes $z) $b) (: (add-type-annotation-holes $w) $c))) ($7815342 $7815348)))))))
 
</span>;;;; Test add-type-annotation-holes
<span class="ansi38-013099040">

!(assertAlphaEqual (add-type-annotation-holes (: (STTrans VA VIV) (<: (VocalsIn "English") Audio))) (: (STTrans (: VA $a) (: VIV $b)) (<: (VocalsIn "English") Audio)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_add-type-annotation-holes'(D, C), E, E=['add-type-annotation-holes', D], (F=['STTrans', 'VA', 'VIV'], G=['VocalsIn', "English"], H=[<:, G, 'Audio'], D=[:, F, H])), I=ispuU(J, (K=[:, 'VA', _], L=[:, 'VIV', _], M=['STTrans', K, L], N=['VocalsIn', "English"], O=[<:, N, 'Audio'], J=[:, M, O])), mc__1_2_assertAlphaEqual(B, I, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.43">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.43</h3>
; 
; EVAL TEST
; took 0.000446 secs. (445.80 microseconds) 

!(assertAlphaEqual [ispeEnNC $7955426 [mc__1_1_add-type-annotation-holes $7955438 $7955426] $7955430 [ = $7955430 (add-type-annotation-holes $7955438) ] [ , [ = $7955468 (STTrans VA VIV) ] [ , [ = $7955498 (VocalsIn "English") ] [ , [ = $7955522 (<: $7955498 Audio) ] [ = $7955438 (: $7955468 $7955522) ] ] ] ]] [ispuU $7955576 [ , [ = $7955588 (: VA $a) ] [ , [ = $7955632 (: VIV $b) ] [ , [ = $7955676 (STTrans $7955588 $7955632) ] [ , [ = $7955706 (VocalsIn "English") ] [ , [ = $7955730 (<: $7955706 Audio) ] [ = $7955576 (: $7955676 $7955730) ] ] ] ] ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l alpha_equ 
      ( (: 
          (STTrans 
            (: VA $7957462) 
            (: VIV $7957486)) 
          (<: 
            (VocalsIn "English") Audio))) 
      ( (: 
          (STTrans 
            (: VA $a) 
            (: VIV $b)) 
          (<: 
            (VocalsIn "English") Audio)))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertAlphaEqual (add-type-annotation-holes (coerce (STTrans VA VIV))) (coerce (: (STTrans (: VA $a) (: VIV $b)) $c)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_add-type-annotation-holes'(D, C), E, E=['add-type-annotation-holes', D], (F=['STTrans', 'VA', 'VIV'], D=[coerce, F])), G=ispuU(H, (I=[:, 'VA', _], J=[:, 'VIV', _], K=['STTrans', I, J], L=[:, K, _], H=[coerce, L])), mc__1_2_assertAlphaEqual(B, G, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.44">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.44</h3>
; 
; EVAL TEST
; took 0.000392 secs. (391.80 microseconds) 

!(assertAlphaEqual [ispeEnNC $7994792 [mc__1_1_add-type-annotation-holes $7994804 $7994792] $7994796 [ = $7994796 (add-type-annotation-holes $7994804) ] [ , [ = $7994834 (STTrans VA VIV) ] [ = $7994804 (coerce $7994834) ] ]] [ispuU $7994882 [ , [ = $7994894 (: VA $a) ] [ , [ = $7994938 (: VIV $b) ] [ , [ = $7994982 (STTrans $7994894 $7994938) ] [ , [ = $7995012 (: $7994982 $c) ] [ = $7994882 (coerce $7995012) ] ] ] ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l alpha_equ 
      ( (coerce (: (STTrans (: VA $7998444) (: VIV $7998468)) $7998474))) 
      ( (coerce (: (STTrans (: VA $a) (: VIV $b)) $c)))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertAlphaEqual (add-type-annotation-holes (: (. (Φ midi2voice-zh.singingZH (. (machine-translation.translate "English" "Chinese") (. upload speech-recognition.s2t)) tomidi.a2m) (coerce SIA)) (-> (: $x (SongIn $l)) (VocalsIn "Chinese")))) (: (. (: (Φ (: midi2voice-zh.singingZH $a) (: (. (: (machine-translation.translate (: "English" $b) (: "Chinese" $c)) $d) (: (. (: upload $e) (: speech-recognition.s2t $f)) $g)) $h) (: tomidi.a2m $i)) $j) (: (coerce (: SIA $k)) $m)) (-> (: $x (SongIn $l)) (VocalsIn "Chinese"))))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_add-type-annotation-holes'(D, C), E, E=['add-type-annotation-holes', D], (F=['machine-translation.translate', "English", "Chinese"], G=['.', upload, 'speech-recognition.s2t'], H=['.', F, G], I=['Φ', 'midi2voice-zh.singingZH', H, 'tomidi.a2m'], J=[coerce, 'SIA'], K=['.', I, J], L=['SongIn', M], N=[:, O, L], P=['VocalsIn', "Chinese"], Q=[->, N, P], D=[:, K, Q])), R=ispuU(S, (T=[:, 'midi2voice-zh.singingZH', _], U=[:, "English", _], V=[:, "Chinese", _], W=['machine-translation.translate', U, V], X=[:, W, _], Y=[:, upload, _], Z=[:, 'speech-recognition.s2t', _], A1=['.', Y, Z], B1=[:, A1, _], C1=['.', X, B1], D1=[:, C1, _], E1=[:, 'tomidi.a2m', _], F1=['Φ', T, D1, E1], G1=[:, F1, _], H1=[:, 'SIA', _], I1=[coerce, H1], J1=[:, I1, _], K1=['.', G1, J1], L1=['SongIn', M], M1=[:, O, L1], N1=['VocalsIn', "Chinese"], O1=[->, M1, N1], S=[:, K1, O1])), mc__1_2_assertAlphaEqual(B, R, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.45">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.45</h3>
; 
; EVAL TEST
; took 0.000837 secs. (836.80 microseconds) 

!(assertAlphaEqual [ispeEnNC $8078718 [mc__1_1_add-type-annotation-holes $8078730 $8078718] $8078722 [ = $8078722 (add-type-annotation-holes $8078730) ] [ , [ = $8078760 (machine-translation.translate "English" "Chinese") ] [ , [ = $8078790 (. upload speech-recognition.s2t) ] [ , [ = $8078820 (. $8078760 $8078790) ] [ , [ = $8078850 (Φ midi2voice-zh.singingZH $8078820 tomidi.a2m) ] [ , [ = $8078886 (coerce SIA) ] [ , [ = $8078910 (. $8078850 $8078886) ] [ , [ = $8078940 (SongIn $l) ] [ , [ = $8078978 (: $x $8078940) ] [ , [ = $8079022 (VocalsIn "Chinese") ] [ , [ = $8079046 (-> $8078978 $8079022) ] [ = $8078730 (: $8078910 $8079046) ] ] ] ] ] ] ] ] ] ] ]] [ispuU $8079100 [ , [ = $8079112 (: midi2voice-zh.singingZH $a) ] [ , [ = $8079156 (: "English" $b) ] [ , [ = $8079200 (: "Chinese" $c) ] [ , [ = $8079244 (machine-translation.translate $8079156 $8079200) ] [ , [ = $8079274 (: $8079244 $d) ] [ , [ = $8079318 (: upload $e) ] [ , [ = $8079362 (: speech-recognition.s2t $f) ] [ , [ = $8079406 (. $8079318 $8079362) ] [ , [ = $8079436 (: $8079406 $g) ] [ , [ = $8079480 (. $8079274 $8079436) ] [ , [ = $8079510 (: $8079480 $h) ] [ , [ = $8079554 (: tomidi.a2m $i) ] [ , [ = $8079598 (Φ $8079112 $8079510 $8079554) ] [ , [ = $8079634 (: $8079598 $j) ] [ , [ = $8079678 (: SIA $k) ] [ , [ = $8079722 (coerce $8079678) ] [ , [ = $8079746 (: $8079722 $m) ] [ , [ = $8079790 (. $8079634 $8079746) ] [ , [ = $8079820 (SongIn $l) ] [ , [ = $8079844 (: $x $8079820) ] [ , [ = $8079874 (VocalsIn "Chinese") ] [ , [ = $8079898 (-> $8079844 $8079874) ] [ = $8079100 (: $8079790 $8079898) ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l alpha_equ 
      ( (: 
          (. 
            (: 
              (Φ 
                (: midi2voice-zh.singingZH $8099540) 
                (: 
                  (. 
                    (: 
                      (machine-translation.translate 
                        (: "English" $8099620) 
                        (: "Chinese" $8099652)) $8099658) 
                    (: 
                      (. 
                        (: upload $8099706) 
                        (: speech-recognition.s2t $8099730)) $8099736)) $8099742) 
                (: tomidi.a2m $8099766)) $8099772) 
            (: 
              (coerce (: SIA $8099820)) $8099826)) 
          (-> 
            (: $x 
              (SongIn $l)) 
            (VocalsIn "Chinese")))) 
      ( (: 
          (. 
            (: 
              (Φ 
                (: midi2voice-zh.singingZH $a) 
                (: 
                  (. 
                    (: 
                      (machine-translation.translate 
                        (: "English" $b) 
                        (: "Chinese" $c)) $d) 
                    (: 
                      (. 
                        (: upload $e) 
                        (: speech-recognition.s2t $f)) $g)) $h) 
                (: tomidi.a2m $i)) $j) 
            (: 
              (coerce (: SIA $k)) $m)) 
          (-> 
            (: $x 
              (SongIn $l)) 
            (VocalsIn "Chinese"))))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertAlphaEqual (add-type-annotation-holes (: (. (Φ mixer.mix sound-spleeter.DTLOutput.accomp (. (Φ midi2voice-zh.singingZH (. (machine-translation.translate "English" "Chinese") (. upload speech-recognition.s2t)) tomidi.a2m) (. (coerce (STTrans VA VIV)) sound-spleeter.DTLOutput.vocals))) sound-spleeter.spleeter) (-> (: $x (SongIn "English")) (SongIn "Chinese")))) (: (. (: (Φ (: mixer.mix $a) (: sound-spleeter.DTLOutput.accomp $b) (: (. (: (Φ (: midi2voice-zh.singingZH $c) (: (. (: (machine-translation.translate (: "English" $d) (: "Chinese" $e)) $f) (: (. (: upload $g) (: speech-recognition.s2t $h)) $i)) $j) (: tomidi.a2m $k)) $l) (: (. (: (coerce (: (STTrans (: VA $m) (: VIV $n)) $o)) $p) (: sound-spleeter.DTLOutput.vocals $q)) $r)) $s)) $t) (: sound-spleeter.spleeter $u)) (-> (: $x (SongIn "English")) (SongIn "Chinese"))))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_add-type-annotation-holes'(D, C), E, E=['add-type-annotation-holes', D], (F=['machine-translation.translate', "English", "Chinese"], G=['.', upload, 'speech-recognition.s2t'], H=['.', F, G], I=['Φ', 'midi2voice-zh.singingZH', H, 'tomidi.a2m'], J=['STTrans', 'VA', 'VIV'], K=[coerce, J], L=['.', K, 'sound-spleeter.DTLOutput.vocals'], M=['.', I, L], N=['Φ', 'mixer.mix', 'sound-spleeter.DTLOutput.accomp', M], O=['.', N, 'sound-spleeter.spleeter'], P=['SongIn', "English"], Q=[:, R, P], S=['SongIn', "Chinese"], T=[->, Q, S], D=[:, O, T])), U=ispuU(V, (W=[:, 'mixer.mix', _], X=[:, 'sound-spleeter.DTLOutput.accomp', _], Y=[:, 'midi2voice-zh.singingZH', _], Z=[:, "English", _], A1=[:, "Chinese", _], B1=['machine-translation.translate', Z, A1], C1=[:, B1, _], D1=[:, upload, _], E1=[:, 'speech-recognition.s2t', _], F1=['.', D1, E1], G1=[:, F1, _], H1=['.', C1, G1], I1=[:, H1, _], J1=[:, 'tomidi.a2m', _], K1=['Φ', Y, I1, J1], L1=[:, K1, _], M1=[:, 'VA', _], N1=[:, 'VIV', _], O1=['STTrans', M1, N1], P1=[:, O1, _], Q1=[coerce, P1], R1=[:, Q1, _], S1=[:, 'sound-spleeter.DTLOutput.vocals', _], T1=['.', R1, S1], U1=[:, T1, _], V1=['.', L1, U1], W1=[:, V1, _], X1=['Φ', W, X, W1], Y1=[:, X1, _], Z1=[:, 'sound-spleeter.spleeter', _], A2=['.', Y1, Z1], B2=['SongIn', "English"], C2=[:, R, B2], D2=['SongIn', "Chinese"], E2=[->, C2, D2], V=[:, A2, E2])), mc__1_2_assertAlphaEqual(B, U, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.46">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.46</h3>
; 
; EVAL TEST
; took 0.002 secs. (1.60 milliseconds) 

!(assertAlphaEqual [ispeEnNC $8274966 [mc__1_1_add-type-annotation-holes $8274978 $8274966] $8274970 [ = $8274970 (add-type-annotation-holes $8274978) ] [ , [ = $8275008 (machine-translation.translate "English" "Chinese") ] [ , [ = $8275038 (. upload speech-recognition.s2t) ] [ , [ = $8275068 (. $8275008 $8275038) ] [ , [ = $8275098 (Φ midi2voice-zh.singingZH $8275068 tomidi.a2m) ] [ , [ = $8275134 (STTrans VA VIV) ] [ , [ = $8275164 (coerce $8275134) ] [ , [ = $8275188 (. $8275164 sound-spleeter.DTLOutput.vocals) ] [ , [ = $8275218 (. $8275098 $8275188) ] [ , [ = $8275248 (Φ mixer.mix sound-spleeter.DTLOutput.accomp $8275218) ] [ , [ = $8275284 (. $8275248 sound-spleeter.spleeter) ] [ , [ = $8275314 (SongIn "English") ] [ , [ = $8275338 (: $x $8275314) ] [ , [ = $8275382 (SongIn "Chinese") ] [ , [ = $8275406 (-> $8275338 $8275382) ] [ = $8274978 (: $8275284 $8275406) ] ] ] ] ] ] ] ] ] ] ] ] ] ] ]] [ispuU $8275460 [ , [ = $8275472 (: mixer.mix $a) ] [ , [ = $8275516 (: sound-spleeter.DTLOutput.accomp $b) ] [ , [ = $8275560 (: midi2voice-zh.singingZH $c) ] [ , [ = $8275604 (: "English" $d) ] [ , [ = $8275648 (: "Chinese" $e) ] [ , [ = $8275692 (machine-translation.translate $8275604 $8275648) ] [ , [ = $8275722 (: $8275692 $f) ] [ , [ = $8275766 (: upload $g) ] [ , [ = $8275810 (: speech-recognition.s2t $h) ] [ , [ = $8275854 (. $8275766 $8275810) ] [ , [ = $8275884 (: $8275854 $i) ] [ , [ = $8275928 (. $8275722 $8275884) ] [ , [ = $8275958 (: $8275928 $j) ] [ , [ = $8276002 (: tomidi.a2m $k) ] [ , [ = $8276046 (Φ $8275560 $8275958 $8276002) ] [ , [ = $8276082 (: $8276046 $l) ] [ , [ = $8276126 (: VA $m) ] [ , [ = $8276170 (: VIV $n) ] [ , [ = $8276214 (STTrans $8276126 $8276170) ] [ , [ = $8276244 (: $8276214 $o) ] [ , [ = $8276288 (coerce $8276244) ] [ , [ = $8276312 (: $8276288 $p) ] [ , [ = $8276356 (: sound-spleeter.DTLOutput.vocals $q) ] [ , [ = $8276400 (. $8276312 $8276356) ] [ , [ = $8276430 (: $8276400 $r) ] [ , [ = $8276474 (. $8276082 $8276430) ] [ , [ = $8276504  [:,_8276474,_8276528{$_s}]  ] [ ,  _8276548=['Φ',_8275472,_8275516,_8276504]   _8276584=[:,_8276548,_8276608{$_t}],_8276628=[:,'sound-spleeter.spleeter',_8276652{$_u}],_8276672=['.',_8276584,_8276628],_8276702=['SongIn',"English"],_8276726=[:,_8275356{$_x},_8276702],_8276756=['SongIn',"Chinese"],_8276780=[->,_8276726,_8276756],_8275460=[:,_8276672,_8276780]  ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l alpha_equ 
      ( (: 
          (. 
            (: 
              (Φ 
                (: mixer.mix $8305362) 
                (: sound-spleeter.DTLOutput.accomp $8305386) 
                (: 
                  (. 
                    (: 
                      (Φ 
                        (: midi2voice-zh.singingZH $8305458) 
                        (: 
                          (. 
                            (: 
                              (machine-translation.translate 
                                (: "English" $8305538) 
                                (: "Chinese" $8305570)) $8305576) 
                            (: 
                              (. 
                                (: upload $8305624) 
                                (: speech-recognition.s2t $8305648)) $8305654)) $8305660) 
                        (: tomidi.a2m $8305684)) $8305690) 
                    (: 
                      (. 
                        (: 
                          (coerce (: (STTrans (: VA $8305786) (: VIV $8305810)) $8305816)) $8305822) 
                        (: sound-spleeter.DTLOutput.vocals $8305846)) $8305852)) $8305858)) $8305864) 
            (: sound-spleeter.spleeter $8305888)) 
          (-> 
            (: $x 
              (SongIn "English")) 
            (SongIn "Chinese")))) 
      ( (: 
          (. 
            (: 
              (Φ 
                (: mixer.mix $a) 
                (: sound-spleeter.DTLOutput.accomp $b) 
                (: 
                  (. 
                    (: 
                      (Φ 
                        (: midi2voice-zh.singingZH $c) 
                        (: 
                          (. 
                            (: 
                              (machine-translation.translate 
                                (: "English" $d) 
                                (: "Chinese" $e)) $f) 
                            (: 
                              (. 
                                (: upload $g) 
                                (: speech-recognition.s2t $h)) $i)) $j) 
                        (: tomidi.a2m $k)) $l) 
                    (: 
                      (. 
                        (: 
                          (coerce (: (STTrans (: VA $m) (: VIV $n)) $o)) $p) 
                        (: sound-spleeter.DTLOutput.vocals $q)) $r)) $s)) $t) 
            (: sound-spleeter.spleeter $u)) 
          (-> 
            (: $x 
              (SongIn "English")) 
            (SongIn "Chinese"))))]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Remove type annotations from a query.
;;;;
;;;; For instance
;;;;
;;;; (remove-type-annotations (: (ModusPonens (: ab (→ A B)) (: a A)) B))
;;;;
;;;; outputs
;;;;
;;;; (ModusPonens ab a)
<span class="ansi38-255165000"> (: remove-type-annotations (-> $a $a))
 
</span><span class="ansi38-255165000"> (= (remove-type-annotations $term)  
  (case 
    (get-metatype $term) 
    ( (Symbol $term) 
      (Grounded $term) 
      (Variable $term) 
      (Expression (case $term ((() ()) (($x $y $z) (if (== $x :) (remove-type-annotations $y) ((remove-type-annotations $x) (remove-type-annotations $y) (remove-type-annotations $z)))) ($else (let* (($head (car-atom $term)) ($tail (cdr-atom $term)) ($rth (remove-type-annotations $head)) ($rtt (remove-type-annotations $tail))) (cons-atom $rth $rtt)))))))))
 
</span>;;;; Test remove-type-annotations
<span class="ansi38-013099040">

!(assertEqual (remove-type-annotations (: (STTrans (: VA $a) (: VIV $b)) (<: (VocalsIn "English") Audio))) (STTrans VA VIV))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_remove-type-annotations'(D, C), E, E=['remove-type-annotations', D], (F=[:, 'VA', _], G=[:, 'VIV', _], H=['STTrans', F, G], I=['VocalsIn', "English"], J=[<:, I, 'Audio'], D=[:, H, J])), K=ispuU(L, L=['STTrans', 'VA', 'VIV']), mc__1_2_assertEqual(B, K, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.47">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.47</h3>
; 
; EVAL TEST
; took 0.000362 secs. (361.60 microseconds) 

!(assertEqual [ispeEnNC $8620128 [mc__1_1_remove-type-annotations $8620140 $8620128] $8620132 [ = $8620132 (remove-type-annotations $8620140) ] [ , [ = $8620170 (: VA $a) ] [ , [ = $8620214 (: VIV $b) ] [ , [ = $8620258 (STTrans $8620170 $8620214) ] [ , [ = $8620288 (VocalsIn "English") ] [ , [ = $8620312 (<: $8620288 Audio) ] [ = $8620140 (: $8620258 $8620312) ] ] ] ] ] ]] [ispuU $8620366 [ = $8620366 (STTrans VA VIV) ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (STTrans VA VIV)) 
      ( (STTrans VA VIV))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertAlphaEqual (remove-type-annotations (: (. (: (machine-translation.translate (: "English" $b) (: "Chinese" $c)) $d) (: (. (: upload $e) (: speech-recognition.s2t $f)) $g)) $h)) (. (machine-translation.translate "English" "Chinese") (. upload speech-recognition.s2t)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_remove-type-annotations'(D, C), E, E=['remove-type-annotations', D], (F=[:, "English", _], G=[:, "Chinese", _], H=['machine-translation.translate', F, G], I=[:, H, _], J=[:, upload, _], K=[:, 'speech-recognition.s2t', _], L=['.', J, K], M=[:, L, _], N=['.', I, M], D=[:, N, _])), O=ispuU(P, (Q=['machine-translation.translate', "English", "Chinese"], R=['.', upload, 'speech-recognition.s2t'], P=['.', Q, R])), mc__1_2_assertAlphaEqual(B, O, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.48">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.48</h3>
; 
; EVAL TEST
; took 0.000467 secs. (467.00 microseconds) 

!(assertAlphaEqual [ispeEnNC $8664066 [mc__1_1_remove-type-annotations $8664078 $8664066] $8664070 [ = $8664070 (remove-type-annotations $8664078) ] [ , [ = $8664108 (: "English" $b) ] [ , [ = $8664152 (: "Chinese" $c) ] [ , [ = $8664196 (machine-translation.translate $8664108 $8664152) ] [ , [ = $8664226 (: $8664196 $d) ] [ , [ = $8664270 (: upload $e) ] [ , [ = $8664314 (: speech-recognition.s2t $f) ] [ , [ = $8664358 (. $8664270 $8664314) ] [ , [ = $8664388 (: $8664358 $g) ] [ , [ = $8664432 (. $8664226 $8664388) ] [ = $8664078 (: $8664432 $h) ] ] ] ] ] ] ] ] ] ]] [ispuU $8664500 [ , [ = $8664512 (machine-translation.translate "English" "Chinese") ] [ , [ = $8664542 (. upload speech-recognition.s2t) ] [ = $8664500 (. $8664512 $8664542) ] ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l alpha_equ 
      ( (. 
          (machine-translation.translate "English" "Chinese") 
          (. upload speech-recognition.s2t))) 
      ( (. 
          (machine-translation.translate "English" "Chinese") 
          (. upload speech-recognition.s2t)))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertAlphaEqual (remove-type-annotations (: (Φ (: midi2voice-zh.singingZH $a) (: (. (: (machine-translation.translate (: "English" $b) (: "Chinese" $c)) $d) (: (. (: upload $e) (: speech-recognition.s2t $f)) $g)) $h) (: tomidi.a2m $i)) $j)) (Φ midi2voice-zh.singingZH (. (machine-translation.translate "English" "Chinese") (. upload speech-recognition.s2t)) tomidi.a2m))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_remove-type-annotations'(D, C), E, E=['remove-type-annotations', D], (F=[:, 'midi2voice-zh.singingZH', _], G=[:, "English", _], H=[:, "Chinese", _], I=['machine-translation.translate', G, H], J=[:, I, _], K=[:, upload, _], L=[:, 'speech-recognition.s2t', _], M=['.', K, L], N=[:, M, _], O=['.', J, N], P=[:, O, _], Q=[:, 'tomidi.a2m', _], R=['Φ', F, P, Q], D=[:, R, _])), S=ispuU(T, (U=['machine-translation.translate', "English", "Chinese"], V=['.', upload, 'speech-recognition.s2t'], W=['.', U, V], T=['Φ', 'midi2voice-zh.singingZH', W, 'tomidi.a2m'])), mc__1_2_assertAlphaEqual(B, S, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.49">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.49</h3>
; 
; EVAL TEST
; took 0.000825 secs. (824.90 microseconds) 

!(assertAlphaEqual [ispeEnNC $8718454 [mc__1_1_remove-type-annotations $8718466 $8718454] $8718458 [ = $8718458 (remove-type-annotations $8718466) ] [ , [ = $8718496 (: midi2voice-zh.singingZH $a) ] [ , [ = $8718540 (: "English" $b) ] [ , [ = $8718584 (: "Chinese" $c) ] [ , [ = $8718628 (machine-translation.translate $8718540 $8718584) ] [ , [ = $8718658 (: $8718628 $d) ] [ , [ = $8718702 (: upload $e) ] [ , [ = $8718746 (: speech-recognition.s2t $f) ] [ , [ = $8718790 (. $8718702 $8718746) ] [ , [ = $8718820 (: $8718790 $g) ] [ , [ = $8718864 (. $8718658 $8718820) ] [ , [ = $8718894 (: $8718864 $h) ] [ , [ = $8718938 (: tomidi.a2m $i) ] [ , [ = $8718982 (Φ $8718496 $8718894 $8718938) ] [ = $8718466 (: $8718982 $j) ] ] ] ] ] ] ] ] ] ] ] ] ] ]] [ispuU $8719056 [ , [ = $8719068 (machine-translation.translate "English" "Chinese") ] [ , [ = $8719098 (. upload speech-recognition.s2t) ] [ , [ = $8719128 (. $8719068 $8719098) ] [ = $8719056 (Φ midi2voice-zh.singingZH $8719128 tomidi.a2m) ] ] ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l alpha_equ 
      ( (Φ midi2voice-zh.singingZH 
          (. 
            (machine-translation.translate "English" "Chinese") 
            (. upload speech-recognition.s2t)) tomidi.a2m)) 
      ( (Φ midi2voice-zh.singingZH 
          (. 
            (machine-translation.translate "English" "Chinese") 
            (. upload speech-recognition.s2t)) tomidi.a2m))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertAlphaEqual (remove-type-annotations (. (: (Φ (: midi2voice-zh.singingZH $a) (: (. (: (machine-translation.translate (: "English" $b) (: "Chinese" $c)) $d) (: (. (: upload $e) (: speech-recognition.s2t $f)) $g)) $h) (: tomidi.a2m $i)) $j) (: (coerce (: SIA $k)) $l))) (. (Φ midi2voice-zh.singingZH (. (machine-translation.translate "English" "Chinese") (. upload speech-recognition.s2t)) tomidi.a2m) (coerce SIA)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_remove-type-annotations'(D, C), E, E=['remove-type-annotations', D], (F=[:, 'midi2voice-zh.singingZH', _], G=[:, "English", _], H=[:, "Chinese", _], I=['machine-translation.translate', G, H], J=[:, I, _], K=[:, upload, _], L=[:, 'speech-recognition.s2t', _], M=['.', K, L], N=[:, M, _], O=['.', J, N], P=[:, O, _], Q=[:, 'tomidi.a2m', _], R=['Φ', F, P, Q], S=[:, R, _], T=[:, 'SIA', _], U=[coerce, T], V=[:, U, _], D=['.', S, V])), W=ispuU(X, (Y=['machine-translation.translate', "English", "Chinese"], Z=['.', upload, 'speech-recognition.s2t'], A1=['.', Y, Z], B1=['Φ', 'midi2voice-zh.singingZH', A1, 'tomidi.a2m'], C1=[coerce, 'SIA'], X=['.', B1, C1])), mc__1_2_assertAlphaEqual(B, W, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.50">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.50</h3>
; 
; EVAL TEST
; took 0.000915 secs. (915.50 microseconds) 

!(assertAlphaEqual [ispeEnNC $8783660 [mc__1_1_remove-type-annotations $8783672 $8783660] $8783664 [ = $8783664 (remove-type-annotations $8783672) ] [ , [ = $8783702 (: midi2voice-zh.singingZH $a) ] [ , [ = $8783746 (: "English" $b) ] [ , [ = $8783790 (: "Chinese" $c) ] [ , [ = $8783834 (machine-translation.translate $8783746 $8783790) ] [ , [ = $8783864 (: $8783834 $d) ] [ , [ = $8783908 (: upload $e) ] [ , [ = $8783952 (: speech-recognition.s2t $f) ] [ , [ = $8783996 (. $8783908 $8783952) ] [ , [ = $8784026 (: $8783996 $g) ] [ , [ = $8784070 (. $8783864 $8784026) ] [ , [ = $8784100 (: $8784070 $h) ] [ , [ = $8784144 (: tomidi.a2m $i) ] [ , [ = $8784188 (Φ $8783702 $8784100 $8784144) ] [ , [ = $8784224 (: $8784188 $j) ] [ , [ = $8784268 (: SIA $k) ] [ , [ = $8784312 (coerce $8784268) ] [ , [ = $8784336 (: $8784312 $l) ] [ = $8783672 (. $8784224 $8784336) ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ]] [ispuU $8784404 [ , [ = $8784416 (machine-translation.translate "English" "Chinese") ] [ , [ = $8784446 (. upload speech-recognition.s2t) ] [ , [ = $8784476 (. $8784416 $8784446) ] [ , [ = $8784506 (Φ midi2voice-zh.singingZH $8784476 tomidi.a2m) ] [ , [ = $8784542 (coerce SIA) ] [ = $8784404 (. $8784506 $8784542) ] ] ] ] ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l alpha_equ 
      ( (. 
          (Φ midi2voice-zh.singingZH 
            (. 
              (machine-translation.translate "English" "Chinese") 
              (. upload speech-recognition.s2t)) tomidi.a2m) 
          (coerce SIA))) 
      ( (. 
          (Φ midi2voice-zh.singingZH 
            (. 
              (machine-translation.translate "English" "Chinese") 
              (. upload speech-recognition.s2t)) tomidi.a2m) 
          (coerce SIA)))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(assertAlphaEqual (remove-type-annotations (: (. (: (Φ (: midi2voice-zh.singingZH $a) (: (. (: (machine-translation.translate (: "English" $b) (: "Chinese" $c)) $d) (: (. (: upload $e) (: speech-recognition.s2t $f)) $g)) $h) (: tomidi.a2m $i)) $j) (: (coerce (: SIA $k)) $l)) (-> (: $x (SongIn $l)) (VocalsIn "Chinese")))) (. (Φ midi2voice-zh.singingZH (. (machine-translation.translate "English" "Chinese") (. upload speech-recognition.s2t)) tomidi.a2m) (coerce SIA)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=ispeEnNC(C, 'mc__1_1_remove-type-annotations'(D, C), E, E=['remove-type-annotations', D], (F=[:, 'midi2voice-zh.singingZH', _], G=[:, "English", _], H=[:, "Chinese", _], I=['machine-translation.translate', G, H], J=[:, I, _], K=[:, upload, _], L=[:, 'speech-recognition.s2t', _], M=['.', K, L], N=[:, M, _], O=['.', J, N], P=[:, O, _], Q=[:, 'tomidi.a2m', _], R=['Φ', F, P, Q], S=[:, R, _], T=[:, 'SIA', _], U=[coerce, T], V=[:, U, W], X=['.', S, V], Y=['SongIn', W], Z=[:, _, Y], A1=['VocalsIn', "Chinese"], B1=[->, Z, A1], D=[:, X, B1])), C1=ispuU(D1, (E1=['machine-translation.translate', "English", "Chinese"], F1=['.', upload, 'speech-recognition.s2t'], G1=['.', E1, F1], H1=['Φ', 'midi2voice-zh.singingZH', G1, 'tomidi.a2m'], I1=[coerce, 'SIA'], D1=['.', H1, I1])), mc__1_2_assertAlphaEqual(B, C1, A))).

</span>
;<h3 id="ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.51">;; ENGLISH-TO-CHINESE-SONG-COMP.ISSUE-FIRST-PART-COMP.51</h3>
; 
; EVAL TEST
; took 0.000899 secs. (898.60 microseconds) 

!(assertAlphaEqual [ispeEnNC $8875532 [mc__1_1_remove-type-annotations $8875544 $8875532] $8875536 [ = $8875536 (remove-type-annotations $8875544) ] [ , [ = $8875574 (: midi2voice-zh.singingZH $a) ] [ , [ = $8875618 (: "English" $b) ] [ , [ = $8875662 (: "Chinese" $c) ] [ , [ = $8875706 (machine-translation.translate $8875618 $8875662) ] [ , [ = $8875736 (: $8875706 $d) ] [ , [ = $8875780 (: upload $e) ] [ , [ = $8875824 (: speech-recognition.s2t $f) ] [ , [ = $8875868 (. $8875780 $8875824) ] [ , [ = $8875898 (: $8875868 $g) ] [ , [ = $8875942 (. $8875736 $8875898) ] [ , [ = $8875972 (: $8875942 $h) ] [ , [ = $8876016 (: tomidi.a2m $i) ] [ , [ = $8876060 (Φ $8875574 $8875972 $8876016) ] [ , [ = $8876096 (: $8876060 $j) ] [ , [ = $8876140 (: SIA $k) ] [ , [ = $8876184 (coerce $8876140) ] [ , [ = $8876208 (: $8876184 $l) ] [ , [ = $8876252 (. $8876096 $8876208) ] [ , [ = $8876282 (SongIn $l) ] [ , [ = $8876306 (: $x $8876282) ] [ , [ = $8876350 (VocalsIn "Chinese") ] [ , [ = $8876374 (-> $8876306 $8876350) ] [ = $8875544 (: $8876252 $8876374) ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ]] [ispuU $8876428 [ , [ = $8876440 (machine-translation.translate "English" "Chinese") ] [ , [ = $8876470 (. upload speech-recognition.s2t) ] [ , [ = $8876500 (. $8876440 $8876470) ] [ , [ = $8876530 (Φ midi2voice-zh.singingZH $8876500 tomidi.a2m) ] [ , [ = $8876566 (coerce SIA) ] [ = $8876428 (. $8876530 $8876566) ] ] ] ] ] ]])

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l alpha_equ 
      ( (. 
          (Φ midi2voice-zh.singingZH 
            (. 
              (machine-translation.translate "English" "Chinese") 
              (. upload speech-recognition.s2t)) tomidi.a2m) 
          (coerce SIA))) 
      ( (. 
          (Φ midi2voice-zh.singingZH 
            (. 
              (machine-translation.translate "English" "Chinese") 
              (. upload speech-recognition.s2t)) tomidi.a2m) 
          (coerce SIA)))]]
</span>
Deterministic: <span class="ansi33">()
</span>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Knowledge and rule base ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<span class="ansi38-013099040">

!(bind! &kb (new-space))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    ('mc__1_0_new-space'(B), 'mc__1_2_bind!'('&kb', B, A))).

</span>
Deterministic: <span class="ansi33">()
</span>;;;;;;;;;;;;;;;;
;;;; Ontology ;;
;;;;;;;;;;;;;;;;
;;;; The ontology tries to be based on existing ontologies when
;;;; possible.  See the following discussion for a list of ontologies
;;;;
;;;; https://github.com/singnet/ai-dsl/discussions/18
;;;; Language
<span class="ansi38-013099040">

!(add-atom &kb (: NS (<: NaturalLanguage String)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[<:, 'NaturalLanguage', 'String'], C=[:, 'NS', B], 'mc__1_2_add-atom'(space_1, C, A))).

</span><span class="ansi38-255165000"> (: NS (<: NaturalLanguage String))
 
</span>
Deterministic: <span class="ansi33">()
</span>;;; SUMO
;;;; Text
<span class="ansi38-013099040">

!(add-atom &kb (: TS (<: Text String)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[<:, 'Text', 'String'], C=[:, 'TS', B], 'mc__1_2_add-atom'(space_1, C, A))).

</span><span class="ansi38-255165000"> (: TS (<: Text String))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: TIT (<: (TextIn $l) Text)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=['TextIn', _], C=[<:, B, 'Text'], D=[:, 'TIT', C], 'mc__1_2_add-atom'(space_1, D, A))).

</span><span class="ansi38-255165000"> (: TIT (<: (TextIn $l) Text))
 
</span>
Deterministic: <span class="ansi33">()
</span>;;;; URL
<span class="ansi38-013099040">

!(add-atom &kb (: US (<: UniformResourceLocator String)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[<:, 'UniformResourceLocator', 'String'], C=[:, 'US', B], 'mc__1_2_add-atom'(space_1, C, A))).

</span><span class="ansi38-255165000"> (: US (<: UniformResourceLocator String))
 
</span>
Deterministic: <span class="ansi33">()
</span>;;; SUMO
<span class="ansi38-013099040">

!(add-atom &kb (: UTU (<: (UniformResourceLocatorOfType $t) UniformResourceLocator)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=['UniformResourceLocatorOfType', _], C=[<:, B, 'UniformResourceLocator'], D=[:, 'UTU', C], 'mc__1_2_add-atom'(space_1, D, A))).

</span><span class="ansi38-255165000"> (: UTU (<: (UniformResourceLocatorOfType $t) UniformResourceLocator))
 
</span>
Deterministic: <span class="ansi33">()
</span>;;;; MIDI
<span class="ansi38-013099040">

!(add-atom &kb (: MB (<: MusicalInstrumentDigitalInterface Bytes)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[<:, 'MusicalInstrumentDigitalInterface', 'Bytes'], C=[:, 'MB', B], 'mc__1_2_add-atom'(space_1, C, A))).

</span><span class="ansi38-255165000"> (: MB (<: MusicalInstrumentDigitalInterface Bytes))
 
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Audio
<span class="ansi38-013099040">

!(add-atom &kb (: AB (<: Audio Bytes)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[<:, 'Audio', 'Bytes'], C=[:, 'AB', B], 'mc__1_2_add-atom'(space_1, C, A))).

</span><span class="ansi38-255165000"> (: AB (<: Audio Bytes))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: IA (<: Instrumental Audio)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[<:, 'Instrumental', 'Audio'], C=[:, 'IA', B], 'mc__1_2_add-atom'(space_1, C, A))).

</span><span class="ansi38-255165000"> (: IA (<: Instrumental Audio))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: VA (<: Vocals Audio)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[<:, 'Vocals', 'Audio'], C=[:, 'VA', B], 'mc__1_2_add-atom'(space_1, C, A))).

</span><span class="ansi38-255165000"> (: VA (<: Vocals Audio))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: VIV (<: (VocalsIn $l) Vocals)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=['VocalsIn', _], C=[<:, B, 'Vocals'], D=[:, 'VIV', C], 'mc__1_2_add-atom'(space_1, D, A))).

</span><span class="ansi38-255165000"> (: VIV (<: (VocalsIn $l) Vocals))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: SIA (<: (SongIn $l) Audio)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=['SongIn', _], C=[<:, B, 'Audio'], D=[:, 'SIA', C], 'mc__1_2_add-atom'(space_1, D, A))).

</span><span class="ansi38-255165000"> (: SIA (<: (SongIn $l) Audio))
 
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Additionally we add an upper type called Data, which all data types
;;;; are subtypes of.  This can be used as pruning criterion.  In
;;;; principle we would only need to do that for the most general data
;;;; types, like String, Number, etc, however, since it is used for
;;;; pruning, such criterion should compute as fast as possible, so we
;;;; directly provide the entire transitive closure.
<span class="ansi38-013099040">

!(add-atom &kb (: BD (<: Bytes Data)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[<:, 'Bytes', 'Data'], C=[:, 'BD', B], 'mc__1_2_add-atom'(space_1, C, A))).

</span><span class="ansi38-255165000"> (: BD (<: Bytes Data))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: SD (<: String Data)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[<:, 'String', 'Data'], C=[:, 'SD', B], 'mc__1_2_add-atom'(space_1, C, A))).

</span><span class="ansi38-255165000"> (: SD (<: String Data))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: ND (<: NaturalLanguage Data)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[<:, 'NaturalLanguage', 'Data'], C=[:, 'ND', B], 'mc__1_2_add-atom'(space_1, C, A))).

</span><span class="ansi38-255165000"> (: ND (<: NaturalLanguage Data))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: TD (<: Text Data)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[<:, 'Text', 'Data'], C=[:, 'TD', B], 'mc__1_2_add-atom'(space_1, C, A))).

</span><span class="ansi38-255165000"> (: TD (<: Text Data))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: TID (<: (TextIn $l) Data)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=['TextIn', _], C=[<:, B, 'Data'], D=[:, 'TID', C], 'mc__1_2_add-atom'(space_1, D, A))).

</span><span class="ansi38-255165000"> (: TID (<: (TextIn $l) Data))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: UD (<: UniformResourceLocator Data)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[<:, 'UniformResourceLocator', 'Data'], C=[:, 'UD', B], 'mc__1_2_add-atom'(space_1, C, A))).

</span><span class="ansi38-255165000"> (: UD (<: UniformResourceLocator Data))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: UTD (<: (UniformResourceLocatorOfType $t) Data)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=['UniformResourceLocatorOfType', _], C=[<:, B, 'Data'], D=[:, 'UTD', C], 'mc__1_2_add-atom'(space_1, D, A))).

</span><span class="ansi38-255165000"> (: UTD (<: (UniformResourceLocatorOfType $t) Data))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: MD (<: MusicalInstrumentDigitalInterface Data)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[<:, 'MusicalInstrumentDigitalInterface', 'Data'], C=[:, 'MD', B], 'mc__1_2_add-atom'(space_1, C, A))).

</span><span class="ansi38-255165000"> (: MD (<: MusicalInstrumentDigitalInterface Data))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: AD (<: Audio Data)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[<:, 'Audio', 'Data'], C=[:, 'AD', B], 'mc__1_2_add-atom'(space_1, C, A))).

</span><span class="ansi38-255165000"> (: AD (<: Audio Data))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: ID (<: Instrumental Data)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[<:, 'Instrumental', 'Data'], C=[:, 'ID', B], 'mc__1_2_add-atom'(space_1, C, A))).

</span><span class="ansi38-255165000"> (: ID (<: Instrumental Data))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: VD (<: Vocals Data)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[<:, 'Vocals', 'Data'], C=[:, 'VD', B], 'mc__1_2_add-atom'(space_1, C, A))).

</span><span class="ansi38-255165000"> (: VD (<: Vocals Data))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: VID (<: (VocalsIn $l) Data)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=['VocalsIn', _], C=[<:, B, 'Data'], D=[:, 'VID', C], 'mc__1_2_add-atom'(space_1, D, A))).

</span><span class="ansi38-255165000"> (: VID (<: (VocalsIn $l) Data))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: SOD (<: (sound-spleeter.DTLOutput $l) Data)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=['sound-spleeter.DTLOutput', _], C=[<:, B, 'Data'], D=[:, 'SOD', C], 'mc__1_2_add-atom'(space_1, D, A))).

</span><span class="ansi38-255165000"> (: SOD (<: (sound-spleeter.DTLOutput $l) Data))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: VID (<: (VocalsIn $l) Data)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=['VocalsIn', _], C=[<:, B, 'Data'], D=[:, 'VID', C], 'mc__1_2_add-atom'(space_1, D, A))).

</span><span class="ansi38-255165000"> (: VID (<: (VocalsIn $l) Data))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: IND (<: Instrumental Data)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[<:, 'Instrumental', 'Data'], C=[:, 'IND', B], 'mc__1_2_add-atom'(space_1, C, A))).

</span><span class="ansi38-255165000"> (: IND (<: Instrumental Data))
 
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">

!(add-atom &kb (: SID (<: (SongIn $l) Data)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=['SongIn', _], C=[<:, B, 'Data'], D=[:, 'SID', C], 'mc__1_2_add-atom'(space_1, D, A))).

</span><span class="ansi38-255165000"> (: SID (<: (SongIn $l) Data))
 
</span>
Deterministic: <span class="ansi33">()
</span>;;;;;;;;;;;;;;;;
;;;; Services ;;
;;;;;;;;;;;;;;;;
;;;; The following is partly obtained from crawling the actual
;;;; SingularityNET market place, partly made up to simplify the
;;;; composition.
;;;; For now we paste the content of
;;;; english-song-to-chinese-song-services.metta here because the import
;;;; operation imports the stdlib as well and let stdlib functions being
;;;; used as rules and axioms by the backward chainer.
;;;;
;;;; Also, for the sake of simplicity the names have been shorten by
;;;; removing the organization.  For instance
;;;;
;;;; sound-spleeter.DTLOutput.vocals
;;;;
;;;; becomes
;;;;
;;;; vocals
;;;;
;;;; Also, only the useful definitions are kept.  For instance the
;;;; sound-spleeter.MkDTLOutput constructor is commented because it has
;;;; no use in the final composition.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Services involved in creating a composite service to turn English
;;;; singing into Chinese singing.
;;;;
;;;; The service specifications are obtained from the output of
;;;;
;;;; ./gen-snet-marketplace-metta.sh naint.machine-translation naint.midi2voice-zh snet.sound-spleeter snet.speech-recognition
;;;;
;;;; then curated to retain only the information about the type
;;;; signatures of service calls.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; MeTTa representation, generated by protobuf-metta
;;;;
;;;; Protobuf file: translate.proto
;;;; Protobuf syntax: proto3
;;;; Prefix: naint.machine-translation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Define machine-translation.translate service method
;;;;
;;;; Note: this one remains curried because the first two arguments are
;;;; viewed as parameters (this is a way to work around the rigidity of
;;;; uncurried combinators).
<span class="ansi38-013099040">

!(add-atom &kb (: machine-translation.translate (-> (: $in_nl NaturalLanguage) (: $out_nl NaturalLanguage) (-> (: $url (UniformResourceLocatorOfType (TextIn $in_nl))) (TextIn $out_nl)))))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[:, C, 'NaturalLanguage'], D=[:, E, 'NaturalLanguage'], F=['TextIn', C], G=['UniformResourceLocatorOfType', F], H=[:, _, G], I=['TextIn', E], J=[->, H, I], K=[->, B, D, J], L=[:, 'machine-translation.translate', K], 'mc__1_2_add-atom'(space_1, L, A))).

</span><span class="ansi38-255165000"> (: machine-translation.translate (-> (: $in_nl NaturalLanguage) (: $out_nl NaturalLanguage) (-> (: $url (UniformResourceLocatorOfType (TextIn $in_nl))) (TextIn $out_nl))))
 
</span>
Deterministic: <span class="ansi33">()
</span>;;;; We add an extra micro service to turn Text into a URL
<span class="ansi38-013099040">

!(add-atom &kb (: upload (-> (: $x $a) (UniformResourceLocatorOfType $a))))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[:, _, C], D=['UniformResourceLocatorOfType', C], E=[->, B, D], F=[:, upload, E], 'mc__1_2_add-atom'(space_1, F, A))).

</span><span class="ansi38-255165000"> (: upload (-> (: $x $a) (UniformResourceLocatorOfType $a)))
 
</span>
Deterministic: <span class="ansi33">()
</span>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; MeTTa representation, generated by protobuf-metta
;;;;
;;;; Protobuf file: singingZH.proto
;;;; Protobuf syntax: proto3
;;;; Protobuf package: singingZH
;;;; Prefix: midi2voice-zh
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Define midi2voice-zh.singingZH service method
<span class="ansi38-013099040">

!(add-atom &kb (: midi2voice-zh.singingZH (-> (: $text (TextIn "Chinese")) (: $midi MusicalInstrumentDigitalInterface) (VocalsIn "Chinese"))))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=['TextIn', "Chinese"], C=[:, _, B], D=[:, _, 'MusicalInstrumentDigitalInterface'], E=['VocalsIn', "Chinese"], F=[->, C, D, E], G=[:, 'midi2voice-zh.singingZH', F], 'mc__1_2_add-atom'(space_1, G, A))).

</span><span class="ansi38-255165000"> (: midi2voice-zh.singingZH (-> (: $text (TextIn "Chinese")) (: $midi MusicalInstrumentDigitalInterface) (VocalsIn "Chinese")))
 
</span>
Deterministic: <span class="ansi33">()
</span>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; MeTTa representation, generated by protobuf-metta
;;;;
;;;; Protobuf file: sound_spleeter.proto
;;;; Protobuf syntax: proto3
;;;; Prefix: snet.sound-spleeter
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;
;;;; Message Types ;;
;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;
;;;; Output ;;
;;;;;;;;;;;;;;
;;;; ;; Define sound-spleeter.Output constuctor
;;;; !(add-atom &kb (: sound-spleeter.MkOutput
;;;;                   (-> (: $voc Vocals)
;;;;                       (-> (: $inst Instrumental)
;;;;                           sound-spleeter.Output))))
;;;; ;; Define sound-spleeter.Output access functions
;;;; ;; Define sound-spleeter.Output.vocals
;;;; !(add-atom &kb (: sound-spleeter.Output.vocals
;;;;                   (-> (: $out sound-spleeter.Output)
;;;;                       Vocals)))
;;;; ;; Define sound-spleeter.Output.accomp
;;;; !(add-atom &kb (: sound-spleeter.Output.accomp
;;;;                   (-> (: $out sound-spleeter.Output)
;;;;                       Instrumental)))
;;;; DTL version of Output
;;;; ;; Define sound-spleeter.DTLOutput constuctor
;;;; !(add-atom &kb (: sound-spleeter.MkDTLOutput
;;;;                   (-> (: $l NaturalLanguage)
;;;;                       (: $voc (VocalsIn $l))
;;;;                       (: $inst Instrumental)
;;;;                       (sound-spleeter.DTLOutput $l))))
;;;; Define sound-spleeter.DTLOutput access functions
;;;; Define sound-spleeter.DTLOutput.vocals
<span class="ansi38-013099040">

!(add-atom &kb (: sound-spleeter.DTLOutput.vocals (-> (: $out (sound-spleeter.DTLOutput $l)) (VocalsIn $l))))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=['sound-spleeter.DTLOutput', C], D=[:, _, B], E=['VocalsIn', C], F=[->, D, E], G=[:, 'sound-spleeter.DTLOutput.vocals', F], 'mc__1_2_add-atom'(space_1, G, A))).

</span><span class="ansi38-255165000"> (: sound-spleeter.DTLOutput.vocals (-> (: $out (sound-spleeter.DTLOutput $l)) (VocalsIn $l)))
 
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Define sound-spleeter.OutputDTL.accomp
<span class="ansi38-013099040">

!(add-atom &kb (: sound-spleeter.DTLOutput.accomp (-> (: $out (sound-spleeter.DTLOutput $l)) Instrumental)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=['sound-spleeter.DTLOutput', _], C=[:, _, B], D=[->, C, 'Instrumental'], E=[:, 'sound-spleeter.DTLOutput.accomp', D], 'mc__1_2_add-atom'(space_1, E, A))).

</span><span class="ansi38-255165000"> (: sound-spleeter.DTLOutput.accomp (-> (: $out (sound-spleeter.DTLOutput $l)) Instrumental))
 
</span>
Deterministic: <span class="ansi33">()
</span>;;;;;;;;;;;;;;;;
;;;; Services ;;
;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;
;;;; SoundSpleeter ;;
;;;;;;;;;;;;;;;;;;;;;
;;;; ;; Define sound-spleeter.spleeter service method
;;;; !(add-atom &kb (: sound-spleeter.spleeter
;;;;                   (-> (: $audio Audio)
;;;;                       ;; We reuse the spleeter Output type to hold
;;;;                       ;; a pair of Audio
;;;;                       sound-spleeter.Output)))
;;;; Define DTL version of sound-spleeter.spleeter
<span class="ansi38-013099040">

!(add-atom &kb (: sound-spleeter.spleeter (-> (: $song (SongIn $l)) (sound-spleeter.DTLOutput $l))))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=['SongIn', C], D=[:, _, B], E=['sound-spleeter.DTLOutput', C], F=[->, D, E], G=[:, 'sound-spleeter.spleeter', F], 'mc__1_2_add-atom'(space_1, G, A))).

</span><span class="ansi38-255165000"> (: sound-spleeter.spleeter (-> (: $song (SongIn $l)) (sound-spleeter.DTLOutput $l)))
 
</span>
Deterministic: <span class="ansi33">()
</span>;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; MeTTa representation, generated by protobuf-metta
;;;;
;;;; Protobuf file: asr.proto
;;;; Protobuf syntax: proto3
;;;; Protobuf package: asr
;;;; Prefix: speech-recognition
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Define speech-recognition.s2t service method
<span class="ansi38-013099040">

!(add-atom &kb (: speech-recognition.s2t (-> (: $audio Audio) (TextIn "English"))))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[:, _, 'Audio'], C=['TextIn', "English"], D=[->, B, C], E=[:, 'speech-recognition.s2t', D], 'mc__1_2_add-atom'(space_1, E, A))).

</span><span class="ansi38-255165000"> (: speech-recognition.s2t (-> (: $audio Audio) (TextIn "English")))
 
</span>
Deterministic: <span class="ansi33">()
</span>;;;; ;; Define speech-recognition.s2t service method
;;;; !(add-atom &kb (: speech-recognition.s2t
;;;;                   (-> (: $x (VocalsIn "English"))
;;;;                       (TextIn "English"))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Handwrite missing services, ToMidi and Mixer ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;
;;;; ToMidi ;;
;;;;;;;;;;;;;;
;;;; Method
<span class="ansi38-013099040">

!(add-atom &kb (: tomidi.a2m (-> (: $audio Audio) MusicalInstrumentDigitalInterface)))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[:, _, 'Audio'], C=[->, B, 'MusicalInstrumentDigitalInterface'], D=[:, 'tomidi.a2m', C], 'mc__1_2_add-atom'(space_1, D, A))).

</span><span class="ansi38-255165000"> (: tomidi.a2m (-> (: $audio Audio) MusicalInstrumentDigitalInterface))
 
</span>
Deterministic: <span class="ansi33">()
</span>;;;;;;;;;;;;;
;;;; Mixer ;;
;;;;;;;;;;;;;
;;;; ;; Method
;;;; !(add-atom &kb (: mixer.mix (-> (: $audio1 Audio)
;;;;                                 (-> (: $audio2 Audio)
;;;;                                     Audio))))
;;;; DTL version
<span class="ansi38-013099040">

!(add-atom &kb (: mixer.mix (-> (: $inst Instrumental) (: $voc (VocalsIn $l)) (SongIn $l))))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[:, _, 'Instrumental'], C=['VocalsIn', D], E=[:, _, C], F=['SongIn', D], G=[->, B, E, F], H=[:, 'mixer.mix', G], 'mc__1_2_add-atom'(space_1, H, A))).

</span><span class="ansi38-255165000"> (: mixer.mix (-> (: $inst Instrumental) (: $voc (VocalsIn $l)) (SongIn $l)))
 
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Acrobatic attempt to specify a property about mixing without
;;;; overloading the type signature of the mixer
;;;;
;;;; (: $mixer Mixer) -> ($mixer (c1 $x) (c2 $y)) and (: $x (VocalsIn $l)) (: $y Instrumental) -> $z === mix ...) -> (: $z (SongIn $l))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Other type definitions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; English language string
<span class="ansi38-013099040">

!(add-atom &kb (: "English" NaturalLanguage))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[:, "English", 'NaturalLanguage'], 'mc__1_2_add-atom'(space_1, B, A))).

</span><span class="ansi38-255165000"> (: "English" NaturalLanguage)
 
</span>
Deterministic: <span class="ansi33">()
</span>;;;; Chinese language string
<span class="ansi38-013099040">

!(add-atom &kb (: "Chinese" NaturalLanguage))

</span><span class="ansi38-017068017">:- do_metta_runtime(A,
                    (B=[:, "Chinese", 'NaturalLanguage'], 'mc__1_2_add-atom'(space_1, B, A))).

</span><span class="ansi38-255165000"> (: "Chinese" NaturalLanguage)
 
</span>
Deterministic: <span class="ansi33">()
</span>;            [ = /home/deb12user/metta-wam/tests/quick_quality/NilG_ai-dsl/english-to-chinese-song/issue_First_part.metta 0 ]
<span class="ansi1">LoonIt Report
</span>------------
<span class="ansi32">Successes: 46
</span><span class="ansi31">Failures: 5
</span><br/> <a href="#" onclick="window.history.back(); return false;">Return to summaries</a><br/>
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[(Error (assertEqual [ispeEnN $3620214 [mc__1_0_random-index $3620214] $3620220 [ = $3620220 (random-index) ]] [ispu 823576]) ('
Got: ' (885440) '
EXP: ' (823576)))]
[()]
[(Error (assertEqual [ispeEnNC $5380284 [mc__1_1_toDOT $5380472 $5380284] $5380290 [ = $5380290 (toDOT $5380472) ] [ = $5380472 [ispu mix] ]] [ispuU $5380648 [ , [ = $5383624 (DOT.MkSymbolIdentifier __IN__ 0) ] [ , [ = $5385820 (DOT.MkLabelAttribute "\"\"") ] [ , [ = $5387880 (DOT.MkShapeAttribute DOT.Shape.None) ] [ , [ = $5386950 (Cons $5387880 Nil) ] [ , [ = $5384890 (Cons $5385820 $5386950) ] [ , [ = $5382700 (DOT.MkNode $5383624 $5384890) ] [ , [ = $5391892 (DOT.MkSymbolIdentifier __OUT__ 0) ] [ , [ = $5394088 (DOT.MkLabelAttribute "\"\"") ] [ , [ = $5396148 (DOT.MkShapeAttribute DOT.Shape.None) ] [ , [ = $5395218 (Cons $5396148 Nil) ] [ , [ = $5393158 (Cons $5394088 $5395218) ] [ , [ = $5390968 (DOT.MkNode $5391892 $5393158) ] [ , [ = $5400160 (DOT.MkSymbolIdentifier mix 823576) ] [ , [ = $5402356 (DOT.MkLabelAttribute "\"mix\"") ] [ , [ = $5404416 (DOT.MkShapeAttribute DOT.Shape.Box) ] [ , [ = $5403486 (Cons $5404416 Nil) ] [ , [ = $5401426 (Cons $5402356 $5403486) ] [ , [ = $5399236 (DOT.MkNode $5400160 $5401426) ] [ , [ = $5398306 (Cons $5399236 Nil) ] [ , [ = $5390038 (Cons $5390968 $5398306) ] [ , [ = $5381770 (Cons $5382700 $5390038) ] [ , [ = $5411158 (DOT.MkSymbolIdentifier __IN__ 0) ] [ , [ = $5413354 (DOT.MkLabelAttribute "\"\"") ] [ , [ = $5415414 (DOT.MkShapeAttribute DOT.Shape.None) ] [ , [ = $5414484 (Cons $5415414 Nil) ] [ , [ = $5412424 (Cons $5413354 $5414484) ] [ , [ = $5410234  ['DOT.MkNode',_5411158,_5412424]  ] [ ,  _5418496=['DOT.MkSymbolIdentifier',mix,823576]   _5420692=['DOT.MkLabelAttribute',"\"mix\""],_5422752=['DOT.MkShapeAttribute','DOT.Shape.Box'],_5421822=['Cons',_5422752,'Nil'],_5419762=['Cons',_5420692,_5421822],_5417572=['DOT.MkNode',_5418496,_5419762],_5409252=['DOT.MkEdge',_5410234,_5417572,'Nil'],_5428390=['DOT.MkSymbolIdentifier',mix,823576],_5430586=['DOT.MkLabelAttribute',"\"mix\""],_5432646=['DOT.MkShapeAttribute','DOT.Shape.Box'],_5431716=['Cons',_5432646,'Nil'],_5429656=['Cons',_5430586,_5431716],_5427466=['DOT.MkNode',_5428390,_5429656],_5435728=['DOT.MkSymbolIdentifier','__OUT__',0],_5437924=['DOT.MkLabelAttribute',"\"\""],_5439984=['DOT.MkShapeAttribute','DOT.Shape.None'],_5439054=['Cons',_5439984,'Nil'],_5436994=['Cons',_5437924,_5439054],_5434804=['DOT.MkNode',_5435728,_5436994],_5426484=['DOT.MkEdge',_5427466,_5434804,'Nil'],_5425554=['Cons',_5426484,'Nil'],_5408322=['Cons',_5409252,_5425554],_5445234=['DOT.MkSymbolIdentifier','__IN__',0],_5447430=['DOT.MkLabelAttribute',"\"\""],_5449490=['DOT.MkShapeAttribute','DOT.Shape.None'],_5448560=['Cons',_5449490,'Nil'],_5446500=['Cons',_5447430,_5448560],_5444310=['DOT.MkNode',_5445234,_5446500],_5452572=['DOT.MkSymbolIdentifier','__OUT__',0],_5454768=['DOT.MkLabelAttribute',"\"\""],_5456828=['DOT.MkShapeAttribute','DOT.Shape.None'],_5455898=['Cons',_5456828,'Nil'],_5453838=['Cons',_5454768,_5455898],_5451648=['DOT.MkNode',_5452572,_5453838],_5459916=['DOT.MkRankdirAttribute','DOT.Rankdir.BT'],_5458986=['Cons',_5459916,'Nil'],_5380648=['MkDOT',_5381770,_5408322,_5444310,_5451648,_5458986]  ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ]]) ('
Got: ' ((MkDOT (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier mix 885440) (Cons (DOT.MkLabelAttribute "\"mix\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil))) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier mix 885440) (Cons (DOT.MkLabelAttribute "\"mix\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier mix 885440) (Cons (DOT.MkLabelAttribute "\"mix\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) Nil) Nil)) (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkRankdirAttribute DOT.Rankdir.BT) Nil))) '
EXP: ' ((MkDOT (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier mix 823576) (Cons (DOT.MkLabelAttribute "\"mix\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil))) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier mix 823576) (Cons (DOT.MkLabelAttribute "\"mix\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier mix 823576) (Cons (DOT.MkLabelAttribute "\"mix\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) Nil) Nil)) (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkRankdirAttribute DOT.Rankdir.BT) Nil)))))]
[()]
[(Error (assertEqual [ispeEnNC $5580372 [mc__1_1_toDOT $5581820 $5580372] $5580378 [ = $5580378 (toDOT $5581820) ] [ = $5581820 [ispuU $5580488 [ , [ = $5580858 (-> A B) ] [ = $5580488 (: f $5580858) ] ]] ]] [ispuU $5582026 [ , [ = $5585002 (DOT.MkSymbolIdentifier __IN__ 0) ] [ , [ = $5587198 (DOT.MkLabelAttribute "\"\"") ] [ , [ = $5589258 (DOT.MkShapeAttribute DOT.Shape.None) ] [ , [ = $5588328 (Cons $5589258 Nil) ] [ , [ = $5586268 (Cons $5587198 $5588328) ] [ , [ = $5584078 (DOT.MkNode $5585002 $5586268) ] [ , [ = $5593270 (DOT.MkSymbolIdentifier __OUT__ 0) ] [ , [ = $5595466 (DOT.MkLabelAttribute "\"\"") ] [ , [ = $5597526 (DOT.MkShapeAttribute DOT.Shape.None) ] [ , [ = $5596596 (Cons $5597526 Nil) ] [ , [ = $5594536 (Cons $5595466 $5596596) ] [ , [ = $5592346 (DOT.MkNode $5593270 $5594536) ] [ , [ = $5601538 (DOT.MkSymbolIdentifier f 823576) ] [ , [ = $5603734 (DOT.MkLabelAttribute "\"f\"") ] [ , [ = $5605794 (DOT.MkShapeAttribute DOT.Shape.Box) ] [ , [ = $5604864 (Cons $5605794 Nil) ] [ , [ = $5602804 (Cons $5603734 $5604864) ] [ , [ = $5600614 (DOT.MkNode $5601538 $5602804) ] [ , [ = $5599684 (Cons $5600614 Nil) ] [ , [ = $5591416 (Cons $5592346 $5599684) ] [ , [ = $5583148 (Cons $5584078 $5591416) ] [ , [ = $5612536 (DOT.MkSymbolIdentifier __IN__ 0) ] [ , [ = $5614732 (DOT.MkLabelAttribute "\"\"") ] [ , [ = $5616792 (DOT.MkShapeAttribute DOT.Shape.None) ] [ , [ = $5615862 (Cons $5616792 Nil) ] [ , [ = $5613802 (Cons $5614732 $5615862) ] [ , [ = $5611612  ['DOT.MkNode',_5612536,_5613802]  ] [ ,  _5619874=['DOT.MkSymbolIdentifier',f,823576]   _5622070=['DOT.MkLabelAttribute',"\"f\""],_5624130=['DOT.MkShapeAttribute','DOT.Shape.Box'],_5623200=['Cons',_5624130,'Nil'],_5621140=['Cons',_5622070,_5623200],_5618950=['DOT.MkNode',_5619874,_5621140],_5627218=['DOT.MkLabelAttribute',"\"A\""],_5626288=['Cons',_5627218,'Nil'],_5610630=['DOT.MkEdge',_5611612,_5618950,_5626288],_5632148=['DOT.MkSymbolIdentifier',f,823576],_5634344=['DOT.MkLabelAttribute',"\"f\""],_5636404=['DOT.MkShapeAttribute','DOT.Shape.Box'],_5635474=['Cons',_5636404,'Nil'],_5633414=['Cons',_5634344,_5635474],_5631224=['DOT.MkNode',_5632148,_5633414],_5639486=['DOT.MkSymbolIdentifier','__OUT__',0],_5641682=['DOT.MkLabelAttribute',"\"\""],_5643742=['DOT.MkShapeAttribute','DOT.Shape.None'],_5642812=['Cons',_5643742,'Nil'],_5640752=['Cons',_5641682,_5642812],_5638562=['DOT.MkNode',_5639486,_5640752],_5646830=['DOT.MkLabelAttribute',"\"B\""],_5645900=['Cons',_5646830,'Nil'],_5630242=['DOT.MkEdge',_5631224,_5638562,_5645900],_5629312=['Cons',_5630242,'Nil'],_5609700=['Cons',_5610630,_5629312],_5651516=['DOT.MkSymbolIdentifier','__IN__',0],_5653712=['DOT.MkLabelAttribute',"\"\""],_5655772=['DOT.MkShapeAttribute','DOT.Shape.None'],_5654842=['Cons',_5655772,'Nil'],_5652782=['Cons',_5653712,_5654842],_5650592=['DOT.MkNode',_5651516,_5652782],_5658854=['DOT.MkSymbolIdentifier','__OUT__',0],_5661050=['DOT.MkLabelAttribute',"\"\""],_5663110=['DOT.MkShapeAttribute','DOT.Shape.None'],_5662180=['Cons',_5663110,'Nil'],_5660120=['Cons',_5661050,_5662180],_5657930=['DOT.MkNode',_5658854,_5660120],_5666198=['DOT.MkRankdirAttribute','DOT.Rankdir.BT'],_5665268=['Cons',_5666198,'Nil'],_5582026=['MkDOT',_5583148,_5609700,_5650592,_5657930,_5665268]  ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ]]) ('
Got: ' ((MkDOT (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier f 885440) (Cons (DOT.MkLabelAttribute "\"f\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil))) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier f 885440) (Cons (DOT.MkLabelAttribute "\"f\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) (Cons (DOT.MkLabelAttribute "\"A\"") Nil)) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier f 885440) (Cons (DOT.MkLabelAttribute "\"f\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkLabelAttribute "\"B\"") Nil)) Nil)) (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkRankdirAttribute DOT.Rankdir.BT) Nil))) '
EXP: ' ((MkDOT (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkNode (DOT.MkSymbolIdentifier f 823576) (Cons (DOT.MkLabelAttribute "\"f\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) Nil))) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier f 823576) (Cons (DOT.MkLabelAttribute "\"f\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) (Cons (DOT.MkLabelAttribute "\"A\"") Nil)) (Cons (DOT.MkEdge (DOT.MkNode (DOT.MkSymbolIdentifier f 823576) (Cons (DOT.MkLabelAttribute "\"f\"") (Cons (DOT.MkShapeAttribute DOT.Shape.Box) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkLabelAttribute "\"B\"") Nil)) Nil)) (DOT.MkNode (DOT.MkSymbolIdentifier __IN__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (DOT.MkNode (DOT.MkSymbolIdentifier __OUT__ 0) (Cons (DOT.MkLabelAttribute "\"\"") (Cons (DOT.MkShapeAttribute DOT.Shape.None) Nil))) (Cons (DOT.MkRankdirAttribute DOT.Rankdir.BT) Nil)))))]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[(Error (assertEqual [ispeEnNC $6372560 [mc__1_1_DOT.toString $6372682 $6372560] $6372566 [ = $6372566 (DOT.toString $6372682) ] [ , [ = $6372870 [ispu mix] ] [mc__1_1_toDOT $6372870 $6372682] ]] [ispu "digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"mix823576\" [label=\"mix\", shape=box]\n\n\"__IN__0\" -> \"mix823576\" []\n\"mix823576\" -> \"__OUT__0\" []\n}"]) ('
Got: ' ("digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"mix885440\" [label=\"mix\", shape=box]\n\n\"__IN__0\" -> \"mix885440\" []\n\"mix885440\" -> \"__OUT__0\" []\n}") '
EXP: ' ("digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"mix823576\" [label=\"mix\", shape=box]\n\n\"__IN__0\" -> \"mix823576\" []\n\"mix823576\" -> \"__OUT__0\" []\n}")))]
[()]
[(Error (assertEqual [ispeEnNC $6450272 [mc__1_1_DOT.toString $6450394 $6450272] $6450278 [ = $6450278 (DOT.toString $6450394) ] [ , [ = $6451200 [ispuU $6450510 [ = $6450510 (. f g) ]] ] [mc__1_1_toDOT $6451200 $6450394] ]] [ispu "digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"f616257\" [label=\"f\", shape=box]\n\"g823576\" [label=\"g\", shape=box]\n\n\"g823576\" -> \"f616257\" []\n\"f616257\" -> \"__OUT__0\" []\n\"__IN__0\" -> \"g823576\" []\n}"]) ('
Got: ' ("digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"f403958\" [label=\"f\", shape=box]\n\"g885440\" [label=\"g\", shape=box]\n\n\"g885440\" -> \"f403958\" []\n\"f403958\" -> \"__OUT__0\" []\n\"__IN__0\" -> \"g885440\" []\n}") '
EXP: ' ("digraph Flowchart {\nrankdir=BT\n\n\"__IN__0\" [label=\"\", shape=none]\n\"__OUT__0\" [label=\"\", shape=none]\n\"f616257\" [label=\"f\", shape=box]\n\"g823576\" [label=\"g\", shape=box]\n\n\"g823576\" -> \"f616257\" []\n\"f616257\" -> \"__OUT__0\" []\n\"__IN__0\" -> \"g823576\" []\n}")))]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]

Script done on 2025-05-05 08:39:15-07:00 [COMMAND_EXIT_CODE="1"]

</pre>
</body>

</html>
