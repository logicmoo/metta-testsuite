<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title></title>
<style type="text/css">
.ansi2html-content { display: inline; white-space: pre-wrap; word-wrap: break-word; }
.body_foreground { color: #AAAAAA; }
.body_background { background-color: #000000; }
.inv_foreground { color: #000000; }
.inv_background { background-color: #AAAAAA; }
.ansi1 { font-weight: bold; }
.ansi2 { font-weight: lighter; }
.ansi4 { text-decoration: underline; }
.ansi31 { color: #aa0000; }
.ansi32 { color: #00aa00; }
.ansi33 { color: #aa5500; }
.ansi35 { color: #E850A8; }
.ansi36 { color: #00aaaa; }
.ansi37 { color: #F5F1DE; }
.ansi40 { background-color: #000316; }
.ansi91 { color: #ff0000; }
.ansi92 { color: #00ff00; }
.ansi94 { color: #5c5cff; }
.ansi95 { color: #ff00ff; }
.ansi96 { color: #00ffff; }
.ansi97 { color: #ffffff; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-255165009 { color: #FFA509; }
.ansi38-255238088 { color: #FFEE58; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
.ansi38-013099040 { color: #0D6328; }
</style>
</head>
<body class="body_foreground body_background" style="font-size: normal;" >
<pre class="ansi2html-content">
Script started on 2025-04-25 19:00:24-07:00 [COMMAND="swipl -x /home/deb12user/metta-wam/prolog/metta_lang/Sav.HOSTAGE.MeTTaLog  -- --python=enable -- --debug --html --log --douglas --hide=fdfdf tests/quick_quality/argset-chaining/utils.metta  " TERM="xterm" TTY="/dev/pts/6" COLUMNS="160" LINES="40"]
<span class="ansi37"></span><span class="ansi37 ansi40"></span><span class="ansi37 ansi40">initialize</span>: <span class="ansi95"></span><span class="ansi95"></span><span class="ansi95">
 reset_cmdline_flags( [ '-l', 
                       '/home/deb12user/metta-wam/prolog/metta_lang/metta_interp.pl', '-g','qcompile_mettalog.',--,'--douglas', 
                       '--exeout=/home/deb12user/metta-wam/prolog/metta_lang/Sav.HOSTAGE.MeTTaLog'])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">douglas==true
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">exeout=='/home/deb12user/metta-wam/prolog/metta_lang/Sav.HOSTAGE.MeTTaLog'
</span> 
<span class="ansi37"></span><span class="ansi37 ansi40"></span><span class="ansi37 ansi40">initialize</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 os_argv( [ swipl, 
           '-x', 
           '/home/deb12user/metta-wam/prolog/metta_lang/Sav.HOSTAGE.MeTTaLog', --,'--python=enable',--, 
           '--debug','--html','--log','--douglas', 
              '--hide=fdfdf', 'tests/quick_quality/argset-chaining/utils.metta'])
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">python==enable
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">debug==true
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">html==true
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">douglas==true
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">hide==fdfdf
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi96"></span><span class="ansi96"></span><span class="ansi96">set_debug(fdfdf,false)
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">'trace-on-test'==false
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">load==show
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">test==true
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">debug==true
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">html==true
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">douglas==true
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">'trace-on-test'==false
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">test==true
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">debug==true
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">html==true
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">douglas==true
</span> 

; user:[load_metta_file &self tests/quick_quality/argset-chaining/utils.metta]
;            [track_load_into_file /home/deb12user/metta-wam/tests/quick_quality/argset-chaining/utils.metta]
;                     [load_answer_file /home/deb12user/metta-wam/tests/quick_quality/argset-chaining/utils.metta.answers /home/deb12user/metta-wam/tests/quick_quality/argset-chaining/utils.metta]
;                     [ = 1 "[()]" ]
;                      [ = 2 "[()]" ]
;                      [ = 3 "[()]" ]
;                       [ = 4 "[(((: a (A 1))) ((: $a (A $v)))), (() ((: $a (A $v)) (: $a2 (A $v2)))), (((: a (A 1))) ((: $a2 (A $v2)))), (((: a (A 1)) (: a (A 1))) ())]" ]
;                       [ = 5 "[()]" ]
;                       [ = 6 "[()]" ]
;                        [ = 7 "[()]" ]
;                        [ = 8 "[()]" ]
;                         [ = 9 "[()]" ]
;                         [ = 10 "[()]" ]
;                         [ = 11 "[()]" ]
;                          [ = 12 "[(((: a2 (A 2)) (: a1 (A 1))) ((: a2 (A 2)) (: a1 (A 1))) ((: a2 (A 2)) (: a1 (A 1)))), (((: a2 (A 2)) (: a1 (A 1))) ((: a2 (A 2)) (: a2 (A 2))) ((: a2 (A 2)) (: a2 (A 2)))), (((: a2 (A 2)) (: a1 (A 1))) ((: a1 (A 1)) (: a2 (A 2))) ((: a2 (A 2)) (: a1 (A 1)))), (((: a2 (A 2)) (: a1 (A 1))) ((: a1 (A 1)) (: a1 (A 1))) ((: a1 (A 1)) (: a1 (A 1))))]" ]
;                          [ = 13 "real 0m0.726s" ]
;                           [ = 13 "user 0m0.704s" ]
;                           [ = 13 "sys 0m0.000s" ]
;                           [ = 13 "" ]
;                    [load_answer_file /home/deb12user/metta-wam/tests/quick_quality/argset-chaining/utils.metta.answers /home/deb12user/metta-wam/tests/quick_quality/argset-chaining/utils.metta]
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 transpiler_clause_store( <=, 
  [2], 
  0, 
  ['Number','Number'], 
  'Bool', 
  [ x(doeval,eager,[number]), 
    x(doeval,eager,[number])], 
  x(doeval,eager,[boolean]), 
  [<=,_x,_y], 
  [ or, 
    [<,_x,_y], 
    [==,_x,_y]])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(<=,[2],<,[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">transpiler_depends_on(<=,[2],==,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ [ prolog_if, 
    [ [ assign, 
        P, 
        [ fcall(<,[2]), 
          [_x,_y]]], 
      [ native(is_True), 
        P]], 
    [ [ assign,  Q   ,'True']], 
    [ [ assign, 
        R, 
        [ fcall(==,[2]), 
          [_x,_y]]], 
      [assign,Q,R]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">'mc__1_2_<='(P,Q,R) :-  
    ((
     ('mc__1_2_<'(P,Q,S),is_True(S)*->R='True');
     ('mc__1_2_=='(P,Q,T),R=T)  ))
</span> 
<span class="ansi2"></span><span class="ansi2"></span><span class="ansi2"></span><span class="ansi2">skipping_redef</span>: <span class="ansi1"></span><span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">'mc__1_2_<='(P,Q,R) :-  
    ((
     ('mc__1_2_<'(P,Q,S),is_True(S)*->R='True');
     ('mc__1_2_=='(P,Q,T),R=T)  ))
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( fromNumber, 
  [1], 
  0, 
  ['Number'], 
  'Nat', 
  [ x(doeval,eager,[number])], 
  x(doeval,eager,['Nat']), 
  [fromNumber,_n], 
  [ if, 
    [<=,_n,0], 
    'Z', 
    [ 'S', 
      [ fromNumber, 
        [-,_n,1]]]])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">transpiler_predicate_store( user, 
  fromNumber, 
  [1], todo,todo, 
  [ x(doeval,eager,[number])], 
  x(doeval,eager,['Nat']))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa(fromNumber,[1]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(fromNumber,[1],<=,[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(fromNumber,[1],'S',[1])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(fromNumber,[1],-,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ prolog_if, 
    [ [ assign, 
        P, 
        [ fcall(<=,[2]), 
          [_n,0]]], 
      [ native(is_True), 
        P]], 
    [ [ assign,  Q   , 'Z'  ]], 
    [ [ assign, 
        R, 
        [ fcall(-,[2]), 
          [_n,1]]], 
      [ assign, 
        S, 
        [ fcall(fromNumber,[1]), 
          [R]]], 
      [ assign, T,list(['S',S])], 
      [assign,Q,T]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 mc__1_1_fromNumber(P,Q) :-  
    ((
     ('mc__1_2_<='(P,0,R),is_True(R)*->Q='Z');
     (( 'mc__1_2_-'(P,1,S)  ,
        mc__1_1_fromNumber(S,T) , 
        U=['S',T] , 
        Q=U))  ))
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( fromNat, 
  [1], 
  0, 
  ['Nat'], 
  'Number', 
  [ x(doeval,eager,['Nat'])], 
  x(doeval,eager,[number]), 
  [fromNat,'Z'], 
  0)
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">transpiler_predicate_store( user, 
  fromNat, 
  [1], todo,todo, 
  [ x(doeval,eager,['Nat'])], 
  x(doeval,eager,[number]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa(fromNat,[1]) =  
  []
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">mc__1_1_fromNat('Z',0):-true
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( fromNat, 
  [1], 
  1, 
  ['Nat'], 
  'Number', 
  [ x(doeval,eager,['Nat'])], 
  x(doeval,eager,[number]), 
  [ fromNat, 
    ['S',_k]], 
  [ +, 
    1, 
    [fromNat,_k]])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(fromNat,[1],+,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ assign, 
    P, 
    [ fcall(fromNat,[1]), 
      [_k]]], 
  [ assign, 
    Q, 
    [ fcall(+,[2]), 
      [1,P]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 mc__1_1_fromNat(['S',P],Q) :- 
  mc__1_1_fromNat(P,R) , 
  'mc__1_2_+'(1,R,Q)
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 transpiler_clause_store( 'is-variable', 
  [1], 
  0, 
  ['Atom'], 
  'Bool', 
  [x(noeval,lazy,[])], 
  x(doeval,eager,[boolean]), 
  ['is-variable',_x], 
  [ ==, 
    ['get-metatype',_x], 
    'Variable'])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">transpiler_predicate_store( user, 
  'is-variable', 
  [1], todo,todo, 
  [x(noeval,lazy,[])], 
  x(doeval,eager,[boolean]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa('is-variable',[1]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">transpiler_depends_on('is-variable',[1],==,[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('is-variable',[1],'get-metatype',[1])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ [ native(as_p1_expr), _x,P], 
  [ assign, 
    Q, 
    [ fcall('get-metatype',[1]), 
      [P]]], 
  [ assign, 
    R, 
    [ fcall(==,[2]), 
      [Q,'Variable']]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">'mc__1_1_is-variable'(P,Q) :- 
  as_p1_expr(P,R) , 
  'mc__1_1_get-metatype'(R,S) , 
  'mc__1_2_=='(S,'Variable',Q)
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( 'lazy-or', 
  [2], 
  0, 
  ['Bool','Atom'], 
  'Bool', 
  [ x(doeval,eager,[boolean]), 
    x(noeval,lazy,[])], 
  x(doeval,eager,[boolean]), 
  ['lazy-or','False',_x], 
  _x)
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'lazy-or', 
  [2], todo,todo, 
  [ x(doeval,eager,[boolean]), 
    x(noeval,lazy,[])], 
  x(doeval,eager,[boolean]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa('lazy-or',[2]) =  
  []
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ native(as_p1_exec), _x,P]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">'mc__1_2_lazy-or'('False',P,Q):-as_p1_exec(P,Q)
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( 'lazy-or', 
  [2], 
  1, 
  ['Bool','Atom'], 
  'Bool', 
  [ x(doeval,eager,[boolean]), 
    x(noeval,lazy,[])], 
  x(doeval,eager,[boolean]), 
  ['lazy-or','True',_x], 
  'True')
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">'mc__1_2_lazy-or'('True',P,'True'):-true
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( 'lazy-and', 
  [2], 
  0, 
  ['Bool','Atom'], 
  'Bool', 
  [ x(doeval,eager,[boolean]), 
    x(noeval,lazy,[])], 
  x(doeval,eager,[boolean]), 
  ['lazy-and','False',_x], 
  'False')
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'lazy-and', 
  [2], todo,todo, 
  [ x(doeval,eager,[boolean]), 
    x(noeval,lazy,[])], 
  x(doeval,eager,[boolean]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa('lazy-and',[2]) =  
  []
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 []
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">'mc__1_2_lazy-and'('False',P,'False'):-true
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( 'lazy-and', 
  [2], 
  1, 
  ['Bool','Atom'], 
  'Bool', 
  [ x(doeval,eager,[boolean]), 
    x(noeval,lazy,[])], 
  x(doeval,eager,[boolean]), 
  ['lazy-and','True',_x], 
  _x)
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ native(as_p1_exec), _x,P]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">'mc__1_2_lazy-and'('True',P,Q):-as_p1_exec(P,Q)
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 transpiler_clause_store( 'is-expression', 
  [1], 
  0, 
  ['Atom'], 
  'Bool', 
  [x(noeval,lazy,[])], 
  x(doeval,eager,[boolean]), 
  ['is-expression',_x], 
  [ ==, 
    ['get-metatype',_x], 
    'Expression'])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">transpiler_predicate_store( user, 
  'is-expression', 
  [1], todo,todo, 
  [x(noeval,lazy,[])], 
  x(doeval,eager,[boolean]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa('is-expression',[1]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">transpiler_depends_on('is-expression',[1],==,[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('is-expression',[1],'get-metatype',[1])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ [ native(as_p1_expr), _x,P], 
  [ assign, 
    Q, 
    [ fcall('get-metatype',[1]), 
      [P]]], 
  [ assign, 
    R, 
    [ fcall(==,[2]), 
      [Q,'Expression']]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">'mc__1_1_is-expression'(P,Q) :- 
  as_p1_expr(P,R) , 
  'mc__1_1_get-metatype'(R,S) , 
  'mc__1_2_=='(S,'Expression',Q)
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 transpiler_clause_store( 'is-closed', 
  [1], 
  0, 
  ['Atom'], 
  'Bool', 
  [x(noeval,lazy,[])], 
  x(doeval,eager,[boolean]), 
  ['is-closed',_x], 
  [ if, 
    ['is-variable',_x], 
    'False', 
    [ if, 
      [ 'lazy-and', 
        ['is-expression',_x], 
        [ not, 
          [==,_x,[]]]], 
      [ 'lazy-and', 
        [ let, 
          _head, 
          ['car-atom',_x], 
          ['is-closed',_head]], 
        [ let, 
          _tail, 
          ['cdr-atom',_x], 
          ['is-closed',_tail]]], 
      'True']])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">transpiler_predicate_store( user, 
  'is-closed', 
  [1], todo,todo, 
  [x(noeval,lazy,[])], 
  x(doeval,eager,[boolean]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa('is-closed',[1]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('is-closed',[1],'is-variable',[1])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('is-closed',[1],'lazy-and',[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('is-closed',[1],'is-expression',[1])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('is-closed',[1],not,[1])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">transpiler_depends_on('is-closed',[1],==,[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('is-closed',[1],'car-atom',[1])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('is-closed',[1],'cdr-atom',[1])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ [ prolog_if, 
    [ [ assign, 
        P, 
        [ fcall('is-variable',[1]), 
          [_x]]], 
      [ native(is_True), 
        P]], 
    [ [ assign ,   Q   ,'False']], 
    [ [ prolog_if, 
        [ [ assign, 
            R, 
            [ fcall('is-expression',[1]), 
              [_x]]], 
          [ assign, 
            S, 
            [ ispeEnNC, 
              T, 
              [ [ assign, 
                  T, 
                  [ fcall(not,[1]), 
                    [U]]]], 
              V, 
              [ [ assign, V,list([not,U])]], 
              [ [ native(as_p1_exec), _x,W], 
                [ assign, 
                  U, 
                  [ fcall(==,[2]), 
                    [W,[]]]]]]], 
          [ assign, 
            X, 
            [ fcall('lazy-and',[2]), 
              [R,S]]], 
          [ native(is_True), 
            X]], 
        [ [ native(as_p1_expr), _x,Y], 
          [ assign, 
            Z, 
            [ fcall('car-atom',[1]), 
              [Y]]], 
          [assign,_head,Z], 
          [ assign, 
            A1, 
            [ispu,_head]], 
          [ assign, 
            B1, 
            [ fcall('is-closed',[1]), 
              [A1]]], 
          [ assign, 
            C1, 
            [ ispeEnNC, 
              D1, 
              [ [ assign, 
                  D1, 
                  [ fcall('is-closed',[1]), 
                    [E1]]]], 
              F1, 
              [ [ assign, F1,list(['is-closed',E1])]], 
              [ [ native(as_p1_expr), _x,G1], 
                [ assign, 
                  H1, 
                  [ fcall('cdr-atom',[1]), 
                    [G1]]], 
                [assign,_tail,H1], 
                [ assign, 
                  E1, 
                  [ispu,_tail]]]]], 
          [ assign, 
            I1, 
            [ fcall('lazy-and',[2]), 
              [B1,C1]]], 
          [assign,J1,I1]], 
        [ [ assign,  J1  ,'True']]], 
      [assign,Q,J1]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 'mc__1_1_is-closed'(P,Q) :-  
    ((
     ('mc__1_1_is-variable'(P,R),is_True(R)*->Q='False');
     (  ((
         (  ((
             (  ((
                 (( 'mc__1_1_is-expression'(P,S)  ,
                    T =  
                      ispeEnNC( U, 
                        mc__1_1_not(V,U), W,W=[not,V], 
                        as_p1_exec(P,X),'mc__1_2_=='(X,[],V)) , 
                    'mc__1_2_lazy-and'(S,T,Y) , 
                    is_True(Y)))*->
                 (( as_p1_expr(P,Z)  ,
                    'mc__1_1_car-atom'(Z,A1) , 
                    B1=A1 , 
                    C1=ispu(B1) , 
                    'mc__1_1_is-closed'(C1,D1) , 
                    E1 =  
                      ispeEnNC( F1, 
                        'mc__1_1_is-closed'(G1,F1), 
                        H1, 
                        H1=['is-closed',G1], 
                        ( as_p1_expr(P,I1)  ,
                          'mc__1_1_cdr-atom'(I1,J1) , 
                          K1=J1 , 
                          G1=ispu(K1))) , 
                    'mc__1_2_lazy-and'(D1,E1,L1) , 
                    M1=L1))  )));
             (M1='True')  ))),
         (Q=M1)  )))  ))
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( tracem, 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [tracem,_msg,_a], 
  [ 'trace!', 
    [_msg,_a], 
    _a])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  tracem, 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa(tracem,[2]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(tracem,[2],'trace!',[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ transpiler_apply, mc__1_1_,_msg, 
    [_msg,_a], 
    P, 
    [_a], 
    [_a], 
    [x(doeval,eager,[])], 
    [ 
    [[]], 
    [ 
    [[]]], 
  [ assign, 
    Q, 
    list(['trace!',P,_a])]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 mc__1_2_tracem(P,Q,R) :- 
  transpiler_apply( mc__1_1_, 
    P, 
    [P,Q], 
    S, 
    [Q], 
    [Q], 
    [x(doeval,eager,[])], 
    [true], 
    [true]) , 
  R=['trace!',S,Q]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  [time,_expr], 
  [ let, 
    _start, 
    [ [  'py-atom' ,'time.time']], 
    [ let, _res,_expr, 
      [ let, 
        _stop, 
        [ [  'py-atom' ,'time.time']], 
        [ 'Time', 
          [-,_stop,_start], 
          _res]]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  [time,_expr], 
  [ let, 
    _start, 
    [ 'py-atom-call', 
      ['time.time']], 
    [ let, _res,_expr, 
      [ let, 
        _stop, 
        [ 'py-atom-call', 
          ['time.time']], 
        [ 'Time', 
          [-,_stop,_start], 
          _res]]]]]
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( time, 
  [1], 
  0, 
  ['Atom'], 
  P, 
  [x(noeval,lazy,[])], 
  x(doeval,eager,[]), 
  [time,_expr], 
  [ let, 
    _start, 
    [ 'py-atom-call', 
      ['time.time']], 
    [ let, _res,_expr, 
      [ let, 
        _stop, 
        [ 'py-atom-call', 
          ['time.time']], 
        [ 'Time', 
          [-,_stop,_start], 
          _res]]]])
</span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi97"></span><span class="ansi97 ansi40"></span><span class="ansi97 ansi40">skip_redef_fa(time,[1])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(time,[1],'py-atom-call',[1])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(time,[1],'time.time',[0])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(time,[1],'Time',[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(time,[1],-,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ assign, P,list(['time.time'])], 
  [ assign, 
    Q, 
    [ call_var('py-atom-call',1), 
      P]], 
  [assign,_start,Q], 
  [ native(as_p1_exec), _expr,R], 
  [assign,_res,R], 
  [ assign, S,list(['time.time'])], 
  [ assign, 
    T, 
    [ call_var('py-atom-call',1), 
      S]], 
  [assign,_stop,T], 
  [ assign, 
    U, 
    [ fcall(-,[2]), 
      [_stop,_start]]], 
  [ assign, 
    V, 
    list(['Time',U,_res])]]
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(time,[1],'py-atom-call',0)
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 mc__1_1_time(P,Q) :- 
  R=['time.time'] , 
  'mc_n_1__py-atom-call'(R,[],S) , 
  T=S , 
  as_p1_exec(P,U) , 
  V=U , 
  W=['time.time'] , 
  'mc_n_1__py-atom-call'(W,[],X) , 
  Y=X , 
  'mc__1_2_-'(Y,T,Z) , 
  Q=['Time',Z,V]
</span> 
<span class="ansi2"></span><span class="ansi2"></span><span class="ansi2"></span><span class="ansi2">skipping_redef</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36"></span><span class="ansi1 ansi36">
 mc__1_1_time(P,Q) :- 
  R=['time.time'] , 
  'mc_n_1__py-atom-call'(R,[],S) , 
  T=S , 
  as_p1_exec(P,U) , 
  V=U , 
  W=['time.time'] , 
  'mc_n_1__py-atom-call'(W,[],X) , 
  Y=X , 
  'mc__1_2_-'(Y,T,Z) , 
  Q=['Time',Z,V]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  ['myfold-atom',_list,_init,_f], 
  [ 'if-decons-expr', _list,_head,_tail, 
    [ 'myfold-atom', 
      _tail, 
      [_f,_init,_head], 
      _f], 
    _init]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  ['myfold-atom',_list,_init,_f], 
  [ if, 
    ['decons-ht',_list,_head,_tail], 
    [ 'myfold-atom', 
      _tail, 
      [_f,_init,_head], 
      _f], 
    _init]]
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( 'myfold-atom', 
  [3], 
  0, 
  ['Any','Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), x(doeval,eager,[]),x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  ['myfold-atom',_list,_init,_f], 
  [ if, 
    ['decons-ht',_list,_head,_tail], 
    [ 'myfold-atom', 
      _tail, 
      [_f,_init,_head], 
      _f], 
    _init])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'myfold-atom', 
  [3], todo,todo, 
  [ x(doeval,eager,[]), x(doeval,eager,[]),x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa('myfold-atom',[3]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('myfold-atom',[3],'decons-ht',[3])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ prolog_if, 
    [ [ assign, 
        P, 
        [ fcall('decons-ht',[3]), 
          [_list,_head,_tail]]], 
      [ native(is_True), 
        P]], 
    [ [ transpiler_apply, mc__1_2_,_f, 
        [_f,_init,_head], 
        Q, 
        [_init,_head], 
        [_init,_head], 
        [ x(doeval,eager,[]), 
          x(noeval,eager,[])], 
        [ 
        [[],[]], 
        [ 
        [[],[]]], 
      [ assign, 
        R, 
        [ fcall('myfold-atom',[3]), 
          [_tail,Q,_f]]], 
      [assign,S,R]], 
    [ [ assign,  S   ,_init ]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 'mc__1_3_myfold-atom'(P,Q,R,S) :-  
    ((
     (  ((
         ('mc__1_3_decons-ht'(P,T,U,V),is_True(V))*->
         (( transpiler_apply( mc__1_2_, 
              R, 
              [R,Q,T], 
              W, 
              [Q,T], 
              [Q,T], 
              [ x(doeval,eager,[]), 
                x(noeval,eager,[])], 
              [true,true], 
              [true,true])  ,
            'mc__1_3_myfold-atom'(U,W,R,X) , 
            S=X))  )));
     (S=Q)  ))
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  ['myfold-atom1',_list,_f], 
  [ if, 
    [ ==, 
      ['get-metatype',_list], 
      'Variable'], 
    _list, 
    [ 'if-decons-expr', _list,_head,_tail, 
      ['myfold-atom',_tail,_head,_f], 
      _list]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  ['myfold-atom1',_list,_f], 
  [ if, 
    [ ==, 
      ['get-metatype',_list], 
      'Variable'], 
    _list, 
    [ if, 
      ['decons-ht',_list,_head,_tail], 
      ['myfold-atom',_tail,_head,_f], 
      _list]]]
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 transpiler_clause_store( 'myfold-atom1', 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  ['myfold-atom1',_list,_f], 
  [ if, 
    [ ==, 
      ['get-metatype',_list], 
      'Variable'], 
    _list, 
    [ if, 
      ['decons-ht',_list,_head,_tail], 
      ['myfold-atom',_tail,_head,_f], 
      _list]])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'myfold-atom1', 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa('myfold-atom1',[2]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">transpiler_depends_on('myfold-atom1',[2],==,[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('myfold-atom1',[2],'get-metatype',[1])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('myfold-atom1',[2],'decons-ht',[3])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('myfold-atom1',[2],'myfold-atom',[3])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ [ prolog_if, 
    [ [ assign, 
        P, 
        [ fcall('get-metatype',[1]), 
          [_list]]], 
      [ assign, 
        Q, 
        [ fcall(==,[2]), 
          [P,'Variable']]], 
      [ native(is_True), 
        Q]], 
    [ [ assign,  R   ,_list ]], 
    [ [ prolog_if, 
        [ [ assign, 
            S, 
            [ fcall('decons-ht',[3]), 
              [_list,_head,_tail]]], 
          [ native(is_True), 
            S]], 
        [ [ assign, 
            T, 
            [ fcall('myfold-atom',[3]), 
              [_tail,_head,_f]]], 
          [assign,U,T]], 
        [ [ assign,  U   ,_list ]]], 
      [assign,R,U]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">'mc__1_2_myfold-atom1'(P,Q,R) :-  
    ((
     (  ((
         (( 'mc__1_1_get-metatype'(P,S)  ,
            'mc__1_2_=='(S,'Variable',T) , 
            is_True(T)))*->
         (R=P)  )));
     (  ((
         (  ((
             (  ((
                 ('mc__1_3_decons-ht'(P,U,V,W),is_True(W))*->
                 ('mc__1_3_myfold-atom'(V,U,Q,X),Y=X)  )));
             (Y=P)  ))),
         (R=Y)  )))  ))
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  ['myfoldr-atom',_list,_init,_f], 
  [ 'if-decons-expr', _list,_head,_tail, 
    [ _f, 
      ['myfoldr-atom',_tail,_init,_f], 
      _head], 
    _init]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  ['myfoldr-atom',_list,_init,_f], 
  [ if, 
    ['decons-ht',_list,_head,_tail], 
    [ _f, 
      ['myfoldr-atom',_tail,_init,_f], 
      _head], 
    _init]]
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( 'myfoldr-atom', 
  [3], 
  0, 
  ['Any','Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), x(doeval,eager,[]),x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  ['myfoldr-atom',_list,_init,_f], 
  [ if, 
    ['decons-ht',_list,_head,_tail], 
    [ _f, 
      ['myfoldr-atom',_tail,_init,_f], 
      _head], 
    _init])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'myfoldr-atom', 
  [3], todo,todo, 
  [ x(doeval,eager,[]), x(doeval,eager,[]),x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa('myfoldr-atom',[3]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('myfoldr-atom',[3],'decons-ht',[3])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ prolog_if, 
    [ [ assign, 
        P, 
        [ fcall('decons-ht',[3]), 
          [_list,_head,_tail]]], 
      [ native(is_True), 
        P]], 
    [ [ assign, 
        Q, 
        [ fcall('myfoldr-atom',[3]), 
          [_tail,_init,_f]]], 
      [ transpiler_apply, mc__1_2_,_f, 
        [_f,Q,_head], 
        R, 
        [Q,_head], 
        [S,_head], 
        [ x(doeval,eager,[]), 
          x(noeval,eager,[])], 
        [ [ [ assign, 
              Q, 
              [ fcall('myfoldr-atom',[3]), 
                [_tail,_init,_f]]]], 
          []], 
        [ [ [ assign, 
              S, 
              list(['myfoldr-atom',_tail,_init,_f])]], 
          []]], 
      [assign,T,R]], 
    [ [ assign,  T   ,_init ]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 'mc__1_3_myfoldr-atom'(P,Q,R,S) :-  
    ((
     (  ((
         ('mc__1_3_decons-ht'(P,T,U,V),is_True(V))*->
         (( 'mc__1_3_myfoldr-atom'(U,Q,R,W)  ,
            transpiler_apply( mc__1_2_, 
              R, 
              [R,W,T], 
              X, 
              [W,T], 
              [Y,T], 
              [ x(doeval,eager,[]), 
                x(noeval,eager,[])], 
              [ 'mc__1_3_myfoldr-atom'(U,Q,R,W), 
                true], 
              [ Y=['myfoldr-atom',U,Q,R], 
                true]) , 
            S=X))  )));
     (S=Q)  ))
</span> 
<span class="ansi38-013099040">!(assertEqual (myfoldr-atom (1 2 3) 0 +) 6)

</span>
;<h3 id="ARGSET-CHAINING.UTILS.01">;; ARGSET-CHAINING.UTILS.01</h3>
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [1,2,3], P,Q, 
    [ +, 
      ['myfoldr-atom',Q,0,+], 
      P], 
    0]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [1,2,3], P,Q], 
    [ +, 
      ['myfoldr-atom',Q,0,+], 
      P], 
    0]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [2,3], P,Q, 
    [ +, 
      ['myfoldr-atom',Q,0,+], 
      P], 
    0]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [2,3], P,Q], 
    [ +, 
      ['myfoldr-atom',Q,0,+], 
      P], 
    0]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [3], P,Q, 
    [ +, 
      ['myfoldr-atom',Q,0,+], 
      P], 
    0]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [3], P,Q], 
    [ +, 
      ['myfoldr-atom',Q,0,+], 
      P], 
    0]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [], P,Q, 
    [ +, 
      ['myfoldr-atom',Q,0,+], 
      P], 
    0]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[],P,Q], 
    [ +, 
      ['myfoldr-atom',Q,0,+], 
      P], 
    0]]
</span> 
; 
; EVAL TEST
; took 0.023 secs. (23.02 milliseconds) 

!(assertEqual (myfoldr-atom (1 2 3) 0 +) 6)

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (6) 
      (6)]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  ['munion-atom',_list1,_list2], 
  [ 'if-decons-expr', _list1,_head,_tail, 
    [ let, 
      _res, 
      ['munion-atom',_tail,_list2], 
      ['cons-atom',_head,_res]], 
    _list2]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  ['munion-atom',_list1,_list2], 
  [ if, 
    ['decons-ht',_list1,_head,_tail], 
    [ let, 
      _res, 
      ['munion-atom',_tail,_list2], 
      ['cons-atom',_head,_res]], 
    _list2]]
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( 'munion-atom', 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  ['munion-atom',_list1,_list2], 
  [ if, 
    ['decons-ht',_list1,_head,_tail], 
    [ let, 
      _res, 
      ['munion-atom',_tail,_list2], 
      ['cons-atom',_head,_res]], 
    _list2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'munion-atom', 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa('munion-atom',[2]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('munion-atom',[2],'decons-ht',[3])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('munion-atom',[2],'cons-atom',[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ prolog_if, 
    [ [ assign, 
        P, 
        [ fcall('decons-ht',[3]), 
          [_list1,_head,_tail]]], 
      [ native(is_True), 
        P]], 
    [ [ assign, 
        Q, 
        [ fcall('munion-atom',[2]), 
          [_tail,_list2]]], 
      [assign,_res,Q], 
      [ assign, 
        R, 
        [ fcall('cons-atom',[2]), 
          [_head,_res]]], 
      [assign,S,R]], 
    [ [ assign,  S   ,_list2]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">'mc__1_2_munion-atom'(P,Q,R) :-  
    ((
     (  ((
         ('mc__1_3_decons-ht'(P,S,T,U),is_True(U))*->
         (( 'mc__1_2_munion-atom'(T,Q,V)  ,
            W=V , 
            'mc__1_2_cons-atom'(S,W,X) , 
            R=X))  )));
     (R=Q)  ))
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 transpiler_clause_store( concat, 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [concat,_list1,_list2], 
  [ if, 
    [ ==, 
      ['get-metatype',_list1], 
      'Variable'], 
    _list2, 
    [ if, 
      [ ==, 
        ['get-metatype',_list2], 
        'Variable'], 
      _list1, 
      ['munion-atom',_list1,_list2]]])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  concat, 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa(concat,[2]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">transpiler_depends_on(concat,[2],==,[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(concat,[2],'get-metatype',[1])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(concat,[2],'munion-atom',[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ [ prolog_if, 
    [ [ assign, 
        P, 
        [ fcall('get-metatype',[1]), 
          [_list1]]], 
      [ assign, 
        Q, 
        [ fcall(==,[2]), 
          [P,'Variable']]], 
      [ native(is_True), 
        Q]], 
    [ [ assign,  R   ,_list2]], 
    [ [ prolog_if, 
        [ [ assign, 
            S, 
            [ fcall('get-metatype',[1]), 
              [_list2]]], 
          [ assign, 
            T, 
            [ fcall(==,[2]), 
              [S,'Variable']]], 
          [ native(is_True), 
            T]], 
        [ [ assign,  U   ,_list1]], 
        [ [ assign, 
            V, 
            [ fcall('munion-atom',[2]), 
              [_list1,_list2]]], 
          [assign,U,V]]], 
      [assign,R,U]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">mc__1_2_concat(P,Q,R) :-  
    ((
     (  ((
         (( 'mc__1_1_get-metatype'(P,S)  ,
            'mc__1_2_=='(S,'Variable',T) , 
            is_True(T)))*->
         (R=Q)  )));
     (  ((
         (  ((
             (  ((
                 (( 'mc__1_1_get-metatype'(Q,U)  ,
                    'mc__1_2_=='(U,'Variable',V) , 
                    is_True(V)))*->
                 (W=P)  )));
             ('mc__1_2_munion-atom'(P,Q,X),W=X)  ))),
         (R=W)  )))  ))
</span> 
<span class="ansi38-013099040">!(assertEqual (concat (a b c) (a b d)) (a b c a b d))

</span>
;<h3 id="ARGSET-CHAINING.UTILS.02">;; ARGSET-CHAINING.UTILS.02</h3>
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [a,b,c], P,Q, 
    [ let, 
      R, 
      ['munion-atom',Q,[a,b,d]], 
      ['cons-atom',P,R]], 
    [a,b,d]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[a,b,c],P,Q], 
    [ let, 
      R, 
      ['munion-atom',Q,[a,b,d]], 
      ['cons-atom',P,R]], 
    [a,b,d]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [b,c], P,Q, 
    [ let, 
      R, 
      ['munion-atom',Q,[a,b,d]], 
      ['cons-atom',P,R]], 
    [a,b,d]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[b,c],P,Q], 
    [ let, 
      R, 
      ['munion-atom',Q,[a,b,d]], 
      ['cons-atom',P,R]], 
    [a,b,d]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [c], P,Q, 
    [ let, 
      R, 
      ['munion-atom',Q,[a,b,d]], 
      ['cons-atom',P,R]], 
    [a,b,d]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[c],P,Q], 
    [ let, 
      R, 
      ['munion-atom',Q,[a,b,d]], 
      ['cons-atom',P,R]], 
    [a,b,d]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [], P,Q, 
    [ let, 
      R, 
      ['munion-atom',Q,[a,b,d]], 
      ['cons-atom',P,R]], 
    [a,b,d]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[],P,Q], 
    [ let, 
      R, 
      ['munion-atom',Q,[a,b,d]], 
      ['cons-atom',P,R]], 
    [a,b,d]]]
</span> 
; 
; EVAL TEST
; took 0.034 secs. (33.80 milliseconds) 

!(assertEqual (concat (a b c) (a b d)) (a b c a b d))

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (a b c a b d)) 
      ( (a b c a b d))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  [remove,_list,_elem], 
  [ 'if-decons-expr', _list,_head,_tail, 
    [ unify, _elem,_head, 
      [_head,_tail], 
      [ let, 
        [_res,_ntail], 
        [remove,_tail,_elem], 
        [ _res, 
          ['cons-atom',_head,_ntail]]]], 
    [[],_list]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  [remove,_list,_elem], 
  [ if, 
    ['decons-ht',_list,_head,_tail], 
    [ unify, _elem,_head, 
      [_head,_tail], 
      [ let, 
        [_res,_ntail], 
        [remove,_tail,_elem], 
        [ _res, 
          ['cons-atom',_head,_ntail]]]], 
    [[],_list]]]
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( remove, 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [remove,_list,_elem], 
  [ if, 
    ['decons-ht',_list,_head,_tail], 
    [ unify, _elem,_head, 
      [_head,_tail], 
      [ let, 
        [_res,_ntail], 
        [remove,_tail,_elem], 
        [ _res, 
          ['cons-atom',_head,_ntail]]]], 
    [[],_list]])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  remove, 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa(remove,[2]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(remove,[2],'decons-ht',[3])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(remove,[2],unify,[4])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(remove,[2],'cons-atom',[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ prolog_if, 
    [ [ assign, 
        P, 
        [ fcall('decons-ht',[3]), 
          [_list,_head,_tail]]], 
      [ native(is_True), 
        P]], 
    [ [ assign, 
        Q, 
        [ ispeEnN, 
          R, 
          [ [ transpiler_apply, mc__1_1_,_head, 
              [_head,_tail], 
              R, 
              [_tail], 
              [_tail], 
              [x(noeval,eager,[])], 
              [ 
              [[]], 
              [ 
              [[]]]], 
          S, 
          [ [ assign, 
              S, 
              list([_head,_tail])]]]], 
      [ assign, 
        T, 
        [ ispeEnNC, 
          U, 
          [ [ transpiler_apply, mc__1_1_,_res, 
              [_res,V], 
              U, 
              [V], 
              [W], 
              [ x(noeval,eager,[list])], 
              [ [ [ assign, 
                    V, 
                    [ fcall('cons-atom',[2]), 
                      [_head,_ntail]]]]], 
              [ [ [ assign, 
                    W, 
                    list(['cons-atom',_head,_ntail])]]]]], 
          X, 
          [ [ assign, X,list([_res,V])]], 
          [ [ assign, 
              Y, 
              [ fcall(remove,[2]), 
                [_tail,_elem]]], 
            [ assign, 
              [_res,_ntail], 
              Y], 
            [ assign, 
              V, 
              [ fcall('cons-atom',[2]), 
                [_head,_ntail]]]]]], 
      [ assign, 
        Z, 
        [ fcall(unify,[4]), 
          [_elem,_head,Q,T]]], 
      [assign,A1,Z]], 
    [ [ assign, B1,list([[],_list])], 
      [assign,A1,B1]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 mc__1_2_remove(P,Q,R) :-  
    ((
     (  ((
         ('mc__1_3_decons-ht'(P,S,T,U),is_True(U))*->
         (( V =  
              ispeEnN( W, 
                transpiler_apply( mc__1_1_, 
                  S, 
                  [S,T], 
                  W, 
                  [T], 
                  [T], 
                  [x(noeval,eager,[])], 
                  [true], 
                  [true]), 
                X, 
                X=[S,T])  ,
            Y =  
              ispeEnNC( Z, 
                transpiler_apply( mc__1_1_, 
                  A1, 
                  [A1,B1], 
                  Z, 
                  [B1], 
                  [C1], 
                  [ x(noeval,eager,[list])], 
                  ['mc__1_2_cons-atom'(S,D1,B1)], 
                  [C1=['cons-atom',S,D1]]), 
                E1, 
                E1=[A1,B1], 
                ( mc__1_2_remove(T,Q,F1)  ,
                  [A1,D1]=F1 , 
                  'mc__1_2_cons-atom'(S,D1,B1))) , 
            mc__1_4_unify(Q,S,V,Y,G1) , 
            R=G1))  )));
     (H1=[[],P],R=H1)  ))
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  ['remove=',_list,_elem], 
  [ 'if-decons-expr', _list,_head,_tail, 
    [ if, 
      [==,_elem,_head], 
      ['remove=',_tail,_elem], 
      [ let, 
        _ntail, 
        ['remove=',_tail,_elem], 
        ['cons-atom',_head,_ntail]]], 
    _list]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  ['remove=',_list,_elem], 
  [ if, 
    ['decons-ht',_list,_head,_tail], 
    [ if, 
      [==,_elem,_head], 
      ['remove=',_tail,_elem], 
      [ let, 
        _ntail, 
        ['remove=',_tail,_elem], 
        ['cons-atom',_head,_ntail]]], 
    _list]]
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 transpiler_clause_store( 'remove=', 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  ['remove=',_list,_elem], 
  [ if, 
    ['decons-ht',_list,_head,_tail], 
    [ if, 
      [==,_elem,_head], 
      ['remove=',_tail,_elem], 
      [ let, 
        _ntail, 
        ['remove=',_tail,_elem], 
        ['cons-atom',_head,_ntail]]], 
    _list])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'remove=', 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa('remove=',[2]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('remove=',[2],'decons-ht',[3])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">transpiler_depends_on('remove=',[2],==,[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('remove=',[2],'cons-atom',[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ [ prolog_if, 
    [ [ assign, 
        P, 
        [ fcall('decons-ht',[3]), 
          [_list,_head,_tail]]], 
      [ native(is_True), 
        P]], 
    [ [ prolog_if, 
        [ [ assign, 
            Q, 
            [ fcall(==,[2]), 
              [_elem,_head]]], 
          [ native(is_True), 
            Q]], 
        [ [ assign, 
            R, 
            [ fcall('remove=',[2]), 
              [_tail,_elem]]], 
          [assign,S,R]], 
        [ [ assign, 
            T, 
            [ fcall('remove=',[2]), 
              [_tail,_elem]]], 
          [assign,_ntail,T], 
          [ assign, 
            U, 
            [ fcall('cons-atom',[2]), 
              [_head,_ntail]]], 
          [assign,S,U]]], 
      [assign,V,S]], 
    [ [ assign,  V   ,_list ]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">'mc__1_2_remove='(P,Q,R) :-  
    ((
     (  ((
         ('mc__1_3_decons-ht'(P,S,T,U),is_True(U))*->
         (  ((
             (  ((
                 (  ((
                     ('mc__1_2_=='(Q,S,V),is_True(V))*->
                     ('mc__1_2_remove='(T,Q,W),X=W)  )));
                 (( 'mc__1_2_remove='(T,Q,Y)  ,
                    Z=Y , 
                    'mc__1_2_cons-atom'(S,Z,A1) , 
                    X=A1))  ))),
             (R=X)  )))  )));
     (R=P)  ))
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  ['unique=',_list], 
  [ 'if-decons-expr', _list,_head,_tail, 
    [ let, 
      _ntail, 
      [ 'unique=', 
        ['remove=',_tail,_head]], 
      ['cons-atom',_head,_ntail]], 
    _list]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  ['unique=',_list], 
  [ if, 
    ['decons-ht',_list,_head,_tail], 
    [ let, 
      _ntail, 
      [ 'unique=', 
        ['remove=',_tail,_head]], 
      ['cons-atom',_head,_ntail]], 
    _list]]
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( 'unique=', 
  [1], 
  0, 
  ['Any'], 
  'Any', 
  [x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  ['unique=',_list], 
  [ if, 
    ['decons-ht',_list,_head,_tail], 
    [ let, 
      _ntail, 
      [ 'unique=', 
        ['remove=',_tail,_head]], 
      ['cons-atom',_head,_ntail]], 
    _list])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">transpiler_predicate_store(user,'unique=',[1],todo,todo,[x(doeval,eager,[])],x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa('unique=',[1]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('unique=',[1],'decons-ht',[3])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('unique=',[1],'remove=',[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('unique=',[1],'cons-atom',[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ prolog_if, 
    [ [ assign, 
        P, 
        [ fcall('decons-ht',[3]), 
          [_list,_head,_tail]]], 
      [ native(is_True), 
        P]], 
    [ [ assign, 
        Q, 
        [ fcall('remove=',[2]), 
          [_tail,_head]]], 
      [ assign, 
        R, 
        [ fcall('unique=',[1]), 
          [Q]]], 
      [assign,_ntail,R], 
      [ assign, 
        S, 
        [ fcall('cons-atom',[2]), 
          [_head,_ntail]]], 
      [assign,T,S]], 
    [ [ assign,  T   ,_list ]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">'mc__1_1_unique='(P,Q) :-  
    ((
     (  ((
         ('mc__1_3_decons-ht'(P,R,S,T),is_True(T))*->
         (( 'mc__1_2_remove='(S,R,U)  ,
            'mc__1_1_unique='(U,V) , 
            W=V , 
            'mc__1_2_cons-atom'(R,W,X) , 
            Q=X))  )));
     (Q=P)  ))
</span> 
<span class="ansi38-013099040">!(assertEqual (unique= ((: $a A) (: $a A) (: $b A))) ((: $a A) (: $b A)))

</span>
;<h3 id="ARGSET-CHAINING.UTILS.03">;; ARGSET-CHAINING.UTILS.03</h3>
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [  : ,_a ,'A'],
      [  : ,_a ,'A'],
      [  : ,_b ,'A']], P,Q, 
    [ let, 
      R, 
      [ 'unique=', 
        ['remove=',Q,P]], 
      ['cons-atom',P,R]], 
    [ [  : ,_a ,'A'],
      [  : ,_a ,'A'],
      [  : ,_b ,'A']]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [  : ,_a ,'A'],
        [  : ,_a ,'A'],
        [  : ,_b ,'A']], P,Q], 
    [ let, 
      R, 
      [ 'unique=', 
        ['remove=',Q,P]], 
      ['cons-atom',P,R]], 
    [ [  : ,_a ,'A'],
      [  : ,_a ,'A'],
      [  : ,_b ,'A']]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [  : ,_a ,'A'],
      [  : ,_b ,'A']], P,Q, 
    [ if, 
      [ ==, 
        [:,_a,'A'], 
        P], 
      [ 'remove=', 
        Q, 
        [:,_a,'A']], 
      [ let, 
        R, 
        [ 'remove=', 
          Q, 
          [:,_a,'A']], 
        ['cons-atom',P,R]]], 
    [ [  : ,_a ,'A'],
      [  : ,_b ,'A']]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [  : ,_a ,'A'],
        [  : ,_b ,'A']], P,Q], 
    [ if, 
      [ ==, 
        [:,_a,'A'], 
        P], 
      [ 'remove=', 
        Q, 
        [:,_a,'A']], 
      [ let, 
        R, 
        [ 'remove=', 
          Q, 
          [:,_a,'A']], 
        ['cons-atom',P,R]]], 
    [ [  : ,_a ,'A'],
      [  : ,_b ,'A']]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [  : ,_b ,'A']], P,Q, 
    [ if, 
      [ ==, 
        [:,_a,'A'], 
        P], 
      [ 'remove=', 
        Q, 
        [:,_a,'A']], 
      [ let, 
        R, 
        [ 'remove=', 
          Q, 
          [:,_a,'A']], 
        ['cons-atom',P,R]]], 
    [ [  : ,_b ,'A']]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [  : ,_b ,'A']], P,Q], 
    [ if, 
      [ ==, 
        [:,_a,'A'], 
        P], 
      [ 'remove=', 
        Q, 
        [:,_a,'A']], 
      [ let, 
        R, 
        [ 'remove=', 
          Q, 
          [:,_a,'A']], 
        ['cons-atom',P,R]]], 
    [ [  : ,_b ,'A']]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [], P,Q, 
    [ if, 
      [ ==, 
        [:,_b,'A'], 
        P], 
      [ 'remove=', 
        Q, 
        [:,_b,'A']], 
      [ let, 
        R, 
        [ 'remove=', 
          Q, 
          [:,_b,'A']], 
        ['cons-atom',P,R]]], 
    []]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[],P,Q], 
    [ if, 
      [ ==, 
        [:,_b,'A'], 
        P], 
      [ 'remove=', 
        Q, 
        [:,_b,'A']], 
      [ let, 
        R, 
        [ 'remove=', 
          Q, 
          [:,_b,'A']], 
        ['cons-atom',P,R]]], 
    []]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [], P,Q, 
    [ let, 
      R, 
      [ 'unique=', 
        ['remove=',Q,P]], 
      ['cons-atom',P,R]], 
    []]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[],P,Q], 
    [ let, 
      R, 
      [ 'unique=', 
        ['remove=',Q,P]], 
      ['cons-atom',P,R]], 
    []]]
</span> 
; 
; EVAL TEST
; took 0.064 secs. (63.90 milliseconds) 

!(assertEqual (unique= ((: $a A) (: $a A) (: $b A))) ((: $a A) (: $b A)))

<span class="ansi31">  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( ( (: $b A))) 
      ( ( (: $a A) (: $b A)))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'('[|]'('[|]'(:,'[|]'(_6532854{$_b},'[|]'('A',[]))),[]),[]),'[|]'('[|]'('[|]'(:,'[|]'(_6532956{$_a},'[|]'('A',[]))),'[|]'('[|]'(:,'[|]'(_6532994{$_b},'[|]'('A',[]))),[])),[]))

Deterministic: <span class="ansi33">  (Error 
    (assertEqual 
      (unique= ((: $a A) (: $a A) (: $b A))) 
      ( (: $a A) (: $b A))) 
    ('
Got: ' 
      ( ( (: $b A))) '
EXP: ' 
      ( ( (: $a A) (: $b A)))))
</span><span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( '=unify', 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  ['=unify',_a,_b], 
  [ sealed, 
    [_a,_b], 
    [ unify, _a,_b,'True','False']])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  '=unify', 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa('=unify',[2]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('=unify',[2],sealed,[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('=unify',[2],unify,[4])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ transpiler_apply, mc__1_1_,_a, 
    [_a,_b], 
    P, 
    [_b], 
    [_b], 
    [x(doeval,eager,[])], 
    [ 
    [[]], 
    [ 
    [[]]], 
  [ assign, 
    Q, 
    [ispu,'True']], 
  [ assign, 
    R, 
    [ispu,'False']], 
  [ assign, 
    S, 
    [ fcall(unify,[4]), 
      [_a,_b,Q,R]]], 
  [ assign, 
    T, 
    list([sealed,P,S])]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 'mc__1_2_=unify'(P,Q,R) :- 
  transpiler_apply( mc__1_1_, 
    P, 
    [P,Q], 
    S, 
    [Q], 
    [Q], 
    [x(doeval,eager,[])], 
    [true], 
    [true]) , 
  T=ispu('True') , 
  U=ispu('False') , 
  mc__1_4_unify(P,Q,T,U,V) , 
  R=[sealed,S,V]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  [removePrf,_ccls,_premise], 
  [ 'if-decons-expr', _ccls,_head,_tail, 
    [ if, 
      ['=unify',_premise,_head], 
      [ let, 
        [:,_prf,Type], 
        _head, 
        [ if, 
          [ 'lazy-or', 
            ['is-closed',Type], 
            ['=alpha',_premise,_head]], 
          'Empty', 
          [ let, 
            [_res,_ntail], 
            [removePrf,_tail,_premise], 
            [ _res, 
              ['cons-atom',_head,_ntail]]]]], 
      'Empty'], 
    'Empty']]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  [removePrf,_ccls,_premise], 
  [ if, 
    ['decons-ht',_ccls,_head,_tail], 
    [ if, 
      ['=unify',_premise,_head], 
      [ let, 
        [:,_prf,Type], 
        _head, 
        [ if, 
          [ 'lazy-or', 
            ['is-closed',Type], 
            ['=alpha',_premise,_head]], 
          'Empty', 
          [ let, 
            [_res,_ntail], 
            [removePrf,_tail,_premise], 
            [ _res, 
              ['cons-atom',_head,_ntail]]]]], 
      'Empty'], 
    'Empty']]
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( removePrf, 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [removePrf,_ccls,_premise], 
  [ if, 
    ['decons-ht',_ccls,_head,_tail], 
    [ if, 
      ['=unify',_premise,_head], 
      [ let, 
        [:,_prf,Type], 
        _head, 
        [ if, 
          [ 'lazy-or', 
            ['is-closed',Type], 
            ['=alpha',_premise,_head]], 
          'Empty', 
          [ let, 
            [_res,_ntail], 
            [removePrf,_tail,_premise], 
            [ _res, 
              ['cons-atom',_head,_ntail]]]]], 
      'Empty'], 
    'Empty'])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  removePrf, 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa(removePrf,[2]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(removePrf,[2],'decons-ht',[3])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(removePrf,[2],'=unify',[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(removePrf,[2],'lazy-or',[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(removePrf,[2],'is-closed',[1])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(removePrf,[2],'=alpha',[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(removePrf,[2],'cons-atom',[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ prolog_if, 
    [ [ assign, 
        P, 
        [ fcall('decons-ht',[3]), 
          [_ccls,_head,_tail]]], 
      [ native(is_True), 
        P]], 
    [ [ prolog_if, 
        [ [ assign, 
            Q, 
            [ fcall('=unify',[2]), 
              [_premise,_head]]], 
          [ native(is_True), 
            Q]], 
        [ [ assign, 
            [:,_prf,Type], 
            _head], 
          [ prolog_if, 
            [ [ assign, 
                R, 
                [ispu,Type]], 
              [ assign, 
                S, 
                [ fcall('is-closed',[1]), 
                  [R]]], 
              [ assign, 
                T, 
                [ ispuU, 
                  U, 
                  [ [ assign, 
                      U, 
                      list(['=alpha',_premise,_head])]]]], 
              [ assign, 
                V, 
                [ fcall('lazy-or',[2]), 
                  [S,T]]], 
              [ native(is_True), 
                V]], 
            [ [ assign ,   W   ,'Empty']], 
            [ [ assign, 
                X, 
                [ fcall(removePrf,[2]), 
                  [_tail,_premise]]], 
              [ assign, 
                [_res,_ntail], 
                X], 
              [ assign, 
                Y, 
                [ fcall('cons-atom',[2]), 
                  [_head,_ntail]]], 
              [ transpiler_apply, mc__1_1_,_res, 
                [_res,Y], 
                Z, 
                [Y], 
                [A1], 
                [ x(noeval,eager,[list])], 
                [ [ [ assign, 
                      Y, 
                      [ fcall('cons-atom',[2]), 
                        [_head,_ntail]]]]], 
                [ [ [ assign, 
                      A1, 
                      list(['cons-atom',_head,_ntail])]]]], 
              [assign,W,Z]]], 
          [assign,B1,W]], 
        [ [ assign ,  B1   ,'Empty']]], 
      [assign,C1,B1]], 
    [ [ assign ,  C1   ,'Empty']]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 mc__1_2_removePrf(P,Q,R) :-  
    ((
     (  ((
         ('mc__1_3_decons-ht'(P,S,T,U),is_True(U))*->
         (  ((
             (  ((
                 (  ((
                     ('mc__1_2_=unify'(Q,S,V),is_True(V))*->
                     (( [:,W,X]=S  ,
                          ((
                           (  ((
                               (( Y=ispu(X)  ,
                                  'mc__1_1_is-closed'(Y,Z) , 
                                  A1 =  
                                    ispuU(B1,B1=['=alpha',Q,S]) , 
                                  'mc__1_2_lazy-or'(Z,A1,C1) , 
                                  is_True(C1)))*->
                               (D1='Empty')  )));
                           (( mc__1_2_removePrf(T,Q,E1)  ,
                              [F1,G1]=E1 , 
                              'mc__1_2_cons-atom'(S,G1,H1) , 
                              transpiler_apply( mc__1_1_, 
                                F1, 
                                [F1,H1], 
                                I1, 
                                [H1], 
                                [J1], 
                                [ x(noeval,eager,[list])], 
                                ['mc__1_2_cons-atom'(S,G1,H1)], 
                                [J1=['cons-atom',S,G1]]) , 
                              D1=I1))  )) , 
                        K1=D1))  )));
                 (K1='Empty')  ))),
             (R=K1)  )))  )));
     (R='Empty')  ))
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  [removePrf,_ccls,_premise], 
  [ 'if-decons-expr', _ccls,_head,_tail, 
    [ unify, _premise,_head, 
      [ let, 
        [_res,_ntail], 
        [removePrf,_tail,_premise], 
        [ ['cons-atom',_head,_res], 
          _ntail]], 
      [ let, 
        [_res,_ntail], 
        [removePrf,_tail,_premise], 
        [ _res, 
          ['cons-atom',_head,_ntail]]]], 
    [[],_ccls]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  [removePrf,_ccls,_premise], 
  [ if, 
    ['decons-ht',_ccls,_head,_tail], 
    [ unify, _premise,_head, 
      [ let, 
        [_res,_ntail], 
        [removePrf,_tail,_premise], 
        [ ['cons-atom',_head,_res], 
          _ntail]], 
      [ let, 
        [_res,_ntail], 
        [removePrf,_tail,_premise], 
        [ _res, 
          ['cons-atom',_head,_ntail]]]], 
    [[],_ccls]]]
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( removePrf, 
  [2], 
  1, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [removePrf,_ccls,_premise], 
  [ if, 
    ['decons-ht',_ccls,_head,_tail], 
    [ unify, _premise,_head, 
      [ let, 
        [_res,_ntail], 
        [removePrf,_tail,_premise], 
        [ ['cons-atom',_head,_res], 
          _ntail]], 
      [ let, 
        [_res,_ntail], 
        [removePrf,_tail,_premise], 
        [ _res, 
          ['cons-atom',_head,_ntail]]]], 
    [[],_ccls]])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(removePrf,[2],unify,[4])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">
 transpiler_depends_on(removePrf,[2],'cons-atom',[1,2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ prolog_if, 
    [ [ assign, 
        P, 
        [ fcall('decons-ht',[3]), 
          [_ccls,_head,_tail]]], 
      [ native(is_True), 
        P]], 
    [ [ assign, 
        Q, 
        [ ispeEnNC, 
          R, 
          [ [ assign, 
              S, 
              [ fcall('cons-atom',[2]), 
                [_head,_res]]], 
            [ assign, 
              R, 
              list([S,_ntail])]], 
          T, 
          [ [ assign, 
              U, 
              list(['cons-atom',_head,_res])], 
            [ assign, 
              T, 
              list([U,_ntail])]], 
          [ [ assign, 
              V, 
              [ fcall(removePrf,[2]), 
                [_tail,_premise]]], 
            [ assign, 
              [_res,_ntail], 
              V]]]], 
      [ assign, 
        W, 
        [ ispeEnNC, 
          X, 
          [ [ transpiler_apply, mc__1_1_,_res, 
              [_res,Y], 
              X, 
              [Y], 
              [Z], 
              [ x(noeval,eager,[list])], 
              [ [ [ assign, 
                    Y, 
                    [ fcall('cons-atom',[2]), 
                      [_head,_ntail]]]]], 
              [ [ [ assign, 
                    Z, 
                    list(['cons-atom',_head,_ntail])]]]]], 
          A1, 
          [ [ assign, A1,list([_res,Y])]], 
          [ [ assign, 
              B1, 
              [ fcall(removePrf,[2]), 
                [_tail,_premise]]], 
            [ assign, 
              [_res,_ntail], 
              B1], 
            [ assign, 
              Y, 
              [ fcall('cons-atom',[2]), 
                [_head,_ntail]]]]]], 
      [ assign, 
        C1, 
        [ fcall(unify,[4]), 
          [_premise,_head,Q,W]]], 
      [assign,D1,C1]], 
    [ [ assign, E1,list([[],_ccls])], 
      [assign,D1,E1]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 mc__1_2_removePrf(P,Q,R) :-  
    ((
     (  ((
         ('mc__1_3_decons-ht'(P,S,T,U),is_True(U))*->
         (( V =  
              ispeEnNC( W, 
                'mc__1_2_cons-atom'(S,X,Y),W=[Y,Z], 
                A1, 
                  ((
                   (B1=['cons-atom',S,X]),
                   (A1=[B1,Z])  )), 
                mc__1_2_removePrf(T,Q,C1),[X,Z]=C1)  ,
            D1 =  
              ispeEnNC( E1, 
                transpiler_apply( mc__1_1_, 
                  X, 
                  [X,F1], 
                  E1, 
                  [F1], 
                  [G1], 
                  [ x(noeval,eager,[list])], 
                  ['mc__1_2_cons-atom'(S,Z,F1)], 
                  [G1=['cons-atom',S,Z]]), 
                H1, 
                H1=[X,F1], 
                ( mc__1_2_removePrf(T,Q,I1)  ,
                  [X,Z]=I1 , 
                  'mc__1_2_cons-atom'(S,Z,F1))) , 
            mc__1_4_unify(Q,S,V,D1,J1) , 
            R=J1))  )));
     (K1=[[],P],R=K1)  ))
</span> 
<span class="ansi38-255165009">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!(removePrf ((: $a (A $v)) (: $a2 (A $v2))) (: a (A 1)))
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult (removePrf ((: $a (A $v)) (: $a2 (A $v2))) (: a (A 1))) ((((: a (A 1))) ((: $7806076 (A $7806094)))) (() ((: $7806076 (A $7806094)) (: $7806166 (A $7806184)))) (((: a (A 1))) ((: $7806166 (A $7806184)))) (((: a (A 1)) (: a (A 1))) ())))

</span>
;<h3 id="ARGSET-CHAINING.UTILS.04">;; ARGSET-CHAINING.UTILS.04</h3>
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [ :, 
        _a, 
        ['A',_v]], 
      [ :, 
        _a2, 
        ['A',_v2]]], P,Q, 
    [ if, 
      [ '=unify', 
        [ :, 
          a, 
          ['A',1]], 
        P], 
      [ let, 
        [:,R,S], 
        P, 
        [ if, 
          [ 'lazy-or', 
            ['is-closed',S], 
            [ '=alpha', 
              [ :, 
                a, 
                ['A',1]], 
              P]], 
          'Empty', 
          [ let, 
            [T,U], 
            [ removePrf, 
              Q, 
              [ :, 
                a, 
                ['A',1]]], 
            [ T, 
              ['cons-atom',P,U]]]]], 
      'Empty'], 
    'Empty']]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [ :, 
          _a, 
          ['A',_v]], 
        [ :, 
          _a2, 
          ['A',_v2]]], P,Q], 
    [ if, 
      [ '=unify', 
        [ :, 
          a, 
          ['A',1]], 
        P], 
      [ let, 
        [:,R,S], 
        P, 
        [ if, 
          [ 'lazy-or', 
            ['is-closed',S], 
            [ '=alpha', 
              [ :, 
                a, 
                ['A',1]], 
              P]], 
          'Empty', 
          [ let, 
            [T,U], 
            [ removePrf, 
              Q, 
              [ :, 
                a, 
                ['A',1]]], 
            [ T, 
              ['cons-atom',P,U]]]]], 
      'Empty'], 
    'Empty']]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [ :, 
        _a, 
        ['A',_v]], 
      [ :, 
        _a2, 
        ['A',_v2]]], P,Q, 
    [ unify, 
      [ :, 
        a, 
        ['A',1]], 
      P, 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a, 
            ['A',1]]], 
        [ ['cons-atom',P,R], 
          S]], 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a, 
            ['A',1]]], 
        [ R, 
          ['cons-atom',P,S]]]], 
    [ [], 
      [ [ :, 
          _a, 
          ['A',_v]], 
        [ :, 
          _a2, 
          ['A',_v2]]]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [ :, 
          _a, 
          ['A',_v]], 
        [ :, 
          _a2, 
          ['A',_v2]]], P,Q], 
    [ unify, 
      [ :, 
        a, 
        ['A',1]], 
      P, 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a, 
            ['A',1]]], 
        [ ['cons-atom',P,R], 
          S]], 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a, 
            ['A',1]]], 
        [ R, 
          ['cons-atom',P,S]]]], 
    [ [], 
      [ [ :, 
          _a, 
          ['A',_v]], 
        [ :, 
          _a2, 
          ['A',_v2]]]]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [ :, 
        _a2, 
        ['A',_v2]]], P,Q, 
    [ if, 
      [ '=unify', 
        [ :, 
          a, 
          ['A',1]], 
        P], 
      [ let, 
        [:,R,S], 
        P, 
        [ if, 
          [ 'lazy-or', 
            ['is-closed',S], 
            [ '=alpha', 
              [ :, 
                a, 
                ['A',1]], 
              P]], 
          'Empty', 
          [ let, 
            [T,U], 
            [ removePrf, 
              Q, 
              [ :, 
                a, 
                ['A',1]]], 
            [ T, 
              ['cons-atom',P,U]]]]], 
      'Empty'], 
    'Empty']]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [ :, 
          _a2, 
          ['A',_v2]]], P,Q], 
    [ if, 
      [ '=unify', 
        [ :, 
          a, 
          ['A',1]], 
        P], 
      [ let, 
        [:,R,S], 
        P, 
        [ if, 
          [ 'lazy-or', 
            ['is-closed',S], 
            [ '=alpha', 
              [ :, 
                a, 
                ['A',1]], 
              P]], 
          'Empty', 
          [ let, 
            [T,U], 
            [ removePrf, 
              Q, 
              [ :, 
                a, 
                ['A',1]]], 
            [ T, 
              ['cons-atom',P,U]]]]], 
      'Empty'], 
    'Empty']]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [ :, 
        _a2, 
        ['A',_v2]]], P,Q, 
    [ unify, 
      [ :, 
        a, 
        ['A',1]], 
      P, 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a, 
            ['A',1]]], 
        [ ['cons-atom',P,R], 
          S]], 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a, 
            ['A',1]]], 
        [ R, 
          ['cons-atom',P,S]]]], 
    [ [], 
      [ [ :, 
          _a2, 
          ['A',_v2]]]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [ :, 
          _a2, 
          ['A',_v2]]], P,Q], 
    [ unify, 
      [ :, 
        a, 
        ['A',1]], 
      P, 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a, 
            ['A',1]]], 
        [ ['cons-atom',P,R], 
          S]], 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a, 
            ['A',1]]], 
        [ R, 
          ['cons-atom',P,S]]]], 
    [ [], 
      [ [ :, 
          _a2, 
          ['A',_v2]]]]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [], P,Q, 
    [ if, 
      [ '=unify', 
        [ :, 
          a, 
          ['A',1]], 
        P], 
      [ let, 
        [:,R,S], 
        P, 
        [ if, 
          [ 'lazy-or', 
            ['is-closed',S], 
            [ '=alpha', 
              [ :, 
                a, 
                ['A',1]], 
              P]], 
          'Empty', 
          [ let, 
            [T,U], 
            [ removePrf, 
              Q, 
              [ :, 
                a, 
                ['A',1]]], 
            [ T, 
              ['cons-atom',P,U]]]]], 
      'Empty'], 
    'Empty']]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[],P,Q], 
    [ if, 
      [ '=unify', 
        [ :, 
          a, 
          ['A',1]], 
        P], 
      [ let, 
        [:,R,S], 
        P, 
        [ if, 
          [ 'lazy-or', 
            ['is-closed',S], 
            [ '=alpha', 
              [ :, 
                a, 
                ['A',1]], 
              P]], 
          'Empty', 
          [ let, 
            [T,U], 
            [ removePrf, 
              Q, 
              [ :, 
                a, 
                ['A',1]]], 
            [ T, 
              ['cons-atom',P,U]]]]], 
      'Empty'], 
    'Empty']]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [], P,Q, 
    [ unify, 
      [ :, 
        a, 
        ['A',1]], 
      P, 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a, 
            ['A',1]]], 
        [ ['cons-atom',P,R], 
          S]], 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a, 
            ['A',1]]], 
        [ R, 
          ['cons-atom',P,S]]]], 
    [ 
    [[],[]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[],P,Q], 
    [ unify, 
      [ :, 
        a, 
        ['A',1]], 
      P, 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a, 
            ['A',1]]], 
        [ ['cons-atom',P,R], 
          S]], 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a, 
            ['A',1]]], 
        [ R, 
          ['cons-atom',P,S]]]], 
    [ 
    [[],[]]]]
</span> 
; 
; EVAL TEST
; took 0.252 secs. (251.85 milliseconds) 

!(assertEqualToResult (removePrf ((: $a (A $v)) (: $a2 (A $v2))) (: a (A 1))) ((((: a (A 1))) ((: $7811848 (A $7811866)))) (() ((: $7811848 (A $7811866)) (: $7811938 (A $7811956)))) (((: a (A 1))) ((: $7811938 (A $7811956)))) (((: a (A 1)) (: a (A 1))) ())))

<span class="ansi31">  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( ( ( (: a 
              (A 1)) (: a (A 1))) ())) 
      ( ( ( (: a 
              (A 1))) ((: $7806076 (A $7806094)))) 
        (() ((: $7806076 (A $7806094)) (: $7806166 (A $7806184)))) 
        ( ( (: a 
              (A 1))) ((: $7806166 (A $7806184)))) 
        ( ( (: a 
              (A 1)) (: a (A 1))) ()))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'('[|]'('[|]'('[|]'(:,'[|]'(a,'[|]'('[|]'('A','[|]'(1,[])),[]))),'[|]'('[|]'(:,'[|]'(a,'[|]'('[|]'('A','[|]'(1,[])),[]))),[])),'[|]'([],[])),[]),'[|]'('[|]'('[|]'('[|]'(:,'[|]'(a,'[|]'('[|]'('A','[|]'(1,[])),[]))),[]),'[|]'('[|]'('[|]'(:,'[|]'(_7806076,'[|]'('[|]'('A','[|]'(_7806094,[])),[]))),[]),[])),'[|]'('[|]'([],'[|]'('[|]'('[|]'(:,'[|]'(_7806076,'[|]'('[|]'('A','[|]'(_7806094,[])),[]))),'[|]'('[|]'(:,'[|]'(_7806166,'[|]'('[|]'('A','[|]'(_7806184,[])),[]))),[])),[])),'[|]'('[|]'('[|]'('[|]'(:,'[|]'(a,'[|]'('[|]'('A','[|]'(1,[])),[]))),[]),'[|]'('[|]'('[|]'(:,'[|]'(_7806166,'[|]'('[|]'('A','[|]'(_7806184,[])),[]))),[]),[])),'[|]'('[|]'('[|]'('[|]'(:,'[|]'(a,'[|]'('[|]'('A','[|]'(1,[])),[]))),'[|]'('[|]'(:,'[|]'(a,'[|]'('[|]'('A','[|]'(1,[])),[]))),[])),'[|]'([],[])),[])))))

Deterministic: <span class="ansi33">  (Error 
    (assertEqualToResult 
      (removePrf 
        ( (: $a 
            (A $v)) (: $a2 (A $v2))) 
        (: a 
          (A 1))) 
      ( ( ( (: a 
              (A 1))) ((: $7806076 (A $7806094)))) 
        (() ((: $7806076 (A $7806094)) (: $7806166 (A $7806184)))) 
        ( ( (: a 
              (A 1))) ((: $7806166 (A $7806184)))) 
        ( ( (: a 
              (A 1)) (: a (A 1))) ()))) 
    ('
Got: ' 
      ( ( ( (: a 
              (A 1)) (: a (A 1))) ())) '
EXP: ' 
      ( ( ( (: a 
              (A 1))) ((: $7806076 (A $7806094)))) 
        (() ((: $7806076 (A $7806094)) (: $7806166 (A $7806184)))) 
        ( ( (: a 
              (A 1))) ((: $7806166 (A $7806184)))) 
        ( ( (: a 
              (A 1)) (: a (A 1))) ()))))
</span><span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  [removeAlphaMagic,_list,_elem], 
  [ unify, 
    _elem, 
    [ :, 
      _prf2, 
      ['Eval',_type2,_tv2]], 
    [ 'if-decons-expr', _list,_head,_tail, 
      [ unify, 
        _head, 
        [ :, 
          _prf, 
          ['Eval',_type,_tv]], 
        [ if, 
          ['=alpha',_type,_type2], 
          [ let, 
            [_res,_ntail], 
            [removeAlphaMagic,_tail,_elem], 
            [ ['cons-atom',_head,_res], 
              _ntail]], 
          [ let, 
            [_res,_ntail], 
            [removeAlphaMagic,_tail,_elem], 
            [ _res, 
              ['cons-atom',_head,_ntail]]]], 
        [ let, 
          [_res,_ntail], 
          [removeAlphaMagic,_tail,_elem], 
          [ _res, 
            ['cons-atom',_head,_ntail]]]], 
      [ 
      [[],[]]], 
    [[],_list]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  [removeAlphaMagic,_list,_elem], 
  [ unify, 
    _elem, 
    [ :, 
      _prf2, 
      ['Eval',_type2,_tv2]], 
    [ if, 
      ['decons-ht',_list,_head,_tail], 
      [ unify, 
        _head, 
        [ :, 
          _prf, 
          ['Eval',_type,_tv]], 
        [ if, 
          ['=alpha',_type,_type2], 
          [ let, 
            [_res,_ntail], 
            [removeAlphaMagic,_tail,_elem], 
            [ ['cons-atom',_head,_res], 
              _ntail]], 
          [ let, 
            [_res,_ntail], 
            [removeAlphaMagic,_tail,_elem], 
            [ _res, 
              ['cons-atom',_head,_ntail]]]], 
        [ let, 
          [_res,_ntail], 
          [removeAlphaMagic,_tail,_elem], 
          [ _res, 
            ['cons-atom',_head,_ntail]]]], 
      [ 
      [[],[]]], 
    [[],_list]]]
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( removeAlphaMagic, 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [removeAlphaMagic,_list,_elem], 
  [ unify, 
    _elem, 
    [ :, 
      _prf2, 
      ['Eval',_type2,_tv2]], 
    [ if, 
      ['decons-ht',_list,_head,_tail], 
      [ unify, 
        _head, 
        [ :, 
          _prf, 
          ['Eval',_type,_tv]], 
        [ if, 
          ['=alpha',_type,_type2], 
          [ let, 
            [_res,_ntail], 
            [removeAlphaMagic,_tail,_elem], 
            [ ['cons-atom',_head,_res], 
              _ntail]], 
          [ let, 
            [_res,_ntail], 
            [removeAlphaMagic,_tail,_elem], 
            [ _res, 
              ['cons-atom',_head,_ntail]]]], 
        [ let, 
          [_res,_ntail], 
          [removeAlphaMagic,_tail,_elem], 
          [ _res, 
            ['cons-atom',_head,_ntail]]]], 
      [ 
      [[],[]]], 
    [[],_list]])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  removeAlphaMagic, 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa(removeAlphaMagic,[2]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(removeAlphaMagic,[2],unify,[4])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(removeAlphaMagic,[2],:,[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(removeAlphaMagic,[2],'Eval',[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(removeAlphaMagic,[2],'decons-ht',[3])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(removeAlphaMagic,[2],'=alpha',[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">
 transpiler_depends_on(removeAlphaMagic,[2],'cons-atom',[1,2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(removeAlphaMagic,[2],'cons-atom',[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ assign, 
    P, 
    list(['Eval',_type2,_tv2])], 
  [ assign, 
    Q, 
    list([:,_prf2,P])], 
  [ assign, 
    R, 
    [ ispeEnN, 
      S, 
      [ [ prolog_if, 
          [ [ assign, 
              T, 
              [ fcall('decons-ht',[3]), 
                [_list,_head,_tail]]], 
            [ native(is_True), 
              T]], 
          [ [ assign, 
              U, 
              list(['Eval',_type,_tv])], 
            [ assign, 
              V, 
              list([:,_prf,U])], 
            [ assign, 
              W, 
              [ ispeEnN, 
                X, 
                [ [ prolog_if, 
                    [ [ assign, 
                        Y, 
                        list(['=alpha',_type,_type2])], 
                      [ native(is_True), 
                        Y]], 
                    [ [ assign, 
                        Z, 
                        [ fcall(removeAlphaMagic,[2]), 
                          [_tail,_elem]]], 
                      [ assign, 
                        [_res,_ntail], 
                        Z], 
                      [ assign, 
                        A1, 
                        [ fcall('cons-atom',[2]), 
                          [_head,_res]]], 
                      [ assign, 
                        B1, 
                        list([A1,_ntail])], 
                      [assign,X,B1]], 
                    [ [ assign, 
                        C1, 
                        [ fcall(removeAlphaMagic,[2]), 
                          [_tail,_elem]]], 
                      [ assign, 
                        [_res,_ntail], 
                        C1], 
                      [ assign, 
                        D1, 
                        [ fcall('cons-atom',[2]), 
                          [_head,_ntail]]], 
                      [ transpiler_apply, mc__1_1_,_res, 
                        [_res,D1], 
                        E1, 
                        [D1], 
                        [F1], 
                        [ x(noeval,eager,[list])], 
                        [ [ [ assign, 
                              D1, 
                              [ fcall('cons-atom',[2]), 
                                [_head,_ntail]]]]], 
                        [ [ [ assign, 
                              F1, 
                              list(['cons-atom',_head,_ntail])]]]], 
                      [assign,X,E1]]]], 
                G1, 
                [ [ prolog_if, 
                    [ [ assign, 
                        Y, 
                        list(['=alpha',_type,_type2])], 
                      [ native(is_True), 
                        Y]], 
                    [ [ assign, 
                        Z, 
                        [ fcall(removeAlphaMagic,[2]), 
                          [_tail,_elem]]], 
                      [ assign, 
                        [_res,_ntail], 
                        Z], 
                      [ assign, 
                        H1, 
                        list(['cons-atom',_head,_res])], 
                      [ assign, 
                        I1, 
                        list([H1,_ntail])], 
                      [assign,G1,I1]], 
                    [ [ assign, 
                        C1, 
                        [ fcall(removeAlphaMagic,[2]), 
                          [_tail,_elem]]], 
                      [ assign, 
                        [_res,_ntail], 
                        C1], 
                      [ assign, 
                        D1, 
                        [ fcall('cons-atom',[2]), 
                          [_head,_ntail]]], 
                      [ assign, 
                        J1, 
                        list([_res,D1])], 
                      [assign,G1,J1]]]]]], 
            [ assign, 
              K1, 
              [ ispeEnNC, 
                L1, 
                [ [ transpiler_apply, mc__1_1_,_res, 
                    [_res,M1], 
                    L1, 
                    [M1], 
                    [N1], 
                    [ x(noeval,eager,[list])], 
                    [ [ [ assign, 
                          M1, 
                          [ fcall('cons-atom',[2]), 
                            [_head,_ntail]]]]], 
                    [ [ [ assign, 
                          N1, 
                          list(['cons-atom',_head,_ntail])]]]]], 
                O1, 
                [ [ assign, O1,list([_res,M1])]], 
                [ [ assign, 
                    P1, 
                    [ fcall(removeAlphaMagic,[2]), 
                      [_tail,_elem]]], 
                  [ assign, 
                    [_res,_ntail], 
                    P1], 
                  [ assign, 
                    M1, 
                    [ fcall('cons-atom',[2]), 
                      [_head,_ntail]]]]]], 
            [ assign, 
              Q1, 
              [ fcall(unify,[4]), 
                [_head,V,W,K1]]], 
            [assign,S,Q1]], 
          [ [ assign, R1,list([[],[]])], 
            [assign,S,R1]]]], 
      S1, 
      [ [ prolog_if, 
          [ [ assign, 
              T, 
              [ fcall('decons-ht',[3]), 
                [_list,_head,_tail]]], 
            [ native(is_True), 
              T]], 
          [ [ assign, 
              U, 
              list(['Eval',_type,_tv])], 
            [ assign, 
              V, 
              list([:,_prf,U])], 
            [ assign, 
              W, 
              [ ispeEnN, 
                X, 
                [ [ prolog_if, 
                    [ [ assign, 
                        Y, 
                        list(['=alpha',_type,_type2])], 
                      [ native(is_True), 
                        Y]], 
                    [ [ assign, 
                        Z, 
                        [ fcall(removeAlphaMagic,[2]), 
                          [_tail,_elem]]], 
                      [ assign, 
                        [_res,_ntail], 
                        Z], 
                      [ assign, 
                        A1, 
                        [ fcall('cons-atom',[2]), 
                          [_head,_res]]], 
                      [ assign, 
                        B1, 
                        list([A1,_ntail])], 
                      [assign,X,B1]], 
                    [ [ assign, 
                        C1, 
                        [ fcall(removeAlphaMagic,[2]), 
                          [_tail,_elem]]], 
                      [ assign, 
                        [_res,_ntail], 
                        C1], 
                      [ assign, 
                        D1, 
                        [ fcall('cons-atom',[2]), 
                          [_head,_ntail]]], 
                      [ transpiler_apply, mc__1_1_,_res, 
                        [_res,D1], 
                        E1, 
                        [D1], 
                        [F1], 
                        [ x(noeval,eager,[list])], 
                        [ [ [ assign, 
                              D1, 
                              [ fcall('cons-atom',[2]), 
                                [_head,_ntail]]]]], 
                        [ [ [ assign, 
                              F1, 
                              list(['cons-atom',_head,_ntail])]]]], 
                      [assign,X,E1]]]], 
                G1, 
                [ [ prolog_if, 
                    [ [ assign, 
                        Y, 
                        list(['=alpha',_type,_type2])], 
                      [ native(is_True), 
                        Y]], 
                    [ [ assign, 
                        Z, 
                        [ fcall(removeAlphaMagic,[2]), 
                          [_tail,_elem]]], 
                      [ assign, 
                        [_res,_ntail], 
                        Z], 
                      [ assign, 
                        H1, 
                        list(['cons-atom',_head,_res])], 
                      [ assign, 
                        I1, 
                        list([H1,_ntail])], 
                      [assign,G1,I1]], 
                    [ [ assign, 
                        C1, 
                        [ fcall(removeAlphaMagic,[2]), 
                          [_tail,_elem]]], 
                      [ assign, 
                        [_res,_ntail], 
                        C1], 
                      [ assign, 
                        D1, 
                        [ fcall('cons-atom',[2]), 
                          [_head,_ntail]]], 
                      [ assign, 
                        J1, 
                        list([_res,D1])], 
                      [assign,G1,J1]]]]]], 
            [ assign, 
              K1, 
              [ ispeEnNC, 
                L1, 
                [ [ transpiler_apply, mc__1_1_,_res, 
                    [_res,M1], 
                    L1, 
                    [M1], 
                    [N1], 
                    [ x(noeval,eager,[list])], 
                    [ [ [ assign, 
                          M1, 
                          [ fcall('cons-atom',[2]), 
                            [_head,_ntail]]]]], 
                    [ [ [ assign, 
                          N1, 
                          list(['cons-atom',_head,_ntail])]]]]], 
                O1, 
                [ [ assign, O1,list([_res,M1])]], 
                [ [ assign, 
                    P1, 
                    [ fcall(removeAlphaMagic,[2]), 
                      [_tail,_elem]]], 
                  [ assign, 
                    [_res,_ntail], 
                    P1], 
                  [ assign, 
                    M1, 
                    [ fcall('cons-atom',[2]), 
                      [_head,_ntail]]]]]], 
            [ assign, 
              T1, 
              list([unify,_head,V,W,K1])], 
            [assign,S1,T1]], 
          [ [ assign, U1,list([[],[]])], 
            [assign,S1,U1]]]]]], 
  [ assign, 
    V1, 
    [ ispuU, 
      W1, 
      [ [ assign, W1,list([[],_list])]]]], 
  [ assign, 
    X1, 
    [ fcall(unify,[4]), 
      [_elem,Q,R,V1]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 mc__1_2_removeAlphaMagic(P,Q,R) :- 
  S=['Eval',T,U] , 
  V=[:,W,S] , 
  X =  
    ispeEnN( Y, 
        ((
         (  ((
             ('mc__1_3_decons-ht'(P,Z,A1,B1),is_True(B1))*->
             (( C1=['Eval',D1,E1]  ,
                F1=[:,G1,C1] , 
                H1 =  
                  ispeEnN( I1, 
                      ((
                       (  ((
                           (J1=['=alpha',D1,T],is_True(J1))*->
                           (( mc__1_2_removeAlphaMagic(A1,Q,K1)  ,
                              [L1,M1]=K1 , 
                              'mc__1_2_cons-atom'(Z,L1,N1) , 
                              O1=[N1,M1] , 
                              I1=O1))  )));
                       (( mc__1_2_removeAlphaMagic(A1,Q,P1)  ,
                          [L1,M1]=P1 , 
                          'mc__1_2_cons-atom'(Z,M1,Q1) , 
                          transpiler_apply( mc__1_1_, 
                            L1, 
                            [L1,Q1], 
                            R1, 
                            [Q1], 
                            [S1], 
                            [ x(noeval,eager,[list])], 
                            ['mc__1_2_cons-atom'(Z,M1,Q1)], 
                            [S1=['cons-atom',Z,M1]]) , 
                          I1=R1))  )), 
                    T1, 
                      ((
                       (  ((
                           (J1=['=alpha',D1,T],is_True(J1))*->
                           (( mc__1_2_removeAlphaMagic(A1,Q,K1)  ,
                              [L1,M1]=K1 , 
                              U1=['cons-atom',Z,L1] , 
                              V1=[U1,M1] , 
                              T1=V1))  )));
                       (( mc__1_2_removeAlphaMagic(A1,Q,P1)  ,
                          [L1,M1]=P1 , 
                          'mc__1_2_cons-atom'(Z,M1,Q1) , 
                          W1=[L1,Q1] , 
                          T1=W1))  ))) , 
                X1 =  
                  ispeEnNC( Y1, 
                    transpiler_apply( mc__1_1_, 
                      L1, 
                      [L1,Z1], 
                      Y1, 
                      [Z1], 
                      [A2], 
                      [ x(noeval,eager,[list])], 
                      ['mc__1_2_cons-atom'(Z,M1,Z1)], 
                      [A2=['cons-atom',Z,M1]]), 
                    B2, 
                    B2=[L1,Z1], 
                    ( mc__1_2_removeAlphaMagic(A1,Q,C2)  ,
                      [L1,M1]=C2 , 
                      'mc__1_2_cons-atom'(Z,M1,Z1))) , 
                mc__1_4_unify(Z,F1,H1,X1,D2) , 
                Y=D2))  )));
         (E2=[[],[]],Y=E2)  )), 
      F2, 
        ((
         (  ((
             ('mc__1_3_decons-ht'(P,Z,A1,B1),is_True(B1))*->
             (( C1=['Eval',D1,E1]  ,
                F1=[:,G1,C1] , 
                H1 =  
                  ispeEnN( I1, 
                      ((
                       (  ((
                           (J1=['=alpha',D1,T],is_True(J1))*->
                           (( mc__1_2_removeAlphaMagic(A1,Q,K1)  ,
                              [L1,M1]=K1 , 
                              'mc__1_2_cons-atom'(Z,L1,N1) , 
                              O1=[N1,M1] , 
                              I1=O1))  )));
                       (( mc__1_2_removeAlphaMagic(A1,Q,P1)  ,
                          [L1,M1]=P1 , 
                          'mc__1_2_cons-atom'(Z,M1,Q1) , 
                          transpiler_apply( mc__1_1_, 
                            L1, 
                            [L1,Q1], 
                            R1, 
                            [Q1], 
                            [S1], 
                            [ x(noeval,eager,[list])], 
                            ['mc__1_2_cons-atom'(Z,M1,Q1)], 
                            [S1=['cons-atom',Z,M1]]) , 
                          I1=R1))  )), 
                    T1, 
                      ((
                       (  ((
                           (J1=['=alpha',D1,T],is_True(J1))*->
                           (( mc__1_2_removeAlphaMagic(A1,Q,K1)  ,
                              [L1,M1]=K1 , 
                              U1=['cons-atom',Z,L1] , 
                              V1=[U1,M1] , 
                              T1=V1))  )));
                       (( mc__1_2_removeAlphaMagic(A1,Q,P1)  ,
                          [L1,M1]=P1 , 
                          'mc__1_2_cons-atom'(Z,M1,Q1) , 
                          W1=[L1,Q1] , 
                          T1=W1))  ))) , 
                X1 =  
                  ispeEnNC( Y1, 
                    transpiler_apply( mc__1_1_, 
                      L1, 
                      [L1,Z1], 
                      Y1, 
                      [Z1], 
                      [A2], 
                      [ x(noeval,eager,[list])], 
                      ['mc__1_2_cons-atom'(Z,M1,Z1)], 
                      [A2=['cons-atom',Z,M1]]), 
                    B2, 
                    B2=[L1,Z1], 
                    ( mc__1_2_removeAlphaMagic(A1,Q,C2)  ,
                      [L1,M1]=C2 , 
                      'mc__1_2_cons-atom'(Z,M1,Z1))) , 
                G2 =  
                  [ unify, Z,F1,H1,X1] , 
                F2=G2))  )));
         (H2=[[],[]],F2=H2)  ))) , 
  I2 =  
    ispuU(J2,J2=[[],P]) , 
  mc__1_4_unify(Q,V,X,I2,R)
</span> 
<span class="ansi38-255165009">;; In file as:  
</span><span class="ansi1 ansi38-255238088">!(removeAlphaMagic ((: b (Eval (m a) tv2)) (: c (Eval c tv3)) (: d (Eval (m a) tv4))) (: a (Eval (m a) tv1)))
</span>;; To unit test case:
<span class="ansi38-013099040">!(assertEqualToResult (removeAlphaMagic ((: b (Eval (m a) tv2)) (: c (Eval c tv3)) (: d (Eval (m a) tv4))) (: a (Eval (m a) tv1))) (()))

</span>
;<h3 id="ARGSET-CHAINING.UTILS.05">;; ARGSET-CHAINING.UTILS.05</h3>
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ unify, 
    [ :, 
      a, 
      ['Eval',[m,a],tv1]], 
    [ :, 
      P, 
      ['Eval',Q,R]], 
    [ 'if-decons-expr', 
      [ [ :, 
          b, 
          ['Eval',[m,a],tv2]], 
        [ :, 
          c, 
          ['Eval',c,tv3]], 
        [ :, 
          d, 
          ['Eval',[m,a],tv4]]], S,T, 
      [ unify, 
        S, 
        [ :, 
          U, 
          ['Eval',V,W]], 
        [ if, 
          ['=alpha',V,Q], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ ['cons-atom',S,X], 
              Y]], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ X, 
              ['cons-atom',S,Y]]]], 
        [ let, 
          [X,Y], 
          [ removeAlphaMagic, 
            T, 
            [ :, 
              a, 
              ['Eval',[m,a],tv1]]], 
          [ X, 
            ['cons-atom',S,Y]]]], 
      [ 
      [[],[]]], 
    [ [], 
      [ [ :, 
          b, 
          ['Eval',[m,a],tv2]], 
        [ :, 
          c, 
          ['Eval',c,tv3]], 
        [ :, 
          d, 
          ['Eval',[m,a],tv4]]]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ unify, 
    [ :, 
      a, 
      ['Eval',[m,a],tv1]], 
    [ :, 
      P, 
      ['Eval',Q,R]], 
    [ if, 
      [ 'decons-ht', 
        [ [ :, 
            b, 
            ['Eval',[m,a],tv2]], 
          [ :, 
            c, 
            ['Eval',c,tv3]], 
          [ :, 
            d, 
            ['Eval',[m,a],tv4]]], S,T], 
      [ unify, 
        S, 
        [ :, 
          U, 
          ['Eval',V,W]], 
        [ if, 
          ['=alpha',V,Q], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ ['cons-atom',S,X], 
              Y]], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ X, 
              ['cons-atom',S,Y]]]], 
        [ let, 
          [X,Y], 
          [ removeAlphaMagic, 
            T, 
            [ :, 
              a, 
              ['Eval',[m,a],tv1]]], 
          [ X, 
            ['cons-atom',S,Y]]]], 
      [ 
      [[],[]]], 
    [ [], 
      [ [ :, 
          b, 
          ['Eval',[m,a],tv2]], 
        [ :, 
          c, 
          ['Eval',c,tv3]], 
        [ :, 
          d, 
          ['Eval',[m,a],tv4]]]]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ unify, 
    [ :, 
      a, 
      ['Eval',[m,a],tv1]], 
    [ :, 
      P, 
      ['Eval',Q,R]], 
    [ 'if-decons-expr', 
      [ [ :, 
          c, 
          ['Eval',c,tv3]], 
        [ :, 
          d, 
          ['Eval',[m,a],tv4]]], S,T, 
      [ unify, 
        S, 
        [ :, 
          U, 
          ['Eval',V,W]], 
        [ if, 
          ['=alpha',V,Q], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ ['cons-atom',S,X], 
              Y]], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ X, 
              ['cons-atom',S,Y]]]], 
        [ let, 
          [X,Y], 
          [ removeAlphaMagic, 
            T, 
            [ :, 
              a, 
              ['Eval',[m,a],tv1]]], 
          [ X, 
            ['cons-atom',S,Y]]]], 
      [ 
      [[],[]]], 
    [ [], 
      [ [ :, 
          c, 
          ['Eval',c,tv3]], 
        [ :, 
          d, 
          ['Eval',[m,a],tv4]]]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ unify, 
    [ :, 
      a, 
      ['Eval',[m,a],tv1]], 
    [ :, 
      P, 
      ['Eval',Q,R]], 
    [ if, 
      [ 'decons-ht', 
        [ [ :, 
            c, 
            ['Eval',c,tv3]], 
          [ :, 
            d, 
            ['Eval',[m,a],tv4]]], S,T], 
      [ unify, 
        S, 
        [ :, 
          U, 
          ['Eval',V,W]], 
        [ if, 
          ['=alpha',V,Q], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ ['cons-atom',S,X], 
              Y]], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ X, 
              ['cons-atom',S,Y]]]], 
        [ let, 
          [X,Y], 
          [ removeAlphaMagic, 
            T, 
            [ :, 
              a, 
              ['Eval',[m,a],tv1]]], 
          [ X, 
            ['cons-atom',S,Y]]]], 
      [ 
      [[],[]]], 
    [ [], 
      [ [ :, 
          c, 
          ['Eval',c,tv3]], 
        [ :, 
          d, 
          ['Eval',[m,a],tv4]]]]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ unify, 
    [ :, 
      a, 
      ['Eval',[m,a],tv1]], 
    [ :, 
      P, 
      ['Eval',Q,R]], 
    [ 'if-decons-expr', 
      [ [ :, 
          d, 
          ['Eval',[m,a],tv4]]], S,T, 
      [ unify, 
        S, 
        [ :, 
          U, 
          ['Eval',V,W]], 
        [ if, 
          ['=alpha',V,Q], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ ['cons-atom',S,X], 
              Y]], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ X, 
              ['cons-atom',S,Y]]]], 
        [ let, 
          [X,Y], 
          [ removeAlphaMagic, 
            T, 
            [ :, 
              a, 
              ['Eval',[m,a],tv1]]], 
          [ X, 
            ['cons-atom',S,Y]]]], 
      [ 
      [[],[]]], 
    [ [], 
      [ [ :, 
          d, 
          ['Eval',[m,a],tv4]]]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ unify, 
    [ :, 
      a, 
      ['Eval',[m,a],tv1]], 
    [ :, 
      P, 
      ['Eval',Q,R]], 
    [ if, 
      [ 'decons-ht', 
        [ [ :, 
            d, 
            ['Eval',[m,a],tv4]]], S,T], 
      [ unify, 
        S, 
        [ :, 
          U, 
          ['Eval',V,W]], 
        [ if, 
          ['=alpha',V,Q], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ ['cons-atom',S,X], 
              Y]], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ X, 
              ['cons-atom',S,Y]]]], 
        [ let, 
          [X,Y], 
          [ removeAlphaMagic, 
            T, 
            [ :, 
              a, 
              ['Eval',[m,a],tv1]]], 
          [ X, 
            ['cons-atom',S,Y]]]], 
      [ 
      [[],[]]], 
    [ [], 
      [ [ :, 
          d, 
          ['Eval',[m,a],tv4]]]]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ unify, 
    [ :, 
      a, 
      ['Eval',[m,a],tv1]], 
    [ :, 
      P, 
      ['Eval',Q,R]], 
    [ 'if-decons-expr', 
      [], S,T, 
      [ unify, 
        S, 
        [ :, 
          U, 
          ['Eval',V,W]], 
        [ if, 
          ['=alpha',V,Q], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ ['cons-atom',S,X], 
              Y]], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ X, 
              ['cons-atom',S,Y]]]], 
        [ let, 
          [X,Y], 
          [ removeAlphaMagic, 
            T, 
            [ :, 
              a, 
              ['Eval',[m,a],tv1]]], 
          [ X, 
            ['cons-atom',S,Y]]]], 
      [ 
      [[],[]]], 
    [ 
    [[],[]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ unify, 
    [ :, 
      a, 
      ['Eval',[m,a],tv1]], 
    [ :, 
      P, 
      ['Eval',Q,R]], 
    [ if, 
      ['decons-ht',[],S,T], 
      [ unify, 
        S, 
        [ :, 
          U, 
          ['Eval',V,W]], 
        [ if, 
          ['=alpha',V,Q], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ ['cons-atom',S,X], 
              Y]], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ X, 
              ['cons-atom',S,Y]]]], 
        [ let, 
          [X,Y], 
          [ removeAlphaMagic, 
            T, 
            [ :, 
              a, 
              ['Eval',[m,a],tv1]]], 
          [ X, 
            ['cons-atom',S,Y]]]], 
      [ 
      [[],[]]], 
    [ 
    [[],[]]]]
</span> 
; 
; EVAL TEST
; took 0.456 secs. (455.70 milliseconds) 

!(assertEqualToResult (removeAlphaMagic ((: b (Eval (m a) tv2)) (: c (Eval c tv3)) (: d (Eval (m a) tv4))) (: a (Eval (m a) tv1))) (()))

<span class="ansi31">  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( ( ( (: b 
              (Eval 
                (m a) tv2)) 
            (: c 
              (Eval c tv3)) 
            (: d 
              (Eval 
                (m a) tv4))) ())) 
      (())]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'('[|]'('[|]'('[|]'(:,'[|]'(b,'[|]'('[|]'('Eval','[|]'('[|]'(m,'[|]'(a,[])),'[|]'(tv2,[]))),[]))),'[|]'('[|]'(:,'[|]'(c,'[|]'('[|]'('Eval','[|]'(c,'[|]'(tv3,[]))),[]))),'[|]'('[|]'(:,'[|]'(d,'[|]'('[|]'('Eval','[|]'('[|]'(m,'[|]'(a,[])),'[|]'(tv4,[]))),[]))),[]))),'[|]'([],[])),[]),'[|]'([],[]))

Deterministic: <span class="ansi33">  (Error 
    (assertEqualToResult 
      (removeAlphaMagic 
        ( (: b 
            (Eval 
              (m a) tv2)) 
          (: c 
            (Eval c tv3)) 
          (: d 
            (Eval 
              (m a) tv4))) 
        (: a 
          (Eval 
            (m a) tv1))) 
      (())) 
    ('
Got: ' 
      ( ( ( (: b 
              (Eval 
                (m a) tv2)) 
            (: c 
              (Eval c tv3)) 
            (: d 
              (Eval 
                (m a) tv4))) ())) '
EXP: ' 
      (())))
</span><span class="ansi38-013099040">!(assertEqual (removeAlphaMagic ((: b (Eval (m a) tv2)) (: c (Eval c tv3)) (: d (Eval (m a) tv4))) (: a (Eval (m a) tv1))) (((: b (Eval (m a) tv2)) (: d (Eval (m a) tv4))) ((: c (Eval c tv3)))))

</span>
;<h3 id="ARGSET-CHAINING.UTILS.06">;; ARGSET-CHAINING.UTILS.06</h3>
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ unify, 
    [ :, 
      a, 
      ['Eval',[m,a],tv1]], 
    [ :, 
      P, 
      ['Eval',Q,R]], 
    [ 'if-decons-expr', 
      [ [ :, 
          b, 
          ['Eval',[m,a],tv2]], 
        [ :, 
          c, 
          ['Eval',c,tv3]], 
        [ :, 
          d, 
          ['Eval',[m,a],tv4]]], S,T, 
      [ unify, 
        S, 
        [ :, 
          U, 
          ['Eval',V,W]], 
        [ if, 
          ['=alpha',V,Q], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ ['cons-atom',S,X], 
              Y]], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ X, 
              ['cons-atom',S,Y]]]], 
        [ let, 
          [X,Y], 
          [ removeAlphaMagic, 
            T, 
            [ :, 
              a, 
              ['Eval',[m,a],tv1]]], 
          [ X, 
            ['cons-atom',S,Y]]]], 
      [ 
      [[],[]]], 
    [ [], 
      [ [ :, 
          b, 
          ['Eval',[m,a],tv2]], 
        [ :, 
          c, 
          ['Eval',c,tv3]], 
        [ :, 
          d, 
          ['Eval',[m,a],tv4]]]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ unify, 
    [ :, 
      a, 
      ['Eval',[m,a],tv1]], 
    [ :, 
      P, 
      ['Eval',Q,R]], 
    [ if, 
      [ 'decons-ht', 
        [ [ :, 
            b, 
            ['Eval',[m,a],tv2]], 
          [ :, 
            c, 
            ['Eval',c,tv3]], 
          [ :, 
            d, 
            ['Eval',[m,a],tv4]]], S,T], 
      [ unify, 
        S, 
        [ :, 
          U, 
          ['Eval',V,W]], 
        [ if, 
          ['=alpha',V,Q], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ ['cons-atom',S,X], 
              Y]], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ X, 
              ['cons-atom',S,Y]]]], 
        [ let, 
          [X,Y], 
          [ removeAlphaMagic, 
            T, 
            [ :, 
              a, 
              ['Eval',[m,a],tv1]]], 
          [ X, 
            ['cons-atom',S,Y]]]], 
      [ 
      [[],[]]], 
    [ [], 
      [ [ :, 
          b, 
          ['Eval',[m,a],tv2]], 
        [ :, 
          c, 
          ['Eval',c,tv3]], 
        [ :, 
          d, 
          ['Eval',[m,a],tv4]]]]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ unify, 
    [ :, 
      a, 
      ['Eval',[m,a],tv1]], 
    [ :, 
      P, 
      ['Eval',Q,R]], 
    [ 'if-decons-expr', 
      [ [ :, 
          c, 
          ['Eval',c,tv3]], 
        [ :, 
          d, 
          ['Eval',[m,a],tv4]]], S,T, 
      [ unify, 
        S, 
        [ :, 
          U, 
          ['Eval',V,W]], 
        [ if, 
          ['=alpha',V,Q], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ ['cons-atom',S,X], 
              Y]], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ X, 
              ['cons-atom',S,Y]]]], 
        [ let, 
          [X,Y], 
          [ removeAlphaMagic, 
            T, 
            [ :, 
              a, 
              ['Eval',[m,a],tv1]]], 
          [ X, 
            ['cons-atom',S,Y]]]], 
      [ 
      [[],[]]], 
    [ [], 
      [ [ :, 
          c, 
          ['Eval',c,tv3]], 
        [ :, 
          d, 
          ['Eval',[m,a],tv4]]]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ unify, 
    [ :, 
      a, 
      ['Eval',[m,a],tv1]], 
    [ :, 
      P, 
      ['Eval',Q,R]], 
    [ if, 
      [ 'decons-ht', 
        [ [ :, 
            c, 
            ['Eval',c,tv3]], 
          [ :, 
            d, 
            ['Eval',[m,a],tv4]]], S,T], 
      [ unify, 
        S, 
        [ :, 
          U, 
          ['Eval',V,W]], 
        [ if, 
          ['=alpha',V,Q], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ ['cons-atom',S,X], 
              Y]], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ X, 
              ['cons-atom',S,Y]]]], 
        [ let, 
          [X,Y], 
          [ removeAlphaMagic, 
            T, 
            [ :, 
              a, 
              ['Eval',[m,a],tv1]]], 
          [ X, 
            ['cons-atom',S,Y]]]], 
      [ 
      [[],[]]], 
    [ [], 
      [ [ :, 
          c, 
          ['Eval',c,tv3]], 
        [ :, 
          d, 
          ['Eval',[m,a],tv4]]]]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ unify, 
    [ :, 
      a, 
      ['Eval',[m,a],tv1]], 
    [ :, 
      P, 
      ['Eval',Q,R]], 
    [ 'if-decons-expr', 
      [ [ :, 
          d, 
          ['Eval',[m,a],tv4]]], S,T, 
      [ unify, 
        S, 
        [ :, 
          U, 
          ['Eval',V,W]], 
        [ if, 
          ['=alpha',V,Q], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ ['cons-atom',S,X], 
              Y]], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ X, 
              ['cons-atom',S,Y]]]], 
        [ let, 
          [X,Y], 
          [ removeAlphaMagic, 
            T, 
            [ :, 
              a, 
              ['Eval',[m,a],tv1]]], 
          [ X, 
            ['cons-atom',S,Y]]]], 
      [ 
      [[],[]]], 
    [ [], 
      [ [ :, 
          d, 
          ['Eval',[m,a],tv4]]]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ unify, 
    [ :, 
      a, 
      ['Eval',[m,a],tv1]], 
    [ :, 
      P, 
      ['Eval',Q,R]], 
    [ if, 
      [ 'decons-ht', 
        [ [ :, 
            d, 
            ['Eval',[m,a],tv4]]], S,T], 
      [ unify, 
        S, 
        [ :, 
          U, 
          ['Eval',V,W]], 
        [ if, 
          ['=alpha',V,Q], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ ['cons-atom',S,X], 
              Y]], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ X, 
              ['cons-atom',S,Y]]]], 
        [ let, 
          [X,Y], 
          [ removeAlphaMagic, 
            T, 
            [ :, 
              a, 
              ['Eval',[m,a],tv1]]], 
          [ X, 
            ['cons-atom',S,Y]]]], 
      [ 
      [[],[]]], 
    [ [], 
      [ [ :, 
          d, 
          ['Eval',[m,a],tv4]]]]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ unify, 
    [ :, 
      a, 
      ['Eval',[m,a],tv1]], 
    [ :, 
      P, 
      ['Eval',Q,R]], 
    [ 'if-decons-expr', 
      [], S,T, 
      [ unify, 
        S, 
        [ :, 
          U, 
          ['Eval',V,W]], 
        [ if, 
          ['=alpha',V,Q], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ ['cons-atom',S,X], 
              Y]], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ X, 
              ['cons-atom',S,Y]]]], 
        [ let, 
          [X,Y], 
          [ removeAlphaMagic, 
            T, 
            [ :, 
              a, 
              ['Eval',[m,a],tv1]]], 
          [ X, 
            ['cons-atom',S,Y]]]], 
      [ 
      [[],[]]], 
    [ 
    [[],[]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ unify, 
    [ :, 
      a, 
      ['Eval',[m,a],tv1]], 
    [ :, 
      P, 
      ['Eval',Q,R]], 
    [ if, 
      ['decons-ht',[],S,T], 
      [ unify, 
        S, 
        [ :, 
          U, 
          ['Eval',V,W]], 
        [ if, 
          ['=alpha',V,Q], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ ['cons-atom',S,X], 
              Y]], 
          [ let, 
            [X,Y], 
            [ removeAlphaMagic, 
              T, 
              [ :, 
                a, 
                ['Eval',[m,a],tv1]]], 
            [ X, 
              ['cons-atom',S,Y]]]], 
        [ let, 
          [X,Y], 
          [ removeAlphaMagic, 
            T, 
            [ :, 
              a, 
              ['Eval',[m,a],tv1]]], 
          [ X, 
            ['cons-atom',S,Y]]]], 
      [ 
      [[],[]]], 
    [ 
    [[],[]]]]
</span> 
; 
; EVAL TEST
; took 0.489 secs. (489.09 milliseconds) 

!(assertEqual (removeAlphaMagic ((: b (Eval (m a) tv2)) (: c (Eval c tv3)) (: d (Eval (m a) tv4))) (: a (Eval (m a) tv1))) (((: b (Eval (m a) tv2)) (: d (Eval (m a) tv4))) ((: c (Eval c tv3)))))

<span class="ansi31">  [loonit_failureR 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( ( ( (: b 
              (Eval 
                (m a) tv2)) 
            (: c 
              (Eval c tv3)) 
            (: d 
              (Eval 
                (m a) tv4))) ())) 
      ( ( ( (: b 
              (Eval 
                (m a) tv2)) (: d (Eval (m a) tv4))) ((: c (Eval c tv3)))))]]
</span>equal_enough_for_test_renumbered_l(strict_equals_allow_vn,'[|]'('[|]'('[|]'('[|]'(:,'[|]'(b,'[|]'('[|]'('Eval','[|]'('[|]'(m,'[|]'(a,[])),'[|]'(tv2,[]))),[]))),'[|]'('[|]'(:,'[|]'(c,'[|]'('[|]'('Eval','[|]'(c,'[|]'(tv3,[]))),[]))),'[|]'('[|]'(:,'[|]'(d,'[|]'('[|]'('Eval','[|]'('[|]'(m,'[|]'(a,[])),'[|]'(tv4,[]))),[]))),[]))),'[|]'([],[])),[]),'[|]'('[|]'('[|]'('[|]'(:,'[|]'(b,'[|]'('[|]'('Eval','[|]'('[|]'(m,'[|]'(a,[])),'[|]'(tv2,[]))),[]))),'[|]'('[|]'(:,'[|]'(d,'[|]'('[|]'('Eval','[|]'('[|]'(m,'[|]'(a,[])),'[|]'(tv4,[]))),[]))),[])),'[|]'('[|]'('[|]'(:,'[|]'(c,'[|]'('[|]'('Eval','[|]'(c,'[|]'(tv3,[]))),[]))),[]),[])),[]))

Deterministic: <span class="ansi33">  (Error 
    (assertEqual 
      (removeAlphaMagic 
        ( (: b 
            (Eval 
              (m a) tv2)) 
          (: c 
            (Eval c tv3)) 
          (: d 
            (Eval 
              (m a) tv4))) 
        (: a 
          (Eval 
            (m a) tv1))) 
      ( ( (: b 
            (Eval 
              (m a) tv2)) (: d (Eval (m a) tv4))) ((: c (Eval c tv3))))) 
    ('
Got: ' 
      ( ( ( (: b 
              (Eval 
                (m a) tv2)) 
            (: c 
              (Eval c tv3)) 
            (: d 
              (Eval 
                (m a) tv4))) ())) '
EXP: ' 
      ( ( ( (: b 
              (Eval 
                (m a) tv2)) (: d (Eval (m a) tv4))) ((: c (Eval c tv3)))))))
</span><span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  [elem,_elem,_list], 
  [ 'if-decons-expr', _list,_head,_tail, 
    [ unify, _elem,_head, 
      [_head,_list], 
      [ let, 
        [_res,_ntail], 
        [elem,_tail,_elem], 
        [ _res, 
          ['cons-atom',_head,_ntail]]]], 
    [[],_list]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  [elem,_elem,_list], 
  [ if, 
    ['decons-ht',_list,_head,_tail], 
    [ unify, _elem,_head, 
      [_head,_list], 
      [ let, 
        [_res,_ntail], 
        [elem,_tail,_elem], 
        [ _res, 
          ['cons-atom',_head,_ntail]]]], 
    [[],_list]]]
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( elem, 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [elem,_elem,_list], 
  [ if, 
    ['decons-ht',_list,_head,_tail], 
    [ unify, _elem,_head, 
      [_head,_list], 
      [ let, 
        [_res,_ntail], 
        [elem,_tail,_elem], 
        [ _res, 
          ['cons-atom',_head,_ntail]]]], 
    [[],_list]])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  elem, 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa(elem,[2]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(elem,[2],'decons-ht',[3])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(elem,[2],unify,[4])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(elem,[2],'cons-atom',[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ prolog_if, 
    [ [ assign, 
        P, 
        [ fcall('decons-ht',[3]), 
          [_list,_head,_tail]]], 
      [ native(is_True), 
        P]], 
    [ [ assign, 
        Q, 
        [ ispeEnN, 
          R, 
          [ [ transpiler_apply, mc__1_1_,_head, 
              [_head,_list], 
              R, 
              [_list], 
              [_list], 
              [x(doeval,eager,[])], 
              [ 
              [[]], 
              [ 
              [[]]]], 
          S, 
          [ [ assign, 
              S, 
              list([_head,_list])]]]], 
      [ assign, 
        T, 
        [ ispeEnNC, 
          U, 
          [ [ transpiler_apply, mc__1_1_,_res, 
              [_res,V], 
              U, 
              [V], 
              [W], 
              [ x(noeval,eager,[list])], 
              [ [ [ assign, 
                    V, 
                    [ fcall('cons-atom',[2]), 
                      [_head,_ntail]]]]], 
              [ [ [ assign, 
                    W, 
                    list(['cons-atom',_head,_ntail])]]]]], 
          X, 
          [ [ assign, X,list([_res,V])]], 
          [ [ assign, 
              Y, 
              [ fcall(elem,[2]), 
                [_tail,_elem]]], 
            [ assign, 
              [_res,_ntail], 
              Y], 
            [ assign, 
              V, 
              [ fcall('cons-atom',[2]), 
                [_head,_ntail]]]]]], 
      [ assign, 
        Z, 
        [ fcall(unify,[4]), 
          [_elem,_head,Q,T]]], 
      [assign,A1,Z]], 
    [ [ assign, B1,list([[],_list])], 
      [assign,A1,B1]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 mc__1_2_elem(P,Q,R) :-  
    ((
     (  ((
         ('mc__1_3_decons-ht'(Q,S,T,U),is_True(U))*->
         (( V =  
              ispeEnN( W, 
                transpiler_apply( mc__1_1_, 
                  S, 
                  [S,Q], 
                  W, 
                  [Q], 
                  [Q], 
                  [x(doeval,eager,[])], 
                  [true], 
                  [true]), 
                X, 
                X=[S,Q])  ,
            Y =  
              ispeEnNC( Z, 
                transpiler_apply( mc__1_1_, 
                  A1, 
                  [A1,B1], 
                  Z, 
                  [B1], 
                  [C1], 
                  [ x(noeval,eager,[list])], 
                  ['mc__1_2_cons-atom'(S,D1,B1)], 
                  [C1=['cons-atom',S,D1]]), 
                E1, 
                E1=[A1,B1], 
                ( mc__1_2_elem(T,P,F1)  ,
                  [A1,D1]=F1 , 
                  'mc__1_2_cons-atom'(S,D1,B1))) , 
            mc__1_4_unify(P,S,V,Y,G1) , 
            R=G1))  )));
     (H1=[[],Q],R=H1)  ))
</span> 
<span class="ansi38-013099040">!(assertEqual (elem (: $a A) ((: a $A) (: b B))) ((: a A) ((: a A) (: b B))))

</span>
;<h3 id="ARGSET-CHAINING.UTILS.07">;; ARGSET-CHAINING.UTILS.07</h3>
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [  : , a , A ],
      [  : , b ,'B']], P,Q, 
    [ unify, 
      [:,_a,'A'], 
      P, 
      [ P, 
        [ [  : , a , A ],
          [  : , b ,'B']]], 
      [ let, 
        [R,S], 
        [ elem, 
          Q, 
          [:,_a,'A']], 
        [ R, 
          ['cons-atom',P,S]]]], 
    [ [], 
      [ [  : , a , A ],
        [  : , b ,'B']]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [  : , a , A ],
        [  : , b ,'B']], P,Q], 
    [ unify, 
      [:,_a,'A'], 
      P, 
      [ P, 
        [ [  : , a , A ],
          [  : , b ,'B']]], 
      [ let, 
        [R,S], 
        [ elem, 
          Q, 
          [:,_a,'A']], 
        [ R, 
          ['cons-atom',P,S]]]], 
    [ [], 
      [ [  : , a , A ],
        [  : , b ,'B']]]]]
</span> 
; 
; EVAL TEST
; took 0.041 secs. (41.46 milliseconds) 

!(assertEqual (elem (: $a A) ((: a $A) (: b B))) ((: a A) ((: a A) (: b B))))

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( ( (: a A) ((: a A) (: b B)))) 
      ( ( (: a A) ((: a A) (: b B))))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  [elemsealed,_elem,_list], 
  [ 'if-decons-expr', _list,_head,_tail, 
    [ let, 
      [quote,_shead], 
      [ sealed, 
        _head, 
        [quote,_head]], 
      [ unify, _elem,_head, 
        _shead, 
        [elem,_tail,_elem]]], 
    'Empty']]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  [elemsealed,_elem,_list], 
  [ if, 
    ['decons-ht',_list,_head,_tail], 
    [ let, 
      [quote,_shead], 
      [ sealed, 
        _head, 
        [quote,_head]], 
      [ unify, _elem,_head, 
        _shead, 
        [elem,_tail,_elem]]], 
    'Empty']]
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( elemsealed, 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [elemsealed,_elem,_list], 
  [ if, 
    ['decons-ht',_list,_head,_tail], 
    [ let, 
      [quote,_shead], 
      [ sealed, 
        _head, 
        [quote,_head]], 
      [ unify, _elem,_head, 
        _shead, 
        [elem,_tail,_elem]]], 
    'Empty'])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  elemsealed, 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa(elemsealed,[2]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(elemsealed,[2],'decons-ht',[3])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(elemsealed,[2],sealed,[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(elemsealed,[2],unify,[4])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(elemsealed,[2],elem,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ prolog_if, 
    [ [ assign, 
        P, 
        [ fcall('decons-ht',[3]), 
          [_list,_head,_tail]]], 
      [ native(is_True), 
        P]], 
    [ [ assign, 
        Q, 
        [quote,_head]], 
      [ assign, 
        R, 
        list([sealed,_head,Q])], 
      [ assign, 
        [quote,_shead], 
        R], 
      [ assign, 
        S, 
        [ispu,_shead]], 
      [ assign, 
        T, 
        [ ispeEnN, 
          U, 
          [ [ assign, 
              U, 
              [ fcall(elem,[2]), 
                [_tail,_elem]]]], 
          V, 
          [ [ assign, 
              V, 
              list([elem,_tail,_elem])]]]], 
      [ assign, 
        W, 
        [ fcall(unify,[4]), 
          [_elem,_head,S,T]]], 
      [assign,X,W]], 
    [ [ assign ,   X   ,'Empty']]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 mc__1_2_elemsealed(P,Q,R) :-  
    ((
     (  ((
         ('mc__1_3_decons-ht'(Q,S,T,U),is_True(U))*->
         (( V=[quote,S]  ,
            W=[sealed,S,V] , 
            [quote,X]=W , 
            Y=ispu(X) , 
            Z =  
              ispeEnN( A1, 
                mc__1_2_elem(T,P,A1), 
                B1, 
                B1=[elem,T,P]) , 
            mc__1_4_unify(P,S,Y,Z,C1) , 
            R=C1))  )));
     (R='Empty')  ))
</span> 
<span class="ansi38-013099040">!(assertAlphaEqual (elemsealed (: $a A) ((: a $A) (: b B))) (: a $A))

</span>
;<h3 id="ARGSET-CHAINING.UTILS.08">;; ARGSET-CHAINING.UTILS.08</h3>
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [  : , a , A ],
      [  : , b ,'B']], P,Q, 
    [ let, 
      [quote,R], 
      [ sealed, 
        P, 
        [quote,P]], 
      [ unify, 
        [:,_a,'A'], P,R, 
        [ elem, 
          Q, 
          [:,_a,'A']]]], 
    'Empty']]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [  : , a , A ],
        [  : , b ,'B']], P,Q], 
    [ let, 
      [quote,R], 
      [ sealed, 
        P, 
        [quote,P]], 
      [ unify, 
        [:,_a,'A'], P,R, 
        [ elem, 
          Q, 
          [:,_a,'A']]]], 
    'Empty']]
</span> 
; 
; EVAL TEST
; took 0.018 secs. (17.54 milliseconds) 

!(assertAlphaEqual (elemsealed (: $a A) ((: a $A) (: b B))) (: a $A))

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l alpha_equ 
      ( (: a $A)) 
      ( (: a $A))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  [elemexpr,_elem,_expr], 
  [ if, 
    [==,_elem,_expr], 
    'True', 
    [ 'if-decons-expr', _expr,_head,_tail, 
      [ if, 
        [==,_elem,_head], 
        'True', 
        [elemexpr,_elem,_tail]], 
      'False']]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  [elemexpr,_elem,_expr], 
  [ if, 
    [==,_elem,_expr], 
    'True', 
    [ if, 
      ['decons-ht',_expr,_head,_tail], 
      [ if, 
        [==,_elem,_head], 
        'True', 
        [elemexpr,_elem,_tail]], 
      'False']]]
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 transpiler_clause_store( elemexpr, 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [elemexpr,_elem,_expr], 
  [ if, 
    [==,_elem,_expr], 
    'True', 
    [ if, 
      ['decons-ht',_expr,_head,_tail], 
      [ if, 
        [==,_elem,_head], 
        'True', 
        [elemexpr,_elem,_tail]], 
      'False']])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  elemexpr, 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa(elemexpr,[2]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">transpiler_depends_on(elemexpr,[2],==,[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(elemexpr,[2],'decons-ht',[3])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ [ prolog_if, 
    [ [ assign, 
        P, 
        [ fcall(==,[2]), 
          [_elem,_expr]]], 
      [ native(is_True), 
        P]], 
    [ [ assign,  Q   ,'True']], 
    [ [ prolog_if, 
        [ [ assign, 
            R, 
            [ fcall('decons-ht',[3]), 
              [_expr,_head,_tail]]], 
          [ native(is_True), 
            R]], 
        [ [ prolog_if, 
            [ [ assign, 
                S, 
                [ fcall(==,[2]), 
                  [_elem,_head]]], 
              [ native(is_True), 
                S]], 
            [ [ assign,  T   ,'True']], 
            [ [ assign, 
                U, 
                [ fcall(elemexpr,[2]), 
                  [_elem,_tail]]], 
              [assign,T,U]]], 
          [assign,V,T]], 
        [ [ assign ,   V   ,'False']]], 
      [assign,Q,V]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">mc__1_2_elemexpr(P,Q,R) :-  
    ((
     ('mc__1_2_=='(P,Q,S),is_True(S)*->R='True');
     (  ((
         (  ((
             (  ((
                 ('mc__1_3_decons-ht'(Q,T,U,V),is_True(V))*->
                 (  ((
                     (  ((
                         (  ((
                             ('mc__1_2_=='(P,T,W),is_True(W))*->
                             (X='True')  )));
                         (mc__1_2_elemexpr(P,U,Y),X=Y)  ))),
                     (Z=X)  )))  )));
             (Z='False')  ))),
         (R=Z)  )))  ))
</span> 
<span class="ansi38-013099040">!(assertEqual (elemexpr (implicat a) (traverse (implicat a))) True)

</span>
;<h3 id="ARGSET-CHAINING.UTILS.09">;; ARGSET-CHAINING.UTILS.09</h3>
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    [ ==, 
      [implicat,a], 
      [ traverse, 
        [implicat,a]]], 
    'True', 
    [ 'if-decons-expr', 
      [ traverse, 
        [implicat,a]], P,Q, 
      [ if, 
        [ ==, 
          [implicat,a], 
          P], 
        'True', 
        [ elemexpr, 
          [implicat,a], 
          Q]], 
      'False']]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    [ ==, 
      [implicat,a], 
      [ traverse, 
        [implicat,a]]], 
    'True', 
    [ if, 
      [ 'decons-ht', 
        [ traverse, 
          [implicat,a]], P,Q], 
      [ if, 
        [ ==, 
          [implicat,a], 
          P], 
        'True', 
        [ elemexpr, 
          [implicat,a], 
          Q]], 
      'False']]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    [ ==, 
      [implicat,a], 
      [ [ implicat,   a    ]]], 
    'True', 
    [ 'if-decons-expr', 
      [ [ implicat,   a    ]], P,Q, 
      [ if, 
        [ ==, 
          [implicat,a], 
          P], 
        'True', 
        [ elemexpr, 
          [implicat,a], 
          Q]], 
      'False']]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    [ ==, 
      [implicat,a], 
      [ [ implicat,   a    ]]], 
    'True', 
    [ if, 
      [ 'decons-ht', 
        [ [ implicat,   a    ]], P,Q], 
      [ if, 
        [ ==, 
          [implicat,a], 
          P], 
        'True', 
        [ elemexpr, 
          [implicat,a], 
          Q]], 
      'False']]]
</span> 
; 
; EVAL TEST
; took 0.027 secs. (26.74 milliseconds) 

!(assertEqual (elemexpr (implicat a) (traverse (implicat a))) True)

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (True) 
      (True)]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">!(assertEqual (elemexpr (implicat b) (traverse (implicat a))) False)

</span>
;<h3 id="ARGSET-CHAINING.UTILS.10">;; ARGSET-CHAINING.UTILS.10</h3>
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    [ ==, 
      [implicat,b], 
      [ traverse, 
        [implicat,a]]], 
    'True', 
    [ 'if-decons-expr', 
      [ traverse, 
        [implicat,a]], P,Q, 
      [ if, 
        [ ==, 
          [implicat,b], 
          P], 
        'True', 
        [ elemexpr, 
          [implicat,b], 
          Q]], 
      'False']]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    [ ==, 
      [implicat,b], 
      [ traverse, 
        [implicat,a]]], 
    'True', 
    [ if, 
      [ 'decons-ht', 
        [ traverse, 
          [implicat,a]], P,Q], 
      [ if, 
        [ ==, 
          [implicat,b], 
          P], 
        'True', 
        [ elemexpr, 
          [implicat,b], 
          Q]], 
      'False']]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    [ ==, 
      [implicat,b], 
      [ [ implicat,   a    ]]], 
    'True', 
    [ 'if-decons-expr', 
      [ [ implicat,   a    ]], P,Q, 
      [ if, 
        [ ==, 
          [implicat,b], 
          P], 
        'True', 
        [ elemexpr, 
          [implicat,b], 
          Q]], 
      'False']]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    [ ==, 
      [implicat,b], 
      [ [ implicat,   a    ]]], 
    'True', 
    [ if, 
      [ 'decons-ht', 
        [ [ implicat,   a    ]], P,Q], 
      [ if, 
        [ ==, 
          [implicat,b], 
          P], 
        'True', 
        [ elemexpr, 
          [implicat,b], 
          Q]], 
      'False']]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    [ ==, 
      [implicat,b], 
      []], 
    'True', 
    [ 'if-decons-expr', 
      [], P,Q, 
      [ if, 
        [ ==, 
          [implicat,b], 
          P], 
        'True', 
        [ elemexpr, 
          [implicat,b], 
          Q]], 
      'False']]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    [ ==, 
      [implicat,b], 
      []], 
    'True', 
    [ if, 
      ['decons-ht',[],P,Q], 
      [ if, 
        [ ==, 
          [implicat,b], 
          P], 
        'True', 
        [ elemexpr, 
          [implicat,b], 
          Q]], 
      'False']]]
</span> 
; 
; EVAL TEST
; took 0.037 secs. (36.87 milliseconds) 

!(assertEqual (elemexpr (implicat b) (traverse (implicat a))) False)

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      (False) 
      (False)]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  [elemB,_elem,_list], 
  [ 'if-decons-expr', _list,_head,_tail, 
    [ unify, _elem,_head,'True', 
      [elemB,_elem,_tail]], 
    'False']]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  [elemB,_elem,_list], 
  [ if, 
    ['decons-ht',_list,_head,_tail], 
    [ unify, _elem,_head,'True', 
      [elemB,_elem,_tail]], 
    'False']]
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( elemB, 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [elemB,_elem,_list], 
  [ if, 
    ['decons-ht',_list,_head,_tail], 
    [ unify, _elem,_head,'True', 
      [elemB,_elem,_tail]], 
    'False'])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  elemB, 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa(elemB,[2]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(elemB,[2],'decons-ht',[3])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(elemB,[2],unify,[4])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ prolog_if, 
    [ [ assign, 
        P, 
        [ fcall('decons-ht',[3]), 
          [_list,_head,_tail]]], 
      [ native(is_True), 
        P]], 
    [ [ assign, 
        Q, 
        [ispu,'True']], 
      [ assign, 
        R, 
        [ ispeEnN, 
          S, 
          [ [ assign, 
              S, 
              [ fcall(elemB,[2]), 
                [_elem,_tail]]]], 
          T, 
          [ [ assign, 
              T, 
              list([elemB,_elem,_tail])]]]], 
      [ assign, 
        U, 
        [ fcall(unify,[4]), 
          [_elem,_head,Q,R]]], 
      [assign,V,U]], 
    [ [ assign ,   V   ,'False']]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 mc__1_2_elemB(P,Q,R) :-  
    ((
     (  ((
         ('mc__1_3_decons-ht'(Q,S,T,U),is_True(U))*->
         (( V=ispu('True')  ,
            W =  
              ispeEnN( X, 
                mc__1_2_elemB(P,T,X), 
                Y, 
                Y=[elemB,P,T]) , 
            mc__1_4_unify(P,S,V,W,Z) , 
            R=Z))  )));
     (R='False')  ))
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 transpiler_clause_store( overlap_ff, 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [ overlap_ff, 
    [_left,_intersection,_right], 
    _elem], 
  [ let, 
    [_res,_nright], 
    [removePrf,_right,_elem], 
    [ if, 
      [==,_res,[]], 
      [ ['cons-atom',_elem,_left], _intersection,_right], 
      [ _left, 
        [concat,_res,_intersection], 
        _nright]]])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  overlap_ff, 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa(overlap_ff,[2]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(overlap_ff,[2],removePrf,[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">transpiler_depends_on(overlap_ff,[2],==,[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">
 transpiler_depends_on(overlap_ff,[2],'cons-atom',[2,2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(overlap_ff,[2],'cons-atom',[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(overlap_ff,[2],concat,[2])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ [ assign, 
    P, 
    [ fcall(removePrf,[2]), 
      [_right,_elem]]], 
  [ assign, 
    [_res,_nright], 
    P], 
  [ prolog_if, 
    [ [ assign, 
        Q, 
        [ fcall(==,[2]), 
          [_res,[]]]], 
      [ native(is_True), 
        Q]], 
    [ [ assign, 
        R, 
        [ fcall('cons-atom',[2]), 
          [_elem,_left]]], 
      [ assign, 
        S, 
        list([R,_intersection,_right])], 
      [assign,T,S]], 
    [ [ assign, 
        U, 
        [ fcall(concat,[2]), 
          [_res,_intersection]]], 
      [ transpiler_apply, mc__1_2_,_left, 
        [_left,U,_nright], 
        V, 
        [U,_nright], 
        [W,_nright], 
        [ x(doeval,eager,[]), 
          x(noeval,eager,[])], 
        [ [ [ assign, 
              U, 
              [ fcall(concat,[2]), 
                [_res,_intersection]]]], 
          []], 
        [ [ [ assign, 
              W, 
              list([concat,_res,_intersection])]], 
          []]], 
      [assign,T,V]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 mc__1_2_overlap_ff([P,Q,R],S,T) :- 
  mc__1_2_removePrf(R,S,U) , 
  [V,W]=U , 
    ((
     (  ((
         ('mc__1_2_=='(V,[],X),is_True(X))*->
         (( 'mc__1_2_cons-atom'(S,P,Y)  ,
            Z=[Y,Q,R] , 
            T=Z))  )));
     (( mc__1_2_concat(V,Q,A1)  ,
        transpiler_apply( mc__1_2_, 
          P, 
          [P,A1,W], 
          B1, 
          [A1,W], 
          [C1,W], 
          [ x(doeval,eager,[]), 
            x(noeval,eager,[])], 
          [ mc__1_2_concat(V,Q,A1), 
            true], 
          [ C1=[concat,V,Q], 
            true]) , 
        T=B1))  ))
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 transpiler_clause_store( overlap, 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [overlap,_list1,_list2], 
  [ if, 
    [ ==, 
      ['get-metatype',_list1], 
      'Variable'], 
    [[],_list2,[]], 
    [ if, 
      [ ==, 
        ['get-metatype',_list2], 
        'Variable'], 
      [[],_list1,[]], 
      [ 'myfoldr-atom', 
        _list1, 
        [[],[],_list2], 
        overlap_ff]]])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  overlap, 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa(overlap,[2]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">transpiler_depends_on(overlap,[2],==,[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(overlap,[2],'get-metatype',[1])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(overlap,[2],'myfoldr-atom',[3])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ [ prolog_if, 
    [ [ assign, 
        P, 
        [ fcall('get-metatype',[1]), 
          [_list1]]], 
      [ assign, 
        Q, 
        [ fcall(==,[2]), 
          [P,'Variable']]], 
      [ native(is_True), 
        Q]], 
    [ [ assign, 
        R, 
        list([[],_list2,[]])], 
      [assign,S,R]], 
    [ [ prolog_if, 
        [ [ assign, 
            T, 
            [ fcall('get-metatype',[1]), 
              [_list2]]], 
          [ assign, 
            U, 
            [ fcall(==,[2]), 
              [T,'Variable']]], 
          [ native(is_True), 
            U]], 
        [ [ assign, 
            V, 
            list([[],_list1,[]])], 
          [assign,W,V]], 
        [ [ assign, 
            X, 
            list([[],[],_list2])], 
          [ assign, 
            Y, 
            [ fcall('myfoldr-atom',[3]), 
              [_list1,X,overlap_ff]]], 
          [assign,W,Y]]], 
      [assign,S,W]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 mc__1_2_overlap(P,Q,R) :-  
    ((
     (  ((
         (( 'mc__1_1_get-metatype'(P,S)  ,
            'mc__1_2_=='(S,'Variable',T) , 
            is_True(T)))*->
         (U=[[],Q,[]],R=U)  )));
     (  ((
         (  ((
             (  ((
                 (( 'mc__1_1_get-metatype'(Q,V)  ,
                    'mc__1_2_=='(V,'Variable',W) , 
                    is_True(W)))*->
                 (X=[[],P,[]],Y=X)  )));
             (( Z=[[],[],Q]  ,
                'mc__1_3_myfoldr-atom'(P,Z,overlap_ff,A1) , 
                Y=A1))  ))),
         (R=Y)  )))  ))
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( overlap2, 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [overlap2,_list1,_list2], 
  [ if, 
    [ or, 
      ['is-variable',_list1], 
      ['is-variable',_list2]], 
    [_list1,[],_list2], 
    [ 'myfoldr-atom', 
      _list1, 
      [[],[],_list2], 
      overlap_ff]])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  overlap2, 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa(overlap2,[2]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(overlap2,[2],'is-variable',[1])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(overlap2,[2],'myfoldr-atom',[3])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ prolog_if, 
    [ [ prolog_if, 
        [ [ assign, 
            P, 
            [ispu,_list1]], 
          [ assign, 
            Q, 
            [ fcall('is-variable',[1]), 
              [P]]], 
          [ native(is_True), 
            Q]], 
        [ [ assign,  R   ,'True']], 
        [ [ assign, 
            S, 
            [ispu,_list2]], 
          [ assign, 
            T, 
            [ fcall('is-variable',[1]), 
              [S]]], 
          [assign,R,T]]], 
      [ native(is_True), 
        R]], 
    [ [ transpiler_apply, mc__1_2_,_list1, 
        [_list1,[],_list2], 
        U, 
        [[],_list2], 
        [[],_list2], 
        [ x(noeval,eager,[]), 
          x(doeval,eager,[])], 
        [ 
        [[],[]], 
        [ 
        [[],[]]], 
      [assign,V,U]], 
    [ [ assign, 
        W, 
        list([[],[],_list2])], 
      [ assign, 
        X, 
        [ fcall('myfoldr-atom',[3]), 
          [_list1,W,overlap_ff]]], 
      [assign,V,X]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 mc__1_2_overlap2(P,Q,R) :-  
    ((
     (  ((
         (  ((
             (  ((
                 (  ((
                     (( S=ispu(P)  ,
                        'mc__1_1_is-variable'(S,T) , 
                        is_True(T)))*->
                     (U='True')  )));
                 (( V=ispu(Q)  ,
                    'mc__1_1_is-variable'(V,W) , 
                    U=W))  ))),
             (is_True(U))  )))*->
         (  ((
             (transpiler_apply( mc__1_2_, 
                P, 
                [P,[],Q], 
                X, 
                [[],Q], 
                [[],Q], 
                [ x(noeval,eager,[]), 
                  x(doeval,eager,[])], 
                [true,true], 
                [true,true])),
             (R=X)  )))  )));
     (( Y=[[],[],Q]  ,
        'mc__1_3_myfoldr-atom'(P,Y,overlap_ff,Z) , 
        R=Z))  ))
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( myunique, 
  [1], 
  0, 
  ['Any'], 
  'Any', 
  [x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  [myunique,_a], 
  [ if, 
    ['is-variable',_a], 
    _a, 
    ['unique=',_a]])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">transpiler_predicate_store(user,myunique,[1],todo,todo,[x(doeval,eager,[])],x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa(myunique,[1]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(myunique,[1],'is-variable',[1])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on(myunique,[1],'unique=',[1])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ prolog_if, 
    [ [ assign, 
        P, 
        [ispu,_a]], 
      [ assign, 
        Q, 
        [ fcall('is-variable',[1]), 
          [P]]], 
      [ native(is_True), 
        Q]], 
    [ [ assign,  R   ,  _a  ]], 
    [ [ assign, 
        S, 
        [ fcall('unique=',[1]), 
          [_a]]], 
      [assign,R,S]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">mc__1_1_myunique(P,Q) :-  
    ((
     (  ((
         (R=ispu(P),'mc__1_1_is-variable'(R,S),is_True(S))*->
         (Q=P)  )));
     ('mc__1_1_unique='(P,T),Q=T)  ))
</span> 
<span class="ansi38-013099040">!(assertEqual (myunique (a b a)) (a b))

</span>
;<h3 id="ARGSET-CHAINING.UTILS.11">;; ARGSET-CHAINING.UTILS.11</h3>
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [a,b,a], P,Q, 
    [ let, 
      R, 
      [ 'unique=', 
        ['remove=',Q,P]], 
      ['cons-atom',P,R]], 
    [a,b,a]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[a,b,a],P,Q], 
    [ let, 
      R, 
      [ 'unique=', 
        ['remove=',Q,P]], 
      ['cons-atom',P,R]], 
    [a,b,a]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [b,a], P,Q, 
    [ if, 
      [==,a,P], 
      ['remove=',Q,a], 
      [ let, 
        R, 
        ['remove=',Q,a], 
        ['cons-atom',P,R]]], 
    [b,a]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[b,a],P,Q], 
    [ if, 
      [==,a,P], 
      ['remove=',Q,a], 
      [ let, 
        R, 
        ['remove=',Q,a], 
        ['cons-atom',P,R]]], 
    [b,a]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [a], P,Q, 
    [ if, 
      [==,a,P], 
      ['remove=',Q,a], 
      [ let, 
        R, 
        ['remove=',Q,a], 
        ['cons-atom',P,R]]], 
    [a]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[a],P,Q], 
    [ if, 
      [==,a,P], 
      ['remove=',Q,a], 
      [ let, 
        R, 
        ['remove=',Q,a], 
        ['cons-atom',P,R]]], 
    [a]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [], P,Q, 
    [ if, 
      [==,a,P], 
      ['remove=',Q,a], 
      [ let, 
        R, 
        ['remove=',Q,a], 
        ['cons-atom',P,R]]], 
    []]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[],P,Q], 
    [ if, 
      [==,a,P], 
      ['remove=',Q,a], 
      [ let, 
        R, 
        ['remove=',Q,a], 
        ['cons-atom',P,R]]], 
    []]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [b], P,Q, 
    [ let, 
      R, 
      [ 'unique=', 
        ['remove=',Q,P]], 
      ['cons-atom',P,R]], 
    [b]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[b],P,Q], 
    [ let, 
      R, 
      [ 'unique=', 
        ['remove=',Q,P]], 
      ['cons-atom',P,R]], 
    [b]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [], P,Q, 
    [ if, 
      [==,b,P], 
      ['remove=',Q,b], 
      [ let, 
        R, 
        ['remove=',Q,b], 
        ['cons-atom',P,R]]], 
    []]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[],P,Q], 
    [ if, 
      [==,b,P], 
      ['remove=',Q,b], 
      [ let, 
        R, 
        ['remove=',Q,b], 
        ['cons-atom',P,R]]], 
    []]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [], P,Q, 
    [ let, 
      R, 
      [ 'unique=', 
        ['remove=',Q,P]], 
      ['cons-atom',P,R]], 
    []]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[],P,Q], 
    [ let, 
      R, 
      [ 'unique=', 
        ['remove=',Q,P]], 
      ['cons-atom',P,R]], 
    []]]
</span> 
; 
; EVAL TEST
; took 0.055 secs. (55.35 milliseconds) 

!(assertEqual (myunique (a b a)) (a b))

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( (a b)) 
      ( (a b))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi35"></span><span class="ansi35"></span><span class="ansi35">
 transpiler_clause_store( 'unique-union-atom', 
  [2], 
  0, 
  ['Any','Any'], 
  'Any', 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]), 
  ['unique-union-atom',_a,_b], 
  [ let, 
    _res, 
    [concat,_a,_b], 
    [myunique,_res]])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi31"></span><span class="ansi31 ansi40"></span><span class="ansi4 ansi31 ansi40">
 transpiler_predicate_store( user, 
  'unique-union-atom', 
  [2], todo,todo, 
  [ x(doeval,eager,[]), 
    x(doeval,eager,[])], 
  x(doeval,eager,[]))
</span><span class="ansi31 ansi40"></span><span class="ansi31"></span> 
<span class="ansi92"></span><span class="ansi92"></span><span class="ansi92">recompile_from_depends</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">fa('unique-union-atom',[2]) =  
  []
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('unique-union-atom',[2],concat,[2])
</span> 
<span class="ansi94"></span><span class="ansi94"></span><span class="ansi94">compiler_assertz</span>: <span class="ansi36"></span><span class="ansi36"></span><span class="ansi36">transpiler_depends_on('unique-union-atom',[2],myunique,[1])
</span> 
<span class="ansi2"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91"></span><span class="ansi2 ansi91">pre_ast</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ [ assign, 
    P, 
    [ fcall(concat,[2]), 
      [_a,_b]]], 
  [assign,_res,P], 
  [ assign, 
    Q, 
    [ fcall(myunique,[1]), 
      [_res]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi37"></span><span class="ansi1 ansi37 ansi40"></span><span class="ansi1 ansi37 ansi40">prolog_code</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">'mc__1_2_unique-union-atom'(P,Q,R) :- 
  mc__1_2_concat(P,Q,S) , 
  T=S , 
  mc__1_1_myunique(T,R)
</span> 
<span class="ansi38-013099040">!(assertEqual (unique-union-atom ((: $a A) (: b B)) ((: $a A))) ((: $a A) (: b B)))

</span>
;<h3 id="ARGSET-CHAINING.UTILS.12">;; ARGSET-CHAINING.UTILS.12</h3>
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [  : ,_a ,'A'],
      [  : , b ,'B']], P,Q, 
    [ let, 
      R, 
      [ 'munion-atom', 
        Q, 
        [ [  : ,_a ,'A']]], 
      ['cons-atom',P,R]], 
    [ [  : ,_a ,'A']]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [  : ,_a ,'A'],
        [  : , b ,'B']], P,Q], 
    [ let, 
      R, 
      [ 'munion-atom', 
        Q, 
        [ [  : ,_a ,'A']]], 
      ['cons-atom',P,R]], 
    [ [  : ,_a ,'A']]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [  : , b ,'B']], P,Q, 
    [ let, 
      R, 
      [ 'munion-atom', 
        Q, 
        [ [  : ,_a ,'A']]], 
      ['cons-atom',P,R]], 
    [ [  : ,_a ,'A']]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [  : , b ,'B']], P,Q], 
    [ let, 
      R, 
      [ 'munion-atom', 
        Q, 
        [ [  : ,_a ,'A']]], 
      ['cons-atom',P,R]], 
    [ [  : ,_a ,'A']]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [], P,Q, 
    [ let, 
      R, 
      [ 'munion-atom', 
        Q, 
        [ [  : ,_a ,'A']]], 
      ['cons-atom',P,R]], 
    [ [  : ,_a ,'A']]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[],P,Q], 
    [ let, 
      R, 
      [ 'munion-atom', 
        Q, 
        [ [  : ,_a ,'A']]], 
      ['cons-atom',P,R]], 
    [ [  : ,_a ,'A']]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [  : ,_a ,'A'],
      [  : , b ,'B'],
      [  : ,_a ,'A']], P,Q, 
    [ let, 
      R, 
      [ 'unique=', 
        ['remove=',Q,P]], 
      ['cons-atom',P,R]], 
    [ [  : ,_a ,'A'],
      [  : , b ,'B'],
      [  : ,_a ,'A']]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [  : ,_a ,'A'],
        [  : , b ,'B'],
        [  : ,_a ,'A']], P,Q], 
    [ let, 
      R, 
      [ 'unique=', 
        ['remove=',Q,P]], 
      ['cons-atom',P,R]], 
    [ [  : ,_a ,'A'],
      [  : , b ,'B'],
      [  : ,_a ,'A']]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [  : , b ,'B'],
      [  : ,_a ,'A']], P,Q, 
    [ if, 
      [ ==, 
        [:,_a,'A'], 
        P], 
      [ 'remove=', 
        Q, 
        [:,_a,'A']], 
      [ let, 
        R, 
        [ 'remove=', 
          Q, 
          [:,_a,'A']], 
        ['cons-atom',P,R]]], 
    [ [  : , b ,'B'],
      [  : ,_a ,'A']]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [  : , b ,'B'],
        [  : ,_a ,'A']], P,Q], 
    [ if, 
      [ ==, 
        [:,_a,'A'], 
        P], 
      [ 'remove=', 
        Q, 
        [:,_a,'A']], 
      [ let, 
        R, 
        [ 'remove=', 
          Q, 
          [:,_a,'A']], 
        ['cons-atom',P,R]]], 
    [ [  : , b ,'B'],
      [  : ,_a ,'A']]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [  : ,_a ,'A']], P,Q, 
    [ if, 
      [ ==, 
        [:,_a,'A'], 
        P], 
      [ 'remove=', 
        Q, 
        [:,_a,'A']], 
      [ let, 
        R, 
        [ 'remove=', 
          Q, 
          [:,_a,'A']], 
        ['cons-atom',P,R]]], 
    [ [  : ,_a ,'A']]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [  : ,_a ,'A']], P,Q], 
    [ if, 
      [ ==, 
        [:,_a,'A'], 
        P], 
      [ 'remove=', 
        Q, 
        [:,_a,'A']], 
      [ let, 
        R, 
        [ 'remove=', 
          Q, 
          [:,_a,'A']], 
        ['cons-atom',P,R]]], 
    [ [  : ,_a ,'A']]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [], P,Q, 
    [ if, 
      [ ==, 
        [:,_a,'A'], 
        P], 
      [ 'remove=', 
        Q, 
        [:,_a,'A']], 
      [ let, 
        R, 
        [ 'remove=', 
          Q, 
          [:,_a,'A']], 
        ['cons-atom',P,R]]], 
    []]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[],P,Q], 
    [ if, 
      [ ==, 
        [:,_a,'A'], 
        P], 
      [ 'remove=', 
        Q, 
        [:,_a,'A']], 
      [ let, 
        R, 
        [ 'remove=', 
          Q, 
          [:,_a,'A']], 
        ['cons-atom',P,R]]], 
    []]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [  : , b ,'B']], P,Q, 
    [ let, 
      R, 
      [ 'unique=', 
        ['remove=',Q,P]], 
      ['cons-atom',P,R]], 
    [ [  : , b ,'B']]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [  : , b ,'B']], P,Q], 
    [ let, 
      R, 
      [ 'unique=', 
        ['remove=',Q,P]], 
      ['cons-atom',P,R]], 
    [ [  : , b ,'B']]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [], P,Q, 
    [ if, 
      [==,[:,b,'B'],P], 
      ['remove=',Q,[:,b,'B']], 
      [ let, 
        R, 
        ['remove=',Q,[:,b,'B']], 
        ['cons-atom',P,R]]], 
    []]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[],P,Q], 
    [ if, 
      [==,[:,b,'B'],P], 
      ['remove=',Q,[:,b,'B']], 
      [ let, 
        R, 
        ['remove=',Q,[:,b,'B']], 
        ['cons-atom',P,R]]], 
    []]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [], P,Q, 
    [ let, 
      R, 
      [ 'unique=', 
        ['remove=',Q,P]], 
      ['cons-atom',P,R]], 
    []]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[],P,Q], 
    [ let, 
      R, 
      [ 'unique=', 
        ['remove=',Q,P]], 
      ['cons-atom',P,R]], 
    []]]
</span> 
; 
; EVAL TEST
; took 0.147 secs. (147.41 milliseconds) 

!(assertEqual (unique-union-atom ((: $a A) (: b B)) ((: $a A))) ((: $a A) (: b B)))

<span class="ansi36">  [loonit_success 
    [equal_enough_for_test_renumbered_l strict_equals_allow_vn 
      ( ( (: $a A) (: b B))) 
      ( ( (: $a A) (: b B)))]]
</span>
Deterministic: <span class="ansi33">()
</span><span class="ansi38-013099040">!(let* (($left ((: a2 (A 2)) (: a1 (A 1)))) ($right ((: $a1 (A $v1)) (: $a2 (A $v2)))) (($19667260 $out ()) (overlap2 $left $right))) ($left $right $out))

</span><span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [ :, 
        a2, 
        ['A',2]], 
      [ :, 
        a1, 
        ['A',1]]], P,Q, 
    [ overlap_ff, 
      [ 'myfoldr-atom', 
        Q, 
        [ [], 
          [], 
          [ [ :, 
              _a1, 
              ['A',_v1]], 
            [ :, 
              _a2, 
              ['A',_v2]]]], 
        overlap_ff], 
      P], 
    [ [], 
      [], 
      [ [ :, 
          _a1, 
          ['A',_v1]], 
        [ :, 
          _a2, 
          ['A',_v2]]]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [ :, 
          a2, 
          ['A',2]], 
        [ :, 
          a1, 
          ['A',1]]], P,Q], 
    [ overlap_ff, 
      [ 'myfoldr-atom', 
        Q, 
        [ [], 
          [], 
          [ [ :, 
              _a1, 
              ['A',_v1]], 
            [ :, 
              _a2, 
              ['A',_v2]]]], 
        overlap_ff], 
      P], 
    [ [], 
      [], 
      [ [ :, 
          _a1, 
          ['A',_v1]], 
        [ :, 
          _a2, 
          ['A',_v2]]]]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [ :, 
        a1, 
        ['A',1]]], P,Q, 
    [ overlap_ff, 
      [ 'myfoldr-atom', 
        Q, 
        [ [], 
          [], 
          [ [ :, 
              _a1, 
              ['A',_v1]], 
            [ :, 
              _a2, 
              ['A',_v2]]]], 
        overlap_ff], 
      P], 
    [ [], 
      [], 
      [ [ :, 
          _a1, 
          ['A',_v1]], 
        [ :, 
          _a2, 
          ['A',_v2]]]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [ :, 
          a1, 
          ['A',1]]], P,Q], 
    [ overlap_ff, 
      [ 'myfoldr-atom', 
        Q, 
        [ [], 
          [], 
          [ [ :, 
              _a1, 
              ['A',_v1]], 
            [ :, 
              _a2, 
              ['A',_v2]]]], 
        overlap_ff], 
      P], 
    [ [], 
      [], 
      [ [ :, 
          _a1, 
          ['A',_v1]], 
        [ :, 
          _a2, 
          ['A',_v2]]]]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [], P,Q, 
    [ overlap_ff, 
      [ 'myfoldr-atom', 
        Q, 
        [ [], 
          [], 
          [ [ :, 
              _a1, 
              ['A',_v1]], 
            [ :, 
              _a2, 
              ['A',_v2]]]], 
        overlap_ff], 
      P], 
    [ [], 
      [], 
      [ [ :, 
          _a1, 
          ['A',_v1]], 
        [ :, 
          _a2, 
          ['A',_v2]]]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[],P,Q], 
    [ overlap_ff, 
      [ 'myfoldr-atom', 
        Q, 
        [ [], 
          [], 
          [ [ :, 
              _a1, 
              ['A',_v1]], 
            [ :, 
              _a2, 
              ['A',_v2]]]], 
        overlap_ff], 
      P], 
    [ [], 
      [], 
      [ [ :, 
          _a1, 
          ['A',_v1]], 
        [ :, 
          _a2, 
          ['A',_v2]]]]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [ :, 
        _a1, 
        ['A',_v1]], 
      [ :, 
        _a2, 
        ['A',_v2]]], P,Q, 
    [ if, 
      [ '=unify', 
        [ :, 
          a1, 
          ['A',1]], 
        P], 
      [ let, 
        [:,R,S], 
        P, 
        [ if, 
          [ 'lazy-or', 
            ['is-closed',S], 
            [ '=alpha', 
              [ :, 
                a1, 
                ['A',1]], 
              P]], 
          'Empty', 
          [ let, 
            [T,U], 
            [ removePrf, 
              Q, 
              [ :, 
                a1, 
                ['A',1]]], 
            [ T, 
              ['cons-atom',P,U]]]]], 
      'Empty'], 
    'Empty']]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [ :, 
          _a1, 
          ['A',_v1]], 
        [ :, 
          _a2, 
          ['A',_v2]]], P,Q], 
    [ if, 
      [ '=unify', 
        [ :, 
          a1, 
          ['A',1]], 
        P], 
      [ let, 
        [:,R,S], 
        P, 
        [ if, 
          [ 'lazy-or', 
            ['is-closed',S], 
            [ '=alpha', 
              [ :, 
                a1, 
                ['A',1]], 
              P]], 
          'Empty', 
          [ let, 
            [T,U], 
            [ removePrf, 
              Q, 
              [ :, 
                a1, 
                ['A',1]]], 
            [ T, 
              ['cons-atom',P,U]]]]], 
      'Empty'], 
    'Empty']]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [ :, 
        _a1, 
        ['A',_v1]], 
      [ :, 
        _a2, 
        ['A',_v2]]], P,Q, 
    [ unify, 
      [ :, 
        a1, 
        ['A',1]], 
      P, 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a1, 
            ['A',1]]], 
        [ ['cons-atom',P,R], 
          S]], 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a1, 
            ['A',1]]], 
        [ R, 
          ['cons-atom',P,S]]]], 
    [ [], 
      [ [ :, 
          _a1, 
          ['A',_v1]], 
        [ :, 
          _a2, 
          ['A',_v2]]]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [ :, 
          _a1, 
          ['A',_v1]], 
        [ :, 
          _a2, 
          ['A',_v2]]], P,Q], 
    [ unify, 
      [ :, 
        a1, 
        ['A',1]], 
      P, 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a1, 
            ['A',1]]], 
        [ ['cons-atom',P,R], 
          S]], 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a1, 
            ['A',1]]], 
        [ R, 
          ['cons-atom',P,S]]]], 
    [ [], 
      [ [ :, 
          _a1, 
          ['A',_v1]], 
        [ :, 
          _a2, 
          ['A',_v2]]]]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [ :, 
        _a2, 
        ['A',_v2]]], P,Q, 
    [ if, 
      [ '=unify', 
        [ :, 
          a1, 
          ['A',1]], 
        P], 
      [ let, 
        [:,R,S], 
        P, 
        [ if, 
          [ 'lazy-or', 
            ['is-closed',S], 
            [ '=alpha', 
              [ :, 
                a1, 
                ['A',1]], 
              P]], 
          'Empty', 
          [ let, 
            [T,U], 
            [ removePrf, 
              Q, 
              [ :, 
                a1, 
                ['A',1]]], 
            [ T, 
              ['cons-atom',P,U]]]]], 
      'Empty'], 
    'Empty']]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [ :, 
          _a2, 
          ['A',_v2]]], P,Q], 
    [ if, 
      [ '=unify', 
        [ :, 
          a1, 
          ['A',1]], 
        P], 
      [ let, 
        [:,R,S], 
        P, 
        [ if, 
          [ 'lazy-or', 
            ['is-closed',S], 
            [ '=alpha', 
              [ :, 
                a1, 
                ['A',1]], 
              P]], 
          'Empty', 
          [ let, 
            [T,U], 
            [ removePrf, 
              Q, 
              [ :, 
                a1, 
                ['A',1]]], 
            [ T, 
              ['cons-atom',P,U]]]]], 
      'Empty'], 
    'Empty']]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [ :, 
        _a2, 
        ['A',_v2]]], P,Q, 
    [ unify, 
      [ :, 
        a1, 
        ['A',1]], 
      P, 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a1, 
            ['A',1]]], 
        [ ['cons-atom',P,R], 
          S]], 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a1, 
            ['A',1]]], 
        [ R, 
          ['cons-atom',P,S]]]], 
    [ [], 
      [ [ :, 
          _a2, 
          ['A',_v2]]]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [ :, 
          _a2, 
          ['A',_v2]]], P,Q], 
    [ unify, 
      [ :, 
        a1, 
        ['A',1]], 
      P, 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a1, 
            ['A',1]]], 
        [ ['cons-atom',P,R], 
          S]], 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a1, 
            ['A',1]]], 
        [ R, 
          ['cons-atom',P,S]]]], 
    [ [], 
      [ [ :, 
          _a2, 
          ['A',_v2]]]]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [], P,Q, 
    [ if, 
      [ '=unify', 
        [ :, 
          a1, 
          ['A',1]], 
        P], 
      [ let, 
        [:,R,S], 
        P, 
        [ if, 
          [ 'lazy-or', 
            ['is-closed',S], 
            [ '=alpha', 
              [ :, 
                a1, 
                ['A',1]], 
              P]], 
          'Empty', 
          [ let, 
            [T,U], 
            [ removePrf, 
              Q, 
              [ :, 
                a1, 
                ['A',1]]], 
            [ T, 
              ['cons-atom',P,U]]]]], 
      'Empty'], 
    'Empty']]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[],P,Q], 
    [ if, 
      [ '=unify', 
        [ :, 
          a1, 
          ['A',1]], 
        P], 
      [ let, 
        [:,R,S], 
        P, 
        [ if, 
          [ 'lazy-or', 
            ['is-closed',S], 
            [ '=alpha', 
              [ :, 
                a1, 
                ['A',1]], 
              P]], 
          'Empty', 
          [ let, 
            [T,U], 
            [ removePrf, 
              Q, 
              [ :, 
                a1, 
                ['A',1]]], 
            [ T, 
              ['cons-atom',P,U]]]]], 
      'Empty'], 
    'Empty']]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [], P,Q, 
    [ unify, 
      [ :, 
        a1, 
        ['A',1]], 
      P, 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a1, 
            ['A',1]]], 
        [ ['cons-atom',P,R], 
          S]], 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a1, 
            ['A',1]]], 
        [ R, 
          ['cons-atom',P,S]]]], 
    [ 
    [[],[]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[],P,Q], 
    [ unify, 
      [ :, 
        a1, 
        ['A',1]], 
      P, 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a1, 
            ['A',1]]], 
        [ ['cons-atom',P,R], 
          S]], 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a1, 
            ['A',1]]], 
        [ R, 
          ['cons-atom',P,S]]]], 
    [ 
    [[],[]]]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [ :, 
        a1, 
        ['A',1]], 
      [ :, 
        a1, 
        ['A',1]]], P,Q, 
    [ let, 
      R, 
      ['munion-atom',Q,[]], 
      ['cons-atom',P,R]], 
    []]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [ :, 
          a1, 
          ['A',1]], 
        [ :, 
          a1, 
          ['A',1]]], P,Q], 
    [ let, 
      R, 
      ['munion-atom',Q,[]], 
      ['cons-atom',P,R]], 
    []]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [ [ :, 
        a1, 
        ['A',1]]], P,Q, 
    [ let, 
      R, 
      ['munion-atom',Q,[]], 
      ['cons-atom',P,R]], 
    []]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    [ 'decons-ht', 
      [ [ :, 
          a1, 
          ['A',1]]], P,Q], 
    [ let, 
      R, 
      ['munion-atom',Q,[]], 
      ['cons-atom',P,R]], 
    []]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [], P,Q, 
    [ let, 
      R, 
      ['munion-atom',Q,[]], 
      ['cons-atom',P,R]], 
    []]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[],P,Q], 
    [ let, 
      R, 
      ['munion-atom',Q,[]], 
      ['cons-atom',P,R]], 
    []]]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [], P,Q, 
    [ if, 
      [ '=unify', 
        [ :, 
          a2, 
          ['A',2]], 
        P], 
      [ let, 
        [:,R,S], 
        P, 
        [ if, 
          [ 'lazy-or', 
            ['is-closed',S], 
            [ '=alpha', 
              [ :, 
                a2, 
                ['A',2]], 
              P]], 
          'Empty', 
          [ let, 
            [T,U], 
            [ removePrf, 
              Q, 
              [ :, 
                a2, 
                ['A',2]]], 
            [ T, 
              ['cons-atom',P,U]]]]], 
      'Empty'], 
    'Empty']]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[],P,Q], 
    [ if, 
      [ '=unify', 
        [ :, 
          a2, 
          ['A',2]], 
        P], 
      [ let, 
        [:,R,S], 
        P, 
        [ if, 
          [ 'lazy-or', 
            ['is-closed',S], 
            [ '=alpha', 
              [ :, 
                a2, 
                ['A',2]], 
              P]], 
          'Empty', 
          [ let, 
            [T,U], 
            [ removePrf, 
              Q, 
              [ :, 
                a2, 
                ['A',2]]], 
            [ T, 
              ['cons-atom',P,U]]]]], 
      'Empty'], 
    'Empty']]
</span> 
<span class="ansi2"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32"></span><span class="ansi2 ansi32">metta_macro_in</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ 'if-decons-expr', 
    [], P,Q, 
    [ unify, 
      [ :, 
        a2, 
        ['A',2]], 
      P, 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a2, 
            ['A',2]]], 
        [ ['cons-atom',P,R], 
          S]], 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a2, 
            ['A',2]]], 
        [ R, 
          ['cons-atom',P,S]]]], 
    [ 
    [[],[]]]]
</span> 
<span class="ansi1"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91"></span><span class="ansi1 ansi91">metta_macro_out</span>: <span class="ansi33"></span><span class="ansi33"></span><span class="ansi33">
 [ =, 
  eval10, 
  [ if, 
    ['decons-ht',[],P,Q], 
    [ unify, 
      [ :, 
        a2, 
        ['A',2]], 
      P, 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a2, 
            ['A',2]]], 
        [ ['cons-atom',P,R], 
          S]], 
      [ let, 
        [R,S], 
        [ removePrf, 
          Q, 
          [ :, 
            a2, 
            ['A',2]]], 
        [ R, 
          ['cons-atom',P,S]]]], 
    [ 
    [[],[]]]]
</span> 

Deterministic: <span class="ansi33">  ( ( (: a2 
        (A 2)) (: a1 (A 1))) 
    ( (: a1 
        (A 1)) (: a1 (A 1))) 
    ( (: a1 
        (A 1)) (: a1 (A 1))))
</span>;             [ = /home/deb12user/metta-wam/tests/quick_quality/argset-chaining/utils.metta 0 ]
<span class="ansi1">LoonIt Report
</span>------------
<span class="ansi32">Successes: 8
</span><span class="ansi31">Failures: 4
</span><br/> <a href="#" onclick="window.history.back(); return false;">Return to summaries</a><br/>
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">'trace-on-test'==false
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">load==show
</span> 
<span class="ansi1"></span><span class="ansi1 ansi97"></span><span class="ansi1 ansi97 ansi40"></span><span class="ansi1 ansi97 ansi40">cmdargs</span>: <span class="ansi1"></span><span class="ansi1"></span><span class="ansi1"></span><span class="ansi1">test==true
</span> 
[()]
[()]
[(Error (assertEqual (unique= ((: $a A) (: $a A) (: $b A))) ((: $a A) (: $b A))) ('
Got: ' (((: $b A))) '
EXP: ' (((: $a A) (: $b A)))))]
[(Error (assertEqualToResult (removePrf ((: $a (A $v)) (: $a2 (A $v2))) (: a (A 1))) ((((: a (A 1))) ((: $7806076 (A $7806094)))) (() ((: $7806076 (A $7806094)) (: $7806166 (A $7806184)))) (((: a (A 1))) ((: $7806166 (A $7806184)))) (((: a (A 1)) (: a (A 1))) ()))) ('
Got: ' ((((: a (A 1)) (: a (A 1))) ())) '
EXP: ' ((((: a (A 1))) ((: $7806076 (A $7806094)))) (() ((: $7806076 (A $7806094)) (: $7806166 (A $7806184)))) (((: a (A 1))) ((: $7806166 (A $7806184)))) (((: a (A 1)) (: a (A 1))) ()))))]
[(Error (assertEqualToResult (removeAlphaMagic ((: b (Eval (m a) tv2)) (: c (Eval c tv3)) (: d (Eval (m a) tv4))) (: a (Eval (m a) tv1))) (())) ('
Got: ' ((((: b (Eval (m a) tv2)) (: c (Eval c tv3)) (: d (Eval (m a) tv4))) ())) '
EXP: ' (())))]
[(Error (assertEqual (removeAlphaMagic ((: b (Eval (m a) tv2)) (: c (Eval c tv3)) (: d (Eval (m a) tv4))) (: a (Eval (m a) tv1))) (((: b (Eval (m a) tv2)) (: d (Eval (m a) tv4))) ((: c (Eval c tv3))))) ('
Got: ' ((((: b (Eval (m a) tv2)) (: c (Eval c tv3)) (: d (Eval (m a) tv4))) ())) '
EXP: ' ((((: b (Eval (m a) tv2)) (: d (Eval (m a) tv4))) ((: c (Eval c tv3)))))))]
[()]
[()]
[()]
[()]
[()]
[()]
[(((: a2 (A 2)) (: a1 (A 1))) ((: a1 (A 1)) (: a1 (A 1))) ((: a1 (A 1)) (: a1 (A 1))))]

Script done on 2025-04-25 19:00:28-07:00 [COMMAND_EXIT_CODE="1"]

</pre>
</body>

</html>
