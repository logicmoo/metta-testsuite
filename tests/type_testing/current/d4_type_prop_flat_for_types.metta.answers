((-> $t#57 $t#57 Atom))
(%Undefined%)
((-> Atom Atom Atom))
(src= (@doc remove-atom (@desc "Removes atom from the input Atomspace") (@params ((@param "Reference to the space from which the Atom needs to be removed") (@param "Atom to be removed"))) (@return "Unit atom")))
(src= (@doc assertEqualToResult (@desc "Same as assertEqual but it doesn't evaluate second argument. Second argument is considered as a set of values of the first argument's evaluation") (@params ((@param "First expression (it will be evaluated)") (@param "Second expression (it won't be evaluated)"))) (@return "Unit atom if both expressions after evaluation of the first argument are equal, error - otherwise")))
(src= (= (and True True) True))
(src= (= (or False False) False))
(src= (= (or True True) True))
(src= (= (and False False) False))
(src= (= (and False True) False))
(src= (= (and True False) False))
(src= (= (or False True) True))
(src= (= (or True False) True))
(src= (: map-atom (-> Expression Variable Atom Expression)))
(src= (: unquote (-> %Undefined% %Undefined%)))
(src= (= (help! $atom#3372) (case (get-doc $atom#3372) (((@doc-formal (@item $item#3373) (@kind function) (@type $type#3374) (@desc $descr#3375) (@params $params#3376) (@return (@type $ret-type#3377) (@desc $ret-desc#3378))) (let () (println! (format-args "Function {}: {} {}" ($item#3373 $type#3374 $descr#3375))) (let () (println! (format-args "Parameters:" ())) (let () (for-each-in-atom $params#3376 help-param!) (let () (println! (format-args "Return: (type {}) {}" ($ret-type#3377 $ret-desc#3378))) ()))))) ((@doc-formal (@item $item#3373) (@kind function) (@type $type#3374) (@desc $descr#3375)) (let () (println! (format-args "Function {} (type {}) {}" ($item#3373 $type#3374 $descr#3375))) ())) ((@doc-formal (@item $item#3373) (@kind atom) (@type $type#3374) (@desc $descr#3375)) (let () (println! (format-args "Atom {}: {} {}" ($item#3373 $type#3374 $descr#3375))) ())) ($other#3379 (Error $other#3379 "Cannot match @doc-formal structure"))))))
(src= (@doc if-equal (@desc "Checks if first two arguments are equal and evaluates third argument if equal, fourth argument - otherwise") (@params ((@param "First argument") (@param "Second argument") (@param "Atom to be evaluated if arguments are equal") (@param "Atom to be evaluated if arguments are not equal"))) (@return "Evaluated third or fourth argument")))
(src= (@doc @param (@desc "Used for documentation purposes. Description of function parameter starts with @param as a part of @params which is a part of @doc") (@params ((@param "String containing parameter description"))) (@return "Parameter description")))
(src= (= (nop) ()))
(src= (: get-doc-params (-> Expression Atom Expression (Expression Atom))))
(src= (@doc help-param! (@desc "Function used by function help! to output parameters using println!") (@params ((@param "Parameters list"))) (@return "Unit atom")))
(src= (@doc case (@desc "Subsequently tests multiple pattern-matching conditions (second argument) for the given value (first argument)") (@params ((@param "Atom (it will be evaluated)") (@param "Tuple of pairs mapping condition patterns to results"))) (@return "Result of evaluating of Atom bound to met condition")))
(src= (@doc * (@desc "Multiplies two numbers") (@params ((@param "Multiplier") (@param "Multiplicand"))) (@return "Product")))
(src= (= (get-doc-single-atom $atom#3369) (let $top-space#3370 (mod-space! top) (let $type#3371 (get-type-space $top-space#3370 $atom#3369) (if (is-function $type#3371) (get-doc-function $atom#3369 $type#3371) (get-doc-atom $atom#3369))))))
(src= (@doc <= (@desc "Less than or equal. Checks if first argument is less than or equal to second one") (@params ((@param "First number") (@param "Second number"))) (@return "True if first argument is less than or equal to second, False - otherwise")))
(src= (= (undefined-doc-function-type $params#3366) (if (== () $params#3366) (%Undefined%) (let $params-tail#3367 (cdr-atom $params#3366) (let $tail#3368 (undefined-doc-function-type $params-tail#3367) (cons-atom %Undefined% $tail#3368))))))
(src= (@doc undefined-doc-function-type (@desc "Function used by get-doc-single-atom in case of absence of function's type notation") (@params ((@param "List of parameters for the function we want to get documentation for"))) (@return "List of %Undefined% number of which depends on input list size. So for two parameters function will return (%Undefined% %Undefined% %Undefined%)")))
(src= (@doc get-atoms (@desc "Shows all atoms in the input Atomspace") (@params ((@param "Reference to the space"))) (@return "List of all atoms in the input space")))
(src= (@doc first-from-pair (@desc "Gets a pair as a first argument and returns first atom from pair") (@params ((@param "Pair"))) (@return "First atom from a pair")))
(src= (: evalc (-> Atom Grounded Atom)))
(src= (@doc sqrt-math (@desc "Returns square root for input number (first argument) which should be >= 0") (@params ((@param "Input number"))) (@return "Result of a square root function")))
(src= (@doc empty (@desc "Cuts evaluation of the non-deterministic branch and removes it from the result") (@params ()) (@return "Nothing")))
(src= (@doc >= (@desc "Greater than or equal. Checks if first argument is greater than or equal to second one") (@params ((@param "First number") (@param "Second number"))) (@return "True if first argument is greater than or equal to second, False - otherwise")))
(src= (= (quote $atom#3365) NotReducible))
(src= (@doc isnan-math (@desc "Returns True if input value is NaN. False - otherwise") (@params ((@param "Number"))) (@return "True/False")))
(src= (@doc and (@desc "Logical conjunction of two arguments") (@params ((@param "First argument") (@param "Second argument"))) (@return "Returns True if both arguments are True, False - otherwise")))
(src= (: get-doc (-> Atom Atom)))
(src= (: Error (-> Atom Atom ErrorType)))
(src= (@doc return-on-error (@desc "Returns first argument if it is Empty or an error. Returns second argument otherwise.") (@params ((@param "Previous evaluation result") (@param "Atom for further evaluation"))) (@return "Return previous result if it is an error or Empty or continue evaluation")))
(src= (@doc switch-internal (@desc "This function is being called inside switch function to test one of the cases and it calls switch once again if current condition is not met") (@params ((@param "Atom (it will be evaluated)") (@param "Deconsed tuple of pairs mapping condition patterns to results"))) (@return "Result of evaluating of Atom bound to met condition")))
(src= (: not (-> Bool Bool)))
(src= (@doc mod-space! (@desc "Returns the space of the module (first argument) and tries to load the module if it is not loaded into the module system") (@params ((@param "Module name"))) (@return "Space name")))
(src= (: and (-> Bool Bool Bool)))
(src= (: or (-> Bool Bool Bool)))
(src= (@doc let* (@desc "Same as let but inputs list of pairs of atoms to be unified. For example (let* (($v1 (+ 1 2)) ($v2 (* 5 6))) (+ $v1 $v2))") (@params ((@param "List of pairs, atoms in each pair to be unified") (@param "Expression which will be evaluated if each pair can be unified"))) (@return "Second argument or Empty")))
(src= (@doc @item (@desc "Used for documentation purposes. Converts atom/function's name to DocItem") (@params ((@param "Atom/Function name to be documented"))) (@return "(@item Atom) entity")))
(src= (@doc for-each-in-atom (@desc "Applies function passed as a second argument to each atom inside first argument") (@params ((@param "Expression to each atom in which function will be applied") (@param "Function to apply"))) (@return "Unit atom")))
(src= (: filter-atom (-> Expression Variable Atom Expression)))
(src= (: @desc (-> String DocDescription)))
(src= (@doc @return (@desc "Used for documentation purposes. Description of function return value starts with @return as a part of @doc") (@params ((@param "String containing return value description"))) (@return "Return value description")))
(src= (@doc asin-math (@desc "Returns result of the arcsine function for an input value (first argument)") (@params ((@param "Float number"))) (@return "Result of the arcsine function")))
(src= (@doc help! (@desc "Function prints documentation for the input atom. Without parameters prints the list of the stdlib functions.") (@params ((@param "Input to get documentation for"))) (@return "Unit atom")))
(src= (@doc get-type (@desc "Returns type notation of input atom") (@params ((@param "Atom to get type for"))) (@return "Type notation or %Undefined% if there is no type for input Atom")))
(src= (@doc @doc (@desc "Used for documentation purposes. Function documentation starts with @doc") (@params ((@param "Function name") (@param "Function description. Starts with @desc") (@param "(Optional) parameters description starting with @params which should contain one or more @param symbols") (@param "(Optional) description of what function will return. Starts with @return"))) (@return "Function documentation using @doc-formal")))
(src= (: union (-> Atom Atom Atom)))
(src= (@doc match-types (@desc "Checks if two types can be unified and returns third argument if so, fourth - otherwise") (@params ((@param "First type") (@param "Second type") (@param "Atom to be returned if types can be unified") (@param "Atom to be returned if types cannot be unified"))) (@return "Third or fourth argument")))
(src= (: decons-atom (-> Expression Expression)))
(src= (@doc get-state (@desc "Gets a state as an argument and returns its wrapped atom. E.g. (get-state (State 5)) -> 5") (@params ((@param "State"))) (@return "Atom wrapped by state")))
(src= (@doc unify (@desc "Matches two first arguments and returns third argument if they are matched and forth argument otherwise") (@params ((@param "First atom to unify with") (@param "Second atom to unify with") (@param "Result if two atoms unified successfully") (@param "Result otherwise"))) (@return "Third argument when first two atoms are matched of forth one otherwise")))
(src= (@doc cos-math (@desc "Returns result of the cosine function for an input value in radians (first argument)") (@params ((@param "Angle in radians"))) (@return "Result of the cosine function")))
(src= (= (not True) False))
(src= (= (not False) True))
(src= (@doc unique (@desc "Function takes non-deterministic input (first argument) and returns only unique entities. E.g. (unique (superpose (a b c d d))) -> [a, b, c, d]") (@params ((@param "Non-deterministic set of values"))) (@return "Unique values from input set")))
(src= (= (get-doc-function $name#3356 $type#3357) (let $top-space#3358 (mod-space! top) (unify $top-space#3358 (@doc $name#3356 $desc#3359 (@params $params#3360) $ret#3361) (let $type'#3362 (if (== $type#3357 %Undefined%) (undefined-doc-function-type $params#3360) (cdr-atom $type#3357)) (let ($params'#3363 $ret'#3364) (get-doc-params $params#3360 $ret#3361 $type'#3362) (@doc-formal (@item $name#3356) (@kind function) (@type $type#3357) $desc#3359 (@params $params'#3363) $ret'#3364))) (@doc-formal (@item $name#3356) (@kind function) (@type $type#3357) (@desc "No documentation"))))))
(src= (: help! (-> Atom (->))))
(src= (@doc filter-atom (@desc "Function takes list of atoms (first argument), variable (second argument) and filter predicate (third argument) and returns list with items which passed filter. E.g. (filter-atom (1 2 3 4) $v (eval (> $v 2))) will give (3 4)") (@params ((@param "List of atoms") (@param "Variable") (@param "Filter predicate"))) (@return "Filtered list")))
(src= (@doc % (@desc "Modulo operator. It returns remainder of dividing first argument by second argument") (@params ((@param "Dividend") (@param "Divisor"))) (@return "Remainder")))
(src= (= (help-param! $param#3353) (let (@param (@type $type#3354) (@desc $desc#3355)) $param#3353 (println! (format-args "  {} {}" ((type $type#3354) $desc#3355))))))
(src= (: if-decons-expr (-> Expression Variable Variable Atom Atom Atom)))
(src= (: (@kind atom) DocKindAtom))
(src= (: get-doc-single-atom (-> Atom Atom)))
(src= (= (if-decons-expr $atom#3347 $head#3348 $tail#3349 $then#3350 $else#3351) (function (eval (if-equal $atom#3347 () (return $else#3351) (chain (decons-atom $atom#3347) $list#3352 (unify $list#3352 ($head#3348 $tail#3349) (return $then#3350) (return $else#3351))))))))
(src= (= (let* $pairs#3342 $template#3343) (eval (if-decons-expr $pairs#3342 ($pattern#3344 $atom#3345) $tail#3346 (let $pattern#3344 $atom#3345 (let* $tail#3346 $template#3343)) $template#3343))))
(src= (: intersection (-> Atom Atom Atom)))
(src= (@doc get-metatype (@desc "Returns metatype of the input atom") (@params ((@param "Atom to get metatype for"))) (@return "Metatype of input atom")))
(src= (@doc assertEqual (@desc "Compares (sets of) results of evaluation of two expressions") (@params ((@param "First expression") (@param "Second expression"))) (@return "Unit atom if both expressions after evaluation are equal, error - otherwise")))
(src= (@doc floor-math (@desc "Returns the smallest integer less than or equal to the input value (first argument)") (@params ((@param "Float value"))) (@return "Integer value less than or equal to the input")))
(src= (@doc log-math (@desc "Returns result of a logarithm function given base (first argument) and input number (second argument)") (@params ((@param "Base") (@param "Input number"))) (@return "Result of log function")))
(src= (= (car-atom $atom#3339) (eval (if-decons-expr $atom#3339 $head#3340 $_#3341 $head#3340 (Error (car-atom $atom#3339) "car-atom expects a non-empty expression as an argument")))))
(src= (@doc superpose (@desc "Turns a tuple (first argument) into a nondeterministic result") (@params ((@param "Tuple to be converted"))) (@return "Argument converted to nondeterministic result")))
(src= (= (map-atom $list#3330 $var#3331 $map#3332) (function (eval (if-decons-expr $list#3330 $head#3333 $tail#3334 (chain (eval (map-atom $tail#3334 $var#3331 $map#3332)) $tail-mapped#3335 (chain (eval (atom-subst $head#3333 $var#3331 $map#3332)) $map-expr#3336 (chain $map-expr#3336 $head-mapped#3337 (chain (cons-atom $head-mapped#3337 $tail-mapped#3335) $res#3338 (return $res#3338))))) (return ()))))))
(src= (@doc min-atom (@desc "Returns atom with min value in the expression (first argument). Only numbers allowed") (@params ((@param "Expression which contains atoms of Number type"))) (@return "Min value in the expression. Error if expression contains non-numeric value or is empty")))
(src= (@doc type-cast (@desc "Casts atom passed as a first argument to the type passed as a second argument using space as a context") (@params ((@param "Atom to be casted") (@param "Type to cast atom to") (@param "Context atomspace"))) (@return "Atom if casting is successful, (Error ... BadType) otherwise")))
(src= (= (if False $then#3328 $else#3329) $else#3329))
(src= (= (if True $then#3326 $else#3327) $then#3326))
(src= (= (first-from-pair $pair#3323) (function (unify $pair#3323 ($first#3324 $second#3325) (return $first#3324) (return (Error (first-from-pair $pair#3323) "incorrect pair format"))))))
(src= (@doc new-state (@desc "Creates a new state atom wrapping its argument") (@params ((@param "Atom to be wrapped"))) (@return "Returns (State $value) where $value is an argument to a new-state")))
(src= (@doc flip (@desc "Random boolean value") (@params ()) (@return "Returns uniformly distributed random boolean value")))
(src= (@doc Error (@desc "Error constructor") (@params ((@param "Atom which contains error") (@param "Error message, can be one of the reserved symbols: BadType, IncorrectNumberOfArguments"))) (@return "Instance of the error atom")))
(src= (= (filter-atom $list#3314 $var#3315 $filter#3316) (function (eval (if-decons-expr $list#3314 $head#3317 $tail#3318 (chain (eval (filter-atom $tail#3318 $var#3315 $filter#3316)) $tail-filtered#3319 (chain (eval (atom-subst $head#3317 $var#3315 $filter#3316)) $filter-expr#3320 (chain $filter-expr#3320 $is-filtered#3321 (eval (if $is-filtered#3321 (chain (cons-atom $head#3317 $tail-filtered#3319) $res#3322 (return $res#3322)) (return $tail-filtered#3319)))))) (return ()))))))
(src= (@doc ceil-math (@desc "Returns the smallest integer greater than or equal to the input value (first argument)") (@params ((@param "Float value"))) (@return "Integer value greater than or equal to the input")))
(src= (: id (-> Atom Atom)))
(src= (: is-function (-> Type Bool)))
(src= (@doc acos-math (@desc "Returns result of the arccosine function for an input value (first argument)") (@params ((@param "Float number"))) (@return "Result of the arccosine function")))
(src= (= (foldl-atom $list#3303 $init#3304 $a#3305 $b#3306 $op#3307) (function (eval (if-decons-expr $list#3303 $head#3308 $tail#3309 (chain (eval (atom-subst $init#3304 $a#3305 $op#3307)) $op-init#3310 (chain (eval (atom-subst $head#3308 $b#3306 $op-init#3310)) $op-head#3311 (chain $op-head#3311 $head-folded#3312 (chain (eval (foldl-atom $tail#3309 $head-folded#3312 $a#3305 $b#3306 $op#3307)) $res#3313 (return $res#3313))))) (return $init#3304))))))
(src= (@doc trunc-math (@desc "Returns integer part of the input value (first argument)") (@params ((@param "Float value"))) (@return "Integer part of float")))
(src= (@doc is-function (@desc "Function checks if input type is a function type") (@params ((@param "Type atom"))) (@return "True if type is a function type, False - otherwise")))
(src= (@doc ErrorType (@desc "Type of the atom which contains error")))
(src= (= (empty) Empty))
(src= (@doc new-space (@desc "Creates new Atomspace which could be used further in the program as a separate from &self Atomspace") (@params ()) (@return "Reference to a new space")))
(src= (: (@kind function) DocKindFunction))
(src= (@doc subtraction-atom (@desc "Function takes two tuples and returns their subtraction. E.g. !(subtraction-atom (a b b c) (b c c d)) -> (a b)") (@params ((@param "List of values") (@param "List of values"))) (@return "Subtraction of sets")))
(src= (@doc intersection (@desc "Function takes two non-deterministic inputs (first and second argument) and returns their intersection. E.g. (intersection (superpose (a b c c)) (superpose (b c c c d))) -> [b, c, c]") (@params ((@param "Non-deterministic set of values") (@param "Another non-deterministic set of values"))) (@return "Intersection of sets")))
(src= (@doc bind! (@desc "Registers a new token which is replaced with an atom during the parsing of the rest of the program") (@params ((@param "Token name") (@param "Atom, which is associated with the token after reduction"))) (@return "Unit atom")))
(src= (= (match-types $type1#3299 $type2#3300 $then#3301 $else#3302) (function (eval (if-equal $type1#3299 %Undefined% (return $then#3301) (eval (if-equal $type2#3300 %Undefined% (return $then#3301) (eval (if-equal $type1#3299 Atom (return $then#3301) (eval (if-equal $type2#3300 Atom (return $then#3301) (unify $type1#3299 $type2#3300 (return $then#3301) (return $else#3302)))))))))))))
(src= (@doc > (@desc "Greater than. Checks if first argument is greater than second one") (@params ((@param "First number") (@param "Second number"))) (@return "True if first argument is greater than second, False - otherwise")))
(src= (= (unique $arg#3296) (let $c#3297 (collapse $arg#3296) (let $u#3298 (unique-atom $c#3297) (superpose $u#3298)))))
(src= (@doc = (@desc "A symbol used to define reduction rules for expressions.") (@params ((@param "Pattern to be matched against expression to be reduced") (@param "Result of reduction or transformation of the first pattern"))) (@return "Not reduced itself unless custom equalities over equalities are added")))
(src= (@doc switch (@desc "Subsequently tests multiple pattern-matching conditions (second argument) for the given value (first argument)") (@params ((@param "Atom to be matched with patterns") (@param "Tuple of pairs mapping condition patterns to results"))) (@return "Result which corresponds to the pattern which is matched with the passed atom first")))
(src= (= (get-doc-params $params#3285 $ret#3286 $types#3287) (let $head-type#3288 (car-atom $types#3287) (let $tail-types#3289 (cdr-atom $types#3287) (if (== () $params#3285) (let (@return $ret-desc#3290) $ret#3286 (() (@return (@type $head-type#3288) (@desc $ret-desc#3290)))) (let (@param $param-desc#3291) (car-atom $params#3285) (let $tail-params#3292 (cdr-atom $params#3285) (let ($params'#3293 $result-ret#3294) (get-doc-params $tail-params#3292 $ret#3286 $tail-types#3289) (let $result-params#3295 (cons-atom (@param (@type $head-type#3288) (@desc $param-desc#3291)) $params'#3293) ($result-params#3295 $result-ret#3294))))))))))
(src= (@doc git-module! (@desc "Provides access to module in a remote git repo, from within MeTTa code. Similar to `register-module!`, this op will bypass the catalog search") (@params ((@param "URL to github repo"))) (@return "Unit atom")))
(src= (: if (-> Bool Atom Atom $t#3284)))
(src= (: @item (-> Atom DocItem)))
(src= (= (let $pattern#3281 $atom#3282 $template#3283) (unify $atom#3282 $pattern#3281 $template#3283 Empty)))
(src= (: @return (-> String DocReturnInformal)))
(src= (@doc add-reduct (@desc "Reduces atom (second argument) and adds it into the atomspace (first argument)") (@params ((@param "Atomspace to add atom into") (@param "Atom to add"))) (@return "Unit atom")))
(src= (: atom-subst (-> Atom Variable Atom Atom)))
(src= (: noreduce-eq (-> Atom Atom Bool)))
(src= (: @params (-> Expression DocParameters)))
(src= (= (atom-subst $atom#3278 $var#3279 $templ#3280) (function (chain (eval (id $atom#3278)) $var#3279 (return $templ#3280)))))
(src= (= (subtraction $arg1#3273 $arg2#3274) (let $c1#3275 (collapse $arg1#3273) (let $c2#3276 (collapse $arg2#3274) (let $u#3277 (subtraction-atom $c1#3275 $c2#3276) (superpose $u#3277))))))
(src= (: get-doc-function (-> Atom Type Atom)))
(src= (@doc println! (@desc "Prints a line of text to the console") (@params ((@param "Expression/atom to be printed out"))) (@return "Unit atom")))
(src= (: help-param! (-> Atom (->))))
(src= (: @doc (-> Atom DocDescription DocInformal)))
(src= (@doc not (@desc "Logical negation") (@params ((@param "Argument"))) (@return "Negates boolean input argument (False -> True, True -> False)")))
(src= (: cdr-atom (-> Expression Expression)))
(src= (@doc @type (@desc "Used for documentation purposes. Converts atom/function's type to DocType") (@params ((@param "Atom/Function type to be documented"))) (@return "(@type Type) entity")))
(src= (@doc atan-math (@desc "Returns result of the arctangent function for an input value (first argument)") (@params ((@param "Float number"))) (@return "Result of the tangent function")))
(src= (@doc + (@desc "Sums two numbers") (@params ((@param "Addend") (@param "Augend"))) (@return "Sum")))
(src= (: unique (-> Atom Atom)))
(src= (: return-on-error (-> Atom Atom Atom)))
(src= (@doc chain (@desc "Evaluates first argument, binds it to the variable (second argument) and then evaluates third argument which contains (or not) mentioned variable") (@params ((@param "Atom to be evaluated") (@param "Variable") (@param "Atom which will be evaluated at the end"))) (@return "Result of evaluating third input argument")))
(src= (@doc == (@desc "Checks equality for two arguments of the same type") (@params ((@param "First argument") (@param "Second argument"))) (@return "Returns True if two arguments are equal, False - otherwise. If arguments are of different type function returns Error currently")))
(src= (= (match-type-or $folded#3268 $next#3269 $type#3270) (function (chain (eval (match-types $next#3269 $type#3270 True False)) $matched#3271 (chain (eval (or $folded#3268 $matched#3271)) $or#3272 (return $or#3272))))))
(src= (@doc isinf-math (@desc "Returns True if input value is positive or negative infinity. False - otherwise") (@params ((@param "Number"))) (@return "True/False")))
(src= (@doc pow-math (@desc "Takes base (first argument) and power (second argument) and returns result of a power function (base ^ power)") (@params ((@param "Base") (@param "Power"))) (@return "Result of a power function")))
(src= (@doc cons-atom (@desc "Constructs an expression using two arguments") (@params ((@param "Head of an expression") (@param "Tail of an expression"))) (@return "New expression consists of two input arguments")))
(src= (: metta (-> Atom Type Grounded Atom)))
(src= (@doc @desc (@desc "Used for documentation purposes. Description of function starts with @desc as a part of @doc") (@params ((@param "String containing function description"))) (@return "Function description")))
(src= (= (help!) (let $top-space#3265 (mod-space! top) (unify $top-space#3265 (@doc $name#3266 (@desc $desc#3267)) (let () (println! (format-args "{}\n\t{}" ($name#3266 $desc#3267))) Empty) Empty))))
(src= (@doc quote (@desc "Prevents atom from being reduced") (@params ((@param "Atom"))) (@return "Quoted atom")))
(src= (@doc map-atom (@desc "Function takes list of atoms (first argument), variable to be used inside (second variable) and an expression which will be evaluated for each atom in list (third argument). Expression should contain variable. So e.g. (map-atom (1 2 3 4) $v (eval (+ $v 1))) will give (2 3 4 5)") (@params ((@param "List of atoms") (@param "Variable name") (@param "Template using variable"))) (@return "Result of evaluating template for each atom in a list")))
(src= (@doc index-atom (@desc "Returns atom from an expression (first argument) using index (second argument) or error if index is out of bounds") (@params ((@param "Expression") (@param "Index"))) (@return "Atom from an expression in the place defined by index. Error if index is out of bounds")))
(src= (= (for-each-in-atom $expr#3260 $func#3261) (if (noreduce-eq $expr#3260 ()) () (let $head#3262 (car-atom $expr#3260) (let $tail#3263 (cdr-atom $expr#3260) (let $_#3264 ($func#3261 $head#3262) (for-each-in-atom $tail#3263 $func#3261)))))))
(src= (@doc =alpha (@desc "Checks alpha equality of two expressions") (@params ((@param "First expression") (@param "Second expression"))) (@return "True if both expressions are alpha equal, False - otherwise")))
(src= (@doc foldl-atom (@desc "Function takes list of values (first argument), initial value (second argument) and operation (fifth argument) and applies it consequently to the list of values, using init value as a start. It also takes two variables (third and fourth argument) to use them inside") (@params ((@param "List of values") (@param "Init value") (@param "Variable") (@param "Variable") (@param "Operation"))) (@return "Result of applying operation to the list of values")))
(src= (= (switch $atom#3255 $cases#3256) (function (chain (decons-atom $cases#3256) $list#3257 (chain (eval (switch-internal $atom#3255 $list#3257)) $res#3258 (chain (eval (if-equal $res#3258 NotReducible Empty $res#3258)) $x#3259 (return $x#3259)))))))
(src= (= (id $x#3254) $x#3254))
(src= (@doc / (@desc "Divides first argument by second one") (@params ((@param "Dividend") (@param "Divisor"))) (@return "Fraction")))
(src= (@doc subtraction (@desc "Function takes two non-deterministic inputs (first and second argument) and returns their subtraction. E.g. !(subtraction (superpose (a b b c)) (superpose (b c c d))) -> [a, b]") (@params ((@param "Non-deterministic set of values") (@param "Another non-deterministic set of values"))) (@return "Subtraction of sets")))
(src= (@doc get-doc-function (@desc "Function used by get-doc-single-atom to get documentation on a function. It returns documentation on a function if it exists or default documentation with no description otherwise") (@params ((@param "Function name for which documentation is needed") (@param "Type notation for this function"))) (@return "Documentation for the given function")))
(src= (@doc superpose-bind (@desc "Complement to the collapse-bind. It takes result of collapse-bind (first argument) and returns only result atoms without bindings") (@params ((@param "Expression in form (Atom Binding)"))) (@return "Non-deterministic list of Atoms")))
(src= (@doc include (@desc "Works just like import! but with &self as a first argument. So everything from input file will be included in the current atomspace and evaluated") (@params ((@param "Name of metta script to import"))) (@return "Unit atom")))
(src= (@doc sealed (@desc "Replaces all occurrences of any var from var list (first argument) inside atom (second argument) by unique variable. Can be used to create a locally scoped variables") (@params ((@param "Variable list e.g. ($x $y)") (@param "Atom which uses those variables"))) (@return "Second argument but with variables being replaced with unique variables")))
(src= (@doc random-int (@desc "Returns random int number from range defined by two numbers (first and second argument)") (@params ((@param "Range start") (@param "Range end"))) (@return "Random int number from defined range")))
(src= (@doc nop (@desc "Outputs unit atom") (@params ()) (@return "Unit atom")))
(src= (: eval (-> Atom Atom)))
(src= (@doc (@kind function) (@desc "Used for documentation purposes. Shows type of entity to be documented. (@kind function) in this case")))
(src= (@doc capture (@desc "Wraps an atom and capture the current space") (@params ((@param "Function name which space need to be captured"))) (@return "Function")))
(src= (= (noreduce-eq $a#3252 $b#3253) (== (quote $a#3252) (quote $b#3253))))
(src= (= (intersection $arg1#3247 $arg2#3248) (let $c1#3249 (collapse $arg1#3247) (let $c2#3250 (collapse $arg2#3248) (let $u#3251 (intersection-atom $c1#3249 $c2#3250) (superpose $u#3251))))))
(src= (@doc - (@desc "Subtracts second argument from first one") (@params ((@param "Minuend") (@param "Deductible"))) (@return "Difference")))
(src= (: switch (-> %Undefined% Expression Atom)))
(src= (@doc id (@desc "Returns its argument") (@params ((@param "Input argument"))) (@return "Input argument")))
(src= (@doc get-doc-single-atom (@desc "Function used by get-doc to get documentation on either function or atom. It checks if input name is the name of function or atom and calls correspondent function") (@params ((@param "Atom/Function name for which documentation is needed"))) (@return "Documentation for the given atom/function")))
(src= (: superpose-bind (-> Expression Atom)))
(src= (@doc get-doc-params (@desc "Function used by get-doc-function to get function's parameters documentation (including return value)") (@params ((@param "List of parameters in form of ((@param Description) (@param Description)...)") (@param "Return value's description in form of (@return Description)") (@param "Type notation without -> starting symbol e.g. (Atom Atom Atom)"))) (@return "United list of params and return value each augmented with its type. E.g. (((@param (@type Atom) (@desc Description)) (@param (@type Atom) (@desc Description2))) (@return (@type Atom) (@desc Description)))")))
(src= (@doc change-state! (@desc "Changes input state's wrapped atom to another value (second argument). E.g. (change-state! (State 5) 6) -> (State 6)") (@params ((@param "State created by new-state function") (@param "Atom which will replace wrapped atom in the input state"))) (@return "State with replaced wrapped atom")))
(src= (@doc noreduce-eq (@desc "Checks equality of two atoms without reducing them") (@params ((@param "First atom") (@param "Second atom"))) (@return "True if not reduced atoms are equal, False - otherwise")))
(src= (@doc unique-atom (@desc "Function takes tuple and returns only unique entities. E.g. (unique-atom (a b c d d)) -> (a b c d)") (@params ((@param "List of values"))) (@return "Unique values from input set")))
(src= (: collapse-bind (-> Atom Expression)))
(src= (= (return-on-error $atom#3245 $then#3246) (function (eval (if-equal $atom#3245 Empty (return (return Empty)) (eval (if-error $atom#3245 (return (return $atom#3245)) (return $then#3246))))))))
(src= (= (union $arg1#3240 $arg2#3241) (let $c1#3242 (collapse $arg1#3240) (let $c2#3243 (collapse $arg2#3241) (let $u#3244 (union-atom $c1#3242 $c2#3243) (superpose $u#3244))))))
(src= (@doc add-atom (@desc "Adds atom into the atomspace without reducing it") (@params ((@param "Atomspace to add atom into") (@param "Atom to add"))) (@return "Unit atom")))
(src= (= (add-reduct $dst#3238 $atom#3239) (add-atom $dst#3238 $atom#3239)))
(src= (@doc if (@desc "Replace itself by one of the arguments depending on condition.") (@params ((@param "Boolean condition") (@param "Result when condition is True") (@param "Result when condition is False"))) (@return "Second or third argument")))
(src= (@doc unquote (@desc "Unquotes quoted atom, e.g. (unquote (quote $x)) returns $x") (@params ((@param "Quoted atom"))) (@return "Unquoted atom")))
(src= (@doc assertAlphaEqualToResult (@desc "Same as assertAlphaEqual but it doesn't evaluate second argument. Second argument is considered as a set of values of the first argument's evaluation") (@params ((@param "First expression (it will be evaluated)") (@param "Second expression (it won't be evaluated)"))) (@return "Unit atom if both expressions after evaluation of the first argument are alpha equal, error - otherwise")))
(src= (@doc @params (@desc "Used for function documentation purposes. Contains several @param entities with description of each @param") (@params ((@param "Several (@param ...) entities"))) (@return "DocParameters containing description of all parameters of function in form of (@params ((@param ...) (@param ...) ...))")))
(src= (= (nop $x#3237) ()))
(src= (@doc match-type-or (@desc "Checks if two types (second and third arguments) can be unified and returns result of OR operation between first argument and type checking result") (@params ((@param "Boolean value") (@param "First type") (@param "Second type"))) (@return "True or False")))
(src= (: undefined-doc-function-type (-> Expression Type)))
(src= (: cons-atom (-> Atom Expression Expression)))
(src= (@doc tan-math (@desc "Returns result of the tangent function for an input value in radians (first argument)") (@params ((@param "Angle in radians"))) (@return "Result of the tangent function")))
(src= (: subtraction (-> Atom Atom Atom)))
(src= (= (switch-internal $atom#3232 (($pattern#3233 $template#3234) $tail#3235)) (function (unify $atom#3232 $pattern#3233 (return $template#3234) (chain (eval (switch $atom#3232 $tail#3235)) $ret#3236 (return $ret#3236))))))
(src= (@doc union (@desc "Function takes two non-deterministic inputs (first and second argument) and returns their union. E.g. (union (superpose (a b b c)) (superpose (b c c d))) -> [a, b, b, c, b, c, c, d]") (@params ((@param "Non-deterministic set of values") (@param "Another non-deterministic set of values"))) (@return "Union of sets")))
(src= (@doc evalc (@desc "Evaluates input atom, makes one step of the evaluation") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function") (@param "Space to evaluate atom in its context"))) (@return "Result of evaluation")))
(src= (@doc max-atom (@desc "Returns atom with max value in the expression (first argument). Only numbers allowed") (@params ((@param "Expression which contains atoms of Number type"))) (@return "Max value in the expression. Error if expression contains non-numeric value or is empty")))
(src= (: let* (-> Expression Atom %Undefined%)))
(src= (@doc register-module! (@desc "Takes a file system path (first argument) and loads the module into the runner") (@params ((@param "File system path"))) (@return "Unit atom")))
(src= (@doc format-args (@desc "Fills {} symbols in the input expression with atoms from the second expression. E.g. (format-args (Probability of {} is {}%) (head 50)) gives [(Probability of head is 50%)]. Atoms in the second input value could be variables") (@params ((@param "Expression with {} symbols to be replaced") (@param "Atoms to be placed inside expression instead of {}"))) (@return "Expression with replaced {} with atoms")))
(src= (: @param (-> DocType DocDescription DocParameter)))
(src= (= (cdr-atom $atom#3229) (eval (if-decons-expr $atom#3229 $_#3230 $tail#3231 $tail#3231 (Error (cdr-atom $atom#3229) "cdr-atom expects a non-empty expression as an argument")))))
(src= (: @doc (-> Atom DocDescription DocParameters DocReturnInformal DocInformal)))
(src= (@doc metta (@desc "Run MeTTa interpreter on atom.") (@params ((@param "Atom to be interpreted") (@param "Type of input atom") (@param "Atomspace where intepretation should take place"))) (@return "Result of interpretation")))
(src= (: car-atom (-> Expression Atom)))
(src= (@doc size-atom (@desc "Returns size of an expression (first argument)") (@params ((@param "Expression"))) (@return "Size of an expression")))
(src= (@doc if-decons-expr (@desc "Checks if first argument is non empty expression. If so gets tail and head from the first argument and returns forth argument using head and tail values. Returns fifth argument otherwise.") (@params ((@param "Expression to be deconstructed") (@param "Head variable") (@param "Tail variable") (@param "Template to return if first argument is a non-empty expression") (@param "Default value to return otherwise"))) (@return "Either template with head and tail replaced by values or default value")))
(src= (@doc eval (@desc "Evaluates input atom, makes one step of the evaluation") (@params ((@param "Atom to be evaluated, can be reduced via equality expression (= ...) or by calling a grounded function"))) (@return "Result of evaluation")))
(src= (: unify (-> Atom Atom Atom Atom Atom)))
(src= (@doc decons-atom (@desc "Works as a reverse to cons-atom function. It gets Expression as an input and returns it splitted to head and tail, e.g. (decons-atom (Cons X Nil)) -> (Cons (X Nil))") (@params ((@param "Expression"))) (@return "Deconsed expression")))
(src= (@doc let (@desc "Unify two first argument and apply result of the unification on third argument. Second argument is evaluated before unification.") (@params ((@param "First atom to be unified") (@param "Second atom to be unified") (@param "Expression which will be evaluated if two first arguments can be unified"))) (@return "Third argument or Empty")))
(src= (@doc round-math (@desc "Returns the nearest integer to the input float value (first argument)") (@params ((@param "Float value"))) (@return "Nearest integer to the input")))
(src= (: @return (-> DocType DocDescription DocReturn)))
(src= (@doc @doc-formal (@desc "Used for documentation purposes. get-doc returns documentation starting with @doc-formal symbol. @doc-formal contains 6 or 4 parameters depending on the entity being described (functions being described using 6 parameters, atoms - 4 parameters)") (@params ((@param "Function/Atom name for which documentation is to be displayed. Format (@item name)") (@param "Contains (@kind function) or (@kind atom) depends on entity which documentation is displayed") (@param "Contains type notation of function/atom") (@param "Function/atom description") (@param "(Functions only). Description of function parameters") (@param "(Functions only). Description of function's return value"))) (@return "Expression containing full documentation on function")))
(src= (@doc get-type-space (@desc "Returns type notation of input Atom (second argument) relative to a specified atomspace (first argument)") (@params ((@param "Atomspace where type notation for input atom will be searched") (@param "Atom to get type for"))) (@return "Type notation or %Undefined% if there is no type for input Atom in provided atomspace")))
(src= (@doc match (@desc "Searches for all declared atoms corresponding to the given pattern (second argument) inside space (first argument) and returns the output template (third argument)") (@params ((@param "Atomspace to search pattern") (@param "Pattern atom to be searched") (@param "Output template typically containing variables from the input pattern"))) (@return "If match was successfull it outputs template (third argument) with filled variables (if any were present in pattern) using matched pattern (second argument). Empty - otherwise")))
(src= (: @doc-formal (-> DocItem DocKindFunction DocType DocDescription DocParameters DocReturn DocFormal)))
(src= (@doc intersection-atom (@desc "Function takes two tuples and returns their intersection. E.g. (intersection-atom (a b c c) (b c c c d)) -> (b c c)") (@params ((@param "List of values") (@param "List of values"))) (@return "Intersection of sets")))
(src= (@doc xor (@desc "Logical exclusive or") (@params ((@param "First argument") (@param "Second argument"))) (@return "Returns True if one and only one of the inputs is True")))
(src= (@doc cdr-atom (@desc "Extracts the tail of an expression (all except first atom)") (@params ((@param "Expression"))) (@return "Tail of an expression")))
(src= (@doc pragma! (@desc "Changes global key's (first argument) value to a new one (second argument)") (@params ((@param "Key's name") (@param "New value"))) (@return "Unit atom")))
(src= (: get-doc-atom (-> Atom Atom)))
(src= (@doc collapse (@desc "Converts a nondeterministic result into a tuple") (@params ((@param "Atom which will be evaluated"))) (@return "Tuple")))
(src= (: return (-> $t#3228 $t#3228)))
(src= (@doc < (@desc "Less than. Checks if first argument is less than second one") (@params ((@param "First number") (@param "Second number"))) (@return "True if first argument is less than second, False - otherwise")))
(src= (@doc sin-math (@desc "Returns result of the sine function for an input value in radians (first argument)") (@params ((@param "Angle in radians"))) (@return "Result of the sine function")))
(src= (: for-each-in-atom (-> Expression Atom (->))))
(src= (: add-reduct (-> Grounded %Undefined% (->))))
(src= (@doc car-atom (@desc "Extracts the first atom of an expression as a tuple") (@params ((@param "Expression"))) (@return "First atom of an expression")))
(src= (= (unquote (quote $atom#3227)) $atom#3227))
(src= (= (get-doc-atom $atom#3220) (let $top-space#3221 (mod-space! top) (let $type#3222 (get-type-space $top-space#3221 $atom#3220) (unify $top-space#3221 (@doc $atom#3220 $desc#3223) (@doc-formal (@item $atom#3220) (@kind atom) (@type $type#3222) $desc#3223) (unify $top-space#3221 (@doc $atom#3220 $desc'#3224 (@params $params#3225) $ret#3226) (get-doc-function $atom#3220 %Undefined%) (@doc-formal (@item $atom#3220) (@kind atom) (@type $type#3222) (@desc "No documentation"))))))))
(src= (@doc union-atom (@desc "Function takes two tuples and returns their union. E.g. (union-atom (a b b c) (b c c d)) -> (a b b c b c c d)") (@params ((@param "List of values") (@param "List of values"))) (@return "Union of sets")))
(src= (: help! (-> (->))))
(src= (: ErrorType Type))
(src= (@doc print-mods! (@desc "Prints all modules with their correspondent spaces") (@params ()) (@return "Unit atom")))
(src= (@doc get-doc (@desc "Returns documentation for the given Atom/Function") (@params ((@param "Atom/Function name for which documentation is needed"))) (@return "Documentation for the given atom/function")))
(src= (: if-error (-> Atom Atom Atom Atom)))
(src= (= (type-cast $atom#3210 $type#3211 $space#3212) (function (chain (eval (get-metatype $atom#3210)) $meta#3213 (eval (if-equal $type#3211 $meta#3213 (return $atom#3210) (chain (eval (collapse-bind (eval (get-type $atom#3210 $space#3212)))) $collapsed#3214 (chain (eval (map-atom $collapsed#3214 $pair#3215 (eval (first-from-pair $pair#3215)))) $actual-types#3216 (chain (eval (foldl-atom $actual-types#3216 False $a#3217 $b#3218 (eval (match-type-or $a#3217 $b#3218 $type#3211)))) $is-some-comp#3219 (eval (if $is-some-comp#3219 (return $atom#3210) (return (Error $atom#3210 BadType)))))))))))))
(src= (@doc get-doc-atom (@desc "Function used by get-doc (in case of input type Expression) and get-doc-single-atom (in case input value is not a function) to get documentation on input value") (@params ((@param "Atom's name to get documentation for"))) (@return "Documentation on input Atom")))
(src= (@doc if-error (@desc "Checks if first argument is an error atom. Returns second argument if so or third argument otherwise.") (@params ((@param "Atom to be checked for the error") (@param "Value to return if first argument is an error") (@param "Value to return otherwise"))) (@return "Second or third argument")))
(src= (= (is-function $type#3206) (function (chain (eval (get-metatype $type#3206)) $meta#3207 (eval (switch ($type#3206 $meta#3207) ((($type#3206 Expression) (eval (if-decons-expr $type#3206 $head#3208 $_tail#3209 (unify $head#3208 -> (return True) (return False)) (return (Error (is-function $type#3206) "is-function non-empty expression as an argument"))))) (($type#3206 $meta#3207) (return False)))))))))
(src= (: foldl-atom (-> Expression Atom Variable Variable Atom Atom)))
(src= (@doc or (@desc "Logical disjunction of two arguments") (@params ((@param "First argument") (@param "Second argument"))) (@return "True if any of input arguments is True, False - otherwise")))
(src= (: @doc-formal (-> DocItem DocKindAtom DocType DocDescription DocFormal)))
(src= (@doc trace! (@desc "Prints its first argument and returns second. Both arguments will be evaluated before processing") (@params ((@param "Atom to print") (@param "Atom to return"))) (@return "Evaluated second input")))
(src= (: @type (-> Type DocType)))
(src= (: function (-> Atom Atom)))
(src= (: quote (-> Atom Atom)))
(src= (@doc import! (@desc "Imports module using its relative path (second argument) and binds it to the token (first argument) which will represent imported atomspace. If first argument is &self then everything will be imported to current atomspace") (@params ((@param "Symbol, which is turned into the token for accessing the imported module") (@param "Module name"))) (@return "Unit atom")))
(src= (@doc return (@desc "Returns value from the (function ...) expression") (@params ((@param "Value to be returned"))) (@return "Passed argument")))
(src= (@doc atom-subst (@desc "Substitutes variable passed as a second argument in the third argument by the first argument") (@params ((@param "Value to use for replacement") (@param "Variable to replace") (@param "Template to replace variable by the value"))) (@return "Template with substituted variable")))
(src= (: chain (-> Atom Variable Atom Atom)))
(src= (@doc collapse-bind (@desc "Evaluates minimal MeTTa operation (first argument) and returns an expression which contains all alternative evaluations in a form (Atom Bindings). Bindings are represented in a form of a grounded atom.") (@params ((@param "Minimal MeTTa operation to be evaluated"))) (@return "All alternative evaluations")))
(src= (= (help!) (let $top-space#3201 (mod-space! top) (unify $top-space#3201 (@doc $name#3202 (@desc $desc#3203) $params#3204 $ret#3205) (let () (println! (format-args "{}\n\t{}" ($name#3202 $desc#3203))) Empty) Empty))))
(src= (@doc random-float (@desc "Returns random float number from range defined by two numbers (first and second argument)") (@params ((@param "Range start") (@param "Range end"))) (@return "Random float number from defined range")))
(src= (@doc assertAlphaEqual (@desc "Compares (sets of) results of evaluation of two expressions using alpha equality") (@params ((@param "First expression") (@param "Second expression"))) (@return "Unit atom if both expressions after evaluation are alpha equal, error - otherwise")))
(src= (= (if-error $atom#3194 $then#3195 $else#3196) (function (chain (eval (get-metatype $atom#3194)) $meta#3197 (eval (if-equal $meta#3197 Expression (eval (if-equal $atom#3194 () (return $else#3196) (chain (decons-atom $atom#3194) $list#3198 (unify $list#3198 ($head#3199 $tail#3200) (eval (if-equal $head#3199 Error (return $then#3195) (return $else#3196))) (return $else#3196))))) (return $else#3196)))))))
(src= (: @param (-> String DocParameterInformal)))
(src= (@doc function (@desc "Evaluates the argument until it becomes (return <result>). Then (function (return <result>)) is reduced to the <result>.") (@params ((@param "Atom to be evaluated"))) (@return "Result of atom's evaluation")))
(src= (@doc abs-math (@desc "Returns absolute value of input number (first argument)") (@params ((@param "Input number"))) (@return "Absolute value")))
(src= (: let (-> Atom %Undefined% Atom %Undefined%)))
(src= (@doc (@kind atom) (@desc "Used for documentation purposes. Shows type of entity to be documented. (@kind atom) in this case")))
(src= (= (get-doc $atom#3191) (let $meta-type#3192 (get-metatype $atom#3191) (case $meta-type#3192 ((Expression (get-doc-atom $atom#3191)) ($_#3193 (get-doc-single-atom $atom#3191)))))))
(src= (: Entity Type))
(src= (: HumansAreMortal (-> (Human $t#3190) (Mortal $t#3190))))
(src= (= (do-hide $1#3189) (case $1#3189 ())))
(src= (: Mortal (-> Entity Type)))
(src= (: src= (-> Atom Atom)))
(src= (= (Human Plato) T))
(src= (: = (-> Atom Atom Atom)))
(src= (= (= $x#3188 $x#3188) T))
(src= (: Sam Entity))
(src= (: Plato Entity))
(src= (: Socrates Entity))
(src= (: T Type))
(src= (: Human (-> Entity Type)))
(src= (= (Mortal Socrates) T))
(src= (= (Mortal $x#3187) (Human $x#3187)))
(src= (: PlatoIsHuman (Human Plato)))
(src= (: ift (-> Type $t#3186 $t#3186)))
(src= (= (HumansAreMortal SocratesIsHuman) SocratesIsMortal))
(src= (: SocratesIsMortal (Mortal Socrates)))
(src= (= (ift T $then#3185) $then#3185))
(src= (: do-hide (-> Expression %Undefined%)))
(src= (= (= $type#3183 T) (match ModuleSpace(GroundingSpace-top) (: $x#3184 $type#3183) T)))
(src= (: SocratesIsHuman (Human Socrates)))
(src= (= (= $type#3180 T) (match ModuleSpace(GroundingSpace-top) (: $impl#3181 (-> $cause#3182 $type#3180)) (if (== $cause#3182 $type#3180) (empty) (= $cause#3182 T)))))
[()]
[(m ())]
[()]
[()]
[(m ())]
[(m ())]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[()]
[]
